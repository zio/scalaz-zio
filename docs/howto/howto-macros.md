---
id: use-zio-macros
title: "How to use ZIO Macros?"
---

## Scrapping the boilerplate with macros

Many libraries come together with usage best practices and repeatable code, ZIO is no different. Fortunately ZIO provides macros
to perform these repetitive tasks for you. At the moment these are only available for Scala versions `2.x`, however their equivalents
for Dotty are on our roadmap.

### Prerequisites

To enable macro expansion you need to setup your project:

- for Scala `>= 2.13` add compiler option

```scala
scalacOptions += "-Ymacro-annotations"
```

- for Scala `< 2.13` add macro paradise compiler plugin

```scala
compilerPlugin(("org.scalamacros" % "paradise"  % "2.1.1") cross CrossVersion.full)
```

## Capability accessors

### Installation

```scala
libraryDependencies += "dev.zio" %% "zio-macros" % "<zio-version>"
```

### Description

The `@accessible` macro generates _capability accessors_ into annotated module object.

```scala
import zio._
import zio.macros.accessible

@accessible
trait AccountObserver {
  def processEvent(event: AccountEvent): UIO[Unit]
}

// below will be autogenerated
object AccountObserver {
  def processEvent(event: AccountEvent) =
    ZIO.serviceWithZIO[AccountObserver](_.processEvent(event))
}
```

For normal values, a `ZIO` with `Nothing` on error channel is generated:

```scala
import zio._
import zio.macros.accessible

@accessible
trait ServiceA {
  def pureMethod(v: Something): SomethingElse
}

// below will be autogenerated
object ServiceA {
  def pureMethod(v: Something): ZIO[ServiceA, Nothing, SomethingElse] =
    ZIO.serviceWith[ServiceA](_.pureMethod(v))
}
```

The `@throwing` annotation will mark impure methods. Using this annotation will request ZIO to push the error on the error channel:

```scala
import zio._
import zio.macros.accessible
import zio.macros.throwing

@accessible
trait ServiceB {
  @throwing
  def impureMethod(v: Something): SomethingElse
}

// below will be autogenerated
object ServiceB {
  def impureMethod(v: Something): ZIO[Service, Throwable, SomethingElse] =
    ZIO.serviceWithZIO[ServiceB](s => ZIO(s.impureMethod(v)))
}
```

## Capability tags

### Installation

```scala
libraryDependencies += "dev.zio" %% "zio-test" % "<zio-version>"
```

### Description

The `@mockable[A]` generates _capability tags_ and _mock layer_ into annotated object.

```scala
import zio.mock.mockable

@mockable[AccountObserver]
object AccountObserverMock
```

Will result in:

```scala mdoc:invisible
import zio._

trait AccountEvent
trait AccountObserver {
  def processEvent(event: AccountEvent): UIO[Unit]
}
```

```scala mdoc:compile-only
import zio._
import zio.test.mock.{Mock, Proxy}

object AccountObserverMock extends Mock[AccountObserver] {
  object ProcessEvent extends Effect[AccountEvent, Nothing, Unit]
  object RunCommand   extends Effect[Unit, Nothing, Unit]

  val compose: URLayer[Proxy, AccountObserver] =
    ZIO.serviceWithZIO[Proxy] { proxy =>
      withRuntime[Any].map { rts =>
        new AccountObserver {
          def processEvent(event: AccountEvent) = proxy(ProcessEvent, event)
          def runCommand: UIO[Unit]             = proxy(RunCommand)
        }
      }
    }.toLayer
}
```
