"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[59613],{59946:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"zio-connect/dynamodb-connector","title":"DynamoDB Connector","description":"Setup","source":"@site/docs/zio-connect/dynamodb-connector.md","sourceDirName":"zio-connect","slug":"/zio-connect/dynamodb-connector","permalink":"/zio-connect/dynamodb-connector","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-connect/dynamodb-connector.md","tags":[],"version":"current","frontMatter":{"id":"dynamodb-connector","title":"DynamoDB Connector"},"sidebar":"ecosystem-sidebar","previous":{"title":"Couchbase Connector","permalink":"/zio-connect/couchbase-connector"},"next":{"title":"File Connector","permalink":"/zio-connect/file-connector"}}');var i=n(74848),s=n(28453);const r={id:"dynamodb-connector",title:"DynamoDB Connector"},o=void 0,l={},c=[{value:"Setup",id:"setup",level:2},{value:"Operators",id:"operators",level:2},{value:"<code>batchGetItem</code>",id:"batchgetitem",level:2},{value:"<code>batchWriteItem</code>",id:"batchwriteitem",level:2},{value:"<code>createTable</code>",id:"createtable",level:2},{value:"<code>deleteItem</code>",id:"deleteitem",level:2},{value:"<code>deleteTable</code>",id:"deletetable",level:2},{value:"<code>describeTable</code>",id:"describetable",level:2},{value:"<code>listTables</code>",id:"listtables",level:2},{value:"<code>getItem</code>",id:"getitem",level:2},{value:"<code>putItem</code>",id:"putitem",level:2},{value:"<code>query</code>",id:"query",level:2},{value:"<code>scan</code>",id:"scan",level:2},{value:"<code>tableExists</code>",id:"tableexists",level:2},{value:"<code>updateItem</code>",id:"updateitem",level:2},{value:"<code>updateTable</code>",id:"updatetable",level:2}];function d(e){const t={a:"a",code:"code",em:"em",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h2,{id:"setup",children:"Setup"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:'libraryDependencies += "dev.zio" %% "zio-connect-dynamodb" % "0.4.4"\n'})}),"\n",(0,i.jsx)(t.p,{children:"How to use it?"}),"\n",(0,i.jsxs)(t.p,{children:["All available DynamoDBConnector combinators and operations are available in the package object ",(0,i.jsx)(t.code,{children:"zio.connect.dynamodb._"}),"\nyou will need to import that to get started."]}),"\n",(0,i.jsxs)(t.p,{children:["Additionally, you must also configure and provide the underlying ",(0,i.jsx)(t.code,{children:"DynamoDB"})," layer provided by ",(0,i.jsx)(t.code,{children:"zio-aws"}),"\nyou can read more about how to configure it ",(0,i.jsx)(t.a,{href:"https://zio.github.io/zio-aws/docs/overview/overview_config",children:"here"})]}),"\n",(0,i.jsxs)(t.p,{children:["If you have default credentials in the system environment typically at ",(0,i.jsx)(t.code,{children:"~/.aws/credentials"})," or as env variables\nthe following configuration will likely work."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:"import zio._\nimport zio.aws.netty.NettyHttpClient\nimport zio.aws.core.config.AwsConfig\nimport zio.aws.core.httpclient.HttpClient\nimport zio.connect.dynamodb._\n\nlazy val httpClient: ZLayer[Any, Throwable, HttpClient] = NettyHttpClient.default\nlazy val awsConfig: ZLayer[Any, Throwable, AwsConfig]   = httpClient >>> AwsConfig.default\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Almost everything in this api requires the existence of a table, we utilize the models provided by ",(0,i.jsx)(t.code,{children:"zio-aws"}),"\nto create tables, requests, responses, and all other DynamoDB related types. These are typically modeled as\n",(0,i.jsx)(t.code,{children:"new-types"})," from zio-prelude or case classes."]}),"\n",(0,i.jsx)(t.p,{children:"Here's a create table request:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:'import zio.aws.dynamodb.model._\nimport zio.aws.dynamodb.model.primitives._\n\ndef createTableRequest(tableName: TableName): CreateTableRequest =\n  CreateTableRequest(\n    tableName = tableName,\n    attributeDefinitions = List(\n      AttributeDefinition(\n        KeySchemaAttributeName("id"),\n        ScalarAttributeType.S\n      )\n    ),\n    keySchema = List(\n      KeySchemaElement(KeySchemaAttributeName("id"), KeyType.HASH)\n    ),\n    provisionedThroughput = Some(\n      ProvisionedThroughput(\n        readCapacityUnits = PositiveLongObject(16L),\n        writeCapacityUnits = PositiveLongObject(16L)\n      )\n    ),\n    tableClass = TableClass.STANDARD\n  )\n'})}),"\n",(0,i.jsxs)(t.p,{children:['DynamoDB is "schemaless" in the sense that put data of different shapes in different rows, but you must define\na schema for the keys that the table depends on, these are called "partition keys" and "sort keys" or "hash" and "range" keys.\nOnly a partition/hash key is required, and you should only define attributes for the fields which constitute your\n',(0,i.jsx)(t.code,{children:"keySchema"}),". A valid table definition must also declare a ",(0,i.jsx)(t.code,{children:"provisionedThroughput"}),", but there are ",(0,i.jsx)(t.em,{children:"many"})," other\noptions available for creating tables, you can read more about tables ",(0,i.jsx)(t.a,{href:"https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html#HowItWorks.CoreComponents.Tables",children:"here"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Once you have a table definition you can create a table using the ",(0,i.jsx)(t.code,{children:"createTable"})," combinator:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:'val tableName = TableName("my-table")\nval createTableAction: ZIO[DynamoDBConnector, AwsError, CreateTableResponse] = createTable(createTableRequest(tableName)) >>> createTable\n'})}),"\n",(0,i.jsx)(t.p,{children:"Dynamo tables can take a moment to be created, so you'll want to have some kind of retry mechanism when performing\nsubsequent operations on the table. To illustrate, let's put an item into the table:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:'val putItemAction: ZIO[DynamoDBConnector, AwsError, PutItemResponse] = \n  ZStream(PutItemRequest(tableName, Map("id" -> AttributeValue(s = StringAttributeValue("my-id"))))) >>> putItem\n\nval putItemWithRetry: ZIO[DynamoDBConnector, AwsError, PutItemResponse] =\n    putItemAction.retryWhile {\n      case GenericAwsError(_: ResourceNotFoundException) => true\n      case _ => false\n    }\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Let's say we want to get an item from the table, we can use the ",(0,i.jsx)(t.code,{children:"getItem"})," combinator, note we need to\nprovide the ",(0,i.jsx)(t.em,{children:"full"})," key here to use it:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:'val key = Map("id" -> AttributeValue(s = StringAttributeValue("my-id")))\nval getItemAction: ZIO[DynamoDBConnector, AwsError, GetItemResponse] = \n  getItem(GetItemRequest(tableName, key)) >>> getItem\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Currently, entries from the table are returned as a ",(0,i.jsx)(t.code,{children:"Map[AttributeName, AttributeValue]"})," this may change in the future."]}),"\n",(0,i.jsx)(t.p,{children:"And we can also delete an item from the table:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:"val deleteItemAction: ZIO[DynamoDBConnector, AwsError, DeleteItemResponse] =\ndeleteItem(DeleteItemRequest(tableName, key)) >>> deleteItem\n"})}),"\n",(0,i.jsxs)(t.p,{children:["In order to run a program involving the DynamoDBConnector you need to provide a live ",(0,i.jsx)(t.code,{children:"DynamoDB"})," from ",(0,i.jsx)(t.code,{children:"zio-aws"})," along with config\nand the live connector layer:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:"override def run: ZIO[ZIOAppArgs with Scope, Any, Any] =\n     program.provide(awsConfig, DynamoDb.live, dynamoDBConnectorLiveLayer)\n"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"dynamoDBConnectorLiveLayer"})," is a ",(0,i.jsx)(t.code,{children:"ZLayer"})," that provides the ",(0,i.jsx)(t.code,{children:"LiveDynamoDBConnector"})]}),"\n",(0,i.jsx)(t.h2,{id:"operators",children:"Operators"}),"\n",(0,i.jsx)(t.p,{children:"The following operations are available:"}),"\n",(0,i.jsx)(t.h2,{id:"batchgetitem",children:(0,i.jsx)(t.code,{children:"batchGetItem"})}),"\n",(0,i.jsxs)(t.p,{children:["Accepts a stream of ",(0,i.jsx)(t.code,{children:"BatchGetItemRequest"})," and returns a ",(0,i.jsx)(t.code,{children:"Chunk"})," of ",(0,i.jsx)(t.code,{children:"BatchGetItemResponse"}),", if\none of the tables in the request is not available, the entire request will fail.\nThe response object will contain and ",(0,i.jsx)(t.code,{children:"unprocessedKeys"})," field which can be used to retry the request."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:'val item1              = Map(AttributeName("id") -> AttributeValue(s = StringAttributeValue("key1")))\nval item2              = Map(AttributeName("id") -> AttributeValue(s = StringAttributeValue("key2")))\nval keysAndAttributes  = KeysAndAttributes(List(item1))\nval keysAndAttributes2 = KeysAndAttributes(List(item2))\n\nval batchGetItemRequest =\n  BatchGetItemRequest(Map(tableName -> keysAndAttributes, tableName2 -> keysAndAttributes2))\n  \nval batchGetItemAction: ZIO[DynamoDBConnector, AwsError, Chunk[BatchGetItemResponse]] =\n  batchGetItem(ZStream(batchGetItemRequest)) >>> batchGetItem\n'})}),"\n",(0,i.jsx)(t.h2,{id:"batchwriteitem",children:(0,i.jsx)(t.code,{children:"batchWriteItem"})}),"\n",(0,i.jsxs)(t.p,{children:["Accepts a stream of ",(0,i.jsx)(t.code,{children:"BatchWriteItemRequest"})," and returns a ",(0,i.jsx)(t.code,{children:"Chunk"})," of ",(0,i.jsx)(t.code,{children:"BatchWriteItemResponse"}),", if\none of the tables in the request is not available, the entire request will fail. This is used to\nsimultaneously put and delete items on multiple tables, you cannot write and delete an item\nwith the same key in the same table in a single request. The response object does\nhave an ",(0,i.jsx)(t.code,{children:"unprocessedKeys"})," field which can be used to retry the remaining requests."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:'val tableName = TableName("batchWriteItem1")\nval item1     = Map(AttributeName("id") -> AttributeValue(s = StringAttributeValue("key1")))\nval item2     = Map(AttributeName("id") -> AttributeValue(s = StringAttributeValue("key2")))\nval writeRequests = List(\n  WriteRequest(putRequest = PutRequest(item1)),\n  WriteRequest(putRequest = PutRequest(item2))\n)\nval batchWriteItemRequest = BatchWriteItemRequest(\n  Map(tableName -> writeRequests)\n)\n\nval batchWriteItemAction: ZIO[DynamoDBConnector, AwsError, Chunk[BatchWriteItemResponse]] =\n  batchWriteItem(ZStream(batchWriteItemRequest)) >>> batchWriteItem\n'})}),"\n",(0,i.jsx)(t.h2,{id:"createtable",children:(0,i.jsx)(t.code,{children:"createTable"})}),"\n",(0,i.jsxs)(t.p,{children:["Accepts a stream of ",(0,i.jsx)(t.code,{children:"CreateTableRequest"})," and returns ",(0,i.jsx)(t.code,{children:"Unit"}),". Will fail with a ",(0,i.jsx)(t.code,{children:"ResourceInUseException"})," if the table already exists."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:'def createTableRequest(tableName: TableName): CreateTableRequest =\n  CreateTableRequest(\n    tableName = tableName,\n    attributeDefinitions = List(\n      AttributeDefinition(\n        KeySchemaAttributeName("id"),\n        ScalarAttributeType.S\n      )\n    ),\n    keySchema = List(\n      KeySchemaElement(KeySchemaAttributeName("id"), KeyType.HASH)\n    ),\n    provisionedThroughput = Some(\n      ProvisionedThroughput(\n        readCapacityUnits = PositiveLongObject(16L),\n        writeCapacityUnits = PositiveLongObject(16L)\n      )\n    ),\n    tableClass = TableClass.STANDARD\n  )\n    \nval createTableAction: ZIO[DynamoDBConnector, AwsError, Unit] =\n    ZStream(createTableRequest(tableName)) >>> createTable\n'})}),"\n",(0,i.jsx)(t.h2,{id:"deleteitem",children:(0,i.jsx)(t.code,{children:"deleteItem"})}),"\n",(0,i.jsxs)(t.p,{children:["Accepts a stream of ",(0,i.jsx)(t.code,{children:"DeleteItemRequest"})," and returns ",(0,i.jsx)(t.code,{children:"Unit"}),". Will fail with a\n",(0,i.jsx)(t.code,{children:"ResourceNotFoundException"})," if the table does not exist, does\nnot fail if the item does not exist."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:'val item1 = Map(AttributeName("id") -> AttributeValue(s = StringAttributeValue("key1")))\nval deleteItemAction: ZIO[DynamoDBConnector, AwsError, Unit] = ZStream(DeleteItemRequest(tableName, item1)) >>> deleteItem\n'})}),"\n",(0,i.jsx)(t.h2,{id:"deletetable",children:(0,i.jsx)(t.code,{children:"deleteTable"})}),"\n",(0,i.jsxs)(t.p,{children:["Accepts a stream of ",(0,i.jsx)(t.code,{children:"DeleteTableRequest"})," and returns ",(0,i.jsx)(t.code,{children:"Unit"}),". Will fail\nwith ",(0,i.jsx)(t.code,{children:"ResourceNotFoundException"})," if the table does not exist."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:"val deleteTableAction: ZIO[DynamoDBConnector, AwsError, Unit] = ZStream(DeleteTableRequest(tableName)) >>> deleteTable\n"})}),"\n",(0,i.jsx)(t.h2,{id:"describetable",children:(0,i.jsx)(t.code,{children:"describeTable"})}),"\n",(0,i.jsxs)(t.p,{children:["Accepts a stream of ",(0,i.jsx)(t.code,{children:"DescribeTableRequest"})," and returns a ",(0,i.jsx)(t.code,{children:"Chunk"})," of ",(0,i.jsx)(t.code,{children:"DescribeTableResponse"}),". Will fail\nif the table does not exist."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:"val describeTableAction: ZIO[DynamoDBConnector, AwsError, Chunk[DescribeTableResponse]] = ZStream(DescribeTableRequest(tableName)) >>> describeTable\n"})}),"\n",(0,i.jsx)(t.h2,{id:"listtables",children:(0,i.jsx)(t.code,{children:"listTables"})}),"\n",(0,i.jsxs)(t.p,{children:["Takes a ",(0,i.jsx)(t.code,{children:"ListTableRequest"})," and return a Stream of ",(0,i.jsx)(t.code,{children:"TableName"}),", can also provide a limit to the number of tables returned."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:"val listTablesAction: ZIO[DynamoDBConnector, AwsError, TableName] = listTables(ListTablesRequest()).runCollect\n"})}),"\n",(0,i.jsx)(t.h2,{id:"getitem",children:(0,i.jsx)(t.code,{children:"getItem"})}),"\n",(0,i.jsxs)(t.p,{children:["Accepts a stream of ",(0,i.jsx)(t.code,{children:"GetItemRequest"})," and returns a ",(0,i.jsx)(t.code,{children:"Chunk"})," of ",(0,i.jsx)(t.code,{children:"GetItemResponse"}),".\nWill fail with a ",(0,i.jsx)(t.code,{children:"ResourceNotFoundException"})," if the table does not exist."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:'val item1 = Map(AttributeName("id") -> AttributeValue(s = StringAttributeValue("key1")))\nval getItemAction: ZIO[DynamoDBConnector, AwsError, Chunk[GetItemResponse]] = ZStream(GetItemRequest(tableName, item1)) >>> getItem\n'})}),"\n",(0,i.jsx)(t.h2,{id:"putitem",children:(0,i.jsx)(t.code,{children:"putItem"})}),"\n",(0,i.jsxs)(t.p,{children:["Accepts a stream of ",(0,i.jsx)(t.code,{children:"PutItemRequest"})," and returns ",(0,i.jsx)(t.code,{children:"Unit"}),". Will fail with a ",(0,i.jsx)(t.code,{children:"ResourceNotFoundException"})," if the table does not exist."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:'val item1 = Map(AttributeName("id") -> AttributeValue(s = StringAttributeValue("key1")))\nval putItemAction: ZIO[DynamoDBConnector, AwsError, Unit] = ZStream(PutItemRequest(tableName, item1)) >>> putItem\n'})}),"\n",(0,i.jsx)(t.h2,{id:"query",children:(0,i.jsx)(t.code,{children:"query"})}),"\n",(0,i.jsxs)(t.p,{children:["Accepts a stream of ",(0,i.jsx)(t.code,{children:"QueryRequest"})," and returns a ",(0,i.jsx)(t.code,{children:"Chunk"})," of ",(0,i.jsx)(t.code,{children:"Map[AttributeName, AttributeValue]"}),".\nWill fail with a ",(0,i.jsx)(t.code,{children:"ResourceNotFoundException"})," if the table does not exist."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:'val tableName     = TableName("query1")\nval keyExpression = KeyExpression("id = :id")\nval expressionAttributeValues = Map(\n  ExpressionAttributeValueVariable(":id") -> AttributeValue(s = StringAttributeValue("key1"))\n)\nval queryRequest = QueryRequest(\n  tableName,\n  keyConditionExpression = keyExpression,\n  expressionAttributeValues = expressionAttributeValues\n)\n\nval queryAction: ZIO[DynamoDBConnector, AwsError, Chunk[Map[AttributeName, AttributeValue]]] =\n  ZStream(queryRequest) >>> query\n'})}),"\n",(0,i.jsx)(t.h2,{id:"scan",children:(0,i.jsx)(t.code,{children:"scan"})}),"\n",(0,i.jsxs)(t.p,{children:["Similar to query, but if you don't know the key, you can use scan to return some items in a table or filter\nby some non-key condition. Accepts a stream of ",(0,i.jsx)(t.code,{children:"ScanRequest"})," returns a ",(0,i.jsx)(t.code,{children:"Chunk"})," of ",(0,i.jsx)(t.code,{children:"Map[AttributeName, AttributeValue]"}),".\nFails if the table does not exist."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:'val tableName     = TableName("scan1")\nval scanRequest = ScanRequest(tableName)\n\nval scanAction: ZIO[DynamoDBConnector, AwsError, Chunk[Map[AttributeName, AttributeValue]]] =\n  ZStream(scanRequest) >>> scan\n'})}),"\n",(0,i.jsx)(t.h2,{id:"tableexists",children:(0,i.jsx)(t.code,{children:"tableExists"})}),"\n",(0,i.jsxs)(t.p,{children:["Given a ",(0,i.jsx)(t.code,{children:"TableName"}),", returns a ",(0,i.jsx)(t.code,{children:"Boolean"})," indicating if the table exists."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:"val tableExistsAction: ZIO[DynamoDBConnector, AwsError, Boolean] = ZStream(tableName) >>> tableExists\n"})}),"\n",(0,i.jsx)(t.h2,{id:"updateitem",children:(0,i.jsx)(t.code,{children:"updateItem"})}),"\n",(0,i.jsxs)(t.p,{children:["Accepts a stream of ",(0,i.jsx)(t.code,{children:"UpdateItemRequest"})," and returns ",(0,i.jsx)(t.code,{children:"Unit"}),". Will fail with a ",(0,i.jsx)(t.code,{children:"ResourceNotFoundException"})," if the table does not exist."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:'val tableName = TableName("updateItem1")\nval item1     = Map(AttributeName("id") -> AttributeValue(s = StringAttributeValue("key1")))\nval updateItemRequest = UpdateItemRequest(\n  tableName,\n  item1,\n  Map(\n    AttributeName("authorized") -> AttributeValueUpdate(\n      AttributeValue(bool = BooleanAttributeValue(true)),\n      AttributeAction.PUT\n    )\n  )\n)\n\nval updateItemAction: ZIO[DynamoDBConnector, AwsError, Unit] =\n  ZStream(updateItemRequest) >>> updateItem\n'})}),"\n",(0,i.jsx)(t.h2,{id:"updatetable",children:(0,i.jsx)(t.code,{children:"updateTable"})}),"\n",(0,i.jsxs)(t.p,{children:["Accepts a stream of ",(0,i.jsx)(t.code,{children:"UpdateTableRequest"})," and returns ",(0,i.jsx)(t.code,{children:"Unit"}),". Will fail with a ",(0,i.jsx)(t.code,{children:"ResourceNotFoundException"})," if the table does not exist."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:'val tableName = TableName("updateTable1")\nval updateTableRequest = UpdateTableRequest(\n  tableName,\n  provisionedThroughput = Some(\n    ProvisionedThroughput(\n      readCapacityUnits = PositiveLongObject(16L),\n      writeCapacityUnits = PositiveLongObject(16L)\n    )\n  )\n)\n\nval updateTableAction: ZIO[DynamoDBConnector, AwsError, Unit] =\n  ZStream(updateTableRequest) >>> updateTable\n'})})]})}function u(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var a=n(96540);const i={},s=a.createContext(i);function r(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);