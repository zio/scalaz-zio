"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[97792],{56709:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>c,contentTitle:()=>t,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"zio-json/configuration","title":"Configuration","description":"Field naming","source":"@site/docs/zio-json/configuration.md","sourceDirName":"zio-json","slug":"/zio-json/configuration","permalink":"/zio-json/configuration","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-json/configuration.md","tags":[],"version":"current","frontMatter":{"id":"configuration","title":"Configuration"},"sidebar":"ecosystem-sidebar","previous":{"title":"Encoding","permalink":"/zio-json/encoding"},"next":{"title":"Manual Instances","permalink":"/zio-json/manual-instances"}}');var o=a(74848),i=a(28453);const r={id:"configuration",title:"Configuration"},t=void 0,c={},l=[{value:"Field naming",id:"field-naming",level:2},{value:"jsonDiscriminator",id:"jsondiscriminator",level:2},{value:"Extra fields",id:"extra-fields",level:2},{value:"Aliases",id:"aliases",level:2},{value:"@jsonDerive",id:"jsonderive",level:2}];function d(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"field-naming",children:"Field naming"}),"\n",(0,o.jsxs)(n.p,{children:["By default, the field names of a case class are used as the JSON fields, but it is easy to override this with an annotation ",(0,o.jsx)(n.code,{children:"@jsonField"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["Moreover, you can also mark a whole case class with a member name transformation that will be applied to all members using ",(0,o.jsx)(n.code,{children:"@jsonMemberNames"})," annotation. It takes an argument of type ",(0,o.jsx)(n.code,{children:"JsonMemberFormat"})," which encodes the transformation that will be applied to member names."]}),"\n",(0,o.jsxs)(n.p,{children:["Four most popular transformations are already provided: KebabCase, SnakeCase, PascalCase and CamelCase. If you require something more specific you can also use CustomCase which takes a function of shape ",(0,o.jsx)(n.code,{children:"String => String"})," as an argument and can be used to perform any arbitrary transformation. ",(0,o.jsx)(n.code,{children:"@jsonField"})," annotation takes priority over the transformation defined by ",(0,o.jsx)(n.code,{children:"@jsonMemberNames"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"Here's an example json with most fields snake_cased and one kebab-cased:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-json",children:'{\n  "passion_fruit": true,\n  "granny_smith": true,\n  "dragon_fruit": true,\n  "blood-orange": false\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"And here's the target case class:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import zio.json._\n\n@jsonMemberNames(SnakeCase)\ncase class FruitBasket(\n  passionFruit: Boolean, \n  grannySmith: Boolean, \n  dragonFruit: Boolean, \n  @jsonField("blood-orange") bloodOrange: Boolean\n)\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Notice that all fields are camelCased in Scala and will be both encoded and decoded correctly to snake_case in JSON except ",(0,o.jsx)(n.code,{children:"bloodOrange"})," field that is annotated with a ",(0,o.jsx)(n.code,{children:"@jsonField"})," override that will force it to become ",(0,o.jsx)(n.code,{children:'"blood-orange"'})," after serialization."]}),"\n",(0,o.jsxs)(n.p,{children:["It is also possible to change the type hint that is used to discriminate case classes with ",(0,o.jsx)(n.code,{children:"@jsonHint"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["For example, these annotations change the expected JSON of our ",(0,o.jsx)(n.code,{children:"Fruit"})," family"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import zio.json._\n\nsealed trait Fruit\n\n@jsonHint("banaani") case class Banana(\n  @jsonField("bendiness") curvature: Double\n) extends Fruit\n\n@jsonHint("omena") case class Apple(\n  @jsonField("bad") poison: Boolean\n) extends Fruit\n\nobject Fruit {\n  implicit val codec: JsonCodec[Fruit] =\n    DeriveJsonCodec.gen[Fruit]\n}\n\nval banana: Fruit = Banana(0.5)\n// banana: Fruit = Banana(curvature = 0.5)\nval apple: Fruit = Apple(false)\n// apple: Fruit = Apple(poison = false)\n'})}),"\n",(0,o.jsx)(n.p,{children:"from"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-json",children:'{"Banana":{"curvature":0.5}}\n{"Apple":{"poison":false}}\n'})}),"\n",(0,o.jsx)(n.p,{children:"to"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'banana.toJson\n// res1: String = {"banaani":{"bendiness":0.5}}\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'apple.toJson\n// res2: String = {"omena":{"bad":false}}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Another way of changing type hint is using ",(0,o.jsx)(n.code,{children:"@jsonHintNames"})," annotation on sealed class. It allows to apply transformation\nto all type hint values in hierarchy. Same transformations are provided as for ",(0,o.jsx)(n.code,{children:"@jsonMemberNames"})," annotation."]}),"\n",(0,o.jsx)(n.p,{children:"Here's an example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import zio.json._\n\n@jsonHintNames(SnakeCase)\nsealed trait FruitKind\n\ncase class GoodFruit(good: Boolean) extends FruitKind\n\ncase class BadFruit(bad: Boolean) extends FruitKind\n\nobject FruitKind {\n  implicit val codec: JsonCodec[FruitKind] =\n    DeriveJsonCodec.gen[FruitKind]\n}\n\nval goodFruit: FruitKind = GoodFruit(true)\n// goodFruit: FruitKind = GoodFruit(good = true)\nval badFruit: FruitKind = BadFruit(true)\n// badFruit: FruitKind = BadFruit(bad = true)\n\ngoodFruit.toJson\n// res3: String = "{\\"good_fruit\\":{\\"good\\":true}}"\nbadFruit.toJson\n// res4: String = "{\\"bad_fruit\\":{\\"bad\\":true}}"\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Note that with this code, you can't directly decode the subclasses of ",(0,o.jsx)(n.code,{children:"FruitKind"}),". You would need to create a dedicated decoder for each subclass."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"object GoodFruit {\n  implicit val codec: JsonCodec[GoodFruit] =\n    DeriveJsonCodec.gen[GoodFruit]\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Since ",(0,o.jsx)(n.code,{children:"GoodFruit"})," is only a case class, it will not require any kind of discriminator to be decoded."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'"""{"good":true}""".fromJson[GoodFruit]\n// res5: Either[String, GoodFruit] = Right(value = GoodFruit(good = true))\n'})}),"\n",(0,o.jsxs)(n.p,{children:["If you want for some reason to decode only for a specific type of ",(0,o.jsx)(n.code,{children:"FruitKind"})," that has a discriminator, don't derive the codec for the subtype, but transform the ",(0,o.jsx)(n.code,{children:"FruitKind"})," codec."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'object BadFruit {\n  implicit val decoder: JsonDecoder[BadFruit] =\n    FruitKind.codec.decoder.mapOrFail {\n        case GoodFruit(_) => Left("Expected BadFruit, got GoodFruit")\n        case BadFruit(bad) => Right(BadFruit(bad))\n      }\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"jsondiscriminator",children:"jsonDiscriminator"}),"\n",(0,o.jsx)(n.p,{children:"A popular alternative way to encode sealed traits:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-json",children:'{"type":"banaani", "bendiness":0.5}\n\n{"type":"omena", "bad":false}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["is discouraged for performance reasons. However, if we have no choice in the matter, it may be accommodated with the ",(0,o.jsx)(n.code,{children:"@jsonDiscriminator"})," annotation"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'@jsonDiscriminator("type") sealed trait Fruit\n'})}),"\n",(0,o.jsx)(n.h2,{id:"extra-fields",children:"Extra fields"}),"\n",(0,o.jsxs)(n.p,{children:["We can raise an error if we encounter unexpected fields by using the ",(0,o.jsx)(n.code,{children:"@jsonNoExtraFields"})," annotation on a case class."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"@jsonNoExtraFields case class Watermelon(pips: Int)\n\nobject Watermelon {\n  implicit val decoder: JsonDecoder[Watermelon] =\n    DeriveJsonDecoder.gen[Watermelon]\n}\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'"""{ "pips": 32 }""".fromJson[Watermelon]\n// res7: Either[String, Watermelon] = Right(value = Watermelon(pips = 32))\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'"""{ "pips": 32, "color": "yellow" }""".fromJson[Watermelon]\n// res8: Either[String, Watermelon] = Left(value = "(invalid extra field)")\n'})}),"\n",(0,o.jsx)(n.h2,{id:"aliases",children:"Aliases"}),"\n",(0,o.jsx)(n.p,{children:"Since zio-json 0.4.3."}),"\n",(0,o.jsxs)(n.p,{children:["After a case class field has changed name, you may still want to read JSON documents that use the old name. This is supported by the ",(0,o.jsx)(n.code,{children:"@jsonAliases"})," annotation."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'case class Strawberry(\n  @jsonAliases("seeds") seedCount: Int\n)\n\nobject Strawberry {\n  implicit val decoder: JsonDecoder[Strawberry] =\n    DeriveJsonDecoder.gen[Strawberry]\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"The following two expressions result in an equal value:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'"""{ "seeds": 32 }""".fromJson[Strawberry]\n// res9: Either[String, Strawberry] = Right(value = Strawberry(seedCount = 32))\n"""{ "seedCount": 32 }""".fromJson[Strawberry]\n// res10: Either[String, Strawberry] = Right(\n//   value = Strawberry(seedCount = 32)\n// )\n'})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"@jsonAliases"})," annotation supports multiple aliases. The annotation has no effect on encoding."]}),"\n",(0,o.jsx)(n.h2,{id:"jsonderive",children:"@jsonDerive"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Requires zio-json-macros"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"@jsonDerive"})," allows to reduce that needs to be written using an annotation macro to generate JsonDecoder/JsonEncoder at build-time."]}),"\n",(0,o.jsx)(n.p,{children:"For generating both Encoder and Decoder, simply use jsonDerive"}),"\n",(0,o.jsx)(n.p,{children:"For example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio.json._\n\n@jsonDerive case class Watermelon(pips: Int)\n"})}),"\n",(0,o.jsx)(n.p,{children:"It is equivalent to:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio.json._\n\ncase class Watermelon(pips: Int)\n\nobject Watermelon {\n  implicit val codec: JsonCodec[Watermelon] =\n    DeriveJsonCodec.gen[Watermelon]\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"To generate only an encoder, we can set it as config parameter:"}),"\n",(0,o.jsx)(n.p,{children:"For example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio.json._\n\n@jsonDerive(JsonDeriveConfig.Encoder) case class Watermelon(pips: Int)\n"})}),"\n",(0,o.jsx)(n.p,{children:"It is equivalent to:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio.json._\n\ncase class Watermelon(pips: Int)\n\nobject Watermelon {\n  implicit val encoder: JsonEncoder[Watermelon] =\n    DeriveJsonEncoder.gen[Watermelon]\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"To generate only a decoder, we can set it as config parameter:"}),"\n",(0,o.jsx)(n.p,{children:"For example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",metastring:"modc:compile-only",children:"import zio.json._\n\n@jsonDerive(JsonDeriveConfig.Decoder) case class Watermelon(pips: Int)\n"})}),"\n",(0,o.jsx)(n.p,{children:"It is equivalent to:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio.json._\n\ncase class Watermelon(pips: Int)\n\nobject Watermelon {\n  implicit val decoder: JsonDecoder[Watermelon] =\n    DeriveJsonDecoder.gen[Watermelon]\n}\n"})})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,n,a)=>{a.d(n,{R:()=>r,x:()=>t});var s=a(96540);const o={},i=s.createContext(o);function r(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);