"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[17184],{25211:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>m,frontMatter:()=>r,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"zio-schema/integration-with-zio-streams","title":"Integration with ZIO Streams","description":"In addition to the regular encode and decode functions, each codec also has a streaming version of these functions called streamEncoder and streamDecoder. By invoking these methods on codecs, we can obtain a ZPipeline where the encoder and decoder are integrated into the ZPipeline stream transformer.","source":"@site/docs/zio-schema/integration-with-zio-streams.md","sourceDirName":"zio-schema","slug":"/zio-schema/integration-with-zio-streams","permalink":"/zio-schema/integration-with-zio-streams","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-schema/integration-with-zio-streams.md","tags":[],"version":"current","frontMatter":{"id":"integration-with-zio-streams","title":"Integration with ZIO Streams"}}');var s=t(74848),i=t(28453);const r={id:"integration-with-zio-streams",title:"Integration with ZIO Streams"},a=void 0,c={},d=[];function h(e){const n={code:"code",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["In addition to the regular ",(0,s.jsx)(n.code,{children:"encode"})," and ",(0,s.jsx)(n.code,{children:"decode"})," functions, each codec also has a streaming version of these functions called ",(0,s.jsx)(n.code,{children:"streamEncoder"})," and ",(0,s.jsx)(n.code,{children:"streamDecoder"}),". By invoking these methods on codecs, we can obtain a ",(0,s.jsx)(n.code,{children:"ZPipeline"})," where the encoder and decoder are integrated into the ",(0,s.jsx)(n.code,{children:"ZPipeline"})," stream transformer."]}),"\n",(0,s.jsxs)(n.p,{children:["We can use the ",(0,s.jsx)(n.code,{children:"ZPipline"})," to transform (encode/decode) a stream of values of type ",(0,s.jsx)(n.code,{children:"A"})," into a stream of values of type ",(0,s.jsx)(n.code,{children:"B"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, assume we have a stream of ",(0,s.jsx)(n.code,{children:"Person"})," values, and we want to encode them into a stream of bytes and then convert back to ",(0,s.jsx)(n.code,{children:"Person"})," values. We can do this as follows:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.stream._\nimport zio.schema._\nimport zio.schema.codec.JsonCodec\n\nobject Main extends ZIOAppDefault {\n  case class Person(name: String, age: Int)\n\n  object Person {\n    implicit val schema: Schema[Person] = DeriveSchema.gen[Person]\n  }\n\n  def run: ZIO[Any, Exception, Unit] =\n    ZStream\n      .fromIterable(Seq(Person("John", 42)))\n      .debug("the input object is")\n      .via(JsonCodec.schemaBasedBinaryCodec[Person].streamEncoder)\n      .via(ZPipeline.utfDecode)\n      .debug("json string of person")\n      .via(ZPipeline.utf8Encode)\n      .via(JsonCodec.schemaBasedBinaryCodec[Person].streamDecoder)\n      .debug("person after roundtrip")\n      .runDrain\n}\n'})})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var o=t(96540);const s={},i=o.createContext(s);function r(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);