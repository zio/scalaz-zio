"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[87714],{71940:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"reference/service-pattern/accessor-methods","title":"Accessor Methods (deprecated)","description":"Accessor methods are little helper methods that lookup a service from the environment, and then forward your call to","source":"@site/docs/reference/service-pattern/accessor-methods.md","sourceDirName":"reference/service-pattern","slug":"/reference/service-pattern/accessor-methods","permalink":"/reference/service-pattern/accessor-methods","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/service-pattern/accessor-methods.md","tags":[],"version":"current","frontMatter":{"id":"accessor-methods","title":"Accessor Methods (deprecated)","sidebar_label":"Accessor Methods (deprecated)"},"sidebar":"reference-sidebar","previous":{"title":"Reloadable Services","permalink":"/reference/service-pattern/reloadable-services"},"next":{"title":"Introduction to Dependency Injection in ZIO","permalink":"/reference/di/"}}');var s=r(74848),a=r(28453);const i={id:"accessor-methods",title:"Accessor Methods (deprecated)",sidebar_label:"Accessor Methods (deprecated)"},o=void 0,c={},l=[{value:"What is an Accessor Method?",id:"what-is-an-accessor-method",level:2},{value:"Why are accessor methods deprecated?",id:"why-are-accessor-methods-deprecated",level:2},{value:"Generating Accessor Methods with Macros",id:"generating-accessor-methods-with-macros",level:2},{value:"Monomorphic Services",id:"monomorphic-services",level:2},{value:"Writing Polymorphic Services",id:"writing-polymorphic-services",level:2},{value:"With Proper Type Parameters",id:"with-proper-type-parameters",level:3},{value:"With Higher-Kinded Type Parameters (<code>F[_]</code>)",id:"with-higher-kinded-type-parameters-f_",level:3},{value:"With Higher-Kinded Type Parameters (<code>F[_, _]</code>)",id:"with-higher-kinded-type-parameters-f_-_",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Accessor methods are little helper methods that lookup a service from the environment, and then forward your call to\nthat service."}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.a,{href:"/reference/service-pattern/",children:"service pattern"})," provides a better way to structure programs, and it does not need accessor\nmethods. Therefore, accessor methods are now deprecated."]})}),"\n",(0,s.jsx)(n.h2,{id:"what-is-an-accessor-method",children:"What is an Accessor Method?"}),"\n",(0,s.jsx)(n.p,{children:"Imagine a service defined as:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"import zio._\n\ntrait BlobStorage {\n  def get(id: String): ZIO[Any, Throwable, Array[Byte]]\n\n  def put(content: Array[Byte]): ZIO[Any, Throwable, String]\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"The accessor methods are then defined as:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nobject BlobStorage {\n  // Accessor method for BlobStorage.get\n  def get(id: String): ZIO[BlobStorage, Throwable, Array[Byte]] =\n    ZIO.serviceWithZIO[BlobStorage](_.get(id))\n\n  // Accessor method for BlobStorage.put\n  def put(content: Array[Byte]): ZIO[BlobStorage, Throwable, String] =\n    ZIO.serviceWithZIO[BlobStorage](_.put(content))\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Each accessor method fetches the service from the environment, and then immediately forwards the method call."}),"\n",(0,s.jsx)(n.p,{children:"The service can now be used as:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'  BlobStorage.get("blob-id")  // returns a ZIO[BlobStorage, Throwable, Array[Byte]]\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Notice how the ",(0,s.jsx)(n.code,{children:"BlobStorage"})," trait is in the environment (the ",(0,s.jsx)(n.code,{children:"R"})," channel) of the returned ZIO."]}),"\n",(0,s.jsx)(n.h2,{id:"why-are-accessor-methods-deprecated",children:"Why are accessor methods deprecated?"}),"\n",(0,s.jsx)(n.p,{children:"Accessor methods have some drawbacks:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"You must write more code."}),"\n",(0,s.jsx)(n.li,{children:"The extra code must stay in sync with the service's trait."}),"\n",(0,s.jsx)(n.li,{children:"The service is looked up in the environment each time it is used. This incurs (a small) performance penalty."}),"\n",(0,s.jsxs)(n.li,{children:["The ZIO environment permeates deeper into your code than strictly necessary. This problem is exacerbated when\nservices start exposing the services they depend on in the ",(0,s.jsx)(n.code,{children:"R"})," channel of their method's return types."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The recommended ",(0,s.jsx)(n.a,{href:"/reference/service-pattern/",children:"service pattern"})," injects service dependencies directly, and therefore has none of\nthese problems."]}),"\n",(0,s.jsx)(n.h2,{id:"generating-accessor-methods-with-macros",children:"Generating Accessor Methods with Macros"}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["Accessor Methods macros are only available for Scala versions ",(0,s.jsx)(n.code,{children:"2.x"}),". They will ",(0,s.jsx)(n.em,{children:"not"})," be made available for scala ",(0,s.jsx)(n.code,{children:"3.x"}),"."]})}),"\n",(0,s.jsxs)(n.p,{children:["Writing accessor methods is a repetitive task and is tedious for services with many methods. We can automate the\ngeneration of accessor methods using the ",(0,s.jsx)(n.code,{children:"zio-macro"})," module."]}),"\n",(0,s.jsxs)(n.p,{children:["To install the ",(0,s.jsx)(n.code,{children:"zio-macro"})," add the following line in the ",(0,s.jsx)(n.code,{children:"build.sbt"})," file:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'libraryDependencies += "dev.zio" %% "zio-macros" % "<zio-version>"\n'})}),"\n",(0,s.jsx)(n.p,{children:"In addition, enable macro expansion with:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["for Scala ",(0,s.jsx)(n.code,{children:"2.13"})," add the compiler option:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'scalacOptions += "-Ymacro-annotations"\n'})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["for Scala ",(0,s.jsx)(n.code,{children:"< 2.13"})," add the macro paradise compiler plugin:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'compilerPlugin(("org.scalamacros" % "paradise"  % "2.1.1") cross CrossVersion.full)\n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["If you are using IntelliJ, macro generated accessors will not be available in IDE hints\nwithout ",(0,s.jsx)(n.a,{href:"/guides/tutorials/run-our-first-zio-project-with-intellij-idea",children:"ZIO plugin"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"monomorphic-services",children:"Monomorphic Services"}),"\n",(0,s.jsxs)(n.p,{children:["We can use the ",(0,s.jsx)(n.code,{children:"@accessible"})," macro to generate ",(0,s.jsx)(n.em,{children:"service member accessors"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"import zio._\nimport zio.macros.accessible\n\n@accessible\ntrait ServiceA {\n  def method(input: Something): UIO[Unit]\n}\n\n// below will be autogenerated\nobject ServiceA {\n  def method(input: Something) =\n    ZIO.serviceWithZIO[ServiceA](_.method(input))\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["For normal values, a ",(0,s.jsx)(n.code,{children:"ZIO"})," with ",(0,s.jsx)(n.code,{children:"Nothing"})," on error channel is generated:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"import zio._\nimport zio.macros.accessible\n\n@accessible\ntrait ServiceB {\n  def pureMethod(input: Something): SomethingElse\n}\n\n// below will be autogenerated\nobject ServiceB {\n  def pureMethod(input: Something): ZIO[ServiceB, Nothing, SomethingElse] =\n    ZIO.serviceWith[ServiceB](_.pureMethod(input))\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"@throwing"})," annotation will mark impure methods. Using this annotation will request ZIO to push the error on the\nerror channel:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"import zio._\nimport zio.macros.accessible\nimport zio.macros.throwing\n\n@accessible\ntrait ServiceC {\n  @throwing\n  def impureMethod(input: Something): SomethingElse\n}\n\n// below will be autogenerated\nobject ServiceC {\n  def impureMethod(input: Something): ZIO[ServiceC, Throwable, SomethingElse] =\n    ZIO.serviceWithZIO[ServiceC](s => ZIO(s.impureMethod(input)))\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Below is a fully working example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.macros.accessible\n\n@accessible\ntrait KeyValueStore {\n  def set(key: String, value: Int): Task[Int]\n\n  def get(key: String): Task[Int]\n}\n\n\ncase class InmemoryKeyValueStore(map: Ref[Map[String, Int]])\n  extends KeyValueStore {\n  override def set(key: String, value: Int): Task[Int] =\n    map.update(_.updated(key, value)).map(_ => value)\n\n  override def get(key: String): Task[Int] =\n    map.get.map(_.get(key)).someOrFailException\n}\n\nobject InmemoryKeyValueStore {\n  val layer: ULayer[KeyValueStore] =\n    ZLayer {\n      for {\n        map <- Ref.make(Map[String, Int]())\n      } yield InmemoryKeyValueStore(map)\n    }\n}\n\nobject MainApp extends ZIOAppDefault {\n  val myApp =\n    for {\n      _ <- KeyValueStore.set("key", 5)\n      key <- KeyValueStore.get("key")\n    } yield key\n\n  def run = myApp.provide(InmemoryKeyValueStore.layer).debug\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"writing-polymorphic-services",children:"Writing Polymorphic Services"}),"\n",(0,s.jsx)(n.h3,{id:"with-proper-type-parameters",children:"With Proper Type Parameters"}),"\n",(0,s.jsxs)(n.p,{children:["If the service is polymorphic for some proper types, we can use the ",(0,s.jsx)(n.code,{children:"@accessible"})," macro like previous examples."]}),"\n",(0,s.jsxs)(n.p,{children:["Assume we have a ",(0,s.jsx)(n.code,{children:"KeyValueStore"})," like below, as we will see using ",(0,s.jsx)(n.code,{children:"@accessible"})," will generate us the accessor methods:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.macros.accessible\n\n\n@accessible\ntrait KeyValueStore[K, V] {\n  def set(key: K, value: V): Task[V]\n\n  def get(key: K): Task[V]\n}\n\n\ncase class InmemoryKeyValueStore(map: Ref[Map[String, Int]])\n  extends KeyValueStore[String, Int] {\n  override def set(key: String, value: Int): Task[Int] =\n    map.update(_.updated(key, value)).map(_ => value)\n\n  override def get(key: String): Task[Int] =\n    map.get.map(_.get(key)).someOrFailException\n}\n\nobject InmemoryKeyValueStore {\n  val layer: ULayer[KeyValueStore[String, Int]] =\n    ZLayer {\n      for {\n        map <- Ref.make(Map[String, Int]())\n      } yield InmemoryKeyValueStore(map)\n    }\n}\n\nobject MainApp extends ZIOAppDefault {\n  val myApp =\n    for {\n      _ <- KeyValueStore.set("key", 5)\n      key <- KeyValueStore.get[String, Int]("key")\n    } yield key\n\n  def run = myApp.provide(InmemoryKeyValueStore.layer).debug\n}\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"with-higher-kinded-type-parameters-f_",children:["With Higher-Kinded Type Parameters (",(0,s.jsx)(n.code,{children:"F[_]"}),")"]}),"\n",(0,s.jsxs)(n.p,{children:["If a service has a higher-kinded type parameter like ",(0,s.jsx)(n.code,{children:"F[_]"})," we should use the ",(0,s.jsx)(n.code,{children:"accessibleM"})," macro. Here is an example of\nsuch a service:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.macros.accessibleM\n\n@accessibleM[Task]\ntrait KeyValueStore[K, V, F[_]] {\n  def set(key: K, value: V): F[V]\n\n  def get(key: K): F[V]\n}\n\ncase class InmemoryKeyValueStore(map: Ref[Map[String, Int]])\n  extends KeyValueStore[String, Int, Task] {\n  override def set(key: String, value: Int): Task[Int] =\n    map.update(_.updated(key, value)).map(_ => value)\n\n  override def get(key: String): Task[Int] =\n    map.get.map(_.get(key)).someOrFailException\n\n}\n\nobject InmemoryKeyValueStore {\n  val layer: ULayer[KeyValueStore[String, Int, Task]] =\n    ZLayer {\n      for {\n        map <- Ref.make(Map[String, Int]())\n      } yield InmemoryKeyValueStore(map)\n    }\n}\n\n\nobject MainApp extends ZIOAppDefault {\n  val myApp =\n    for {\n      key <- KeyValueStore.set[String, Int]("key", 5)\n      _ <- KeyValueStore.get[String, Int]("key")\n    } yield key\n\n  def run = myApp.provide(InmemoryKeyValueStore.layer).debug\n}\n\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"with-higher-kinded-type-parameters-f_-_",children:["With Higher-Kinded Type Parameters (",(0,s.jsx)(n.code,{children:"F[_, _]"}),")"]}),"\n",(0,s.jsxs)(n.p,{children:["If the service has a higher-kinded type parameter like ",(0,s.jsx)(n.code,{children:"F[_, _]"})," we should use the ",(0,s.jsx)(n.code,{children:"accessibleMM"})," macro. Let's see an\nexample:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.macros.accessibleMM\n\n@accessibleMM[IO]\ntrait KeyValueStore[K, V, E, F[_, _]] {\n  def set(key: K, value: V): F[E, V]\n\n  def get(key: K): F[E, V]\n}\n\ncase class InmemoryKeyValueStore(map: Ref[Map[String, Int]])\n  extends KeyValueStore[String, Int, String, IO] {\n  override def set(key: String, value: Int): IO[String, Int] =\n    map.update(_.updated(key, value)).map(_ => value)\n\n  override def get(key: String): IO[String, Int] =\n    map.get.map(_.get(key)).someOrFail(s"key not found: $key")\n}\n\nobject InmemoryKeyValueStore {\n  val layer: ULayer[KeyValueStore[String, Int, String, IO]] =\n    ZLayer {\n      for {\n        map <- Ref.make(Map[String, Int]())\n      } yield InmemoryKeyValueStore(map)\n    }\n}\n\nobject MainApp extends ZIOAppDefault {\n  val myApp =\n    for {\n      _ <- KeyValueStore.set[String, Int, String]("key", 5)\n      key <- KeyValueStore.get[String, Int, String]("key")\n    } yield key\n\n  def run = myApp.provide(InmemoryKeyValueStore.layer).debug\n\n}\n'})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>o});var t=r(96540);const s={},a=t.createContext(s);function i(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);