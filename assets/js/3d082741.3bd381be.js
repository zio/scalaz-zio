"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[45754],{40537:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"reference/stream/zstream/error-handling","title":"Error Handling","description":"Recovering from Failure","source":"@site/docs/reference/stream/zstream/error-handling.md","sourceDirName":"reference/stream/zstream","slug":"/reference/stream/zstream/error-handling","permalink":"/reference/stream/zstream/error-handling","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/stream/zstream/error-handling.md","tags":[],"version":"current","frontMatter":{"id":"error-handling","title":"Error Handling"},"sidebar":"reference-sidebar","previous":{"title":"Consuming Streams","permalink":"/reference/stream/zstream/consuming-streams"},"next":{"title":"Scheduling","permalink":"/reference/stream/zstream/scheduling"}}');var a=n(74848),s=n(28453);const i={id:"error-handling",title:"Error Handling"},o=void 0,l={},c=[{value:"Recovering from Failure",id:"recovering-from-failure",level:2},{value:"Recovering from Defects",id:"recovering-from-defects",level:2},{value:"Recovery from Some Errors",id:"recovery-from-some-errors",level:2},{value:"Recovering to ZIO Effect",id:"recovering-to-zio-effect",level:2},{value:"Retry a Failing Stream",id:"retry-a-failing-stream",level:2},{value:"From/To Either",id:"fromto-either",level:2},{value:"Refining Errors",id:"refining-errors",level:2},{value:"Timing Out",id:"timing-out",level:2}];function h(e){const r={code:"code",em:"em",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(r.h2,{id:"recovering-from-failure",children:"Recovering from Failure"}),"\n",(0,a.jsxs)(r.p,{children:["If we have a stream that may fail, we might need to recover from the failure and run another stream, the ",(0,a.jsx)(r.code,{children:"ZStream#orElse"})," takes another stream, so when the failure occurs it will switch over to the provided stream:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-scala",children:'import zio.stream._\n\nval s1 = ZStream(1, 2, 3) ++ ZStream.fail("Oh! Error!") ++ ZStream(4, 5)\nval s2 = ZStream(6, 7, 8)\n\nval stream = s1.orElse(s2)\n// Output: 1, 2, 3, 6, 7, 8\n'})}),"\n",(0,a.jsxs)(r.p,{children:["Another variant of ",(0,a.jsx)(r.code,{children:"orElse"})," is ",(0,a.jsx)(r.code,{children:"ZStream#orElseEither"}),", which distinguishes elements of the two streams using the ",(0,a.jsx)(r.code,{children:"Either"})," data type. Using this operator, the result of the previous example should be ",(0,a.jsx)(r.code,{children:"Left(1), Left(2), Left(3), Right(6), Right(7), Right(8)"}),"."]}),"\n",(0,a.jsxs)(r.p,{children:["ZIO stream has ",(0,a.jsx)(r.code,{children:"ZStream#catchAll"})," which is powerful version of ",(0,a.jsx)(r.code,{children:"ZStream#orElse"}),". By using ",(0,a.jsx)(r.code,{children:"catchAll"})," we can decide what to do based on the type and value of the failure:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-scala",children:'val first =\n  ZStream(1, 2, 3) ++\n    ZStream.fail("Uh Oh!") ++\n    ZStream(4, 5) ++\n    ZStream.fail("Ouch")\n\nval second = ZStream(6, 7, 8)\nval third = ZStream(9, 10, 11)\n\nval stream = first.catchAll {\n  case "Uh Oh!" => second\n  case "Ouch"   => third\n}\n// Output: 1, 2, 3, 6, 7, 8\n'})}),"\n",(0,a.jsx)(r.h2,{id:"recovering-from-defects",children:"Recovering from Defects"}),"\n",(0,a.jsxs)(r.p,{children:["If we need to recover from all causes of failures including defects we should use the ",(0,a.jsx)(r.code,{children:"ZStream#catchAllCause"})," method:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-scala",children:'val s1 = ZStream(1, 2, 3) ++ ZStream.dieMessage("Oh! Boom!") ++ ZStream(4, 5)\nval s2 = ZStream(7, 8, 9)\n\nval stream = s1.catchAllCause(_ => s2)\n// Output: 1, 2, 3, 7, 8, 9\n'})}),"\n",(0,a.jsx)(r.h2,{id:"recovery-from-some-errors",children:"Recovery from Some Errors"}),"\n",(0,a.jsxs)(r.p,{children:["If we need to recover from specific failure we should use ",(0,a.jsx)(r.code,{children:"ZStream#catchSome"}),":"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-scala",children:'val s1 = ZStream(1, 2, 3) ++ ZStream.fail("Oh! Error!") ++ ZStream(4, 5)\nval s2 = ZStream(7, 8, 9)\nval stream = s1.catchSome {\n  case "Oh! Error!" => s2\n}\n// Output: 1, 2, 3, 7, 8, 9\n'})}),"\n",(0,a.jsxs)(r.p,{children:["And, to recover from a specific cause, we should use ",(0,a.jsx)(r.code,{children:"ZStream#catchSomeCause"})," method:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-scala",children:'import zio._\nimport zio.Cause._\nimport zio.stream._\n\nval s1 = ZStream(1, 2, 3) ++ ZStream.dieMessage("Oh! Boom!") ++ ZStream(4, 5)\nval s2 = ZStream(7, 8, 9)\nval stream = s1.catchSomeCause { case Die(value, _) => s2 }\n'})}),"\n",(0,a.jsx)(r.h2,{id:"recovering-to-zio-effect",children:"Recovering to ZIO Effect"}),"\n",(0,a.jsxs)(r.p,{children:["If our stream encounters an error, we can provide some cleanup task as ZIO effect to our stream by using the ",(0,a.jsx)(r.code,{children:"ZStream#onError"})," method:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-scala",children:'import zio._\nimport zio.stream._\n\nval stream = \n  (ZStream(1, 2, 3) ++ ZStream.dieMessage("Oh! Boom!") ++ ZStream(4, 5))\n    .onError(_ => Console.printLine("Stream application closed! We are doing some cleanup jobs.").orDie)\n'})}),"\n",(0,a.jsx)(r.h2,{id:"retry-a-failing-stream",children:"Retry a Failing Stream"}),"\n",(0,a.jsxs)(r.p,{children:["When a stream fails, it can be retried according to the given schedule to the ",(0,a.jsx)(r.code,{children:"ZStream#retry"})," operator:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-scala",children:'val numbers = ZStream(1, 2, 3) ++ \n  ZStream\n    .fromZIO(\n      Console.print("Enter a number: ") *> Console.readLine\n        .flatMap(x =>\n          x.toIntOption match {\n            case Some(value) => ZIO.succeed(value)\n            case None        => ZIO.fail("NaN")\n          }\n        )\n    )\n    .retry(Schedule.exponential(1.second))\n'})}),"\n",(0,a.jsx)(r.h2,{id:"fromto-either",children:"From/To Either"}),"\n",(0,a.jsxs)(r.p,{children:["Sometimes, we might be working with legacy API which does error handling with the ",(0,a.jsx)(r.code,{children:"Either"})," data type. We can ",(0,a.jsx)(r.em,{children:"absolve"})," their error types into the ZStream effect using ",(0,a.jsx)(r.code,{children:"ZStream.absolve"}),":"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-scala",children:"def legacyFetchUrlAPI(url: URL): Either[Throwable, String] = ???\n\ndef fetchUrl(\n    url: URL\n): ZStream[Any, Throwable, String] = \n  ZStream.fromZIO(\n    ZIO.attemptBlocking(legacyFetchUrlAPI(url))\n  ).absolve\n"})}),"\n",(0,a.jsxs)(r.p,{children:["The type of this stream before absolving is ",(0,a.jsx)(r.code,{children:"ZStream[Any, Throwable, Either[Throwable, String]]"}),", this operation let us submerge the error case of an ",(0,a.jsx)(r.code,{children:"Either"})," into the ",(0,a.jsx)(r.code,{children:"ZStream"})," error type."]}),"\n",(0,a.jsxs)(r.p,{children:["We can do the opposite by exposing an error of type ",(0,a.jsx)(r.code,{children:"ZStream[R, E, A]"})," as a part of the ",(0,a.jsx)(r.code,{children:"Either"})," by using ",(0,a.jsx)(r.code,{children:"ZStream#either"}),":"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-scala",children:"val inputs: ZStream[Any, Nothing, Either[IOException, String]] = \n  ZStream.fromZIO(Console.readLine).either\n"})}),"\n",(0,a.jsxs)(r.p,{children:["When we are working with streams of ",(0,a.jsx)(r.code,{children:"Either"})," values, we might want to fail the stream as soon as the emission of the first ",(0,a.jsx)(r.code,{children:"Left"})," value:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-scala",children:'// Stream of Either values that cannot fail\nval eitherStream: ZStream[Any, Nothing, Either[String, Int]] =\n  ZStream(Right(1), Right(2), Left("failed to parse"), Right(4))\n\n// A Fails with the first emission of the left value\nval stream: ZStream[Any, String, Int] = eitherStream.rightOrFail("fail")\n'})}),"\n",(0,a.jsx)(r.h2,{id:"refining-errors",children:"Refining Errors"}),"\n",(0,a.jsxs)(r.p,{children:["We can keep one or some errors and terminate the fiber with the rest by using ",(0,a.jsx)(r.code,{children:"ZStream#refineOrDie"}),":"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-scala",children:"val stream: ZStream[Any, Throwable, Int] =\n  ZStream.fail(new Throwable)\n\nval res: ZStream[Any, IllegalArgumentException, Int] =\n  stream.refineOrDie { case e: IllegalArgumentException => e }\n"})}),"\n",(0,a.jsx)(r.h2,{id:"timing-out",children:"Timing Out"}),"\n",(0,a.jsxs)(r.p,{children:["We can timeout a stream if it does not produce a value after some duration using ",(0,a.jsx)(r.code,{children:"ZStream#timeout"}),", ",(0,a.jsx)(r.code,{children:"ZStream#timeoutFail"})," and ",(0,a.jsx)(r.code,{children:"timeoutFailCause"})," operators:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-scala",children:"stream.timeoutFail(new TimeoutException)(10.seconds)\n"})}),"\n",(0,a.jsx)(r.p,{children:"Or we can switch to another stream if the first stream does not produce a value after some duration:"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-scala",children:"val alternative = ZStream.fromZIO(ZIO.attempt(???))\nstream.timeoutTo(10.seconds)(alternative)\n"})})]})}function d(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,a.jsx)(r,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},28453:(e,r,n)=>{n.d(r,{R:()=>i,x:()=>o});var t=n(96540);const a={},s=t.createContext(a);function i(e){const r=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(s.Provider,{value:r},e.children)}}}]);