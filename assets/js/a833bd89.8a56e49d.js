"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[57461],{28453:(e,n,r)=>{r.d(n,{R:()=>d,x:()=>c});var t=r(96540);const s={},i=t.createContext(s);function d(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),t.createElement(i.Provider,{value:n},e.children)}},67676:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>d,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"reference/sync/concurrentmap","title":"ConcurrentMap","description":"A ConcurrentMap is a wrapper over java.util.concurrent.ConcurrentHashMap.","source":"@site/docs/reference/sync/concurrentmap.md","sourceDirName":"reference/sync","slug":"/reference/sync/concurrentmap","permalink":"/reference/sync/concurrentmap","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/sync/concurrentmap.md","tags":[],"version":"current","frontMatter":{"id":"concurrentmap","title":"ConcurrentMap"},"sidebar":"reference-sidebar","previous":{"title":"CyclicBarrier","permalink":"/reference/sync/cyclicbarrier"},"next":{"title":"ConcurrentSet","permalink":"/reference/sync/concurrentset"}}');var s=r(74848),i=r(28453);const d={id:"concurrentmap",title:"ConcurrentMap"},c=void 0,l={},a=[{value:"Motivation",id:"motivation",level:2},{value:"Creation",id:"creation",level:2},{value:"Update Operations",id:"update-operations",level:2},{value:"Putting values",id:"putting-values",level:3},{value:"Removing values",id:"removing-values",level:3},{value:"Replacing values",id:"replacing-values",level:3},{value:"Remapping Values",id:"remapping-values",level:3},{value:"Retrieval Operations",id:"retrieval-operations",level:2},{value:"Example Usage",id:"example-usage",level:2}];function o(e){const n={code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.code,{children:"ConcurrentMap"})," is a wrapper over ",(0,s.jsx)(n.code,{children:"java.util.concurrent.ConcurrentHashMap"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"motivation",children:"Motivation"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"HashMap"})," in the Scala standard library is not thread-safe. This means that if multiple fibers are accessing the same key, and trying to modify the value, this can lead to inconsistent results."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, assume we have a ",(0,s.jsx)(n.code,{children:"HashMap"})," with a key ",(0,s.jsx)(n.code,{children:"foo"})," and a value of ",(0,s.jsx)(n.code,{children:"0"}),". Let's see what happens if we perform the ",(0,s.jsx)(n.code,{children:"inc"})," workflow 100 times concurrently:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nimport scala.collection.mutable\n\nobject MainApp extends ZIOAppDefault {\n\n  def inc(ref: Ref[mutable.HashMap[String, Int]], key: String) =\n    for {\n      _ <- ref.get\n      _ <- ref.update { map =>\n        map.updateWith(key)(_.map(_ + 1))\n        map\n      }\n    } yield ()\n\n  def run =\n    for {\n      ref <- Ref.make(mutable.HashMap(("foo", 0)))\n      _ <- ZIO.foreachParDiscard(1 to 100)(_ => inc(ref, "foo"))\n      _ <- ref.get.map(_.get("foo")).debug("The final value of foo is")\n    } yield ()\n\n}\n// Different outputs on different executions:\n// The final value of foo is Some(72)\n// The final value of foo is Some(84)\n// The final value of foo is Some(78)\n// ...\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Since the ",(0,s.jsx)(n.code,{children:"HashMap"})," is not thread-safe, every time we run this program, we might get different results, which is not desirable."]}),"\n",(0,s.jsxs)(n.p,{children:["So we need a concurrent data structure that can be used safely in concurrent environments, which the ",(0,s.jsx)(n.code,{children:"ConcurrentMap"})," does for us:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.concurrent.ConcurrentMap\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    for {\n      map <- ConcurrentMap.make(("foo", 0), ("bar", 1), ("baz", 2))\n      _ <- ZIO.foreachParDiscard(1 to 100)(_ =>\n        map.computeIfPresent("foo", (_, v) => v + 1)\n      )\n      _ <- map.get("foo").debug("The final value of foo is")\n    } yield ()\n}\n// Output:\n// The final value of foo is Some(100)\n'})}),"\n",(0,s.jsx)(n.h2,{id:"creation",children:"Creation"}),"\n",(0,s.jsxs)(n.p,{children:["To make an empty ",(0,s.jsx)(n.code,{children:"ConcurrentMap"})," we use ",(0,s.jsx)(n.code,{children:"ConcurrentMap.empty"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"import zio.concurrent.ConcurrentMap\n\nval empty = ConcurrentMap.empty[String, Int]\n"})}),"\n",(0,s.jsxs)(n.p,{children:["And to make a ",(0,s.jsx)(n.code,{children:"ConcurrentMap"})," with some initial values we use ",(0,s.jsx)(n.code,{children:"ConcurrentMap.make"})," or ",(0,s.jsx)(n.code,{children:"ConcurrentMap.fromIterable"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import zio.concurrent.ConcurrentMap\n\nval map1 = ConcurrentMap.make(("foo", 0), ("bar", 1), ("baz", 2))\nval map2 = ConcurrentMap.fromIterable(List(("foo", 0), ("bar", 1), ("baz", 2)))\n'})}),"\n",(0,s.jsx)(n.h2,{id:"update-operations",children:"Update Operations"}),"\n",(0,s.jsxs)(n.p,{children:["Basic operations are provided to manipulate the values in the ",(0,s.jsx)(n.code,{children:"ConcurrentMap"}),":"]}),"\n",(0,s.jsx)(n.h3,{id:"putting-values",children:"Putting values"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Method"}),(0,s.jsx)(n.th,{children:"Definition"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"put(key: K, value: V): UIO[Option[V]]"})}),(0,s.jsx)(n.td,{children:"Adds a new key-value pair and optionally returns previously bound value."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"putAll(keyValues: (K, V)*): UIO[Unit]"})}),(0,s.jsx)(n.td,{children:"Adds all new key-value pairs."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"putIfAbsent(key: K, value: V): UIO[Option[V]]"})}),(0,s.jsx)(n.td,{children:"Adds a new key-value pair, unless the key is already bound to some other value."})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"removing-values",children:"Removing values"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Method"}),(0,s.jsx)(n.th,{children:"Definition"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"remove(key: K): UIO[Option[V]]"})}),(0,s.jsx)(n.td,{children:"Removes the entry for the given key, optionally returning value associated with it."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"remove(key: K, value: V): UIO[Boolean]"})}),(0,s.jsx)(n.td,{children:"Removes the entry for the given key if it is mapped to a given value."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"removeIf(p: (K, V) => Boolean): UIO[Unit]"})}),(0,s.jsx)(n.td,{children:"Removes all elements which do not satisfy the given predicate."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"retainIf(p: (K, V) => Boolean): UIO[Unit]"})}),(0,s.jsx)(n.td,{children:"Removes all elements which do not satisfy the given predicate."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"clear: UIO[Unit]"})}),(0,s.jsx)(n.td,{children:"Removes all elements."})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"replacing-values",children:"Replacing values"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Method"}),(0,s.jsx)(n.th,{children:"Definition"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"replace(key: K, value: V): UIO[Option[V]]"})}),(0,s.jsx)(n.td,{children:"Replaces the entry for the given key only if it is mapped to some value."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"replace(key: K, oldValue: V, newValue: V): UIO[Boolean]"})}),(0,s.jsx)(n.td,{children:"Replaces the entry for the given key only if it was previously mapped to a given value."})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"remapping-values",children:"Remapping Values"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Method"}),(0,s.jsx)(n.th,{children:"Definition"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"compute(key: K, remap: (K, V) => V): UIO[Option[V]]"})}),(0,s.jsx)(n.td,{children:"Attempts to compute a mapping for the given key and its current mapped value."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"def computeIfAbsent(key: K, map: K => V): UIO[V]"})}),(0,s.jsx)(n.td,{children:"Computes a value of a non-existing key."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"computeIfPresent(key: K, remap: (K, V) => V): UIO[Option[V]]"})}),(0,s.jsx)(n.td,{children:"Attempts to compute a new mapping of an existing key."})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"retrieval-operations",children:"Retrieval Operations"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Method"}),(0,s.jsx)(n.th,{children:"Definition"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"get(key: K): UIO[Option[V]]"})}),(0,s.jsx)(n.td,{children:"Retrieves the value associated with the given key."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"exists(p: (K, V) => Boolean): UIO[Boolean]"})}),(0,s.jsx)(n.td,{children:"Tests whether a given predicate holds true for at least one element in a map."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"collectFirst[B](pf: PartialFunction[(K, V), B]): UIO[Option[B]]"})}),(0,s.jsx)(n.td,{children:"Finds the first element of a map for which the partial function is defined and applies the function to it."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"fold[S](zero: S)(f: (S, (K, V)) => S): UIO[S]"})}),(0,s.jsx)(n.td,{children:"Folds the elements of a map using the given binary operator."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"forall(p: (K, V) => Boolean): UIO[Boolean]"})}),(0,s.jsx)(n.td,{children:"Tests whether a predicate is satisfied by all elements of a map."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"isEmpty: UIO[Boolean]"})}),(0,s.jsx)(n.td,{children:"True if there are no elements in this map."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"toChunk: UIO[Chunk[(K, V)]]"})}),(0,s.jsx)(n.td,{children:"Collects all entries into a chunk."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"toList: UIO[List[(K, V)]]"})}),(0,s.jsx)(n.td,{children:"Collects all entries into a list."})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"example-usage",children:"Example Usage"}),"\n",(0,s.jsx)(n.p,{children:"Given:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import zio.concurrent.ConcurrentMap\nimport zio.{Chunk, ZIO}\n\nfor {\n  emptyMap <- ConcurrentMap.empty[Int, String]\n  data     <- ZIO.succeed(Chunk(1 -> "A", 2 -> "B", 3 -> "C"))\n  mapA     <- ConcurrentMap.fromIterable(data)\n  map100   <- ConcurrentMap.make(1 -> 100)\n  mapB     <- ConcurrentMap.make(("A", 1), ("B", 2), ("C", 3))\n} yield ()\n'})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Operation"}),(0,s.jsx)(n.th,{children:"Result"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'mapA.collectFirst { case (3, _) => "Three" }'})}),(0,s.jsx)(n.td,{children:'"Three"'})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'mapA.collectFirst { case (4, _) => "Four" }'})}),(0,s.jsx)(n.td,{children:"Empty"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"map100.compute(1, _+_).get(1)"})}),(0,s.jsx)(n.td,{children:"101"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'emptyMap.computeIfAbsent("abc", _.length).get("abc")'})}),(0,s.jsx)(n.td,{children:"3"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"map100.computeIfPresent(1, _+_).get(1)"})}),(0,s.jsx)(n.td,{children:"101"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"mapA.exists((k, _) => k % 2 == 0)"})}),(0,s.jsx)(n.td,{children:"true"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"mapA.exists((k, _) => k == 4)"})}),(0,s.jsx)(n.td,{children:"false"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"mapB.fold(0) { case (acc, (_, value)) => acc + value }"})}),(0,s.jsx)(n.td,{children:"6"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"mapB.forall((_, v) => v < 4)"})}),(0,s.jsx)(n.td,{children:"true"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"emptyMap.get(1)"})}),(0,s.jsx)(n.td,{children:"None"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'emptyMap.put(1, "b").get(1)'})}),(0,s.jsx)(n.td,{children:'"b"'})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'mapA.putIfAbsent(2, "b").get(2)'})}),(0,s.jsx)(n.td,{children:'"B"'})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'emptyMap.putAll((1, "A"), (2, "B"), (3, "C")).get(1)'})}),(0,s.jsx)(n.td,{children:'"A"'})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"mapA.remove(1).get(1)"})}),(0,s.jsx)(n.td,{children:"None"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'mapA.remove(1,"b").get(1)'})}),(0,s.jsx)(n.td,{children:'"A"'})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"mapA.removeIf((k, _) => k != 1).get(1)"})}),(0,s.jsx)(n.td,{children:'"A"'})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"mapA.removeIf((k, _) => k != 1).get(2)"})}),(0,s.jsx)(n.td,{children:"None"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"mapA.retainIf((k, _) => k == 1).get(1)"})}),(0,s.jsx)(n.td,{children:'"A"'})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"mapA.retainIf((k, _) => k == 1).get(2)"})}),(0,s.jsx)(n.td,{children:"None"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"mapA.clear.isEmpty"})}),(0,s.jsx)(n.td,{children:"true"})]})]})]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}}}]);