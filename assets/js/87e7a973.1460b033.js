"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[61808],{35835:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"zio-direct/index","title":"Introduction to ZIO Direct Style","description":"ZIO Direct Style is a library that allows using directly-style i.e. imperative programming with ZIO effects which is based on the Monadless paradigm.","source":"@site/docs/zio-direct/index.md","sourceDirName":"zio-direct","slug":"/zio-direct/","permalink":"/zio-direct/","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-direct/index.md","tags":[],"version":"current","frontMatter":{"id":"index","title":"Introduction to ZIO Direct Style","sidebar_label":"Introduction"},"sidebar":"ecosystem-sidebar","previous":{"title":"ZIO Deriving","permalink":"/zio-deriving/"},"next":{"title":"Supported Constructs","permalink":"/zio-direct/supported-constructs"}}');var o=t(74848),s=t(28453);const a={id:"index",title:"Introduction to ZIO Direct Style",sidebar_label:"Introduction"},r=void 0,l={},c=[{value:"Installation",id:"installation",level:2},{value:"IDE Support",id:"ide-support",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Branching and Looping Support",id:"branching-and-looping-support",level:2},{value:"Great for Refs and FiberRefs!",id:"great-for-refs-and-fiberrefs",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"ZIO Direct Style is a library that allows using directly-style i.e. imperative programming with ZIO effects which is based on the Monadless paradigm."}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.a,{href:"https://github.com/zio/zio/wiki/Project-Stages",children:(0,o.jsx)(n.img,{src:"https://img.shields.io/badge/Project%20Stage-Development-green.svg",alt:"Development"})})," ",(0,o.jsx)(n.img,{src:"https://github.com/zio/zio-direct/workflows/CI/badge.svg",alt:"CI Badge"})," ",(0,o.jsx)(n.a,{href:"https://oss.sonatype.org/content/repositories/releases/dev/zio/zio-direct_3/",children:(0,o.jsx)(n.img,{src:"https://img.shields.io/nexus/r/https/oss.sonatype.org/dev.zio/zio-direct_3.svg?label=Sonatype%20Release",alt:"Sonatype Releases"})})," ",(0,o.jsx)(n.a,{href:"https://oss.sonatype.org/content/repositories/snapshots/dev/zio/zio-direct_3/",children:(0,o.jsx)(n.img,{src:"https://img.shields.io/nexus/s/https/oss.sonatype.org/dev.zio/zio-direct_3.svg?label=Sonatype%20Snapshot",alt:"Sonatype Snapshots"})})," ",(0,o.jsx)(n.a,{href:"https://javadoc.io/doc/dev.zio/zio-direct-docs_3",children:(0,o.jsx)(n.img,{src:"https://javadoc.io/badge2/dev.zio/zio-direct-docs_3/javadoc.svg",alt:"javadoc"})})," ",(0,o.jsx)(n.a,{href:"https://github.com/zio/zio-direct",children:(0,o.jsx)(n.img,{src:"https://img.shields.io/github/stars/zio/zio-direct?style=social",alt:"ZIO Direct Style"})})]}),"\n",(0,o.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,o.jsxs)(n.p,{children:["To use zio-direct, add the following to your ",(0,o.jsx)(n.code,{children:"build.sbt"})," file."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'libraryDependencies += "dev.zio" %% "zio-direct" % "1.0.0-RC7"\n'})}),"\n",(0,o.jsx)(n.p,{children:"You can also use zio-direct with ZStream and ZPure by importing the following modules."}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Currently this is only supported in Scala 3."}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'// ZStream\nlibraryDependencies += "dev.zio" %% "zio-direct-streams" % "1.0.0-RC7"\n// ZPure\nlibraryDependencies += "dev.zio" %% "zio-direct-pure" % "1.0.0-RC7"\n'})}),"\n",(0,o.jsxs)(n.p,{children:["See the ",(0,o.jsx)(n.a,{href:"other-supported-monads",children:"Other Supported Monads"})," section for more details."]}),"\n",(0,o.jsx)(n.h2,{id:"ide-support",children:"IDE Support"}),"\n",(0,o.jsxs)(n.p,{children:["The preferred IDE to use with ZIO-Direct is Visual Studio Code + Metals. This is because Metals correctly reads the returns from ",(0,o.jsx)(n.code,{children:"defer"})," calls directly from the Scala compiler which is not the case of IntelliJ. To remedy this issue, a Library Extension is provided for ZIO-Direct. See the ",(0,o.jsx)(n.a,{href:"intellij-support",children:"IntelliJ Support"})," section for more details."]}),"\n",(0,o.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,o.jsx)(n.p,{children:"Talk at Functional Scala 2022:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Video - ",(0,o.jsx)(n.a,{href:"https://www.youtube.com/watch?v=DgqfLfzq5eo",children:"https://www.youtube.com/watch?v=DgqfLfzq5eo"})]}),"\n",(0,o.jsxs)(n.li,{children:["Slides - ",(0,o.jsx)(n.a,{href:"https://www.slideshare.net/deusaquilus/ziodirect-functional-scala-2022",children:"https://www.slideshare.net/deusaquilus/ziodirect-functional-scala-2022"})]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["ZIO-Direct allows direct style programming with ZIO. This library provides a ",(0,o.jsx)(n.em,{children:"syntactic sugar"})," that is more powerful than for-comprehensions as well as more natural to use. Simply add the ",(0,o.jsx)(n.code,{children:".run"})," suffix to any ZIO effect in order to retrieve its value."]}),"\n",(0,o.jsxs)(n.p,{children:["ZIO-Direct works by using macros to rewrite sequential code into flatMap-chains based on the ",(0,o.jsx)(n.a,{href:"https://github.com/monadless/monadless",children:"Monadless"})," paradigm. The values resulting in ",(0,o.jsx)(n.code,{children:".run"})," calls from the ZIO effects are not actually awaited. Instead, they are rolled-up into a chain of flatMaps."]}),"\n",(0,o.jsx)(n.p,{children:"For example, in imperative programming operations typically are done in a simple set of steps."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"object FileOps:\n  def read(file: File): String\n  def write(file: File, content: String): Unit\n\nval textA = read(fileA)\nval textB = read(fileB)\nwrite(fileC, textA + textB)\n"})}),"\n",(0,o.jsx)(n.p,{children:"Using functional programming, the equivalent of this functionality is a set of nested flatMap-chains."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"object FileOps\n  def read(file: File): ZIO[Any, Throwable, String]\n  def write(file: File, content: String): ZIO[Any, Throwable, Unit]\n\nread(fileA).flatMap { textA =>\n  read(fileB).flatMap { textB =>\n    write(fileC, textA + textB)\n  }\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"In order to avoid this complexity scala provides a for-comprehension syntactic sugar."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"for {\n  textA <- read(fileA)\n  textB <- read(fileB)\n  _ <- write(fileC, textA + textB)\n} yield ()\n"})}),"\n",(0,o.jsx)(n.p,{children:"Unfortunately this syntactic sugar is limited in many cases, for example, inserting a conditional value inside is impossible."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'for {\n  textA <- read(fileA)\n  // Not a possible syntax\n  if (fileA.contains("some string")) {\n    textB <- read(fileB)\n    _ <- write(fileC, textA + textB)\n  }\n} yield ()\n'})}),"\n",(0,o.jsx)(n.p,{children:"ZIO-Direct offers an equivalent syntactic sugar that is more ergonomic and allows many constructs that for-comprehensions do not."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'defer {\n  val textA = read(fileA).run\n  if (fileA.contains("some string")) {\n    val textB = read(fileB).run\n    write(fileC, textA + textB).run\n  }\n}\n'})}),"\n",(0,o.jsx)(n.h1,{id:"zio-tailored",children:"ZIO-Tailored"}),"\n",(0,o.jsx)(n.p,{children:"ZIO-Direct is specifically tailored to ZIO capabilities as it supports Environment and Error composition in ZIO effects similar to the for-comprehension."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"val out: ZIO[CustomerConfig & DistributorConfig, CustomerGetException | DistrubutorGetException, (Customer, Distributor)] =\n  defer {\n    // Get a customer-configuration object from the environment and extract its .url field\n    val custUrl: String = ZIO.service[CustomerConfig].run.url\n    // Get a distributor-configuration from the environment and extract its .url field\n    val distUrl: String = ZIO.service[DistributorConfig].run.url\n    (\n      // Use the two configurations to make an HTTP-call\n      parseCustomer(httpGetCustomer(custUrl).run),\n      parseDistrubutor(httpGetDistributor(distUrl).run)\n    )\n  }\n"})}),"\n",(0,o.jsx)(n.h2,{id:"branching-and-looping-support",children:"Branching and Looping Support"}),"\n",(0,o.jsx)(n.p,{children:"Unlike the for-comprehension, ZIO-Direct supports branching and looping in the use of flatMaps composition.\nLet's have a look at a another non-trivial example."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"class Database:\n  def nextRow(): ZIO[Any, Throwable, Row]\n  def hasNextRow(): ZIO[Any, Throwable, Boolean]\n  def lockNextRow(): ZIO[Any, Throwable, Boolean]\nobject Database:\n  def open: ZIO[Any, Throwable, Database]\n\ndefer {\n  // Open a database connection\n  val db = Database.open().run\n  // See if there is is a next-row\n  while (db.hasNextRow().run) {\n    // try to lock, if aquired continue\n    if (db.lockNextRow().run)\n      val nextRow = db.nextRow().run\n      doSomethingWith(nextRow)\n    else\n      waitT()\n  }\n}\n"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"NOTE: The above database-api is imaginary."}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"The above code needs to be translated into something like this:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"Database.open.flatMap { db =>\n  def whileFun(): ZIO[Any, Throwable, Unit] =\n    db.hasNextRow().flatMap { hasNextRow =>\n      if (hasNextRow)(\n        db.lockNextRow().flatMap { lockNextRow =>\n          if (!lockNextRow)\n            db.nextRow().map(nextRow => doSomethingWith(nextRow))\n          else\n            ZIO.succeed(waitT())\n        }\n      ).flatMap(_ => whileFun())\n      else\n        ZIO.unit\n    }\n  whileFun()\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"Note that normally this is the exact code that would have to be written to capture such functionality For-comprehensions do not provide a way to do looping and branching so in such cases\na combination of flatMaps and recursion is necessary to avoid calling effects unnecessarily."}),"\n",(0,o.jsx)(n.h2,{id:"great-for-refs-and-fiberrefs",children:"Great for Refs and FiberRefs!"}),"\n",(0,o.jsx)(n.p,{children:"ZIO-direct makes it much easier to use ZIO mutable Ref and FiberRef variables. Since retrieveing and updating Ref and FiberRef variables requries a flatMap/for-comprehension call, it is typically very difficult to use them with branching/looping constructs. ZIO-direct makes these cases much easier."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"class DatabaseApi {\n  val connRef = FiberRef.make[Option[Connection]](None)\n  def openConnection(): Connection = lowLevelDatabaseApi.openConnection()\n  def transaction(action: Action) =\n    defer {\n      val conn = connRef.get.run\n      if (conn == None) {\n        connRef.set(Some(openConnection())).run\n      }\n      val conn1 = connRef.get.run\n      conn.execute(action).run\n    }\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"Instead of having to write the following code:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"class DatabaseApi {\n  val connRef = FiberRef.make[Option[Connection]](None)\n  def openConnection(): Connection = lowLevelDatabaseApi.openConnection()\n  def transaction(action: Action) =\n    connRef.get.flatMap { conn =>\n      (if (conn == None) {\n        connRef.set(Some(openConnection()))\n      } else {\n        ZIO.unit\n      }).flatMap(_ => connRef.get.flatMap { conn1 =>\n        conn1.execute(action)\n      })\n    }\n\n  // Note that for-comprehensions do not help very much in this use-case\n  def transaction0(action: Action) =\n    for {\n      conn <- connRef.get\n      _ <- if (conn == None) {\n        connRef.set(Some(openConnection()))\n      } else {\n        ZIO.unit\n      }\n      conn1 <- connRef.get\n      _ <- conn1.execute(action)\n    }\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var i=t(96540);const o={},s=i.createContext(o);function a(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);