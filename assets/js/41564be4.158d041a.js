"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[56830],{75006:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>s,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"reference/stm/index","title":"Introduction to Software Transactional Memory","description":"Overview","source":"@site/docs/reference/stm/index.md","sourceDirName":"reference/stm","slug":"/reference/stm/","permalink":"/reference/stm/","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/stm/index.md","tags":[],"version":"current","frontMatter":{"id":"index","title":"Introduction to Software Transactional Memory"},"sidebar":"reference-sidebar","previous":{"title":"Semaphore","permalink":"/reference/concurrency/semaphore"},"next":{"title":"STM","permalink":"/reference/stm/stm.md"}}');var i=n(74848),o=n(28453);const s={id:"index",title:"Introduction to Software Transactional Memory"},r=void 0,c={},l=[{value:"Overview",id:"overview",level:2},{value:"The Problem",id:"the-problem",level:2},{value:"Composable Concurrency",id:"composable-concurrency",level:2},{value:"How Does it Work?",id:"how-does-it-work",level:2},{value:"STM Data Types",id:"stm-data-types",level:2},{value:"Advantage of Using STM",id:"advantage-of-using-stm",level:2},{value:"Implication of Using STM",id:"implication-of-using-stm",level:2}];function h(e){const t={a:"a",code:"code",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(t.p,{children:"ZIO supports Software Transactional Memory (STM) which is a modular composable concurrency data structure. It allows us to combine and compose a group of memory operations and perform all of them in one single atomic operation."}),"\n",(0,i.jsx)(t.p,{children:"Software Transactional Memory is an abstraction for concurrent communications. The main benefits of STM are composability and modularity. We can write concurrent abstractions that can be composed with any other abstraction built using STM, without exposing the details of how our abstraction ensures safety. This is typically not the case with the locking mechanism."}),"\n",(0,i.jsxs)(t.p,{children:["The idea of the transactional operation is not new, they have been the fundamental of distributed systems, and those databases that guarantee us an ACID property. Software transactional memory is just all about memory operations. All operations are performed on memory. It is not related to a remote system or a database. Very similar to the database concept of ACID property, but the ",(0,i.jsx)(t.em,{children:"durability"}),", is missing which doesn't make sense for in-memory operations."]}),"\n",(0,i.jsx)(t.p,{children:"In transactional memory, we get these aspects of ACID properties:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Atomicity"})," \u2014 On write operations, we want ",(0,i.jsx)(t.em,{children:"atomic update"}),", which means the update operation either should run at once or not at all."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Consistency"})," \u2014 On read operations, we want a ",(0,i.jsx)(t.em,{children:"consistent view"})," of the state of the program that ensures us all references to the state, get the same value whenever they get the state."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Isolated"})," \u2014 If we have multiple updates, we need to perform these updates in isolated transactions. So each transaction doesn't affect other concurrent transactions. No matter how many fibers are running any number of transactions. None of them have to worry about what is happening in the other transactions."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["The ZIO STM API is inspired by Haskell's ",(0,i.jsx)(t.a,{href:"http://hackage.haskell.org/package/stm-2.5.0.0/docs/Control-Concurrent-STM.html",children:"STM library"})," although the implementation in ZIO is completely different."]}),"\n",(0,i.jsx)(t.h2,{id:"the-problem",children:"The Problem"}),"\n",(0,i.jsxs)(t.p,{children:["Let's start from a simple ",(0,i.jsx)(t.code,{children:"inc"})," function, which takes a mutable reference of ",(0,i.jsx)(t.code,{children:"Int"})," and increases it by ",(0,i.jsx)(t.code,{children:"amount"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:"def inc(counter: Ref[Int], amount: Int) = for {\n  c <- counter.get\n  _ <- counter.set(c + amount)\n} yield c\n"})}),"\n",(0,i.jsx)(t.p,{children:"If there is only one fiber in the world, it is not a problem. This function sounds correct. But what happens if in between reading the value of the counter and setting a new value, another fiber comes and mutates the value of the counter? Another fiber is just updating the counter just after we read the counter. So this function is subject to a race condition, we can test that with the following program:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:"for {\n  counter <- Ref.make(0)\n  _ <- ZIO.collectAllPar(ZIO.replicate(10)(inc(counter, 1)))\n  value <- counter.get\n} yield (value)\n"})}),"\n",(0,i.jsx)(t.p,{children:"The above program runs 10 concurrent fibers to increase the counter value. However, we cannot expect this program to always return 10 as a result."}),"\n",(0,i.jsxs)(t.p,{children:["To fix this issue, we need to perform the ",(0,i.jsx)(t.code,{children:"get"})," and ",(0,i.jsx)(t.code,{children:"set"})," operations atomically. The ",(0,i.jsx)(t.code,{children:"Ref"})," data type some other API like ",(0,i.jsx)(t.code,{children:"update"}),", ",(0,i.jsx)(t.code,{children:"updateAndGet"}),", and ",(0,i.jsx)(t.code,{children:"modify"})," which perform the reading and writing atomically:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:"def inc(counter: Ref[Int], amount: Int) = counter.updateAndGet(_ + amount)\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The most important note about the ",(0,i.jsx)(t.code,{children:"modify"})," operation is that it doesn't use pessimistic locking. It doesn't use any locking primitives for the critical section. It has an optimistic assumption about occurring collisions."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"modify"})," function takes these three steps:"]}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"It assumes that other fibers don't change the shared state and don't interfere in most cases. So it read the shared state without using any locking primitives."}),"\n",(0,i.jsx)(t.li,{children:"It should prepare itself for the worst-case scenarios. If another fiber is accessing the data at the same time, what would happen? Therefore, when we write a new value, it should check everything. It must ensure that it sees a consistent state of the universe, and if it does, then it can change that value."}),"\n",(0,i.jsxs)(t.li,{children:["If it encounters an inconsistent value, it shouldn't continue. So it aborts updating the shared state with an invalidated assumption. It should retry the ",(0,i.jsx)(t.code,{children:"modify"})," operation with an updated state."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Let's see how the ",(0,i.jsx)(t.code,{children:"modify"})," function of ",(0,i.jsx)(t.code,{children:"Ref"})," is implemented without any locking mechanism:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:"  final case class Ref[A](value: AtomicReference[A]) { self =>\n    def modify[B](f: A => (B, A)): UIO[B] = ZIO.succeed {\n      var loop = true\n      var b: B = null.asInstanceOf[B]\n      while (loop) {\n        val current = value.get\n        val tuple   = f(current)\n        b = tuple._1\n        loop = !value.compareAndSet(current, tuple._2)\n      }\n      b\n    }\n }\n"})}),"\n",(0,i.jsxs)(t.p,{children:["As we see, the ",(0,i.jsx)(t.code,{children:"modify"})," operation is implemented in terms of the ",(0,i.jsx)(t.code,{children:"compare-and-swap"})," operation which helps us to perform read and update atomically."]}),"\n",(0,i.jsxs)(t.p,{children:["Let's rename the ",(0,i.jsx)(t.code,{children:"inc"})," function to the ",(0,i.jsx)(t.code,{children:"deposit"})," as follows to try the classic problem of transferring money from one account to another:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:"def deposit(accountBalance: Ref[Int], amount: Int) = accountBalance.update(_ + amount)\n"})}),"\n",(0,i.jsxs)(t.p,{children:["And the ",(0,i.jsx)(t.code,{children:"withdraw"})," function:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:"def withdraw(accountBalance: Ref[Int], amount: Int) = accountBalance.update(_ - amount) \n"})}),"\n",(0,i.jsx)(t.p,{children:"It seems pretty good, but we also need to check that there is sufficient balance in the account to withdraw. So let's add an invariant to check that:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:'def withdraw(accountBalance: Ref[Int], amount: Int) = for {\n  balance <- accountBalance.get\n  _ <- if (balance < amount) ZIO.fail("Insufficient funds in you account") else\n    accountBalance.update(_ - amount)\n} yield ()\n'})}),"\n",(0,i.jsx)(t.p,{children:"What if in between checking and updating the balance, another fiber comes and withdraws all money in the account? This solution has a bug. It has the potential to reach a negative balance."}),"\n",(0,i.jsxs)(t.p,{children:["Suppose we finally reached a solution to do withdraw atomically, the problem remains. We need a way to compose ",(0,i.jsx)(t.code,{children:"withdraw"})," with ",(0,i.jsx)(t.code,{children:"deposit"})," atomically to create a `transfer function:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:"def transfer(from: Ref[Int], to: Ref[Int], amount: Int) = for {\n  _ <- withdraw(from, amount)\n  _ <- deposit(to, amount)\n} yield ()\n"})}),"\n",(0,i.jsxs)(t.p,{children:["In the above example, even if we assume that the ",(0,i.jsx)(t.code,{children:"withdraw"})," and ",(0,i.jsx)(t.code,{children:"deposit"})," are atomic, we can't compose these two transactions. They produce bugs in a concurrent environment. This code doesn't guarantee us that both ",(0,i.jsx)(t.code,{children:"withdraw"})," and ",(0,i.jsx)(t.code,{children:"deposit"})," are performed in one single atomic operation. Other fibers which are executing this ",(0,i.jsx)(t.code,{children:"transfer"})," method can override the shared state and introduce a race condition."]}),"\n",(0,i.jsxs)(t.p,{children:["We need a solution to ",(0,i.jsx)(t.strong,{children:"atomically compose transactions"}),". This is where software transactional memory comes into play."]}),"\n",(0,i.jsx)(t.h2,{id:"composable-concurrency",children:"Composable Concurrency"}),"\n",(0,i.jsx)(t.p,{children:"Software transactional memory provides us a way to compose multiple transactions and perform them in one single transaction."}),"\n",(0,i.jsxs)(t.p,{children:["Let's continue our last effort to convert our ",(0,i.jsx)(t.code,{children:"withdraw"})," method to be one atomic operation. To solve the problem using STM, we replace ",(0,i.jsx)(t.code,{children:"Ref"})," with ",(0,i.jsx)(t.code,{children:"TRef"}),". ",(0,i.jsx)(t.code,{children:"TRef"})," stands for ",(0,i.jsx)(t.em,{children:"Transactional Reference"}),"; it is a mutable reference contained in the ",(0,i.jsx)(t.code,{children:"STM"})," world. ",(0,i.jsx)(t.code,{children:"STM"})," is a monadic data structure that represents an effect that can be performed transactionally:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:'def withdraw(accountBalance: TRef[Int], amount: Int): STM[String, Unit] =\n  for {\n    balance <- accountBalance.get\n    _ <- if (balance < amount)\n      STM.fail("Insufficient funds in you account")\n    else\n      accountBalance.update(_ - amount)\n  } yield ()\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Although the ",(0,i.jsx)(t.code,{children:"deposit"})," operation is atomic, to be able to compose with ",(0,i.jsx)(t.code,{children:"withdraw"})," we need to refactor it to take ",(0,i.jsx)(t.code,{children:"TRef"})," and return ",(0,i.jsx)(t.code,{children:"STM"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:"def deposit(accountBalance: TRef[Int], amount: Int): STM[Nothing, Unit] =\n  accountBalance.update(_ + amount)\n"})}),"\n",(0,i.jsxs)(t.p,{children:["In the ",(0,i.jsx)(t.code,{children:"STM"})," world we can compose all operations and at the end of the world, we perform all of them in one single operation atomically. To be able to compose ",(0,i.jsx)(t.code,{children:"withdraw"})," with ",(0,i.jsx)(t.code,{children:"deposit"})," we need to stay in the ",(0,i.jsx)(t.code,{children:"STM"})," world. Therefore, we didn't perform ",(0,i.jsx)(t.code,{children:"STM.atomically"})," or ",(0,i.jsx)(t.code,{children:"STM#commit"})," methods on each of them."]}),"\n",(0,i.jsxs)(t.p,{children:["Now we can define the ",(0,i.jsx)(t.code,{children:"transfer"})," method by composing these two functions in the ",(0,i.jsx)(t.code,{children:"STM"})," world and converting them into the ",(0,i.jsx)(t.code,{children:"IO"})," atomically:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:"def transfer(from: TRef[Int], to: TRef[Int], amount: Int): IO[String, Unit] =\n  STM.atomically {\n    for {\n      _ <- withdraw(from, amount)\n      _ <- deposit(to, amount)\n    } yield ()\n  }\n"})}),"\n",(0,i.jsx)(t.p,{children:"Assume we are in the middle of transferring money from one account to the other. If we withdraw the first account but haven't deposited the second account, that kind of intermediate state is not visible to any external fibers. The transaction is completely successful if there are no conflicting changes. If there are any conflicts or conflicting changes then the whole transaction, the entire STM will be retried."}),"\n",(0,i.jsx)(t.h2,{id:"how-does-it-work",children:"How Does it Work?"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"STM"})," uses the same idea as the ",(0,i.jsx)(t.code,{children:"Ref#modify"})," function but with a composability feature. The main goal of ",(0,i.jsx)(t.code,{children:"STM"})," is to provide a mechanism to compose multiple transactions and perform them in one single atomic operation."]}),"\n",(0,i.jsxs)(t.p,{children:["The mechanism behind the compositional part is obvious. The ",(0,i.jsx)(t.code,{children:"STM"})," has its own world. It has lots of useful combinators like ",(0,i.jsx)(t.code,{children:"flatMap"})," and ",(0,i.jsx)(t.code,{children:"orElse"})," to compose multiple ",(0,i.jsx)(t.code,{children:"STM"}),"s and create more elegant ones. After we perform a transaction with ",(0,i.jsx)(t.code,{children:"STM#commit"})," or ",(0,i.jsx)(t.code,{children:"STM.atomically"})," the runtime system does the following steps. These steps are not exactly accurate, but they draw an outline of what happens during the transaction:"]}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Starting a Transaction"})," \u2014 When we start a transaction, the runtime system creates a virtual space to keep track of the transaction logs which is build up by recording the reads and tentative writes that the transaction will perform during the transaction steps."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Virtual Execution"})," \u2014 The runtime starts speculating the execution of transactions on every read and write operation. It has two internal logs;  the read and the write log. On the read log, it saves the version of all variables it reads during the intermediate steps, and on the write log, it saves the intermediate result of the transaction. It doesn't change the shared state on the main memory. Anything that is inside an atomic block is not executed immediately, it's executed in the virtual world, just by putting stuff in the internal log, not in the main memory. In this particular model, we guarantee that all computations are isolated from one another."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Commit Phase (Real Execution)"})," \u2014 When it comes to the end of the transaction the runtime system should check everything it has read. It should make sure that it sees a consistent state of the universe and if it has, then it atomically commits. As the STM is optimistic, it assumes that in the middle of a transaction, the chance of interfering with the shared state by other fibers is very rare. But it must ready itself for the worst cases. It should validate its assumption in the final stage. It checks whether the transactional variables involved were modified by any other threads or not. If its assumption got invalidated in the meanwhile of the transaction, it should abandon the transaction and retry it again. It jumps to the start of the transaction with the original and default values and tries again until it succeeds; This is necessary to resolve conflicts. Otherwise, if there is no conflict, it commits the final value atomically to the memory and succeeds. From the point of view of other fibers, all values in memory exchange in one blink of an eye. It's all atomic."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Everything done within a transaction to other transactions looks like it happens at once or not at all. So no matter how many pieces of memory it touches during the transaction. From the other transaction perspective, all of these changes happen at once."}),"\n",(0,i.jsx)(t.h2,{id:"stm-data-types",children:"STM Data Types"}),"\n",(0,i.jsxs)(t.p,{children:["Like the ",(0,i.jsx)(t.code,{children:"ZIO"})," data type, the ",(0,i.jsx)(t.code,{children:"ZSTM"})," has some type aliases as follows:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:"type RSTM[-R, +A]  = ZSTM[R, Throwable, A]\ntype URSTM[-R, +A] = ZSTM[R, Nothing, A]\ntype STM[+E, +A]   = ZSTM[Any, E, A]\ntype USTM[+A]      = ZSTM[Any, Nothing, A]\ntype TaskSTM[+A]   = ZSTM[Any, Throwable, A]\n"})}),"\n",(0,i.jsx)(t.p,{children:"There are a variety of transactional data structures that can take part in an STM transaction:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.a,{href:"/reference/stm/tarray",children:"TArray"})})," - A ",(0,i.jsx)(t.code,{children:"TArray[A]"})," is an array of mutable references that can participate in transactions."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.a,{href:"/reference/stm/trandom",children:"TRandom"})})," \u2014 ",(0,i.jsx)(t.code,{children:"TRandom"})," is a random service that provides utilities to generate random numbers, which can participate in STM transactions."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.a,{href:"/reference/stm/tset",children:"TSet"})})," - A ",(0,i.jsx)(t.code,{children:"TSet"})," is a mutable set that can participate in transactions."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.a,{href:"/reference/stm/tmap",children:"TMap"})})," - A ",(0,i.jsx)(t.code,{children:"TMap[A]"})," is a mutable map that can participate in transactions."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.a,{href:"/reference/stm/tref",children:"TRef"})})," - A ",(0,i.jsx)(t.code,{children:"TRef"})," is a mutable reference to an immutable value that can participate in transactions."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.a,{href:"/reference/stm/tpriorityqueue",children:"TPriorityQueue"})})," - A ",(0,i.jsx)(t.code,{children:"TPriorityQueue[A]"})," is a mutable priority queue that can participate in transactions."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.a,{href:"/reference/stm/tpromise",children:"TPromise"})})," - A ",(0,i.jsx)(t.code,{children:"TPromise"})," is a mutable reference that can be set exactly once and can participate in transactions."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.a,{href:"/reference/stm/tqueue",children:"TQueue"})})," - A ",(0,i.jsx)(t.code,{children:"TQueue"})," is a mutable queue that can participate in transactions."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.a,{href:"/reference/stm/treentrantlock",children:"TReentrantLock"})})," - A ",(0,i.jsx)(t.code,{children:"TReentrantLock"})," is a reentrant read / write lock that can be composed."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.a,{href:"/reference/stm/tsemaphore",children:"TSemaphore"})})," - A ",(0,i.jsx)(t.code,{children:"TSemaphore"})," is a semaphore that can participate in transactions."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.a,{href:"/reference/stm/thub",children:"THub"})})," - A ",(0,i.jsx)(t.code,{children:"THub"})," is a hub that can participate in STM transactions."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Since STM places a great emphasis on compositionality, we can build upon these data structures and define our very own concurrent data structures. For example, we can build a transactional priority queue using ",(0,i.jsx)(t.code,{children:"TRef"}),", ",(0,i.jsx)(t.code,{children:"TMap"})," and ",(0,i.jsx)(t.code,{children:"TQueue"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"advantage-of-using-stm",children:"Advantage of Using STM"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Composable Transaction"})," \u2014 Combining atomic operations using locking-oriented programming is almost impossible. ZIO provides the ",(0,i.jsx)(t.code,{children:"STM"})," data type, which has lots of combinators to compose transactions."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Declarative"})," \u2014 ZIO STM is completely declarative. It doesn't require us to think about low-level primitives. It doesn't force us to think about the ordering of locks. Reasoning concurrent programs in a declarative fashion is very simple. We can just focus on the logic of our program and run it in a concurrent environment deterministically. The user code is much simpler of course because it doesn't have to deal with the concurrency at all."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Optimistic Concurrency"})," \u2014 In most cases, we are allowed to be optimistic unless there is tremendous contention. So if we haven't tremendous contention it really pays to be optimistic. It allows a higher volume of concurrent transactions."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Lock-Free"})," \u2014 All operations are non-blocking using lock-free algorithms."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Fine-Grained Locking"}),"\u2014 Coarse-grained locking is very simple to implement, but it has a negative impact on performance, while fine-grained locking significantly has better performance, but it is very cumbersome, sophisticated, and error-prone even for experienced programmers. We would like to have the ease of use of coarse-grain locking, but at the same time, we would like to have the efficiency of fine-grain locking. ZIO provides several data types which are a very coarse way of using concurrency, but they are implemented as if every single word were lockable. So the granularity of concurrency is fine-grained. It increases the performance and concurrency. For example, if we have two fibers accessing the same ",(0,i.jsx)(t.code,{children:"TArray"}),", one of them reads and writes on the first index of our array, and another one reads and writes to the second index of that array, they will not conflict. It is just like as if we were locking the indices, not the whole array."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"implication-of-using-stm",children:"Implication of Using STM"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Running I/O Inside STM"}),"\u2014 There is a strict boundary between the ",(0,i.jsx)(t.code,{children:"STM"})," world and the ",(0,i.jsx)(t.code,{children:"ZIO"})," world. This boundary propagates even deeper because we are not allowed to execute arbitrary effects in the ",(0,i.jsx)(t.code,{children:"STM"})," universe. Performing side effects and I/O operations inside a transaction is problematic. In the ",(0,i.jsx)(t.code,{children:"STM"})," the only effect that exists is the ",(0,i.jsx)(t.code,{children:"STM"})," itself. We cannot print something or launch a missile inside a transaction as it will nondeterministically get printed on every reties that transaction does that."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Large Allocations"})," \u2014 We should be very careful in choosing the best data structure for using STM operations. For example, if we use a single data structure with ",(0,i.jsx)(t.code,{children:"TRef"})," and that data structure occupies a big chunk of memory. Every time we are updating this data structure during the transaction, the runtime system needs a fresh copy of this chunk of memory."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Running Expensive Operations"}),"\u2014 The beautiful feature of the ",(0,i.jsx)(t.code,{children:"retry"})," combinator is when we decide to retry the transaction, the ",(0,i.jsx)(t.code,{children:"retry"})," avoids the busy loop. It waits until any of the underlying transactional variables have changed. However, we should be careful about running expensive operations multiple times."]}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>r});var a=n(96540);const i={},o=a.createContext(i);function s(e){const t=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(o.Provider,{value:t},e.children)}}}]);