"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[49221],{79370:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"zio-http/reference/client","title":"Client","description":"ZClient is an HTTP client that enables us to make HTTP requests and handle responses in a purely functional manner. ZClient leverages the ZIO library\'s capabilities to provide a high-performance, asynchronous, and type-safe HTTP client solution.","source":"@site/docs/zio-http/reference/client.md","sourceDirName":"zio-http/reference","slug":"/zio-http/reference/client","permalink":"/zio-http/reference/client","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-http/reference/client.md","tags":[],"version":"current","frontMatter":{"id":"client","title":"Client"},"sidebar":"ecosystem-sidebar","previous":{"title":"Server","permalink":"/zio-http/reference/server"},"next":{"title":"Routes","permalink":"/zio-http/reference/routing/routes"}}');var s=t(74848),o=t(28453);const r={id:"client",title:"Client"},l=void 0,c={},a=[{value:"Key Features",id:"key-features",level:2},{value:"Making HTTP Requests",id:"making-http-requests",level:2},{value:"&quot;Streaming&quot; Client",id:"streaming-client",level:3},{value:"&quot;Batched&quot; Client",id:"batched-client",level:3},{value:"Performing WebSocket Connections",id:"performing-websocket-connections",level:2},{value:"Configuring Headers",id:"configuring-headers",level:2},{value:"Composable URLs",id:"composable-urls",level:2},{value:"Client Aspects/Middlewares",id:"client-aspectsmiddlewares",level:2},{value:"Debugging Aspects",id:"debugging-aspects",level:3},{value:"Logging Aspects",id:"logging-aspects",level:3},{value:"Follow Redirects",id:"follow-redirects",level:3},{value:"Configuring ZIO HTTP Client",id:"configuring-zio-http-client",level:2},{value:"Configuring SSL",id:"configuring-ssl",level:3},{value:"Configuring Proxy",id:"configuring-proxy",level:3},{value:"Connection Pooling",id:"connection-pooling",level:3},{value:"Enabling Response Decompression",id:"enabling-response-decompression",level:3},{value:"Customizing <code>ClientDriver</code> and <code>DnsResolver</code>",id:"customizing-clientdriver-and-dnsresolver",level:2},{value:"Examples",id:"examples",level:2},{value:"Simple Client Example",id:"simple-client-example",level:3},{value:"ClientServer Example",id:"clientserver-example",level:3},{value:"Authentication Client Example",id:"authentication-client-example",level:3},{value:"Reconnecting WebSocket Client Example",id:"reconnecting-websocket-client-example",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ZClient"})," is an HTTP client that enables us to make HTTP requests and handle responses in a purely functional manner. ZClient leverages the ZIO library's capabilities to provide a high-performance, asynchronous, and type-safe HTTP client solution."]}),"\n",(0,s.jsx)(n.h2,{id:"key-features",children:"Key Features"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purely Functional"}),": ZClient is built on top of the ZIO library, enabling a purely functional approach to handling HTTP requests and responses. This ensures referential transparency and composability, making it easy to build and reason about complex HTTP interactions."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Type-Safe"}),": ZClient's API is designed to be type-safe, leveraging Scala's type system to catch errors at compile time and provide a seamless development experience. This helps prevent common runtime errors and enables developers to write robust and reliable HTTP client code."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Asynchronous & Non-blocking"}),": ZClient is fully asynchronous and non-blocking, allowing us to perform multiple HTTP requests concurrently without blocking threads. This ensures optimal resource utilization and scalability, making it suitable for high-performance applications."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Middleware Support"}),": ZClient provides support for middleware, allowing us to customize and extend its behavior to suit our specific requirements. We can easily plug in middleware to add functionalities such as logging, debugging, caching, and more."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Flexible Configuration"}),": ZClient offers flexible configuration options, allowing us to fine-tune its behavior according to our needs. We can configure settings such as SSL, proxy, connection pooling, timeouts, and more to optimize the client's performance and behavior."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"WebSocket Support"}),": In addition to traditional HTTP requests, ZClient also supports WebSocket communication, enabling bidirectional, full-duplex communication between client and server over a single, long-lived connection."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"SSL Support"}),": ZClient provides built-in support for SSL (Secure Sockets Layer) connections, allowing secure communication over the network. Users can configure SSL settings such as certificates, trust stores, and encryption protocols to ensure data confidentiality and integrity."]}),"\n",(0,s.jsx)(n.h2,{id:"making-http-requests",children:"Making HTTP Requests"}),"\n",(0,s.jsxs)(n.p,{children:["We can think of a ",(0,s.jsx)(n.code,{children:"ZClient"})," as a function that takes a ",(0,s.jsx)(n.code,{children:"Request"})," and returns a ",(0,s.jsx)(n.code,{children:"ZIO"})," effect that calls the server with the given request and returns the response that the server sends back.\nRequests can be executed in 2 modes:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"batched"}),": The entire body of the request is materialized in memory, and the connection lifecycle is managed automatically by the client."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"streaming"}),": The body of the request ",(0,s.jsx)(n.em,{children:"might be"})," streaming, and the connection lifecycle is managed through the ",(0,s.jsx)(n.code,{children:"Scope"})," in the effect's environment."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Client"}),"'s companion object contains methods that reflect the 2 modes of request execution:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"object Client {\n  def batched(request: Request): ZIO[Client, Throwable, Response] = ???\n  def streaming(request: Request): ZIO[Client & Scope, Throwable, Response] = ???\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"streaming-client",children:'"Streaming" Client'}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"streaming"})," mode is the default mode for executing HTTP requests. It requires the ",(0,s.jsx)(n.code,{children:"Client"})," and ",(0,s.jsx)(n.code,{children:"Scope"})," environments to perform the request and handle the response. The ",(0,s.jsx)(n.code,{children:"Client"})," environment is used to make the request, while the ",(0,s.jsx)(n.code,{children:"Scope"})," environment is used to manage the lifecycle of resources such as connections, sockets, and other I/O-related resources that are acquired and released during the request-response operation."]}),"\n",(0,s.jsxs)(n.p,{children:["When making a request in the ",(0,s.jsx)(n.code,{children:"streaming"})," mode, we need to explicitly close the ",(0,s.jsx)(n.code,{children:"Scope"})," once we've collected the response body:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.http._\n\n// OK\nval good =\n  ZIO.scoped {\n    Client\n      .streaming(Request.get("http://jsonplaceholder.typicode.com/todos"))\n      .flatMap(_.body.asString)\n  }.flatMap(???)\n  \n// BAD: The server might be streaming the response body, and we\'ve forcefully closed the connection before it finishes\nval bad1 =\n  ZIO.scoped {\n    Client\n      .streaming(Request.get("http://jsonplaceholder.typicode.com/todos"))\n      .map(_.headers)\n  }\n    .flatMap(???)\n\n// BAD: We\'re closing the scope before collecting the response body\nval bad2 =\n  ZIO.scoped {\n      Client\n        .streaming(Request.get("http://jsonplaceholder.typicode.com/todos"))\n    }\n    .flatMap(_.body.asString)\n    .flatMap(???)\n\n// VERY BAD: The connection will not be closed until the application exits, which will lead to resource leaks!\nval bad3 =\n  Client\n    .streaming(Request.get("http://jsonplaceholder.typicode.com/todos"))\n    .flatMap(_.body.asString)\n    .flatMap(???)\n    .provideSomeLayer[Client](Scope.default)\n'})}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsxs)(n.p,{children:["As a rule of thumb, you should ",(0,s.jsx)(n.strong,{children:"never"})," use ",(0,s.jsx)(n.code,{children:"Scope.default"})," with Client!"]}),(0,s.jsxs)(n.p,{children:["To learn more about resource management and ",(0,s.jsx)(n.code,{children:"Scope"})," in ZIO, refer to the ",(0,s.jsx)(n.a,{href:"https://zio.dev/reference/resource/scope",children:"dedicated guide on this topic"})," in the ZIO Core documentation."]})]}),"\n",(0,s.jsx)(n.h3,{id:"batched-client",children:'"Batched" Client'}),"\n",(0,s.jsxs)(n.p,{children:["Handling of ",(0,s.jsx)(n.code,{children:"Scope"})," can quickly become cumbersome in cases where we simply want to execute an HTTP request and not handle the lifetime of the HTTP request.\nThe ",(0,s.jsx)(n.code,{children:"batched"})," mode is simply a sub-implementation of the ",(0,s.jsx)(n.code,{children:"streaming"})," mode where the ",(0,s.jsx)(n.code,{children:"Scope"})," (i.e., connection lifecycle) is managed automatically."]}),"\n",(0,s.jsxs)(n.p,{children:["Executing a request via the ",(0,s.jsx)(n.code,{children:"batched"})," method can be done as simply as:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.http._\n\nval good =\n  Client\n    .batched(Request.get("http://jsonplaceholder.typicode.com/todos"))\n    .flatMap(_.body.asString)\n    .flatMap(???)\n'})}),"\n",(0,s.jsxs)(n.p,{children:["::: warning\nThe ",(0,s.jsx)(n.code,{children:"batched"})," methods will materialize the entire body of the request to memory.\nUse this only when you don't need to stream the request body!\n:::"]}),"\n",(0,s.jsxs)(n.p,{children:["We can similarly use the ",(0,s.jsx)(n.code,{children:"batched"})," method on an instance of ",(0,s.jsx)(n.code,{children:"Client"})," to return a new instance where all the methods will be executed in the ",(0,s.jsx)(n.code,{children:"batched"})," mode. Below is a realistic example showcasing the usage of the ",(0,s.jsx)(n.code,{children:"batched"})," client:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.http._\nimport zio.schema.DeriveSchema\nimport zio.schema.codec.JsonCodec.schemaBasedBinaryCodec\n\ncase class Todo(\n  userId: Int,\n  id: Int,\n  title: String,\n  completed: Boolean,\n)\n\nobject Todo {\n  implicit val todoSchema = DeriveSchema.gen[Todo]\n}\n\nfinal class JsonPlaceHolderService(baseClient: Client) {\n  private val client = baseClient.batched\n\n  def todos(): ZIO[Any, Throwable, List[Todo]] =\n    client\n      .request(Request.get("http://jsonplaceholder.typicode.com/todos"))\n      .flatMap(_.body.to[List[Todo]])\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["ZIO HTTP has several utility methods to create different types of requests, such as ",(0,s.jsx)(n.code,{children:"Client#get"}),", ",(0,s.jsx)(n.code,{children:"Client#post"}),", ",(0,s.jsx)(n.code,{children:"Client#put"}),", ",(0,s.jsx)(n.code,{children:"Client#delete"}),", etc:"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Method"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"def get(suffix: String)"})}),(0,s.jsx)(n.td,{children:"Performs a GET request with the given path suffix."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"def head(suffix: String)"})}),(0,s.jsx)(n.td,{children:"Performs a HEAD request with the given path suffix."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"def patch(suffix: String)"})}),(0,s.jsx)(n.td,{children:"Performs a PATCH request with the given path suffix."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"def post(suffix: String)(body: In)"})}),(0,s.jsx)(n.td,{children:"Performs a POST request with the given path suffix and provided body."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"def put(suffix: String)(body: In)"})}),(0,s.jsx)(n.td,{children:"Performs a PUT request with the given path suffix and provided body."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"def delete(suffix: String)"})}),(0,s.jsx)(n.td,{children:"Performs a DELETE request with the given path suffix."})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"performing-websocket-connections",children:"Performing WebSocket Connections"}),"\n",(0,s.jsxs)(n.p,{children:["We can also think of a client as a function that takes a ",(0,s.jsx)(n.code,{children:"WebSocketApp"})," and returns a ",(0,s.jsx)(n.code,{children:"ZIO"})," effect that performs the WebSocket operations and returns a response:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"object ZClient {\n  def socket[R](socketApp: WebSocketApp[R]): ZIO[R with Client & Scope, Throwable, Response] = ???\n}\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"socket"}),' method is not available on the "Batched" client!']})}),"\n",(0,s.jsxs)(n.p,{children:["Here is a simple example of how to use the ",(0,s.jsx)(n.code,{children:"ZClient#socket"})," method to perform a WebSocket connection:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.http._\nimport zio.http.ChannelEvent._\n\nobject WebSocketSimpleClient extends ZIOAppDefault {\n\n  val url = "ws://ws.vi-server.org/mirror"\n\n  val socketApp: WebSocketApp[Any] =\n    Handler\n\n      // Listen for all websocket channel events\n      .webSocket { channel =>\n        channel.receiveAll {\n\n          // Send a "foo" message to the server once the connection is established\n          case UserEventTriggered(UserEvent.HandshakeComplete) =>\n            channel.send(Read(WebSocketFrame.text("foo"))) *>\n              ZIO.debug("Connection established and the foo message sent to the server")\n\n          // Send a "bar" if the server sends a "foo"\n          case Read(WebSocketFrame.Text("foo")) =>\n            channel.send(Read(WebSocketFrame.text("bar"))) *>\n              ZIO.debug("Received the foo message from the server and the bar message sent to the server")\n\n          // Close the connection if the server sends a "bar"\n          case Read(WebSocketFrame.Text("bar")) =>\n            ZIO.debug("Received the bar message from the server and Goodbye!") *>\n              channel.send(Read(WebSocketFrame.close(1000)))\n\n          case _ =>\n            ZIO.unit\n        }\n      }\n\n  val app: ZIO[Client, Throwable, Unit] =\n    for {\n      url    <- ZIO.fromEither(URL.decode("ws://ws.vi-server.org/mirror"))\n      client <- ZIO.serviceWith[Client](_.url(url))\n      _      <- ZIO.scoped(client.socket(socketApp) *> ZIO.never)\n    } yield ()\n\n  val run: ZIO[Any, Throwable, Any] =\n    app.provide(Client.default)\n\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["In the above example, we defined a WebSocket client that connects to a mirror server and sends and receives messages. When the connection is established, it receives the ",(0,s.jsx)(n.code,{children:"UserEvent.HandshakeComplete"}),' event and then it sends a "foo" message to the server. Consequently, the server sends a "foo" message, and the client responds with a "bar" message. Finally, the server sends a "bar" message, and the client closes the connection.']}),"\n",(0,s.jsx)(n.h2,{id:"configuring-headers",children:"Configuring Headers"}),"\n",(0,s.jsxs)(n.p,{children:["By default, the client adds the ",(0,s.jsx)(n.code,{children:"User-Agent"})," header to all requests. Additionally, as the ",(0,s.jsx)(n.code,{children:"ZClient"})," extends the ",(0,s.jsx)(n.code,{children:"HeaderOps"})," trait, we have access to all operations that can be performed on headers inside the client."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, to add a custom header we can use the ",(0,s.jsx)(n.code,{children:"Client#addHeader"})," method:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.http._\nimport zio.http.Header.Authorization\n\nval program = for {\n  client <- ZIO.serviceWith[Client](_.addHeader(Authorization.Bearer(token = "dummyBearerToken")))\n  res    <- client.request(Request.get("http://localhost:8080/users"))\n} yield ()\n'})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["To learn more about headers and how they work, check out our dedicated section called ",(0,s.jsx)(n.a,{href:"/zio-http/reference/headers/#headers-operations",children:"Header Operations"})," on the headers page."]})}),"\n",(0,s.jsx)(n.h2,{id:"composable-urls",children:"Composable URLs"}),"\n",(0,s.jsxs)(n.p,{children:["In ZIO HTTP, URLs are composable. This means that if we have two URLs, we can combine them to create a new URL. This is useful when we want to prevent duplication of the base URL in our code. For example, assume we have a base URL ",(0,s.jsx)(n.code,{children:"http://localhost:8080"})," and we want to make several requests to different endpoints and query parameters under this base URL. We can configure the client with this URL using the ",(0,s.jsx)(n.code,{children:"Client#url"})," and then every request will be made can be relative to this base URL:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.http._\nimport zio.schema.DeriveSchema\nimport zio.schema.codec.JsonCodec.schemaBasedBinaryCodec\n\ncase class User(name: String, age: Int)\nobject User {\n  implicit val schema = DeriveSchema.gen[User]\n}\n\nval program: ZIO[Client, Throwable, Unit] =\n  for {\n    client <- ZIO.serviceWith[Client](_.url(url"http://localhost:8080").batched)\n    _      <- client.post("/users")(Body.from(User("John", 42)))\n    res    <- client.get("/users")\n    _      <- client.delete("/users/1")\n    _      <- res.body.asString.debug\n  } yield ()\n'})}),"\n",(0,s.jsx)(n.p,{children:"The following methods are available for setting the base URL:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Method Signature"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Client#url(url: URL)"})}),(0,s.jsx)(n.td,{children:"Sets the URL directly."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Client#uri(uri: URI)"})}),(0,s.jsx)(n.td,{children:"Sets the URL from the provided URI."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Client#path(path: String)"})}),(0,s.jsx)(n.td,{children:"Sets the path of the URL from a string."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Client#path(path: Path)"})}),(0,s.jsxs)(n.td,{children:["Sets the path of the URL from a ",(0,s.jsx)(n.code,{children:"Path"})," object."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Client#port(port: Int)"})}),(0,s.jsx)(n.td,{children:"Sets the port of the URL."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Client#scheme(scheme: Scheme)"})}),(0,s.jsx)(n.td,{children:"Sets the scheme (protocol) for the URL."})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Scheme"})," is a sealed trait that represents the different schemes (protocols) that can be used in a request. The available schemes are ",(0,s.jsx)(n.code,{children:"HTTP"})," and ",(0,s.jsx)(n.code,{children:"HTTPS"})," for HTTP requests, and ",(0,s.jsx)(n.code,{children:"WS"})," and ",(0,s.jsx)(n.code,{children:"WSS"})," for WebSockets."]}),"\n",(0,s.jsx)(n.p,{children:"Here is the list of methods that are available for adding URL, Path, and QueryParams to the client's configuration:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Methods"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Client#addUrl(url: URL)"})}),(0,s.jsx)(n.td,{children:"Adds another URL to the existing one."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Client#addPath(path: String)"})}),(0,s.jsx)(n.td,{children:"Adds a path segment to the URL."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Client#addPath(path: Path)"})}),(0,s.jsxs)(n.td,{children:["Adds a path segment from a ",(0,s.jsx)(n.code,{children:"Path"})," object to the URL."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Client#addLeadingSlash"})}),(0,s.jsx)(n.td,{children:"Adds a leading slash to the URL path."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Client#addTrailingSlash"})}),(0,s.jsx)(n.td,{children:"Adds a trailing slash to the URL path."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Client#addQueryParam(key: String, value: String)"})}),(0,s.jsx)(n.td,{children:"Adds a query parameter with the specified key-value pair to the URL."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Client#addQueryParams(params: QueryParams)"})}),(0,s.jsxs)(n.td,{children:["Adds multiple query parameters to the URL from a ",(0,s.jsx)(n.code,{children:"QueryParams"})," object."]})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"client-aspectsmiddlewares",children:"Client Aspects/Middlewares"}),"\n",(0,s.jsxs)(n.p,{children:["Client aspects are a powerful feature of ZIO HTTP, enabling us to intercept, modify, and extend client behavior. The ",(0,s.jsx)(n.code,{children:"ZClientAspect"})," is represented as a function that takes a ",(0,s.jsx)(n.code,{children:"ZClient"})," and returns a new ",(0,s.jsx)(n.code,{children:"ZClient"})," with customized behavior. We apply aspects to a client using the ",(0,s.jsx)(n.code,{children:"ZClient#@@"})," method, allowing modification of various execution aspects such as metrics, tracing, encoding, decoding, and debugging."]}),"\n",(0,s.jsx)(n.h3,{id:"debugging-aspects",children:"Debugging Aspects"}),"\n",(0,s.jsxs)(n.p,{children:["To debug the client, we can use the ",(0,s.jsx)(n.code,{children:"ZClientAspect.debug"})," aspect, which logs the request details to the console. This is useful for debugging and troubleshooting client interactions, as it provides visibility into the low-level details of the HTTP requests and responses:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.http._\n\nobject ClientWithDebugAspect extends ZIOAppDefault {\n  val program =\n    for {\n      client <- ZIO.service[Client].map(_ @@ ZClientAspect.debug)\n      _      <- client.batched(Request.get("http://jsonplaceholder.typicode.com/todos"))\n    } yield ()\n\n  override val run = program.provide(Client.default)\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"ZClientAspect.debug"})," also takes a partial function from ",(0,s.jsx)(n.code,{children:"Response"})," to ",(0,s.jsx)(n.code,{children:"String"}),", which enables us to customize the logging output based on the response. This is useful for logging specific details from the response, such as status code, headers, and body:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'val debugResponse = ZClientAspect.debug { case res: Response => res.headers.mkString("\\n") }\n\nval program =\n  for {\n    client <- ZIO.service[Client].map(_ @@ debugResponse)\n    _      <- client.request(Request.get("http://jsonplaceholder.typicode.com/todos"))\n  } yield ()\n'})}),"\n",(0,s.jsx)(n.h3,{id:"logging-aspects",children:"Logging Aspects"}),"\n",(0,s.jsxs)(n.p,{children:["To log the client interactions, we can use the ",(0,s.jsx)(n.code,{children:"ZClientAspect.requestLogging"})," which logs the request details such as method, duration, url, user-agent, status code and request size."]}),"\n",(0,s.jsx)(n.p,{children:"Let's try an example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.http._\n\nval loggingAspect =\n  ZClientAspect.requestLogging(\n    loggedRequestHeaders = Set(Header.UserAgent),\n    logResponseBody = true,\n  )\n\nval program =\n  for {\n    client <- ZIO.service[Client].map(_ @@ loggingAspect)\n    _      <- client.request(Request.get("http://jsonplaceholder.typicode.com/todos"))\n  } yield ()\n'})}),"\n",(0,s.jsx)(n.h3,{id:"follow-redirects",children:"Follow Redirects"}),"\n",(0,s.jsxs)(n.p,{children:["To follow redirects, we can apply the ",(0,s.jsx)(n.code,{children:"ZClientAspect.followRedirects"})," aspect, which takes the maximum number of redirects to follow and a callback function that allows us to customize the behavior when a redirect is encountered:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.http._\n\nval followRedirects = ZClientAspect.followRedirects(3)((resp, message) => ZIO.logInfo(message).as(resp))\n\nfor {\n  client   <- ZIO.service[Client].map(_ @@ followRedirects)\n  response <- client.request(Request.get("http://google.com"))\n  _        <- response.body.asString.debug\n} yield ()\n'})}),"\n",(0,s.jsx)(n.h2,{id:"configuring-zio-http-client",children:"Configuring ZIO HTTP Client"}),"\n",(0,s.jsxs)(n.p,{children:["The ZIO HTTP Client provides a flexible configuration mechanism through the ",(0,s.jsx)(n.code,{children:"ZClient.Config"})," class. This class allows us to customize various aspects of the HTTP client, including SSL settings, proxy configuration, connection pool size, timeouts, and more. The ",(0,s.jsx)(n.code,{children:"ZClient.Config.default"})," provides a default configuration that can be customized using ",(0,s.jsx)(n.code,{children:"copy"})," method or by using the utility methods provided by the ",(0,s.jsx)(n.code,{children:"ZClient.Config"})," class."]}),"\n",(0,s.jsx)(n.p,{children:"Let's take a look at the available configuration options:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"SSL Configuration"}),": Allows us to specify SSL settings for secure connections."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Proxy Configuration"}),": Enables us to configure a proxy server for outgoing HTTP requests."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Connection Pool Configuration"}),": Defines the size of the connection pool."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Max Initial Line Length"}),": Sets the maximum length of the initial line in an HTTP request or response. The default is set to 4096 characters."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Max Header Size"}),": Specifies the maximum size of HTTP headers in bytes. The default is set to 8192 bytes."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Request Decompression"}),": Specifies whether the client should decompress the response body if it's compressed."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Local Address"}),": Specifies the local network interface or address to use for outgoing connections. It's set to None, indicating that the client will use the default local address."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Add User-Agent Header"}),": Indicates whether the client should automatically add a User-Agent header to outgoing requests. It's set to true in the default configuration."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"WebSocket Configuration"}),": Configures settings specific to WebSocket connections. In this example, the default WebSocket configuration is used."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Idle Timeout"}),": Specifies the maximum idle time for persistent connections in seconds. The default is set to 50 seconds."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Connection Timeout"}),": Specifies the maximum time to wait for establishing a connection in seconds. By default, the client has no connection timeout."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Here are some of the above configuration options in more detail:"}),"\n",(0,s.jsx)(n.h3,{id:"configuring-ssl",children:"Configuring SSL"}),"\n",(0,s.jsxs)(n.p,{children:["The default SSL configuration of ",(0,s.jsx)(n.code,{children:"ZClient.Config.default"})," is ",(0,s.jsx)(n.code,{children:"None"}),". To enable and configure SSL for the client, we can use the ",(0,s.jsx)(n.code,{children:"ZClient.Config#ssl"})," method. This method takes a config of type ",(0,s.jsx)(n.code,{children:"ClientSSLConfig"})," which supports different SSL configurations such as ",(0,s.jsx)(n.code,{children:"Default"}),", ",(0,s.jsx)(n.code,{children:"FromCertFile"}),", ",(0,s.jsx)(n.code,{children:"FromCertResource"}),", ",(0,s.jsx)(n.code,{children:"FromTrustStoreFile"}),", and `FromTrustStoreResource."]}),"\n",(0,s.jsx)(n.p,{children:"Let's see an example of how to configure SSL for the client:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",metastring:'title="zio-http-example/src/main/scala/example/HttpsClient.scala" ',children:'package example\n\nimport zio._\n\nimport zio.http._\nimport zio.http.netty.NettyConfig\nimport zio.http.netty.client.NettyClientDriver\n\nobject HttpsClient extends ZIOAppDefault {\n  val url     = URL.decode("https://jsonplaceholder.typicode.com/todos/1").toOption.get\n  val headers = Headers(Header.Host("jsonplaceholder.typicode.com"))\n\n  val sslConfig = ClientSSLConfig.FromTrustStoreResource(\n    trustStorePath = "truststore.jks",\n    trustStorePassword = "changeit",\n  )\n\n  val clientConfig = ZClient.Config.default.ssl(sslConfig)\n\n  val program = for {\n    data <- ZClient.batched(Request.get(url).addHeaders(headers))\n    _    <- Console.printLine(data)\n  } yield ()\n\n  val run =\n    program.provide(\n      ZLayer.succeed(clientConfig),\n      Client.customized,\n      NettyClientDriver.live,\n      DnsResolver.default,\n      ZLayer.succeed(NettyConfig.default),\n    )\n\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"configuring-proxy",children:"Configuring Proxy"}),"\n",(0,s.jsxs)(n.p,{children:["To configure a proxy for the client, we can use the ",(0,s.jsx)(n.code,{children:"Client#proxy"})," method. This method takes a ",(0,s.jsx)(n.code,{children:"Proxy"})," and updates the client's configuration to use the specified proxy for all requests:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.http._\n\nval program = for {\n  proxyUrl <- ZIO.fromEither(URL.decode("http://localhost:8123"))\n  client   <- ZIO.serviceWith[Client](_.proxy(Proxy(url = proxyUrl)))\n  res      <- client.request(Request.get("https://jsonplaceholder.typicode.com/todos"))\n} yield ()\n'})}),"\n",(0,s.jsx)(n.h3,{id:"connection-pooling",children:"Connection Pooling"}),"\n",(0,s.jsx)(n.p,{children:"Connection pooling is a crucial mechanism in ZIO HTTP for optimizing the management of HTTP connections. By default, ZIO HTTP uses a fixed-size connection pool with a capacity of 10 connections. This means that the client can maintain up to 10 idle connections to the server for reuse. When the client makes a request, it checks the connection pool for an available connection to the server. If a connection is available, it reuses it for the request. If no connection is available, it creates a new connection and adds it to the pool."}),"\n",(0,s.jsxs)(n.p,{children:["To configure the connection pool, we have to update the ",(0,s.jsx)(n.code,{children:"ZClient.Config#connectionPool"})," field with the preferred configuration. The ",(0,s.jsx)(n.code,{children:"ConnectionPoolConfig"})," trait serves as a base trait for different connection pool configurations. It is a sealed trait with five different implementations:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Disabled"}),": Indicates that connection pooling is disabled."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Fixed"}),": Takes a single parameter, ",(0,s.jsx)(n.code,{children:"size"}),", which specifies a fixed size connection pool."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"FixedPerHost"}),": Takes a map of ",(0,s.jsx)(n.code,{children:"URL.Location.Absolute"})," to ",(0,s.jsx)(n.code,{children:"Fixed"})," to specify a fixed size connection pool per host."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Dynamic"}),": Takes three parameters, ",(0,s.jsx)(n.code,{children:"minimum"}),", ",(0,s.jsx)(n.code,{children:"maximum"}),", and ",(0,s.jsx)(n.code,{children:"ttl"}),", to configure a dynamic connection pool with minimum and maximum sizes and a time-to-live (TTL) duration."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"DynamicPerHost"}),": Similar to Dynamic, but with configurations per host."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Also the ",(0,s.jsx)(n.code,{children:"ZClient.Config"})," has some utility methods to update the connection pool configuration, e.g. ",(0,s.jsx)(n.code,{children:"ZClient.Config#fixedConnectionPool"})," and ",(0,s.jsx)(n.code,{children:"ZClient.Config#dynamicConnectionPool"}),". Let's see an example of how to configure the connection pool:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",metastring:'title="zio-http-example/src/main/scala/example/ClientWithConnectionPooling.scala" ',children:'package example\n\nimport zio._\n\nimport zio.http._\nimport zio.http.netty.NettyConfig\n\nobject ClientWithConnectionPooling extends ZIOAppDefault {\n  val program = for {\n    url    <- ZIO.fromEither(URL.decode("http://jsonplaceholder.typicode.com/posts"))\n    client <- ZIO.serviceWith[Client](_.addUrl(url))\n    _      <- ZIO.foreachParDiscard(Chunk.fromIterable(1 to 100)) { i =>\n      client.batched(Request.get(i.toString)).flatMap(_.body.asString).debug\n    }\n  } yield ()\n\n  val config = ZClient.Config.default.dynamicConnectionPool(10, 20, 5.second)\n\n  override val run =\n    program.provide(\n      ZLayer.succeed(config),\n      Client.live,\n      ZLayer.succeed(NettyConfig.default),\n      DnsResolver.default,\n    )\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"enabling-response-decompression",children:"Enabling Response Decompression"}),"\n",(0,s.jsx)(n.p,{children:"When making HTTP requests using a client, such as a web browser or a custom HTTP client, it's essential to optimize data transfer for efficiency and performance."}),"\n",(0,s.jsxs)(n.p,{children:["By default, most HTTP clients do not advertise compression support when making requests to web servers. However, servers often compress response bodies when they detect that the client supports compression. To enable response compression, we need to add the ",(0,s.jsx)(n.code,{children:"Accept-Encoding"})," header to our HTTP requests. The ",(0,s.jsx)(n.code,{children:"Accept-Encoding"})," header specifies the compression algorithms supported by the client. Common values include ",(0,s.jsx)(n.code,{children:"gzip"})," and ",(0,s.jsx)(n.code,{children:"deflate"}),". When a server receives a request with the ",(0,s.jsx)(n.code,{children:"Accept-Encoding"})," header, it may compress the response body using one of the specified algorithms."]}),"\n",(0,s.jsx)(n.p,{children:"Here's an example of an HTTP request with the Accept-Encoding header:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-http",children:"GET https://example.com/\nAccept-Encoding: gzip, deflate\n"})}),"\n",(0,s.jsx)(n.p,{children:"When a server responds with a compressed body, it includes the Content-Encoding header to specify the compression algorithm used. The client then needs to decompress the body before processing its contents."}),"\n",(0,s.jsx)(n.p,{children:"For example, a compressed response might look like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-http",children:"200 OK\ncontent-encoding: gzip\ncontent-type: application/json; charset=utf-8\n\n<compressed-body>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["To decompress the response body with ",(0,s.jsx)(n.code,{children:"ZClient"}),", we need to enable response decompression by using the ",(0,s.jsx)(n.code,{children:"ZClient.Config#requestDecompression"})," method:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",metastring:'title="zio-http-example/src/main/scala/example/ClientWithDecompression.scala" ',children:'package example\n\nimport zio._\n\nimport zio.http.Header.AcceptEncoding\nimport zio.http._\nimport zio.http.netty.NettyConfig\n\nobject ClientWithDecompression extends ZIOAppDefault {\n\n  val program = for {\n    url    <- ZIO.fromEither(URL.decode("https://jsonplaceholder.typicode.com"))\n    client <- ZIO.serviceWith[Client](_.addUrl(url))\n    res    <-\n      client\n        .addHeader(AcceptEncoding(AcceptEncoding.GZip(), AcceptEncoding.Deflate()))\n        .batched(Request.get("/todos"))\n    data   <- res.body.asString\n    _      <- Console.printLine(data)\n  } yield ()\n\n  val config       = ZClient.Config.default.requestDecompression(true)\n  override val run =\n    program.provide(\n      ZLayer.succeed(config),\n      Client.live,\n      ZLayer.succeed(NettyConfig.default),\n      DnsResolver.default,\n    )\n\n}\n'})}),"\n",(0,s.jsxs)(n.h2,{id:"customizing-clientdriver-and-dnsresolver",children:["Customizing ",(0,s.jsx)(n.code,{children:"ClientDriver"})," and ",(0,s.jsx)(n.code,{children:"DnsResolver"})]}),"\n",(0,s.jsxs)(n.p,{children:["Rather than utilizing the default layer, ",(0,s.jsx)(n.code,{children:"Client.default"}),", we have the option to employ the ",(0,s.jsx)(n.code,{children:"Client.customized"})," layer. This layer requires ",(0,s.jsx)(n.code,{children:"ClientDriver"}),", ",(0,s.jsx)(n.code,{children:"DnsResolver"}),", and the ",(0,s.jsx)(n.code,{children:"Client.Config"})," layers:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"object Client {\n  val customized: ZLayer[Config with ClientDriver with DnsResolver, Throwable, Client] = ???\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"This empowers us to interchange the client driver with alternatives beyond the default Netty driver or to customize it to our specific requirements. Also, we can customize the DNS resolver to use a different DNS resolution mechanism."}),"\n",(0,s.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,s.jsx)(n.h3,{id:"simple-client-example",children:"Simple Client Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",metastring:'title="zio-http-example/src/main/scala/example/SimpleClient.scala" ',children:'package example\n\nimport zio._\n\nimport zio.http._\n\nobject SimpleClient extends ZIOAppDefault {\n  val url = URL.decode("https://jsonplaceholder.typicode.com/todos").toOption.get\n\n  val program = for {\n    client <- ZIO.service[Client]\n    res    <- client.url(url).batched(Request.get("/"))\n    data   <- res.body.asString\n    _      <- Console.printLine(data)\n  } yield ()\n\n  override val run = program.provide(Client.default)\n\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"clientserver-example",children:"ClientServer Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",metastring:'title="zio-http-example/src/main/scala/example/ClientServer.scala" ',children:'package example\n\nimport zio.ZIOAppDefault\n\nimport zio.http._\n\nobject ClientServer extends ZIOAppDefault {\n  val url = URL.decode("http://localhost:8080/hello").toOption.get\n\n  val app = Routes(\n    Method.GET / "hello" -> handler(Response.text("hello")),\n    Method.GET / ""      -> handler(ZClient.batched(Request.get(url))),\n  ).sandbox\n\n  val run =\n    Server.serve(app).provide(Server.default, Client.default).exitCode\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"authentication-client-example",children:"Authentication Client Example"}),"\n",(0,s.jsxs)(n.p,{children:["This example code demonstrates accessing a protected route in an ",(0,s.jsx)(n.a,{href:"https://github.com/zio/zio-http/blob/main/zio-http-example/src/main/scala/example/AuthenticationClient.scala",children:"authentication server"})," by first obtaining a JWT token through a login request and then using that token to access the protected route:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",metastring:'title="zio-http-example/src/main/scala/example/AuthenticationClient.scala" ',children:'package example\n\nimport zio._\n\nimport zio.http._\n\nobject AuthenticationClient extends ZIOAppDefault {\n\n  /**\n   * This example is trying to access a protected route in AuthenticationServer\n   * by first making a login request to obtain a jwt token and use it to access\n   * a protected route. Run AuthenticationServer before running this example.\n   */\n  val url = "http://localhost:8080"\n\n  val loginUrl = URL.decode(s"${url}/login").toOption.get\n  val greetUrl = URL.decode(s"${url}/profile/me").toOption.get\n\n  val program = for {\n    client   <- ZIO.service[Client]\n    // Making a login request to obtain the jwt token. In this example the password should be the reverse string of username.\n    token    <- client\n      .batched(\n        Request\n          .get(loginUrl)\n          .withBody(\n            Body.fromMultipartForm(\n              Form(\n                FormField.simpleField("username", "John"),\n                FormField.simpleField("password", "nhoJ"),\n              ),\n              Boundary("boundary123"),\n            ),\n          ),\n      )\n      .flatMap(_.body.asString)\n    // Once the jwt token is procured, adding it as a Bearer token in Authorization header while accessing a protected route.\n    response <- client.batched(Request.get(greetUrl).addHeader(Header.Authorization.Bearer(token)))\n    body     <- response.body.asString\n    _        <- Console.printLine(body)\n  } yield ()\n\n  override val run = program.provide(Client.default)\n\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"reconnecting-websocket-client-example",children:"Reconnecting WebSocket Client Example"}),"\n",(0,s.jsxs)(n.p,{children:["This example represents a WebSocket client application that automatically attempts to reconnect upon encountering errors or disconnections. It uses the ",(0,s.jsx)(n.code,{children:"Promise"})," to notify about WebSocket errors:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",metastring:'title="zio-http-example/src/main/scala/example/WebSocketReconnectingClient.scala" ',children:'package example\n\nimport zio._\n\nimport zio.http.ChannelEvent.{ExceptionCaught, Read, UserEvent, UserEventTriggered}\nimport zio.http._\n\nobject WebSocketReconnectingClient extends ZIOAppDefault {\n\n  val url = "ws://ws.vi-server.org/mirror"\n\n  // A promise is used to be able to notify application about websocket errors\n  def makeSocketApp(p: Promise[Nothing, Throwable]): WebSocketApp[Any] =\n    Handler\n\n      // Listen for all websocket channel events\n      .webSocket { channel =>\n        channel.receiveAll {\n\n          // On connect send a "foo" message to the server to start the echo loop\n          case UserEventTriggered(UserEvent.HandshakeComplete) =>\n            channel.send(ChannelEvent.Read(WebSocketFrame.text("foo")))\n\n          // On receiving "foo", we\'ll reply with another "foo" to keep echo loop going\n          case Read(WebSocketFrame.Text("foo"))                =>\n            ZIO.logInfo("Received foo message.") *>\n              ZIO.sleep(1.second) *>\n              channel.send(ChannelEvent.Read(WebSocketFrame.text("foo")))\n\n          // Handle exception and convert it to failure to signal the shutdown of the socket connection via the promise\n          case ExceptionCaught(t)                              =>\n            ZIO.fail(t)\n\n          case _ =>\n            ZIO.unit\n        }\n      }.tapErrorZIO { f =>\n        // signal failure to application\n        p.succeed(f)\n      }\n\n  val app: ZIO[Client & Scope, Throwable, Unit] = {\n    (for {\n      p <- zio.Promise.make[Nothing, Throwable]\n      _ <- makeSocketApp(p).connect(url).catchAll { t =>\n        // convert a failed connection attempt to an error to trigger a reconnect\n        p.succeed(t)\n      }\n      f <- p.await\n      _ <- ZIO.logError(s"App failed: $f")\n      _ <- ZIO.logError(s"Trying to reconnect...")\n      _ <- ZIO.sleep(1.seconds)\n    } yield {\n      ()\n    }) *> app\n  }\n\n  val run =\n    ZIO.scoped(app).provide(Client.default)\n\n}\n'})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>l});var i=t(96540);const s={},o=i.createContext(s);function r(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);