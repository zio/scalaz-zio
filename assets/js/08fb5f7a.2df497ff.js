"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[49034],{28453:(e,s,t)=>{t.d(s,{R:()=>a,x:()=>o});var n=t(96540);const i={},r=n.createContext(i);function a(e){const s=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),n.createElement(r.Provider,{value:s},e.children)}},67437:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"zio-query/index","title":"Introduction to ZIO Query","description":"ZIO Query is a library for writing optimized queries to data sources in a high-level compositional style. It can add efficient pipelining, batching, and caching to any data source. ZIO Query helps us dramatically reduce load on data sources and improve performance.","source":"@site/docs/zio-query/index.md","sourceDirName":"zio-query","slug":"/zio-query/","permalink":"/zio-query/","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-query/index.md","tags":[],"version":"current","frontMatter":{"id":"index","title":"Introduction to ZIO Query","sidebar_label":"ZIO Query"},"sidebar":"ecosystem-sidebar","previous":{"title":"Resources","permalink":"/zio-profiling/resources"},"next":{"title":"ZIO Query","permalink":"/zio-query/"}}');var i=t(74848),r=t(28453);const a={id:"index",title:"Introduction to ZIO Query",sidebar_label:"ZIO Query"},o=void 0,l={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Installation",id:"installation",level:2},{value:"Example",id:"example",level:2},{value:"Resources",id:"resources",level:2}];function c(e){const s={a:"a",code:"code",em:"em",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.a,{href:"https://github.com/zio/zio-query",children:"ZIO Query"})," is a library for writing optimized queries to data sources in a high-level compositional style. It can add efficient pipelining, batching, and caching to any data source. ZIO Query helps us dramatically reduce load on data sources and improve performance."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.a,{href:"https://github.com/zio/zio/wiki/Project-Stages",children:(0,i.jsx)(s.img,{src:"https://img.shields.io/badge/Project%20Stage-Production%20Ready-brightgreen.svg",alt:"Production Ready"})})," ",(0,i.jsx)(s.img,{src:"https://github.com/zio/zio-query/workflows/CI/badge.svg",alt:"CI Badge"})," ",(0,i.jsx)(s.a,{href:"https://oss.sonatype.org/content/repositories/releases/dev/zio/zio-query_2.13/",children:(0,i.jsx)(s.img,{src:"https://img.shields.io/nexus/r/https/oss.sonatype.org/dev.zio/zio-query_2.13.svg?label=Sonatype%20Release",alt:"Sonatype Releases"})})," ",(0,i.jsx)(s.a,{href:"https://oss.sonatype.org/content/repositories/snapshots/dev/zio/zio-query_2.13/",children:(0,i.jsx)(s.img,{src:"https://img.shields.io/nexus/s/https/oss.sonatype.org/dev.zio/zio-query_2.13.svg?label=Sonatype%20Snapshot",alt:"Sonatype Snapshots"})})," ",(0,i.jsx)(s.a,{href:"https://javadoc.io/doc/dev.zio/zio-query-docs_2.13",children:(0,i.jsx)(s.img,{src:"https://javadoc.io/badge2/dev.zio/zio-query-docs_2.13/javadoc.svg",alt:"javadoc"})})," ",(0,i.jsx)(s.a,{href:"https://github.com/zio/zio-query",children:(0,i.jsx)(s.img,{src:"https://img.shields.io/github/stars/zio/zio-query?style=social",alt:"ZIO Query"})})]}),"\n",(0,i.jsx)(s.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(s.p,{children:"Some key features of ZIO Query:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Batching"})," \u2014 ZIO Query detects parts of composite queries that can be executed in parallel without changing the semantics of the query."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Pipelining"})," \u2014 ZIO Query detects parts of composite queries that can be combined together for fewer individual requests to the data source."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Caching"})," \u2014 ZIO Query can transparently cache read queries to minimize the cost of fetching the same item repeatedly in the scope of a query."]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"Compared with Fetch, ZIO Query supports response types that depend on request types, does not require higher-kinded types and implicits, supports ZIO environment and statically typed errors, and has no dependencies except for ZIO."}),"\n",(0,i.jsxs)(s.p,{children:["A ",(0,i.jsx)(s.code,{children:"ZQuery[R, E, A]"})," is a purely functional description of an effectual query that may contain requests from one or more data sources, requires an environment ",(0,i.jsx)(s.code,{children:"R"}),", and may fail with an ",(0,i.jsx)(s.code,{children:"E"})," or succeed with an ",(0,i.jsx)(s.code,{children:"A"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["Requests that can be performed in parallel, as expressed by ",(0,i.jsx)(s.code,{children:"zipWithPar"})," and combinators derived from it, will automatically be batched. Requests that must be performed sequentially, as expressed by ",(0,i.jsx)(s.code,{children:"zipWith"})," and combinators derived from it, will automatically be pipelined. This allows for aggressive data source specific optimizations. Requests can also be deduplicated and cached."]}),"\n",(0,i.jsx)(s.p,{children:"This allows for writing queries in a high level, compositional style, with confidence that they will automatically be optimized. For example, consider the following query from a user service."}),"\n",(0,i.jsx)(s.p,{children:"Assume we have the following database access layer APIs:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-scala",children:"def getAllUserIds: ZIO[Any, Nothing, List[Int]] = {\n  // Get all user IDs e.g. SELECT id FROM users\n  ZIO.succeed(???)\n}\n\ndef getUserNameById(id: Int): ZIO[Any, Nothing, String] = {\n  // Get user by ID e.g. SELECT name FROM users WHERE id = $id\n  ZIO.succeed(???)\n}\n"})}),"\n",(0,i.jsx)(s.p,{children:"We can get their corresponding usernames from the database by the following code snippet:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-scala",children:"val userNames = for {\n  ids   <- getAllUserIds\n  names <- ZIO.foreachPar(ids)(getUserNameById)\n} yield names\n"})}),"\n",(0,i.jsxs)(s.p,{children:["It works, but this is not performant. It is going to query the underlying database ",(0,i.jsx)(s.em,{children:"N + 1"})," times, one for ",(0,i.jsx)(s.code,{children:"getAllUserIds"})," and one for each call to ",(0,i.jsx)(s.code,{children:"getUserNameById"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["In contrast, ",(0,i.jsx)(s.code,{children:"ZQuery"})," will automatically optimize this to two queries, one for ",(0,i.jsx)(s.code,{children:"userIds"})," and one for ",(0,i.jsx)(s.code,{children:"userNames"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-scala",children:"lazy val getAllUserIds: ZQuery[Any, Nothing, List[Int]]    = ???\ndef getUserNameById(id: Int): ZQuery[Any, Nothing, String] = ???\n\nlazy val userQuery: ZQuery[Any, Nothing, List[String]] = for {\n  userIds   <- getAllUserIds\n  userNames <- ZQuery.foreachPar(userIds)(getUserNameById)\n} yield userNames\n"})}),"\n",(0,i.jsx)(s.h2,{id:"installation",children:"Installation"}),"\n",(0,i.jsxs)(s.p,{children:["In order to use this library, we need to add the following line in our ",(0,i.jsx)(s.code,{children:"build.sbt"})," file:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-scala",children:'libraryDependencies += "dev.zio" %% "zio-query" % "0.7.6"\n'})}),"\n",(0,i.jsx)(s.h2,{id:"example",children:"Example"}),"\n",(0,i.jsx)(s.p,{children:"Here is an example of using ZIO Query, which optimizes multiple database queries by batching all of them in one query:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-scala",children:'import zio._\nimport zio.query._\n\nobject ZQueryExample extends ZIOAppDefault {\n  case class GetUserName(id: Int) extends Request[Throwable, String]\n\n  lazy val UserDataSource: DataSource.Batched[Any, GetUserName] =\n    new DataSource.Batched[Any, GetUserName] {\n      val identifier: String = "UserDataSource"\n\n      def run(requests: Chunk[GetUserName])(implicit trace: Trace): ZIO[Any, Nothing, CompletedRequestMap] =\n        requests.toList match {\n          case request :: Nil =>\n            val result: Task[String] = {\n              // get user by ID e.g. SELECT name FROM users WHERE id = $id\n              ZIO.succeed(???)\n            }\n\n            result.exit.map(CompletedRequestMap.single(request, _))\n\n          case batch: Seq[GetUserName] =>\n            val result: Task[List[(Int, String)]] = {\n              // get multiple users at once e.g. SELECT id, name FROM users WHERE id IN ($ids)\n              ZIO.succeed(???)\n            }\n\n            result.foldCause(\n              CompletedRequestMap.failCause(requests, _),\n              CompletedRequestMap.fromIterableWith(_)(kv => GetUserName(kv._1), kv => Exit.succeed(kv._2))\n            )\n        }\n    }\n\n  def getUserNameById(id: Int): ZQuery[Any, Throwable, String] =\n    ZQuery.fromRequest(GetUserName(id))(UserDataSource)\n\n  val query: ZQuery[Any, Throwable, List[String]] =\n    for {\n      ids <- ZQuery.succeed(1 to 10)\n      names <- ZQuery.foreachPar(ids)(id => getUserNameById(id)).map(_.toList)\n    } yield (names)\n\n  def run = query.run.tap(usernames => Console.printLine(s"Usernames: $usernames"))\n}\n'})}),"\n",(0,i.jsx)(s.h2,{id:"resources",children:"Resources"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.a,{href:"https://www.youtube.com/watch?v=rUUxDXJMzJo",children:"Wicked Fast API Calls with ZIO Query"})," by Adam Fraser (July 2020) (",(0,i.jsx)(s.a,{href:"https://www.youtube.com/watch?v=rUUxDXJMzJo",children:"https://www.youtube.com/watch?v=rUUxDXJMzJo"}),")"]}),"\n"]})]})}function u(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);