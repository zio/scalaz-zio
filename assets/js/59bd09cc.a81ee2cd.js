"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[9272],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>s});var a=t(96540);const i={},r=a.createContext(i);function o(e){const n=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),a.createElement(r.Provider,{value:n},e.children)}},74308:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>f,frontMatter:()=>o,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"reference/stm/tref","title":"TRef","description":"A TRef[A] is a mutable reference to an immutable value, which can participate in transactions in STM. The mutable reference can be retrieved and set from within transactions, with strong guarantees for atomicity, consistency, and isolation from other transactions.","source":"@site/versioned_docs/version-1.0.18/reference/stm/tref.md","sourceDirName":"reference/stm","slug":"/reference/stm/tref","permalink":"/1.0.18/reference/stm/tref","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/versioned_docs/version-1.0.18/reference/stm/tref.md","tags":[],"version":"1.0.18","frontMatter":{"id":"tref","title":"TRef"}}');var i=t(74848),r=t(28453);const o={id:"tref",title:"TRef"},s=void 0,l={},c=[{value:"Create a TRef",id:"create-a-tref",level:2},{value:"Retrieve the value out of a TRef",id:"retrieve-the-value-out-of-a-tref",level:2},{value:"Set a value to a TRef",id:"set-a-value-to-a-tref",level:2},{value:"Update the value of the TRef",id:"update-the-value-of-the-tref",level:2},{value:"Modify the value of the TRef",id:"modify-the-value-of-the-tref",level:2},{value:"Example usage",id:"example-usage",level:2},{value:"ZTRef",id:"ztref",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.code,{children:"TRef[A]"})," is a mutable reference to an immutable value, which can participate in transactions in STM. The mutable reference can be retrieved and set from within transactions, with strong guarantees for atomicity, consistency, and isolation from other transactions."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"TRef"})," provides the low-level machinery to create transactions from modifications of STM memory."]}),"\n",(0,i.jsx)(n.h2,{id:"create-a-tref",children:"Create a TRef"}),"\n",(0,i.jsxs)(n.p,{children:["Creating a ",(0,i.jsx)(n.code,{children:"TRef"})," inside a transaction:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"import zio._\nimport zio.stm._\n\nval createTRef: STM[Nothing, TRef[Int]] = TRef.make(10)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Or creating a ",(0,i.jsx)(n.code,{children:"TRef"})," inside a transaction, and immediately committing the transaction, which allows you to store and pass along the reference."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"import zio._\nimport zio.stm._\n\nval commitTRef: UIO[TRef[Int]] = TRef.makeCommit(10)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"retrieve-the-value-out-of-a-tref",children:"Retrieve the value out of a TRef"}),"\n",(0,i.jsx)(n.p,{children:"Retrieving the value in a single transaction:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"import zio._\nimport zio.stm._\n\nval retrieveSingle: UIO[Int] = (for {\n  tRef <- TRef.make(10)\n  value <- tRef.get\n} yield value).commit\n"})}),"\n",(0,i.jsx)(n.p,{children:"Or on multiple transactional statements:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"import zio._\nimport zio.stm._\n\nval retrieveMultiple: UIO[Int] = for {\n  tRef <- TRef.makeCommit(10)\n  value <- tRef.get.commit\n} yield value\n"})}),"\n",(0,i.jsx)(n.h2,{id:"set-a-value-to-a-tref",children:"Set a value to a TRef"}),"\n",(0,i.jsx)(n.p,{children:"Setting the value overwrites the existing content of a reference."}),"\n",(0,i.jsx)(n.p,{children:"Setting the value in a single transaction:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"import zio._\nimport zio.stm._\n\nval setSingle: UIO[Int] = (for {\n  tRef <- TRef.make(10)\n  _ <- tRef.set(20)\n  nValue <- tRef.get\n} yield nValue).commit\n"})}),"\n",(0,i.jsx)(n.p,{children:"Or on multiple transactions:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"import zio._\nimport zio.stm._\n\nval setMultiple: UIO[Int] = for {\n  tRef <- TRef.makeCommit(10)\n  nValue <- tRef.set(20).flatMap(_ => tRef.get).commit\n} yield nValue\n"})}),"\n",(0,i.jsx)(n.h2,{id:"update-the-value-of-the-tref",children:"Update the value of the TRef"}),"\n",(0,i.jsxs)(n.p,{children:["The update function ",(0,i.jsx)(n.code,{children:"A => A"})," allows computing a new value for the ",(0,i.jsx)(n.code,{children:"TRef"})," using the old value."]}),"\n",(0,i.jsx)(n.p,{children:"Updating the value in a single transaction:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"import zio._\nimport zio.stm._\n\nval updateSingle: UIO[Int] = (for {\n  tRef <- TRef.make(10)\n  nValue <- tRef.updateAndGet(_ + 20)\n} yield nValue).commit\n"})}),"\n",(0,i.jsx)(n.p,{children:"Or on multiple transactions:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"import zio._\nimport zio.stm._\n\nval updateMultiple: UIO[Int] = for {\n  tRef <- TRef.makeCommit(10)\n  nValue <- tRef.updateAndGet(_ + 20).commit\n} yield nValue\n"})}),"\n",(0,i.jsx)(n.h2,{id:"modify-the-value-of-the-tref",children:"Modify the value of the TRef"}),"\n",(0,i.jsxs)(n.p,{children:["The modify function ",(0,i.jsx)(n.code,{children:"A => (B, A): B"})," works similar to ",(0,i.jsx)(n.code,{children:"update"}),", but allows extracting some information (the ",(0,i.jsx)(n.code,{children:"B"}),") out of the update operation."]}),"\n",(0,i.jsx)(n.p,{children:"Modify the value in a single transaction:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.stm._\n\nval modifySingle: UIO[(String, Int)] = (for {\n  tRef <- TRef.make(10)\n  mValue <- tRef.modify(v => ("Zee-Oh", v + 10))\n  nValue <- tRef.get\n} yield (mValue, nValue)).commit\n'})}),"\n",(0,i.jsx)(n.p,{children:"Or on multiple transactions:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.stm._\n\nval modifyMultiple: UIO[(String, Int)] = for {\n  tRef <- TRef.makeCommit(10)\n  tuple2 <- tRef.modify(v => ("Zee-Oh", v + 10)).zip(tRef.get).commit\n} yield tuple2\n'})}),"\n",(0,i.jsx)(n.h2,{id:"example-usage",children:"Example usage"}),"\n",(0,i.jsxs)(n.p,{children:["Here is a scenario where we use a ",(0,i.jsx)(n.code,{children:"TRef"})," to hand-off a value between two ",(0,i.jsx)(n.code,{children:"Fiber"}),"s"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.stm._\n\ndef transfer(tSender: TRef[Int],\n             tReceiver: TRef[Int],\n             amount: Int): UIO[Int] = {\n  STM.atomically {\n    for {\n      _ <- tSender.get.retryUntil(_ >= amount)\n      _ <- tSender.update(_ - amount)\n      nAmount <- tReceiver.updateAndGet(_ + amount)\n    } yield nAmount\n  }\n}\n\nval transferredMoney: UIO[String] = for {\n  tSender <- TRef.makeCommit(50)\n  tReceiver <- TRef.makeCommit(100)\n  _ <- transfer(tSender, tReceiver, 50).fork\n  _ <- tSender.get.retryUntil(_ == 0).commit\n  tuple2 <- tSender.get.zip(tReceiver.get).commit\n  (senderBalance, receiverBalance) = tuple2\n} yield s"sender: $senderBalance & receiver: $receiverBalance"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["In this example, we create and commit two transactional references for the sender and receiver to be able to extract their value.\nOn the following step, we create an atomic transactional that updates both accounts only when there is sufficient balance available in the sender account. In the end, we fork to run asynchronously.\nOn the running fiber, we suspend until the sender balance suffers changes, in this case, to reach ",(0,i.jsx)(n.code,{children:"zero"}),". Finally, we extract the new values out of the accounts and combine them in one result."]}),"\n",(0,i.jsx)(n.h2,{id:"ztref",children:"ZTRef"}),"\n",(0,i.jsxs)(n.p,{children:["Like ",(0,i.jsx)(n.code,{children:"Ref[A]"}),", ",(0,i.jsx)(n.code,{children:"TRef[A]"})," is actually a type alias for ",(0,i.jsx)(n.code,{children:"ZTRef[+EA, +EB, -A, +B]"}),", a polymorphic, transactional reference and supports all the transformations that ",(0,i.jsx)(n.code,{children:"ZRef"})," does. For more discussion regarding polymorphic references see the documentation on ",(0,i.jsx)(n.a,{href:"/1.0.18/reference/concurrency/ref",children:(0,i.jsx)(n.code,{children:"ZRef"})}),"."]})]})}function f(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);