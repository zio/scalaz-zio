"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[12433],{83334:(e,o,n)=>{n.r(o),n.d(o,{assets:()=>d,contentTitle:()=>t,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"zio-http/reference/body/binary_codecs","title":"BinaryCodecs for Request/Response Bodies","description":"ZIO HTTP has built-in support for encoding and decoding request/response bodies. This is achieved using generating codecs for our custom data types powered by ZIO Schema.","source":"@site/docs/zio-http/reference/body/binary_codecs.md","sourceDirName":"zio-http/reference/body","slug":"/zio-http/reference/body/binary_codecs","permalink":"/zio-http/reference/body/binary_codecs","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-http/reference/body/binary_codecs.md","tags":[],"version":"current","frontMatter":{"id":"binary_codecs","title":"BinaryCodecs for Request/Response Bodies","sidebar_label":"BinaryCodecs"},"sidebar":"ecosystem-sidebar","previous":{"title":"Form Data","permalink":"/zio-http/reference/body/form"},"next":{"title":"Template","permalink":"/zio-http/reference/body/template"}}');var i=n(74848),c=n(28453);const r={id:"binary_codecs",title:"BinaryCodecs for Request/Response Bodies",sidebar_label:"BinaryCodecs"},t=void 0,d={},a=[{value:"JSON Codec Example",id:"json-codec-example",level:2},{value:"JSON Serialization of Response Body",id:"json-serialization-of-response-body",level:3},{value:"JSON Deserialization of Request Body",id:"json-deserialization-of-request-body",level:3}];function l(e){const o={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,c.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(o.p,{children:["ZIO HTTP has built-in support for encoding and decoding request/response bodies. This is achieved using generating codecs for our custom data types powered by ",(0,i.jsx)(o.a,{href:"https://zio.dev/zio-schema",children:"ZIO Schema"}),"."]}),"\n",(0,i.jsx)(o.p,{children:"ZIO Schema is a library for defining the schema for any custom data type, including case classes, sealed traits, and enumerations, other than the built-in types. It provides a way to derive codecs for these custom data types, for encoding and decoding data to/from JSON, Protobuf, Avro, and other formats."}),"\n",(0,i.jsx)(o.p,{children:"Having codecs for our custom data types allows us to easily serialize/deserialize data to/from request/response bodies in our HTTP applications."}),"\n",(0,i.jsxs)(o.p,{children:["The ",(0,i.jsx)(o.code,{children:"Body"})," data type in ZIO HTTP represents the body message of a request or a response. It has two main functionality for encoding and decoding request/response bodies, both of which require an implicit ",(0,i.jsx)(o.code,{children:"BinaryCodec"})," for the corresponding data type:"]}),"\n",(0,i.jsxs)(o.ul,{children:["\n",(0,i.jsxs)(o.li,{children:[(0,i.jsx)(o.strong,{children:(0,i.jsx)(o.code,{children:"Body#to[A]"})})," \u2014 It decodes the request body to a custom data of type ",(0,i.jsx)(o.code,{children:"A"})," using the implicit ",(0,i.jsx)(o.code,{children:"BinaryCodec"})," for ",(0,i.jsx)(o.code,{children:"A"}),"."]}),"\n",(0,i.jsxs)(o.li,{children:[(0,i.jsx)(o.strong,{children:(0,i.jsx)(o.code,{children:"Body.from[A]"})})," \u2014 It encodes custom data of type ",(0,i.jsx)(o.code,{children:"A"})," to a response body using the implicit ",(0,i.jsx)(o.code,{children:"BinaryCodec"})," for ",(0,i.jsx)(o.code,{children:"A"}),"."]}),"\n"]}),"\n",(0,i.jsx)(o.pre,{children:(0,i.jsx)(o.code,{className:"language-scala",children:"trait Body {\n  def to[A](implicit codec: BinaryCodec[A]): Task[A] = ???\n}\n\nobject Body {\n  def from[A](a: A)(implicit codec: BinaryCodec[A]): Body = ???\n}\n"})}),"\n",(0,i.jsxs)(o.p,{children:["To use these two methods, we need to have an implicit ",(0,i.jsx)(o.code,{children:"BinaryCodec"})," for our custom data type, ",(0,i.jsx)(o.code,{children:"A"}),". Let's assume we have a ",(0,i.jsx)(o.code,{children:"Book"})," case class with ",(0,i.jsx)(o.code,{children:"title"}),", ",(0,i.jsx)(o.code,{children:"authors"})," fields:"]}),"\n",(0,i.jsx)(o.pre,{children:(0,i.jsx)(o.code,{className:"language-scala",children:"case class Book(title: String, authors: List[String])\n"})}),"\n",(0,i.jsxs)(o.p,{children:["To create a ",(0,i.jsx)(o.code,{children:"BinaryCodec[Book]"})," for our ",(0,i.jsx)(o.code,{children:"Book"})," case class, we can implement the ",(0,i.jsx)(o.code,{children:"BinaryCodec"})," interface:"]}),"\n",(0,i.jsx)(o.pre,{children:(0,i.jsx)(o.code,{className:"language-scala",children:"import zio._ \nimport zio.stream._\nimport zio.schema.codec._\n\nimplicit val bookBinaryCodec = new BinaryCodec[Book] {\n  override def encode(value: Book): Chunk[Byte] = ???\n  override def streamEncoder: ZPipeline[Any, Nothing, Book, Byte] = ???\n  override def decode(whole: Chunk[Byte]): Either[DecodeError, Book] = ???\n  override def streamDecoder: ZPipeline[Any, DecodeError, Byte, Book] = ???\n}\n"})}),"\n",(0,i.jsxs)(o.p,{children:["Now, when we call ",(0,i.jsx)(o.code,{children:'Body.from(Book("Zionomicon", List("John De Goes")))'}),", it will encode the ",(0,i.jsx)(o.code,{children:"Book"})," case class to a response body using the implicit ",(0,i.jsx)(o.code,{children:"BinaryCodec[Book]"}),". But, what happens if we add a new field to the ",(0,i.jsx)(o.code,{children:"Book"})," case class, or change one of the existing fields? We would need to update the ",(0,i.jsx)(o.code,{children:"BinaryCodec[Book]"})," implementation to reflect these changes. Also, if we want to support body response bodies with multiple book objects, we would need to implement a new codec for ",(0,i.jsx)(o.code,{children:"List[Book]"}),". So, maintaining these codecs can be cumbersome and error-prone."]}),"\n",(0,i.jsxs)(o.p,{children:["ZIO Schema simplifies this process by providing a way to derive codecs for our custom data types. For each custom data type, ",(0,i.jsx)(o.code,{children:"A"}),", if we write/derive a ",(0,i.jsx)(o.code,{children:"Schema[A]"})," using ZIO Schema, then we can derive a ",(0,i.jsx)(o.code,{children:"BinaryCodec[A]"})," for any format supported by ZIO Schema, including JSON, Protobuf, Avro, and Thrift."]}),"\n",(0,i.jsxs)(o.p,{children:["So, let's generate a ",(0,i.jsx)(o.code,{children:"Schema[Book]"})," for our ",(0,i.jsx)(o.code,{children:"Book"})," case class:"]}),"\n",(0,i.jsx)(o.pre,{children:(0,i.jsx)(o.code,{className:"language-scala",children:"import zio.schema._\n\nobject Book {\n  implicit val schema: Schema[Book] = DeriveSchema.gen[Book]\n}\n"})}),"\n",(0,i.jsxs)(o.p,{children:["Based on what format we want, we can add one of the following codecs to our ",(0,i.jsx)(o.code,{children:"build.sbt"})," file:"]}),"\n",(0,i.jsx)(o.pre,{children:(0,i.jsx)(o.code,{className:"language-scala",children:'libraryDependencies += "dev.zio" %% "zio-schema-json"     % "1.4.1"\nlibraryDependencies += "dev.zio" %% "zio-schema-protobuf" % "1.4.1"\nlibraryDependencies += "dev.zio" %% "zio-schema-avro"     % "1.4.1"\nlibraryDependencies += "dev.zio" %% "zio-schema-thrift"   % "1.4.1"\n'})}),"\n",(0,i.jsxs)(o.p,{children:["After adding the required codec's dependency, we can import the right binary codec inside the ",(0,i.jsx)(o.code,{children:"zio.schema.codec"})," package:"]}),"\n",(0,i.jsxs)(o.table,{children:[(0,i.jsx)(o.thead,{children:(0,i.jsxs)(o.tr,{children:[(0,i.jsx)(o.th,{children:"Codecs"}),(0,i.jsxs)(o.th,{children:["Schema Based BinaryCodec (",(0,i.jsx)(o.code,{children:"zio.schema.codec"})," package)"]}),(0,i.jsx)(o.th,{children:"Output"})]})}),(0,i.jsxs)(o.tbody,{children:[(0,i.jsxs)(o.tr,{children:[(0,i.jsx)(o.td,{children:"JSON"}),(0,i.jsx)(o.td,{children:(0,i.jsx)(o.code,{children:"JsonCodec.schemaBasedBinaryCodec[A](implicit schema: Schema[A])"})}),(0,i.jsx)(o.td,{children:"BinaryCodec[A]"})]}),(0,i.jsxs)(o.tr,{children:[(0,i.jsx)(o.td,{children:"Protobuf"}),(0,i.jsx)(o.td,{children:(0,i.jsx)(o.code,{children:"ProtobufCodec.protobufCodec[A](implicit schema: Schema[A])"})}),(0,i.jsx)(o.td,{children:"BinaryCodec[A]"})]}),(0,i.jsxs)(o.tr,{children:[(0,i.jsx)(o.td,{children:"Avro"}),(0,i.jsx)(o.td,{children:(0,i.jsx)(o.code,{children:"AvroCodec.schemaBasedBinaryCodec[A](implicit schema: Schema[A])"})}),(0,i.jsx)(o.td,{children:"BinaryCodec[A]"})]}),(0,i.jsxs)(o.tr,{children:[(0,i.jsx)(o.td,{children:"Thrift"}),(0,i.jsx)(o.td,{children:(0,i.jsx)(o.code,{children:"ThriftCodec.thriftBinaryCodec[A](implicit schema: Schema[A])"})}),(0,i.jsx)(o.td,{children:"BinaryCodec[A]"})]}),(0,i.jsxs)(o.tr,{children:[(0,i.jsx)(o.td,{children:"MsgPack"}),(0,i.jsx)(o.td,{children:(0,i.jsx)(o.code,{children:"MessagePackCodec.messagePackCodec[A](implicit schema: Schema[A])"})}),(0,i.jsx)(o.td,{children:"BinaryCodec[A]"})]})]})]}),"\n",(0,i.jsxs)(o.p,{children:["That is very simple! To have a ",(0,i.jsx)(o.code,{children:"BinaryCodec"})," of type ",(0,i.jsx)(o.code,{children:"A"})," we only need to derive a ",(0,i.jsx)(o.code,{children:"Schema[A]"})," and then use an appropriate codec from the ",(0,i.jsx)(o.code,{children:"zio.schema.codec"})," package."]}),"\n",(0,i.jsx)(o.h2,{id:"json-codec-example",children:"JSON Codec Example"}),"\n",(0,i.jsx)(o.h3,{id:"json-serialization-of-response-body",children:"JSON Serialization of Response Body"}),"\n",(0,i.jsx)(o.p,{children:"Assume want to write an HTTP API that returns a list of books in JSON format:"}),"\n",(0,i.jsx)(o.pre,{children:(0,i.jsx)(o.code,{className:"language-scala",metastring:'title="zio-http-example/src/main/scala/example/codecs/ResponseBodyJsonSerializationExample.scala" ',children:'package example.codecs\n\nimport zio._\n\nimport zio.schema.codec.JsonCodec.schemaBasedBinaryCodec\nimport zio.schema.{DeriveSchema, Schema}\n\nimport zio.http._\n\nobject ResponseBodyJsonSerializationExample extends ZIOAppDefault {\n\n  case class Book(title: String, authors: List[String])\n\n  object Book {\n    implicit val schema: Schema[Book] = DeriveSchema.gen\n  }\n\n  val book1 = Book("Programming in Scala", List("Martin Odersky", "Lex Spoon", "Bill Venners", "Frank Sommers"))\n  val book2 = Book("Zionomicon", List("John A. De Goes", "Adam Fraser"))\n  val book3 = Book("Effect-Oriented Programming", List("Bill Frasure", "Bruce Eckel", "James Ward"))\n\n  val routes: Routes[Any, Nothing] =\n    Routes(\n      Method.GET / "users" ->\n        handler(Response(body = Body.from(List(book1, book2, book3)))),\n    )\n\n  def run = Server.serve(routes).provide(Server.default)\n}\n'})}),"\n",(0,i.jsx)(o.h3,{id:"json-deserialization-of-request-body",children:"JSON Deserialization of Request Body"}),"\n",(0,i.jsxs)(o.p,{children:["In the example below, we have an HTTP API that accepts a JSON request body containing a ",(0,i.jsx)(o.code,{children:"Book"})," object and adds it to a list of books:"]}),"\n",(0,i.jsx)(o.pre,{children:(0,i.jsx)(o.code,{className:"language-scala",metastring:'title="zio-http-example/src/main/scala/example/codecs/RequestBodyJsonDeserializationExample.scala" ',children:'package example.codecs\n\nimport zio._\n\nimport zio.schema.codec.JsonCodec.schemaBasedBinaryCodec\nimport zio.schema.{DeriveSchema, Schema}\n\nimport zio.http._\n\nobject RequestBodyJsonDeserializationExample extends ZIOAppDefault {\n\n  case class Book(title: String, authors: List[String])\n\n  object Book {\n    implicit val schema: Schema[Book] = DeriveSchema.gen\n  }\n\n  val routes: Routes[Ref[List[Book]], Nothing] =\n    Routes(\n      Method.POST / "books" ->\n        handler { (req: Request) =>\n          for {\n            book  <- req.body.to[Book].catchAll(_ => ZIO.fail(Response.badRequest("unable to deserialize the request")))\n            books <- ZIO.service[Ref[List[Book]]]\n            _     <- books.updateAndGet(_ :+ book)\n          } yield Response.ok\n        },\n      Method.GET / "books"  ->\n        handler { (_: Request) =>\n          ZIO\n            .serviceWithZIO[Ref[List[Book]]](_.get)\n            .map(books => Response(body = Body.from(books)))\n        },\n    )\n\n  def run = Server.serve(routes).provide(Server.default, ZLayer.fromZIO(Ref.make(List.empty[Book])))\n}\n'})}),"\n",(0,i.jsxs)(o.p,{children:["To send a POST request to the ",(0,i.jsx)(o.code,{children:"/books"})," endpoint with a JSON body containing a ",(0,i.jsx)(o.code,{children:"Book"})," object, we can use the following ",(0,i.jsx)(o.code,{children:"curl"})," command:"]}),"\n",(0,i.jsx)(o.pre,{children:(0,i.jsx)(o.code,{className:"language-shell",children:'$ curl -X POST -d \'{"title": "Zionomicon", "authors": ["John De Goes", "Adam Fraser"]}\' http://localhost:8080/books\n'})}),"\n",(0,i.jsxs)(o.p,{children:["After sending the POST request, we can retrieve the list of books by sending a GET request to the ",(0,i.jsx)(o.code,{children:"/books"})," endpoint:"]}),"\n",(0,i.jsx)(o.pre,{children:(0,i.jsx)(o.code,{className:"language-shell",children:"$ curl http://localhost:8080/books\n"})})]})}function h(e={}){const{wrapper:o}={...(0,c.R)(),...e.components};return o?(0,i.jsx)(o,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},28453:(e,o,n)=>{n.d(o,{R:()=>r,x:()=>t});var s=n(96540);const i={},c=s.createContext(i);function r(e){const o=s.useContext(c);return s.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function t(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(c.Provider,{value:o},e.children)}}}]);