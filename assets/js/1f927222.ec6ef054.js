"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[88440],{28453:(e,i,n)=>{n.d(i,{R:()=>a,x:()=>s});var o=n(96540);const t={},r=o.createContext(t);function a(e){const i=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function s(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),o.createElement(r.Provider,{value:i},e.children)}},59698:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>d,contentTitle:()=>s,default:()=>f,frontMatter:()=>a,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"zio-config/automatic-validations","title":"Automatic Validations","description":"By bringing in zio-config-refined module, you get validations for your config parameters almost for free.","source":"@site/docs/zio-config/automatic-validations.md","sourceDirName":"zio-config","slug":"/zio-config/automatic-validations","permalink":"/zio-config/automatic-validations","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-config/automatic-validations.md","tags":[],"version":"current","frontMatter":{"id":"automatic-validations","title":"Automatic Validations"},"sidebar":"ecosystem-sidebar","previous":{"title":"Read from various Sources","permalink":"/zio-config/read-from-various-sources"},"next":{"title":"Resources","permalink":"/zio-config/resources"}}');var t=n(74848),r=n(28453);const a={id:"automatic-validations",title:"Automatic Validations"},s=void 0,d={},c=[{value:"Basic Example",id:"basic-example",level:2},{value:"Direct Interaction with Refined Predicates",id:"direct-interaction-with-refined-predicates",level:2},{value:"Derive from existing Config",id:"derive-from-existing-config",level:2},{value:"Auto-Derivation and Refined",id:"auto-derivation-and-refined",level:2}];function l(e){const i={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(i.p,{children:["By bringing in ",(0,t.jsx)(i.code,{children:"zio-config-refined"})," module, you get validations for your config parameters almost for free.\n",(0,t.jsx)(i.code,{children:"zio-config"})," elegantly integrates with ",(0,t.jsx)(i.code,{children:"Refined"})," library for you to achieve this with same ergonomics."]}),"\n",(0,t.jsxs)(i.p,{children:["If you are not familiar with ",(0,t.jsx)(i.code,{children:"refined"})," library, refer ",(0,t.jsx)(i.a,{href:"https://github.com/fthomas/refined",children:"https://github.com/fthomas/refined"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["There are various ways that zio-config can interact with refined library.\nTake a look at ",(0,t.jsx)(i.code,{children:"zio.config.refined"})," package."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-scala",children:" import zio.Config\n import zio.ConfigProvider\n import zio.config._, refined._\n\n"})}),"\n",(0,t.jsx)(i.p,{children:"A few examples are given below."}),"\n",(0,t.jsx)(i.h2,{id:"basic-example",children:"Basic Example"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-scala",children:' import eu.timepit.refined.types.string.NonEmptyString\n\n case class Jdbc(username: NonEmptyString, password: NonEmptyString)\n\n val jdbc: Config[Jdbc] =\n   (refineType[NonEmptyString]("username") zip\n     refineType[NonEmptyString]("password")).to[Jdbc]\n\n ConfigProvider.fromMap(Map("username" -> "", "password" -> "")).load(jdbc)\n'})}),"\n",(0,t.jsx)(i.h2,{id:"direct-interaction-with-refined-predicates",children:"Direct Interaction with Refined Predicates"}),"\n",(0,t.jsxs)(i.p,{children:["If you need to directly interact with ",(0,t.jsx)(i.code,{children:"Predicate"}),"s (ex: ",(0,t.jsx)(i.code,{children:"NonEmpty"}),"), then\n",(0,t.jsx)(i.code,{children:"refine[A, P]"})," method is useful."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-scala",children:' import eu.timepit.refined._, api._, string._, collection._\n \n type NonEmptyString = String Refined NonEmpty\n \n val refinedConfig: Config[NonEmptyString] = \n   refineType[NonEmptyString]("USERNAME")\n  \n // Another way of doing it is\n val urlConfig: Config[Refined[String, Url]] =\n   refine[String, Url]("URL")\n   \n // refineType takes a fully formed type (String Refined NonEmpty) where as refine allows you to play with the predicate directly (NonEmpty)  \n'})}),"\n",(0,t.jsx)(i.h2,{id:"derive-from-existing-config",children:"Derive from existing Config"}),"\n",(0,t.jsxs)(i.p,{children:["Of various methods available in ",(0,t.jsx)(i.code,{children:"zio.config.refined"})," package,\nthe most interesting one is being able to get a refined type out of an already derived Config.\nThis shows the composable nature of zio-config."]}),"\n",(0,t.jsx)(i.p,{children:"Take a look at the below example"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-scala",children:' import eu.timepit.refined._, api._, numeric._, collection._\n import zio.config.magnolia.deriveConfig\n\n case class MyConfig(url: String, port: Int)\n\n val configs: Config[List[MyConfig]] =\n   Config.listOf("databases", deriveConfig[MyConfig])\n\n // A list of database configs, such that size should be greater than 2.\n val databaseList: Config[Refined[List[MyConfig], Size[Greater[W.`2`.T]]]] =\n   refine[Size[Greater[W.`2`.T]]](configs)\n'})}),"\n",(0,t.jsx)(i.h2,{id:"auto-derivation-and-refined",children:"Auto-Derivation and Refined"}),"\n",(0,t.jsx)(i.p,{children:"You can also use auto derivations with refined."}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-scala",children:'import zio.ConfigProvider\nimport eu.timepit.refined.W\nimport eu.timepit.refined.api.Refined\nimport eu.timepit.refined.collection.{ NonEmpty, Size }\nimport zio.config.magnolia.deriveConfig\n\nobject RefinedReadConfig extends App {\n  case class RefinedProd(\n    ldap: Refined[String, NonEmpty],\n    port: Refined[Int, GreaterEqual[W.`1024`.T]],\n    dbUrl: Option[Refined[String, NonEmpty]]\n  )\n\n  val configMap =\n    Map(\n      "LDAP"     -> "ldap",\n      "PORT"     -> "1999",\n      "DBURL"   -> "ddd"\n    )\n\n  val result =\n    ConfigProvider.fromMap(configMap).load(deriveConfig[RefinedProd].mapKey(_.toUpperCase))\n\n  // RefinedProd(ldap,1999,Some(ddd))\n}\n'})})]})}function f(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}}}]);