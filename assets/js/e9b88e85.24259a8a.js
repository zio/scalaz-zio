"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[69699],{28453:(e,i,o)=>{o.d(i,{R:()=>l,x:()=>t});var n=o(96540);const r={},c=n.createContext(r);function l(e){const i=n.useContext(c);return n.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function t(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),n.createElement(c.Provider,{value:i},e.children)}},88077:(e,i,o)=>{o.r(i),o.d(i,{assets:()=>d,contentTitle:()=>t,default:()=>p,frontMatter:()=>l,metadata:()=>n,toc:()=>s});const n=JSON.parse('{"id":"zio-quill/compiler-performance","title":"Compiler performance","description":"Quill will probably make the slow scala compiler even slower, since a lot of additional Parsing, Typechecking, Implicit resolution works introduced to expand a Query.","source":"@site/docs/zio-quill/compiler-performance.md","sourceDirName":"zio-quill","slug":"/zio-quill/compiler-performance","permalink":"/zio-quill/compiler-performance","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-quill/compiler-performance.md","tags":[],"version":"current","frontMatter":{"id":"compiler-performance","title":"Compiler performance"},"sidebar":"ecosystem-sidebar","previous":{"title":"Logging","permalink":"/zio-quill/logging"},"next":{"title":"Additional Resources","permalink":"/zio-quill/additional-resources"}}');var r=o(74848),c=o(28453);const l={id:"compiler-performance",title:"Compiler performance"},t=void 0,d={},s=[{value:"Use <code>-Yprofile-trace</code> scalac options.",id:"use--yprofile-trace-scalac-options",level:2},{value:"Split large module into multiple submodules",id:"split-large-module-into-multiple-submodules",level:2},{value:"Define decoder/encoder directly instead of <code>MappedEncoding</code>",id:"define-decoderencoder-directly-instead-of-mappedencoding",level:2},{value:"Share <code>QueryMeta</code> instance",id:"share-querymeta-instance",level:2}];function a(e){const i={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,c.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(i.p,{children:["Quill will probably make the slow scala compiler even slower, since a lot of additional ",(0,r.jsx)(i.code,{children:"Parsing"}),", ",(0,r.jsx)(i.code,{children:"Typechecking"}),", ",(0,r.jsx)(i.code,{children:"Implicit resolution"})," works introduced to expand a Query."]}),"\n",(0,r.jsx)(i.p,{children:"Following tips may help improving compilation time."}),"\n",(0,r.jsxs)(i.h2,{id:"use--yprofile-trace-scalac-options",children:["Use ",(0,r.jsx)(i.code,{children:"-Yprofile-trace"})," scalac options."]}),"\n",(0,r.jsxs)(i.p,{children:["With ",(0,r.jsx)(i.code,{children:"-Yprofile-trace"})," option, a chrome trace file will be produced after compilation.\nIt will help figure out what slowing down the compiler."]}),"\n",(0,r.jsx)(i.p,{children:"Note, this option need some tweak if you are running on java 9 or newer version."}),"\n",(0,r.jsx)(i.h2,{id:"split-large-module-into-multiple-submodules",children:"Split large module into multiple submodules"}),"\n",(0,r.jsx)(i.p,{children:"Since scalac is not fully parallelized, split into independent submodules can significantly reduce build time on multi-core cpu."}),"\n",(0,r.jsxs)(i.h2,{id:"define-decoderencoder-directly-instead-of-mappedencoding",children:["Define decoder/encoder directly instead of ",(0,r.jsx)(i.code,{children:"MappedEncoding"})]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.code,{children:"MappedEncoding"})," introduce more implicit resolutions, which may slow down compiler."]}),"\n",(0,r.jsx)(i.p,{children:"It is possible to define instance directly."}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-scala",children:"case class FooId(id: Long)\nimplicit val fooIdEncoder: Encoder[FooId] = mappedEncoder(MappedEncoding[FooId, Long](_.id), longEncoder)\nimplicit val fooIdDecoder: Decoder[FooId] = mappedDecoder(MappedEncoding[Long, FooId](FooId(_)), longDecoder)\n"})}),"\n",(0,r.jsxs)(i.h2,{id:"share-querymeta-instance",children:["Share ",(0,r.jsx)(i.code,{children:"QueryMeta"})," instance"]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.code,{children:"QueryMeta"})," generation requires ",(0,r.jsx)(i.code,{children:"Decoder"})," resolution, tree generation, typechecking, etc which can be very slow."]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.code,{children:"QueryMeta"})," is not shared by default, so define shared ",(0,r.jsx)(i.code,{children:"QueryMeta"})," instance may reduce build time."]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-scala",children:"val ctx = SqlMirrorContext(MirrorIdiom, Literal)\n\n// Prevent using default macro generated query meta instance.\n// Use `_` instead of `*` if `-Xsource:3` not enabled.\nimport ctx.{ materializeQueryMeta => *, * }\n\n // Instance type must not be specified here, otherwise it will become dynamic query.\nimplicit val orderQueryMeta = ctx.materializeQueryMeta[Order]\n\nctx.run {\n  query[Order]\n}\n"})}),"\n",(0,r.jsxs)(i.p,{children:["Note, to use ",(0,r.jsx)(i.a,{href:"https://github.com/scala/scala/pull/10439",children:(0,r.jsx)(i.code,{children:"-Xsource:3"})})," scalac options, ",(0,r.jsx)(i.code,{children:"-Xmigration"})," or ",(0,r.jsx)(i.code,{children:"-Wconf:cat=scala3-migration:w"})," is required."]}),"\n",(0,r.jsx)(i.p,{children:"Otherwise, it will not compile due to lack of explicit type of implicit definition."})]})}function p(e={}){const{wrapper:i}={...(0,c.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}}}]);