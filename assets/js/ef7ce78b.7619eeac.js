"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[43150],{58754:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"zio-prelude/functional-abstractions/concrete-types/identity","title":"Identity","description":"Identity[A] describes a data type with an associative combining operation that also has an identity element.","source":"@site/docs/zio-prelude/functional-abstractions/concrete-types/identity.md","sourceDirName":"zio-prelude/functional-abstractions/concrete-types","slug":"/zio-prelude/functional-abstractions/concrete-types/identity","permalink":"/zio-prelude/functional-abstractions/concrete-types/identity","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-prelude/functional-abstractions/concrete-types/identity.md","tags":[],"version":"current","frontMatter":{"id":"identity","title":"Identity"},"sidebar":"ecosystem-sidebar","previous":{"title":"Hash","permalink":"/zio-prelude/functional-abstractions/concrete-types/hash"},"next":{"title":"Inverse","permalink":"/zio-prelude/functional-abstractions/concrete-types/inverse"}}');var o=n(74848),a=n(28453);const s={id:"identity",title:"Identity"},c=void 0,r={},d=[];function l(e){const t={code:"code",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"Identity[A]"})," describes a data type with an associative combining operation that also has an identity element."]}),"\n",(0,o.jsx)(t.p,{children:"Its signature is:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:"trait Associative[A] {\n  def combine(left: => A, right: => A): A\n}\n\ntrait Identity[A] extends Associative[A] {\n  def identity: A\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["The identity element is a neutral value that does not have any structure itself and so combining it with any other value just leaves the structure of the other value unchanged. For instance, an empty ",(0,o.jsx)(t.code,{children:"Chunk"})," is an identity element with respect to the ",(0,o.jsx)(t.code,{children:"++"})," operator."]}),"\n",(0,o.jsxs)(t.p,{children:["It is important to note here that while ",(0,o.jsx)(t.code,{children:"Identity"})," describes a data type with an identity element, that identity element only has meaning in relation to the binary operator. Specifically, combining any value of type ",(0,o.jsx)(t.code,{children:"A"})," with the identity element with the ",(0,o.jsx)(t.code,{children:"combine"})," operator must return the value unchanged."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:"a <> identity === a\nidentity <> a === a\n"})}),"\n",(0,o.jsxs)(t.p,{children:["For example, zero is an identity element with respect to addition, but not with respect to multiplication. Similarly, ",(0,o.jsx)(t.code,{children:"true"})," is an identity element with respect to logical conjunction, but ",(0,o.jsx)(t.code,{children:"false"})," is an identity element with respect to logical disjunction."]}),"\n",(0,o.jsx)(t.p,{children:"Many associative combinining operations also have an identity element, but some do not."}),"\n",(0,o.jsx)(t.p,{children:"For example the minimum or maximum of two values on which a total ordering is defined does not have an identity element. Neither does the first or last of two values or the concatenation of collections that cannot be empty."}),"\n",(0,o.jsxs)(t.p,{children:["If we import ",(0,o.jsx)(t.code,{children:"zio.prelude._"})," we can use the same ",(0,o.jsx)(t.code,{children:"<>"})," operator as we did to combine two values for which an ",(0,o.jsx)(t.code,{children:"Associative"})," instance was defined."]}),"\n",(0,o.jsxs)(t.p,{children:["Since the ",(0,o.jsx)(t.code,{children:"identity"})," value is a single value and not an operator we access it slightly different. Typically we will use the ",(0,o.jsx)(t.code,{children:"apply"})," method on the ",(0,o.jsx)(t.code,{children:"Identity"})," companion object."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:"import zio.prelude._\nimport zio.prelude.newtypes._\n\nval zero: Int =\n  Identity[Sum[Int]].identity\n// zero: Int = 0\n"})}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"apply"})," operator on the ",(0,o.jsx)(t.code,{children:"Identity"}),' companion object "looks up" the instance of the type class for the specified type, failing with a compilation error if the instance cannot be found. This operator is available on every functional abstraction in ZIO Prelude and is sometimes referred to as its "summoner".']}),"\n",(0,o.jsxs)(t.p,{children:["Notice also here that we are using the ",(0,o.jsx)(t.code,{children:"Sum"})," new type to specify that we are interested in the identity element with respect to addition rather than another operator such as multiplication. See the section on new types in the documentation for the ",(0,o.jsx)(t.code,{children:"Associative"})," abstraction for a discussion of the use of new types to disambiguate type class instances."]}),"\n",(0,o.jsx)(t.p,{children:"The main value the identity element adds over just having the associative combining operation is the ability to handle cases where we do not have any value of the type at all."}),"\n",(0,o.jsxs)(t.p,{children:["With the ",(0,o.jsx)(t.code,{children:"Associative"})," abstraction we know how to combine any two values of type ",(0,o.jsx)(t.code,{children:"A"}),". So if we have one or more values of type ",(0,o.jsx)(t.code,{children:"A"})," we can always combine them all together by repeatedly applying the ",(0,o.jsx)(t.code,{children:"combine"})," operator."]}),"\n",(0,o.jsxs)(t.p,{children:["However, we need at least one ",(0,o.jsx)(t.code,{children:"A"})," value to get the process started. If we don't have any ",(0,o.jsx)(t.code,{children:"A"})," value initially we have no way to create one with the ",(0,o.jsx)(t.code,{children:"Associative"})," abstraction alone."]}),"\n",(0,o.jsx)(t.p,{children:"To see this, consider the example of computing the minimum value in a collection."}),"\n",(0,o.jsxs)(t.p,{children:["If the collection has exactly one element we can just return it. And if it has more than one element we can combine them using the ",(0,o.jsx)(t.code,{children:"min"})," operator until we only have a single value."]}),"\n",(0,o.jsxs)(t.p,{children:["But what do we do if the collection has no values? We can't do anything so we return an ",(0,o.jsx)(t.code,{children:"Option"})," that is a ",(0,o.jsx)(t.code,{children:"Some"})," with the minimum if there is at least one element and ",(0,o.jsx)(t.code,{children:"None"})," otherwise."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:"import zio.prelude._\nimport zio.prelude.newtypes._\n\ndef min[A: Ord](as: List[A]): Option[A] =\n  Max.wrapAll(as) match {\n    case h :: t => Some(t.foldLeft(h)(_ <> _))\n    case Nil    => None\n  }\n"})}),"\n",(0,o.jsx)(t.p,{children:"Compare this to computing the sum of a collection. Now If the collection is empty we can just return the identity value."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:"def sum[A](as: List[A])(implicit identity: Identity[Sum[A]]): A =\n  Sum.wrapAll(as).foldLeft(identity.identity)(identity.combine(_, _))\n"})}),"\n",(0,o.jsx)(t.p,{children:"The identity element handles the case where the collection is empty for us, allowing us to always return a summary value."}),"\n",(0,o.jsxs)(t.p,{children:["If we don't have an identity value we can only guarantee that we can return a summary value if the collection is known not to be empty, such as a ",(0,o.jsx)(t.code,{children:"NonEmptyChunk"})," or a ",(0,o.jsx)(t.code,{children:"NonEmptyList"}),". This is why these data types can be valuable."]}),"\n",(0,o.jsxs)(t.p,{children:["If the collection could be empty and we only have a ",(0,o.jsx)(t.code,{children:"combine"})," operator we may not be able to return a summary value and the best we can do is an ",(0,o.jsx)(t.code,{children:"Option"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["One way to think of this is that the ",(0,o.jsx)(t.code,{children:"None"})," case of the ",(0,o.jsx)(t.code,{children:"Option"})," handles the possibility of failure. Another is that the ",(0,o.jsx)(t.code,{children:"None"})," case of the ",(0,o.jsx)(t.code,{children:"Option"})," provides the identity element for the ",(0,o.jsx)(t.code,{children:"combine"})," operator, which we can express like this:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:"implicit def OptionIdentity[A: Associative]: Identity[Option[A]] =\n  new Identity[Option[A]] {\n    def combine(left: => Option[A], right: => Option[A]): Option[A] =\n      (left, right) match {\n        case (Some(a1), Some(a2)) => Some(a1 <> a2)\n        case (_, None)            => left\n        case (None, _)            => right\n        case (_, _)               => None\n      }\n    def identity: Option[A] = None\n  }\n"})}),"\n",(0,o.jsxs)(t.p,{children:["This says that we can define an ",(0,o.jsx)(t.code,{children:"Identity"})," instance for any ",(0,o.jsx)(t.code,{children:"Option[A]"})," as long as there is an ",(0,o.jsx)(t.code,{children:"Associative"})," instance defined for ",(0,o.jsx)(t.code,{children:"A"}),". The ",(0,o.jsx)(t.code,{children:"Option"}),' provides the "free" structure of an identity element to go from just having an associative ',(0,o.jsx)(t.code,{children:"combine"})," operator to having an ",(0,o.jsx)(t.code,{children:"identity"})," element."]}),"\n",(0,o.jsxs)(t.p,{children:["This can be useful to keep in mind if you are dealing with a collection that could be empty and need an ",(0,o.jsx)(t.code,{children:"Identity"})," instance but only have an ",(0,o.jsx)(t.code,{children:"Associative"})," instance. You can always map your collection type to an ",(0,o.jsx)(t.code,{children:"Option"})," and then you will have an ",(0,o.jsx)(t.code,{children:"Identity"})," instance."]}),"\n",(0,o.jsxs)(t.p,{children:["Data types with an associative ",(0,o.jsx)(t.code,{children:"combine"})," operator and an ",(0,o.jsx)(t.code,{children:"identity"})," element are very common. With an ",(0,o.jsx)(t.code,{children:"Identity"})," instance defined for them and the other tools in ZIO Prelude you are in a good position to handle working with even complex data types."]})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>c});var i=n(96540);const o={},a=i.createContext(o);function s(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);