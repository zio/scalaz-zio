"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[57282],{44201:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"overview/overview_basic_operations","title":"Basic Operations","description":"Mapping","source":"@site/versioned_docs/version-1.0.18/overview/basic_operations.md","sourceDirName":"overview","slug":"/overview/overview_basic_operations","permalink":"/1.0.18/overview/overview_basic_operations","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/versioned_docs/version-1.0.18/overview/basic_operations.md","tags":[],"version":"1.0.18","frontMatter":{"id":"overview_basic_operations","title":"Basic Operations"},"sidebar":"overview_sidebar","previous":{"title":"Creating Effects","permalink":"/1.0.18/overview/overview_creating_effects"},"next":{"title":"Handling Errors","permalink":"/1.0.18/overview/overview_handling_errors"}}');var t=i(74848),r=i(28453);const o={id:"overview_basic_operations",title:"Basic Operations"},c=void 0,a={},l=[{value:"Mapping",id:"mapping",level:2},{value:"Chaining",id:"chaining",level:2},{value:"For Comprehensions",id:"for-comprehensions",level:2},{value:"Zipping",id:"zipping",level:2},{value:"Next Step",id:"next-step",level:2}];function h(e){const n={a:"a",code:"code",em:"em",h2:"h2",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"mapping",children:"Mapping"}),"\n",(0,t.jsxs)(n.p,{children:["You can map over the success channel of an effect by calling the ",(0,t.jsx)(n.code,{children:"ZIO#map"})," method. This lets you transform the success values of effects."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nval succeeded: UIO[Int] = IO.succeed(21).map(_ * 2)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["You can map over the error channel of an effect by calling the ",(0,t.jsx)(n.code,{children:"ZIO#mapError"})," method. This lets you transform the failure values of effects."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'val failed: IO[Exception, Unit] = \n  IO.fail("No no!").mapError(msg => new Exception(msg))\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Note that mapping over an effect's success or error channel does not change the success or failure of the effect, in the same way that mapping over an ",(0,t.jsx)(n.code,{children:"Either"})," does not change whether the ",(0,t.jsx)(n.code,{children:"Either"})," is ",(0,t.jsx)(n.code,{children:"Left"})," or ",(0,t.jsx)(n.code,{children:"Right"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"chaining",children:"Chaining"}),"\n",(0,t.jsxs)(n.p,{children:["You can execute two effects in sequence with the ",(0,t.jsx)(n.code,{children:"flatMap"})," method, which requires that you pass a callback, which will receive the value of the first effect, and can return a second effect that depends on this value:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'val sequenced = \n  getStrLn.flatMap(input => putStrLn(s"You entered: $input"))\n'})}),"\n",(0,t.jsxs)(n.p,{children:["If the first effect fails, the callback passed to ",(0,t.jsx)(n.code,{children:"flatMap"})," will never be invoked, and the composed effect returned by ",(0,t.jsx)(n.code,{children:"flatMap"})," will also fail."]}),"\n",(0,t.jsxs)(n.p,{children:["In ",(0,t.jsx)(n.em,{children:"any"})," chain of effects, the first failure will short-circuit the whole chain, just like throwing an exception will prematurely exit a sequence of statements."]}),"\n",(0,t.jsx)(n.h2,{id:"for-comprehensions",children:"For Comprehensions"}),"\n",(0,t.jsxs)(n.p,{children:["Because the ",(0,t.jsx)(n.code,{children:"ZIO"})," data type supports both ",(0,t.jsx)(n.code,{children:"flatMap"})," and ",(0,t.jsx)(n.code,{children:"map"}),", you can use Scala's ",(0,t.jsx)(n.em,{children:"for comprehensions"})," to build sequential effects:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'val program = \n  for {\n    _    <- putStrLn("Hello! What is your name?")\n    name <- getStrLn\n    _    <- putStrLn(s"Hello, ${name}, welcome to ZIO!")\n  } yield ()\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"For comprehensions"})," provide a more procedural syntax for composing chains of effects."]}),"\n",(0,t.jsx)(n.h2,{id:"zipping",children:"Zipping"}),"\n",(0,t.jsxs)(n.p,{children:["You can combine two effects into a single effect with the ",(0,t.jsx)(n.code,{children:"ZIO#zip"})," method. The resulting effect succeeds with a tuple that contains the success values of both effects:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'val zipped: UIO[(String, Int)] = \n  ZIO.succeed("4").zip(ZIO.succeed(2))\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Note that ",(0,t.jsx)(n.code,{children:"zip"})," operates sequentially: the effect on the left side is executed before the effect on the right side."]}),"\n",(0,t.jsxs)(n.p,{children:["In any ",(0,t.jsx)(n.code,{children:"zip"})," operation, if either the left or right hand sides fail, then the composed effect will fail, because ",(0,t.jsx)(n.em,{children:"both"})," values are required to construct the tuple."]}),"\n",(0,t.jsxs)(n.p,{children:["Sometimes, when the success value of an effect is not useful (for example, it is ",(0,t.jsx)(n.code,{children:"Unit"}),"), it can be more convenient to use the ",(0,t.jsx)(n.code,{children:"ZIO#zipLeft"})," or ",(0,t.jsx)(n.code,{children:"ZIO#zipRight"})," functions, which first perform a ",(0,t.jsx)(n.code,{children:"zip"}),", and then map over the tuple to discard one side or the other:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'val zipRight1 = \n  putStrLn("What is your name?").zipRight(getStrLn)\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"zipRight"})," and ",(0,t.jsx)(n.code,{children:"zipLeft"})," functions have symbolic aliases, known as ",(0,t.jsx)(n.code,{children:"*>"})," and ",(0,t.jsx)(n.code,{children:"<*"}),", respectively. Some developers find these operators easier to read:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'val zipRight2 = \n  putStrLn("What is your name?") *>\n  getStrLn\n'})}),"\n",(0,t.jsx)(n.h2,{id:"next-step",children:"Next Step"}),"\n",(0,t.jsxs)(n.p,{children:["If you are comfortable with the basic operations on ZIO effects, then the next step is to learn about ",(0,t.jsx)(n.a,{href:"/1.0.18/overview/overview_handling_errors",children:"error handling"}),"."]})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>c});var s=i(96540);const t={},r=s.createContext(t);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);