"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[35119],{28453:(e,t,s)=>{s.d(t,{R:()=>o,x:()=>i});var n=s(96540);const r={},a=n.createContext(r);function o(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),n.createElement(a.Provider,{value:t},e.children)}},71663:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"reference/test/index","title":"Introduction to ZIO Test","description":"ZIO Test is a zero dependency testing library that makes it easy to test effectual programs. In ZIO Test, all tests are immutable values and tests are tightly integrated with ZIO, so testing effectual programs is as natural as testing pure ones.","source":"@site/docs/reference/test/index.md","sourceDirName":"reference/test","slug":"/reference/test/","permalink":"/reference/test/","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/test/index.md","tags":[],"version":"current","frontMatter":{"id":"index","title":"Introduction to ZIO Test"},"sidebar":"reference-sidebar","previous":{"title":"Configuration","permalink":"/reference/configuration/"},"next":{"title":"Why ZIO Test?","permalink":"/reference/test/why-zio-test"}}');var r=s(74848),a=s(28453);const o={id:"index",title:"Introduction to ZIO Test"},i=void 0,c={},l=[{value:"Motivation",id:"motivation",level:2},{value:"How ZIO Test was designed",id:"how-zio-test-was-designed",level:2}];function d(e){const t={code:"code",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"ZIO Test"})," is a zero dependency testing library that makes it easy to test effectual programs. In ",(0,r.jsx)(t.strong,{children:"ZIO Test"}),", all tests are immutable values and tests are tightly integrated with ZIO, so testing effectual programs is as natural as testing pure ones."]}),"\n",(0,r.jsx)(t.h2,{id:"motivation",children:"Motivation"}),"\n",(0,r.jsx)(t.p,{children:"We can easily assert ordinary values and data types to test them:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-scala",children:'import scala.Predef.assert\n\nassert(1 + 2 == 2 + 1)\nassert("Hi" == "H" + "i")\n\ncase class Point(x: Long, y: Long)\nassert(Point(5L, 10L) == Point.apply(5L, 10L))\n'})}),"\n",(0,r.jsxs)(t.p,{children:["What about functional effects? Can we assert two effects using ordinary scala assertion to test whether they have the same functionality? As we know, a functional effect, like ",(0,r.jsx)(t.code,{children:"ZIO"}),", describes a series of computations. Unfortunately, we can't assert functional effects without executing them. If we assert two ",(0,r.jsx)(t.code,{children:"ZIO"})," effects, e.g. ",(0,r.jsx)(t.code,{children:"assert(expectedEffect == actualEffect)"}),", the result says nothing about whether these two effects behave similarly and produce the same result or not. Instead, we should ",(0,r.jsx)(t.code,{children:"unsafeRun"})," each one and assert their results."]}),"\n",(0,r.jsxs)(t.p,{children:["Let's say we have a random generator effect, and we want to ensure that the output is bigger than zero, so we should ",(0,r.jsx)(t.code,{children:"unsafeRun"})," the effect and assert the result:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-scala",children:"import scala.Predef.assert\n\nval random = Unsafe.unsafe { implicit unsafe =>\n  Runtime.default.unsafe.run(\n    Random.nextIntBounded(10)\n  ).getOrThrowFiberFailure()\n}\n\nassert(random >= 0)\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Testing effectful programs is difficult since we should use many ",(0,r.jsx)(t.code,{children:"unsafeRun"})," methods. Also, we might need to make sure that the test is non-flaky. In these cases, running ",(0,r.jsx)(t.code,{children:"unsafeRun"})," multiple times is not straightforward. We need a testing framework that treats effects as ",(0,r.jsx)(t.em,{children:"first-class values"}),". So this is the primary motivation for creating the ZIO Test library."]}),"\n",(0,r.jsx)(t.h2,{id:"how-zio-test-was-designed",children:"How ZIO Test was designed"}),"\n",(0,r.jsxs)(t.p,{children:["We designed ZIO Test around the idea of ",(0,r.jsx)(t.em,{children:"making tests first-class objects"}),". This means that tests (and other concepts, like assertions) become ordinary values that can be passed around, transformed, and composed."]}),"\n",(0,r.jsx)(t.p,{children:"This approach allows for greater flexibility compared to some other testing frameworks, where tests and additional logic around tests had to be put into callbacks so that framework could make use of them."}),"\n",(0,r.jsxs)(t.p,{children:["As a result, this approach is also better suited to other ",(0,r.jsx)(t.code,{children:"ZIO"})," concepts like ",(0,r.jsx)(t.code,{children:"Scope"}),", which can only be used within a scoped block of code. This also created a mismatch between ",(0,r.jsx)(t.code,{children:"BeforeAll"}),", ",(0,r.jsx)(t.code,{children:"AfterAll"})," callback-like methods when there were resources that should be opened and closed during test suite execution."]}),"\n",(0,r.jsx)(t.p,{children:"Another thing worth pointing out is that tests being values are also effects. Implications of this design are far-reaching:"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:['First, the well-known problem of testing asynchronous value is gone. Whereas in other frameworks we have to somehow "run" our effects and at best wrap them in ',(0,r.jsx)(t.code,{children:"scala.util.Future"})," because blocking would eliminate running on ScalaJS, ZIO Test expects us to create ",(0,r.jsx)(t.code,{children:"ZIO"})," objects. There is no need for indirect transformations from one wrapping object to another."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:["Second, because our tests are ordinary ",(0,r.jsx)(t.code,{children:"ZIO"})," values, we don't need to turn to a testing framework for things like retries, timeouts, and resource management. We can solve all those problems with the full richness of functions that ",(0,r.jsx)(t.code,{children:"ZIO"})," exposes."]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);