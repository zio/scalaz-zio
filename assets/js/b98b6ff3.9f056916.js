"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[73571],{88522:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>c,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"reference/services/blocking","title":"Blocking","description":"Introduction","source":"@site/versioned_docs/version-1.0.18/reference/services/blocking.md","sourceDirName":"reference/services","slug":"/reference/services/blocking","permalink":"/1.0.18/reference/services/blocking","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/versioned_docs/version-1.0.18/reference/services/blocking.md","tags":[],"version":"1.0.18","frontMatter":{"id":"blocking","title":"Blocking"},"sidebar":"overview_sidebar","previous":{"title":"Random","permalink":"/1.0.18/reference/services/random"},"next":{"title":"System","permalink":"/1.0.18/reference/services/system"}}');var r=o(74848),i=o(28453);const c={id:"blocking",title:"Blocking"},s=void 0,l={},a=[{value:"Introduction",id:"introduction",level:2},{value:"Creating Blocking Effects",id:"creating-blocking-effects",level:2},{value:"Interruption of Blocking Operations",id:"interruption-of-blocking-operations",level:2},{value:"Cancellation of Blocking Operation",id:"cancellation-of-blocking-operation",level:2}];function d(e){const n={code:"code",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"Blocking"})," service provides access to a thread pool that can be used for performing\nblocking operations, such as thread sleeps, synchronous socket/file reads, and so forth."]}),"\n",(0,r.jsxs)(n.p,{children:["By default, ZIO is asynchronous and all effects will be executed on a default primary thread pool which is optimized for asynchronous operations. As ZIO uses a fiber-based concurrency model, if we run ",(0,r.jsx)(n.strong,{children:"Blocking I/O"})," or ",(0,r.jsx)(n.strong,{children:"CPU Work"})," workloads on a primary thread pool, they are going to monopolize all threads of ",(0,r.jsx)(n.strong,{children:"primary thread pool"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"In the following example, we create 20 blocking tasks to run parallel on the primary async thread pool. Assume we have a machine with an 8 CPU core, so the ZIO creates a thread pool of size 16 (2 * 8). If we run this program, all of our threads got stuck, and the remaining 4 blocking tasks (20 - 16) haven't any chance to run on our thread pool:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio.{ZIO, URIO}\nimport zio.console._ \ndef blockingTask(n: Int): URIO[Console, Unit] =\n  putStrLn(s"running blocking task number $n").orDie *>\n    ZIO.effectTotal(Thread.sleep(3000)) *>\n    blockingTask(n)\n\nval program = ZIO.foreachPar((1 to 100).toArray)(blockingTask)\n'})}),"\n",(0,r.jsx)(n.h2,{id:"creating-blocking-effects",children:"Creating Blocking Effects"}),"\n",(0,r.jsxs)(n.p,{children:["ZIO has a separate ",(0,r.jsx)(n.strong,{children:"blocking thread pool"})," specially designed for ",(0,r.jsx)(n.strong,{children:"Blocking I/O"})," and, also ",(0,r.jsx)(n.strong,{children:"CPU Work"})," workloads. We should run blocking workloads on this thread pool to prevent interfering with the primary thread pool."]}),"\n",(0,r.jsx)(n.p,{children:"The contract is that the thread pool will accept unlimited tasks (up to the available memory)\nand continuously create new threads as necessary."}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"blocking"})," operator takes a ZIO effect and return another effect that is going to run on a blocking thread pool:"]}),"\n",(0,r.jsxs)(n.p,{children:["Also, we can directly import a synchronous effect that does blocking operation into ZIO effect by using ",(0,r.jsx)(n.code,{children:"effectBlocking"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio.blocking._\ndef blockingTask(n: Int) = effectBlocking {\n  do {\n    println(s"Running blocking task number $n on dedicated blocking thread pool")\n    Thread.sleep(3000) \n  } while (true)\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"interruption-of-blocking-operations",children:"Interruption of Blocking Operations"}),"\n",(0,r.jsxs)(n.p,{children:["By default, when we convert a blocking operation into the ZIO effects using ",(0,r.jsx)(n.code,{children:"effectBlocking"}),", there is no guarantee that if that effect is interrupted the underlying effect will be interrupted."]}),"\n",(0,r.jsx)(n.p,{children:"Let's create a blocking effect from an endless loop:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'for {\n  _ <- putStrLn("Starting a blocking operation")\n  fiber <- effectBlocking {\n    while (true) {\n      Thread.sleep(1000)\n      println("Doing some blocking operation")\n    }\n  }.ensuring(\n    putStrLn("End of a blocking operation").orDie\n  ).fork\n  _ <- fiber.interrupt.schedule(\n    Schedule.delayed(\n      Schedule.duration(1.seconds)\n    )\n  )\n} yield ()\n'})}),"\n",(0,r.jsxs)(n.p,{children:["When we interrupt this loop after one second, it will not interrupted. It will only stop when the entire JVM stops. So the ",(0,r.jsx)(n.code,{children:"effectBlocking"})," doesn't translate the ZIO interruption into thread interruption (",(0,r.jsx)(n.code,{children:"Thread.interrupt"}),")."]}),"\n",(0,r.jsxs)(n.p,{children:["Instead, we should use ",(0,r.jsx)(n.code,{children:"effectBlockingInterrupt"})," to create interruptible blocking effects:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'for {\n  _ <- putStrLn("Starting a blocking operation")\n  fiber <- effectBlockingInterrupt {\n    while(true) {\n      Thread.sleep(1000)\n      println("Doing some blocking operation")\n    }\n  }.ensuring(\n     putStrLn("End of the blocking operation").orDie\n   ).fork\n  _ <- fiber.interrupt.schedule(\n    Schedule.delayed(\n      Schedule.duration(3.seconds)\n    )\n  )\n} yield ()\n'})}),"\n",(0,r.jsx)(n.p,{children:"Notes:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["If we are converting a blocking I/O to the ZIO effect, it would be better to use ",(0,r.jsx)(n.code,{children:"effectBlockingIO"})," which refines the error type to the ",(0,r.jsx)(n.code,{children:"java.io.IOException"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"effectBlockingInterrupt"})," method adds significant overhead. So for performance-sensitive applications, it is better to handle interruptions manually using ",(0,r.jsx)(n.code,{children:"effectBlockingCancel"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"cancellation-of-blocking-operation",children:"Cancellation of Blocking Operation"}),"\n",(0,r.jsxs)(n.p,{children:["Some blocking operations do not respect ",(0,r.jsx)(n.code,{children:"Thread#interrupt"})," by swallowing ",(0,r.jsx)(n.code,{children:"InterruptedException"}),". So, they will not be interrupted via ",(0,r.jsx)(n.code,{children:"effectBlockingInterrupt"}),". Instead, they may provide us an API to signal them to ",(0,r.jsx)(n.em,{children:"cancel"})," their operation."]}),"\n",(0,r.jsxs)(n.p,{children:["The following ",(0,r.jsx)(n.code,{children:"BlockingService"})," will not be interrupted in case of ",(0,r.jsx)(n.code,{children:"Thread#interrupt"})," call, but it checks the ",(0,r.jsx)(n.code,{children:"released"})," flag constantly. If this flag becomes true, the blocking service will finish its job:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import java.util.concurrent.atomic.AtomicReference\nfinal case class BlockingService() {\n  private val released = new AtomicReference(false)\n\n  def start(): Unit = {\n    while (!released.get()) {\n      println("Doing some blocking operation")\n      try Thread.sleep(1000)\n      catch {\n        case _: InterruptedException => () // Swallowing InterruptedException\n      }\n    }\n    println("Blocking operation closed.")\n  }\n\n  def close(): Unit = {\n    println("Releasing resources and ready to be closed.")\n    released.getAndSet(true)\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["So, to translate ZIO interruption into cancellation of these types of blocking operations we should use ",(0,r.jsx)(n.code,{children:"effectBlockingCancelation"}),". This method takes a ",(0,r.jsx)(n.code,{children:"cancel"})," effect which responsible to signal the blocking code to close itself when ZIO interruption occurs:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"val myApp =\n  for {\n    service <- ZIO.effect(BlockingService())\n    fiber   <- effectBlockingCancelable(\n      effect = service.start()\n    )(\n      cancel = UIO.effectTotal(service.close())\n    ).fork\n    _       <- fiber.interrupt.schedule(\n      Schedule.delayed(\n        Schedule.duration(3.seconds)\n      )\n    )\n  } yield ()\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Here is another example of the cancelation of a blocking operation. When we ",(0,r.jsx)(n.code,{children:"accept"})," a server socket, this blocking operation will never interrupted until we close that using ",(0,r.jsx)(n.code,{children:"ServerSocket#close"})," method:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"import java.net.{Socket, ServerSocket}\ndef accept(ss: ServerSocket): RIO[Blocking, Socket] =\n  effectBlockingCancelable(ss.accept())(UIO.effectTotal(ss.close()))\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,n,o)=>{o.d(n,{R:()=>c,x:()=>s});var t=o(96540);const r={},i=t.createContext(r);function c(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);