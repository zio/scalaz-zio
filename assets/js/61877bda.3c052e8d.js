"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[93281],{28453:(e,t,i)=>{i.d(t,{R:()=>a,x:()=>o});var n=i(96540);const r={},s=n.createContext(r);function a(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),n.createElement(s.Provider,{value:t},e.children)}},69027:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"reference/observability/metrics/histogram","title":"Histogram","description":"A Histogram is a metric representing a collection of numerical with the distribution of the cumulative values over time. They organize a range of measurements into distinct intervals, known as buckets, and record the frequency of measurements falling within each bucket.","source":"@site/docs/reference/observability/metrics/histogram.md","sourceDirName":"reference/observability/metrics","slug":"/reference/observability/metrics/histogram","permalink":"/reference/observability/metrics/histogram","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/observability/metrics/histogram.md","tags":[],"version":"current","frontMatter":{"id":"histogram","title":"Histogram"},"sidebar":"reference-sidebar","previous":{"title":"Gauge","permalink":"/reference/observability/metrics/gauge"},"next":{"title":"Summary","permalink":"/reference/observability/metrics/summary"}}');var r=i(74848),s=i(28453);const a={id:"histogram",title:"Histogram"},o=void 0,l={},c=[{value:"Internals",id:"internals",level:2},{value:"API",id:"api",level:2},{value:"Use Cases",id:"use-cases",level:2},{value:"Examples",id:"examples",level:2},{value:"Histogram With Linear Buckets",id:"histogram-with-linear-buckets",level:3},{value:"Timer Metric",id:"timer-metric",level:3}];function m(e){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:["A ",(0,r.jsx)(t.code,{children:"Histogram"})," is a metric representing a collection of numerical with the distribution of the cumulative values over time. They organize a range of measurements into distinct intervals, known as buckets, and record the frequency of measurements falling within each bucket."]}),"\n",(0,r.jsx)(t.p,{children:"Histograms allow representing not only the value of the quantity being measured but its distribution. They are representation of the distribution of a dataset, which organizes the data into buckets and display the frequency or count of data points within each bucket."}),"\n",(0,r.jsx)(t.h2,{id:"internals",children:"Internals"}),"\n",(0,r.jsx)(t.p,{children:"In a histogram, we assign the incoming samples to pre-defined buckets. So each data point increases the count for the bucket that it falls into, and then the individual samples are discarded. As histograms are bucketed, we can aggregate data across multiple instances. Histograms are a typical way to measure percentiles. We can look at bucket counts to estimate a specific percentile."}),"\n",(0,r.jsxs)(t.p,{children:["A histogram observes ",(0,r.jsx)(t.em,{children:"Double"})," values and counts the observed values in buckets. Each bucket is defined by an upper boundary, and the count for a bucket with the upper boundary ",(0,r.jsx)(t.code,{children:"b"})," increases by ",(0,r.jsx)(t.code,{children:"1"})," if an observed value ",(0,r.jsx)(t.code,{children:"v"})," is less or\nequal to ",(0,r.jsx)(t.code,{children:"b"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["As a consequence, all buckets that have a boundary ",(0,r.jsx)(t.code,{children:"b1"})," with ",(0,r.jsx)(t.code,{children:"b1 > b"})," will increase by ",(0,r.jsx)(t.code,{children:"1"})," after observing ",(0,r.jsx)(t.code,{children:"v"}),"."]}),"\n",(0,r.jsx)(t.p,{children:"A histogram also keeps track of the overall count of observed values, and the sum of all observed values."}),"\n",(0,r.jsxs)(t.p,{children:["By definition, the last bucket is always defined as ",(0,r.jsx)(t.code,{children:"Double.MaxValue"}),", so that the count of observed values in the last bucket is always equal to the overall count of observed values within the histogram."]}),"\n",(0,r.jsxs)(t.p,{children:["The mental model for histogram is inspired from ",(0,r.jsx)(t.a,{href:"https://prometheus.io/docs/concepts/metric_types/#histogram",children:"Prometheus"}),"."]}),"\n",(0,r.jsx)(t.h2,{id:"api",children:"API"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-scala",children:"object Metric {\n  def histogram(\n      name: String,\n      boundaries: Histogram.Boundaries\n    ): Histogram[Double] = ???\n  \n  def timer(\n      name: String,\n      description: String,\n      chronoUnit: ChronoUnit\n    ): Metric[MetricKeyType.Histogram, Duration, MetricState.Histogram] = ???\n  \n  def timer(\n      name: String,\n      chronoUnit: ChronoUnit,\n      boundaries: Chunk[Double]\n    ): Metric[MetricKeyType.Histogram, Duration, MetricState.Histogram] = ???\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"use-cases",children:"Use Cases"}),"\n",(0,r.jsxs)(t.p,{children:["Histograms are widely used in software metrics for various purposes. They are useful in analyzing the performance of software systems. They can represent metrics such as ",(0,r.jsx)(t.strong,{children:"response times"}),", ",(0,r.jsx)(t.strong,{children:"latencies"}),", or ",(0,r.jsx)(t.strong,{children:"throughput"}),". By visualizing the distribution of these metrics in a histogram, developers can identify ",(0,r.jsx)(t.strong,{children:"performance bottlenecks"}),", ",(0,r.jsx)(t.strong,{children:"outliers"}),", or ",(0,r.jsx)(t.strong,{children:"variations"}),". This information aids in optimizing code, infrastructure, and system configurations to improve overall performance."]}),"\n",(0,r.jsxs)(t.p,{children:["Histogram measures the frequency of value observations that fall into specific ",(0,r.jsx)(t.em,{children:"pre-defined buckets"}),". For example, we can measure the request duration of an HTTP request using histograms. Rather than storing every duration for every request, the histogram will make an approximation by storing the frequency of requests that fall into pre-defined particular buckets."]}),"\n",(0,r.jsx)(t.p,{children:"Thus, histograms are the best choice in these situations:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"When we want to observe many values and then later want to calculate the percentile of observed values"}),"\n",(0,r.jsx)(t.li,{children:"When we can estimate the range of values upfront, as the histogram put the observations into pre-defined buckets"}),"\n",(0,r.jsx)(t.li,{children:"When accuracy is not so important, and we don't want the exact values because of the lossy nature of bucketing data in histograms"}),"\n",(0,r.jsx)(t.li,{children:"When we need to aggregate histograms across multiple instances"}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"examples",children:"Examples"}),"\n",(0,r.jsx)(t.h3,{id:"histogram-with-linear-buckets",children:"Histogram With Linear Buckets"}),"\n",(0,r.jsxs)(t.p,{children:["Create a histogram with 12 buckets: ",(0,r.jsx)(t.code,{children:"0..100"})," in steps of ",(0,r.jsx)(t.code,{children:"10"})," and ",(0,r.jsx)(t.code,{children:"Double.MaxValue"}),". It can be applied to effects yielding a ",(0,r.jsx)(t.code,{children:"Double"}),":"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-scala",children:'import zio._\nimport zio.metrics._\n\nval histogram =\n  Metric.histogram("histogram", MetricKeyType.Histogram.Boundaries.linear(0, 10, 11))\n'})}),"\n",(0,r.jsxs)(t.p,{children:["Now we can apply the histogram to effects producing ",(0,r.jsx)(t.code,{children:"Double"}),":"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-scala",children:"import zio._\nimport zio.metrics._\n\nRandom.nextDoubleBetween(0.0d, 120.0d) @@ histogram\n"})}),"\n",(0,r.jsx)(t.h3,{id:"timer-metric",children:"Timer Metric"}),"\n",(0,r.jsx)(t.p,{children:"Here is an example of adding timer metric to track workflow durations:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-scala",children:'import zio._\nimport zio.metrics._\n\nimport java.time.temporal.ChronoUnit\n\nobject Example extends ZIOAppDefault {\n\n  def workflow = ZIO.succeed(42)\n\n  def randomDelay =\n    for {\n      i <- Random.nextLongBetween(1L, 10)\n      _ <- ZIO.sleep(Duration.fromMillis(i))\n    } yield ()\n    \n  val timer =\n    Metric.timer(\n      name = "timer",\n      chronoUnit = ChronoUnit.MILLIS,\n      boundaries = Chunk.iterate(1.0, 10)(_ + 1.0)\n    )\n\n  val run = ((workflow <* randomDelay) @@ timer.trackDuration).repeatN(99)\n}\n'})}),"\n",(0,r.jsx)(t.p,{children:"If we add prometheus layer, we expose the metrics which is something like this:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csv",children:'# TYPE timer histogram\n# HELP timer\ntimer_bucket{time_unit="millis",le="1.0",} 6.0 1686581577320\ntimer_bucket{time_unit="millis",le="2.0",} 16.0 1686581577320\ntimer_bucket{time_unit="millis",le="3.0",} 27.0 1686581577320\ntimer_bucket{time_unit="millis",le="4.0",} 41.0 1686581577320\ntimer_bucket{time_unit="millis",le="5.0",} 49.0 1686581577320\ntimer_bucket{time_unit="millis",le="6.0",} 60.0 1686581577320\ntimer_bucket{time_unit="millis",le="7.0",} 70.0 1686581577320\ntimer_bucket{time_unit="millis",le="8.0",} 85.0 1686581577320\ntimer_bucket{time_unit="millis",le="9.0",} 99.0 1686581577320\ntimer_bucket{time_unit="millis",le="10.0",} 99.0 1686581577320\ntimer_bucket{time_unit="millis",le="+Inf",} 100.0 1686581577320\n\ntimer_sum{time_unit="millis",} 603.0 1686581577320\ntimer_count{time_unit="millis",} 100.0 1686581577320\ntimer_min{time_unit="millis",} 1.0 1686581577320\ntimer_max{time_unit="millis",} 66.0 1686581577320\u23ce\n'})}),"\n",(0,r.jsx)(t.p,{children:'This Prometheus result represents a histogram metric called "timer" with a time unit of milliseconds. The histogram provides information about the distribution of workflow durations.'}),"\n",(0,r.jsx)(t.p,{children:'The histogram is divided into multiple buckets, each representing a range of workflow durations. The "le" label indicates the upper bound of each bucket. The values next to each bucket indicate the count or frequency of measurements falling within that bucket.'}),"\n",(0,r.jsxs)(t.p,{children:["For instance, ",(0,r.jsx)(t.code,{children:'"timer_bucket{time_unit="millis",le="5.0",} 49.0"'})," means there are 49 measurements with duration less than or equal to 5.0 millisecond."]})]})}function u(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(m,{...e})}):m(e)}}}]);