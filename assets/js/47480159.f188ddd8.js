"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[79571],{15024:(e,n,c)=>{c.r(n),c.d(n,{assets:()=>i,contentTitle:()=>a,default:()=>u,frontMatter:()=>s,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"zio-prelude/functional-abstractions/concrete-types/ord","title":"Ord","description":"Ord[A] describes a total ordering on values of type A.","source":"@site/docs/zio-prelude/functional-abstractions/concrete-types/ord.md","sourceDirName":"zio-prelude/functional-abstractions/concrete-types","slug":"/zio-prelude/functional-abstractions/concrete-types/ord","permalink":"/zio-prelude/functional-abstractions/concrete-types/ord","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-prelude/functional-abstractions/concrete-types/ord.md","tags":[],"version":"current","frontMatter":{"id":"ord","title":"Ord"},"sidebar":"ecosystem-sidebar","previous":{"title":"Inverse","permalink":"/zio-prelude/functional-abstractions/concrete-types/inverse"},"next":{"title":"Introduction","permalink":"/zio-prelude/functional-abstractions/parameterized-types/"}}');var o=c(74848),r=c(28453);const s={id:"ord",title:"Ord"},a=void 0,i={},d=[{value:"Defining Ord Instances",id:"defining-ord-instances",level:2}];function l(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"Ord[A]"})," describes a total ordering on values of type ",(0,o.jsx)(n.code,{children:"A"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"Its signature is:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"trait Equal[-A] {\n  def equal(left: A, right: A): Boolean\n}\n\ntrait Ord[-A] {\n  def compare(left: A, right: A): Ordering\n  final def equal(left: A, right: A): Boolean =\n    compare(left, right) == Ordering.Equals\n}\n\nsealed trait Ordering\nobject Ordering {\n  case object LessThan extends Ordering\n  case object GreaterThan extends Ordering\n  case object Equals extends Ordering\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["That is, we can compare any two values of type ",(0,o.jsx)(n.code,{children:"A"})," and either the ",(0,o.jsx)(n.code,{children:"left"})," value is less than the ",(0,o.jsx)(n.code,{children:"right"}),", the ",(0,o.jsx)(n.code,{children:"left"})," value is greater than the ",(0,o.jsx)(n.code,{children:"right"}),", or the two values are equal."]}),"\n",(0,o.jsxs)(n.p,{children:["Furthermore, the results of these comparisons must satisfy the properties that we expect of a total ordering. For example, if ",(0,o.jsx)(n.code,{children:"a"})," is greater than ",(0,o.jsx)(n.code,{children:"b"})," and ",(0,o.jsx)(n.code,{children:"b"})," is greater than ",(0,o.jsx)(n.code,{children:"c"})," then ",(0,o.jsx)(n.code,{children:"a"})," must be greater than ",(0,o.jsx)(n.code,{children:"c"})," and if ",(0,o.jsx)(n.code,{children:"a"})," is greater than ",(0,o.jsx)(n.code,{children:"b"})," then ",(0,o.jsx)(n.code,{children:"b"})," must be less than ",(0,o.jsx)(n.code,{children:"a"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"Ord"})," abstraction builds on the ",(0,o.jsx)(n.code,{children:"Equal"})," abstraction because being able to define a total ordering on values of a type implies being able to compare values of that type for equality, as shown by our implementation of the ",(0,o.jsx)(n.code,{children:"equal"})," operator in terms of ",(0,o.jsx)(n.code,{children:"compare"})," above. This means that if we define an instance of the ",(0,o.jsx)(n.code,{children:"Ord"})," abstraction for a data type we automatically get an instance of the ",(0,o.jsx)(n.code,{children:"Equal"})," abstraction for free and our definition of equality is guaranteed to be consistent with the ordering."]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"Ord"})," abstraction is similar to the ",(0,o.jsx)(n.code,{children:"Ordering"})," type class in the Scala standard library and in fact we can convert any ",(0,o.jsx)(n.code,{children:"scala.math.Ordering"})," to an ",(0,o.jsx)(n.code,{children:"Ord"})," using the ",(0,o.jsx)(n.code,{children:"fromScala"})," operator and any ",(0,o.jsx)(n.code,{children:"Ord"})," to a ",(0,o.jsx)(n.code,{children:"scala.math.Ordering"})," using the ",(0,o.jsx)(n.code,{children:"toScala"})," operator."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio.prelude.Ord\n\nval toScala: scala.math.Ordering[Int] =\n  Ord[Int].toScala\n// toScala: Ordering[Int] = zio.prelude.Ord$$anonfun$toScala$2@4c91d8d8\n\nval fromScala: Ord[Int] =\n  Ord.fromScala(scala.math.Ordering[Int])\n// fromScala: Ord[Int] = zio.prelude.Ord$$anonfun$fromScala$2@8c2263b\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The main advantages that the ",(0,o.jsx)(n.code,{children:"Ord"})," abstraction provides over the ",(0,o.jsx)(n.code,{children:"Ordering"})," in the Scala standard library is improved type inference due to use of variance and integration with the other functional abstractions in ZIO Prelude."]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"Ordering"})," type class in the Scala standard library is invariant, meaning that from the perspective of the Scala compiler an ",(0,o.jsx)(n.code,{children:"Ordering[A]"})," and an ",(0,o.jsx)(n.code,{children:"Ordering[B]"})," are completely unrelated, even if ",(0,o.jsx)(n.code,{children:"A"})," is a subtype of ",(0,o.jsx)(n.code,{children:"B"}),". If we look at the signature of the ",(0,o.jsx)(n.code,{children:"compare"})," operator on ",(0,o.jsx)(n.code,{children:"Ord"})," we can see that this does not reflect the natural variance of this type."]}),"\n",(0,o.jsxs)(n.p,{children:["An ",(0,o.jsx)(n.code,{children:"Ord[A]"})," is a consumer of ",(0,o.jsx)(n.code,{children:"A"})," values, it takes two ",(0,o.jsx)(n.code,{children:"A"})," values and returns a result describing whether one is less than, greater than, or equal to the other. If we know how to order values of type ",(0,o.jsx)(n.code,{children:"A"})," and ",(0,o.jsx)(n.code,{children:"B"})," is a subtype of ",(0,o.jsx)(n.code,{children:"A"})," then we also know how to order values of type ",(0,o.jsx)(n.code,{children:"B"}),", because every ",(0,o.jsx)(n.code,{children:"B"})," is an ",(0,o.jsx)(n.code,{children:"A"}),"!"]}),"\n",(0,o.jsxs)(n.p,{children:["The version of ",(0,o.jsx)(n.code,{children:"Ordering"}),' in the Scala compiler "forgets" this information because it does not use variance, which can lead to type inference problems.']}),"\n",(0,o.jsx)(n.p,{children:"To see this, consider a situation like the following. We have a domain model where customer accounts may be either business accounts or consumer accounts, each of which have a unique identifier."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"sealed trait CustomerAccount\n\ncase class BusinessAccount(id: String) extends CustomerAccount\ncase class ConsumerAccount(id: String) extends CustomerAccount\n"})}),"\n",(0,o.jsx)(n.p,{children:"We might define a total ordering for all accounts like this:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio.prelude._\n\nimplicit val CustomerAccountOrd: Ord[CustomerAccount] =\n  Ord.make {\n    case (BusinessAccount(id1), BusinessAccount(id2)) => id1 =?= id2\n    case (BusinessAccount(_), ConsumerAccount(_))     => Ordering.LessThan\n    case (ConsumerAccount(_), BusinessAccount(_))     => Ordering.GreaterThan\n    case (ConsumerAccount(id1), ConsumerAccount(id2)) => id1 =?= id2\n  }\n// CustomerAccountOrd: Ord[CustomerAccount] = zio.prelude.Ord$$anon$4@2336be79\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Basically this says that we are ordering all business accounts before all consumer accounts and then within each account type we are ordering by the identifier. Note that we are using the ",(0,o.jsx)(n.code,{children:"=?="})," operator which is available on any type for which an ",(0,o.jsx)(n.code,{children:"Ord"})," is defined to return the result of comparing two values of that type."]}),"\n",(0,o.jsx)(n.p,{children:"We can use this ordering to compare two customer accounts"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'val customerAccount1: CustomerAccount = BusinessAccount("abc")\n// customerAccount1: CustomerAccount = BusinessAccount(id = "abc")\nval customerAccount2: CustomerAccount = ConsumerAccount("def")\n// customerAccount2: CustomerAccount = ConsumerAccount(id = "def")\n\nval compareCustomerAccounts: Boolean =\n  customerAccount1 < customerAccount2\n// compareCustomerAccounts: Boolean = true\n'})}),"\n",(0,o.jsx)(n.p,{children:"We can also use it to compare two business accounts or two consumer accounts."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'val consumerAccount1: ConsumerAccount = ConsumerAccount("abc")\n// consumerAccount1: ConsumerAccount = ConsumerAccount(id = "abc")\nval consumerAccount2: ConsumerAccount = ConsumerAccount("def")\n// consumerAccount2: ConsumerAccount = ConsumerAccount(id = "def")\n\nval compareConsumerAccounts: Boolean =\n  consumerAccount1 < consumerAccount2\n// compareConsumerAccounts: Boolean = true\n'})}),"\n",(0,o.jsx)(n.p,{children:"This just works because a consumer account is a customer account and we know how to order customer accounts."}),"\n",(0,o.jsxs)(n.p,{children:["Let's see what happens when we try to do the same thing with the ",(0,o.jsx)(n.code,{children:"Ordering"})," type class defined in the Scala standard library."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import scala.math.Ordering.Implicits._\n\nsealed trait CustomerAccount\n\ncase class BusinessAccount(id: String) extends CustomerAccount\ncase class ConsumerAccount(id: String) extends CustomerAccount\n\nimplicit val CustomerAccountScalaOrdering: scala.math.Ordering[CustomerAccount] =\n  new scala.math.Ordering[CustomerAccount] {\n    def compare(left: CustomerAccount, right: CustomerAccount): Int =\n      (left, right) match {\n        case (BusinessAccount(id1), BusinessAccount(id2)) => id1 compare id2\n        case (BusinessAccount(_), ConsumerAccount(_))     => -1\n        case (ConsumerAccount(_), BusinessAccount(_))     => 1\n        case (ConsumerAccount(id1), ConsumerAccount(id2)) => id1 compare id2\n      }\n}\n// CustomerAccountScalaOrdering: Ordering[CustomerAccount] = repl.MdocSession$MdocApp2$$anon$1@51309253\n"})}),"\n",(0,o.jsx)(n.p,{children:"Besides the lack of specific types in modeling the result of the compare operator this works fine for comparing two customer accounts."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'val customerAccount1: CustomerAccount = BusinessAccount("abc")\n// customerAccount1: CustomerAccount = BusinessAccount(id = "abc")\nval customerAccount2: CustomerAccount = ConsumerAccount("def")\n// customerAccount2: CustomerAccount = ConsumerAccount(id = "def")\n\nval compareCustomerAccounts: Boolean =\n  customerAccount1 < customerAccount2\n// compareCustomerAccounts: Boolean = true\n'})}),"\n",(0,o.jsx)(n.p,{children:"But look what happens when we try to compare two consumer accounts."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'val consumerAccount1: ConsumerAccount = ConsumerAccount("abc")\nval consumerAccount2: ConsumerAccount = ConsumerAccount("def")\n\nval compareConsumerAccounts: Boolean =\n  consumerAccount1 < consumerAccount2\n// error: value < is not a member of MdocApp2.this.ConsumerAccount\n//   consumerAccount1 < consumerAccount2\n//   ^^^^^^^^^^^^^^^^^^\n'})}),"\n",(0,o.jsxs)(n.p,{children:["This code doesn't compile! The Scala compiler is unable to compare the consumer accounts because of the lack of variance on ",(0,o.jsx)(n.code,{children:"scala.math.Ordering"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["We could widen the type of ",(0,o.jsx)(n.code,{children:"ConsumerAccount"})," to ",(0,o.jsx)(n.code,{children:"CustomerAccount"})," but that is unergonomic. And it wouldn't even work if, for example, we were trying to sort the list and needed to maintain the type information that these were consumer accounts rather than just customer accounts."]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"Ord"})," abstraction helps us avoid problems like this and integrates seamlessly with the rest of ZIO Prelude."]}),"\n",(0,o.jsx)(n.h2,{id:"defining-ord-instances",children:"Defining Ord Instances"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"Ord"})," instances are already defined for all the types in ",(0,o.jsx)(n.code,{children:"ZIO"})," and the Scala standard library that have a total ordering."]}),"\n",(0,o.jsxs)(n.p,{children:["ZIO Prelude is also very good at automatically deriving ",(0,o.jsx)(n.code,{children:"Ord"})," instances for more complex data types like tuples. For example if we have a pair of ",(0,o.jsx)(n.code,{children:"Double"})," values representing ",(0,o.jsx)(n.code,{children:"x"})," and ",(0,o.jsx)(n.code,{children:"y"})," coordinates an ordering is already automatically defined for it."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio.prelude._\n\nOrd[(Double, Double)]\n// res5: Ord[(Double, Double)] = zio.prelude.Ord$$anon$5@347c812e\n"})}),"\n",(0,o.jsx)(n.p,{children:"The default instance for tuples will order values by the first field and then if the first field is the same by the second field and so on."}),"\n",(0,o.jsxs)(n.p,{children:["If we want to define an ordering for our own data type and potentially include our own ordering logic we can use the ",(0,o.jsx)(n.code,{children:"make"})," operator."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"case class Point(x: Double, y: Double)\n\nobject Point {\n  implicit val PointOrd: Ord[Point] =\n    Ord.make { (left, right) =>\n      (left.y =?= right.y) <> (left.x =?= right.x)\n    }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"<>"})," operator combines two ",(0,o.jsx)(n.code,{children:"Ordering"})," values, using the result of the first one if it is ",(0,o.jsx)(n.code,{children:"GreaterThan"})," or ",(0,o.jsx)(n.code,{children:"LessThan"})," and otherwise using the result of the second one. You can think of this like sorting by last name and then first name."]}),"\n",(0,o.jsxs)(n.p,{children:["So now we are sorting by the ",(0,o.jsx)(n.code,{children:"y"})," coordinate and then the ",(0,o.jsx)(n.code,{children:"x"})," coordinate."]}),"\n",(0,o.jsxs)(n.p,{children:["Just like the ",(0,o.jsx)(n.code,{children:"Equal"})," abstraction, the ",(0,o.jsx)(n.code,{children:"Ord"})," abstraction supports a ",(0,o.jsx)(n.code,{children:"contramap"})," operator, so we can define a total ordering on a data type as long as we can transform it into another data type that has a total ordering in a way that preserves information."]}),"\n",(0,o.jsxs)(n.p,{children:["This is particularly useful if we want to define an ",(0,o.jsx)(n.code,{children:"Ord"})," instance for our case classes because we can just derive it from the instances for tuples."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"object Point {\n  implicit val PointOrd: Ord[Point] =\n    Ord[(Double, Double)].contramap(point => (point.y, point.x))\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["ZIO Prelude makes it as easy as possible to use and define instances of ",(0,o.jsx)(n.code,{children:"Ord"})," so we can abstract over the property of having a total ordering and integrate it with other parts of ZIO Prelude."]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},28453:(e,n,c)=>{c.d(n,{R:()=>s,x:()=>a});var t=c(96540);const o={},r=t.createContext(o);function s(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);