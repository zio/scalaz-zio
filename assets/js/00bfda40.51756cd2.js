"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[81210],{28453:(e,i,n)=>{n.d(i,{R:()=>t,x:()=>c});var o=n(96540);const r={},s=o.createContext(r);function t(e){const i=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function c(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),o.createElement(s.Provider,{value:i},e.children)}},59447:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>t,metadata:()=>o,toc:()=>a});const o=JSON.parse('{"id":"reference/concurrency/promise","title":"Promise","description":"A Promise[E, A] is a variable of IO[E, A] type that can be set exactly once.","source":"@site/versioned_docs/version-1.0.18/reference/concurrency/promise.md","sourceDirName":"reference/concurrency","slug":"/reference/concurrency/promise","permalink":"/1.0.18/reference/concurrency/promise","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/versioned_docs/version-1.0.18/reference/concurrency/promise.md","tags":[],"version":"1.0.18","frontMatter":{"id":"promise","title":"Promise"},"sidebar":"overview_sidebar","previous":{"title":"RefM","permalink":"/1.0.18/reference/concurrency/refm"},"next":{"title":"Queue","permalink":"/1.0.18/reference/concurrency/queue"}}');var r=n(74848),s=n(28453);const t={id:"promise",title:"Promise"},c=void 0,l={},a=[{value:"Operations",id:"operations",level:2},{value:"Creation",id:"creation",level:3},{value:"Completing",id:"completing",level:3},{value:"Awaiting",id:"awaiting",level:3},{value:"Polling",id:"polling",level:3},{value:"Example Usage",id:"example-usage",level:2}];function d(e){const i={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(i.p,{children:["A ",(0,r.jsx)(i.code,{children:"Promise[E, A]"})," is a variable of ",(0,r.jsx)(i.code,{children:"IO[E, A]"})," type that can be set exactly once."]}),"\n",(0,r.jsxs)(i.p,{children:["Promise is a ",(0,r.jsx)(i.strong,{children:"purely functional synchronization primitive"})," which represents a single value that may not yet be available. When we create a Promise, it always started with an empty value, then it can be completed exactly once at some point, and then it will never become empty or modified again."]}),"\n",(0,r.jsxs)(i.p,{children:["Promise is a synchronization primitive. So, it is useful whenever we want to wait for something to happen. Whenever we need to synchronize a fiber with another fiber, we can use Promise. It allows us to have fibers waiting for other fibers to do things. Any time we want to handoff of a work from one fiber to another fiber or anytime we want to suspend a fiber until some other fiber does a certain amount of work, well we need to be using a Promise. Also, We can use ",(0,r.jsx)(i.code,{children:"Promise"})," with ",(0,r.jsx)(i.code,{children:"Ref"})," to build other concurrent primitives, like Queue and Semaphore."]}),"\n",(0,r.jsxs)(i.p,{children:["By calling ",(0,r.jsx)(i.code,{children:"await"})," on the Promise, the current fiber blocks, until that event happens. As we know, blocking thread in ZIO, don't actually block kernel threads. They are semantic blocking, so when a fiber is blocked the underlying thread is free to run all other fibers."]}),"\n",(0,r.jsxs)(i.p,{children:["Promise is the equivalent of Scala's Promise. It's almost the same, except it has two type parameters, instead of one. Also instead of calling ",(0,r.jsx)(i.code,{children:"future"}),", we need to call ",(0,r.jsx)(i.code,{children:"await"})," on ZIO Promise to wait for the Promise to be completed."]}),"\n",(0,r.jsxs)(i.p,{children:["Promises can be failed with a value of type ",(0,r.jsx)(i.code,{children:"E"})," and succeeded that is completed with success with the value of type ",(0,r.jsx)(i.code,{children:"A"}),". So there are two ways we can complete a Promise, with failure or success and then whoever is waiting on the Promise will get back that failure or success."]}),"\n",(0,r.jsx)(i.h2,{id:"operations",children:"Operations"}),"\n",(0,r.jsx)(i.h3,{id:"creation",children:"Creation"}),"\n",(0,r.jsxs)(i.p,{children:["Promises can be created using ",(0,r.jsx)(i.code,{children:"Promise.make[E, A]"}),", which returns ",(0,r.jsx)(i.code,{children:"UIO[Promise[E, A]]"}),". This is a description of creating a promise, but not the actual promise. Promises cannot be created outside of IO, because creating them involves allocating mutable memory, which is an effect and must be safely captured in IO."]}),"\n",(0,r.jsx)(i.h3,{id:"completing",children:"Completing"}),"\n",(0,r.jsxs)(i.p,{children:["You can complete a ",(0,r.jsx)(i.code,{children:"Promise[E, A]"})," in few different ways:"]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["successfully with a value of type ",(0,r.jsx)(i.code,{children:"A"})," using ",(0,r.jsx)(i.code,{children:"succeed"})]}),"\n",(0,r.jsxs)(i.li,{children:["with ",(0,r.jsx)(i.code,{children:"Exit[E, A]"})," using ",(0,r.jsx)(i.code,{children:"done"})," - each ",(0,r.jsx)(i.code,{children:"await"})," will get this exit propagated"]}),"\n"]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["with result of effect ",(0,r.jsx)(i.code,{children:"IO[E, A]"})," using ",(0,r.jsx)(i.code,{children:"complete"})," - the effect will be executed once and the result will be propagated to all waiting fibers"]}),"\n"]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["with effect ",(0,r.jsx)(i.code,{children:"IO[E, A]"})," using ",(0,r.jsx)(i.code,{children:"completeWith"})," - first fiber that calls ",(0,r.jsx)(i.code,{children:"completeWith"})," wins and sets effect that ",(0,r.jsxs)(i.strong,{children:["will be executed by each ",(0,r.jsx)(i.code,{children:"await"}),"ing fiber"]}),", so be careful when using ",(0,r.jsx)(i.code,{children:"p.completeWith(someEffect)"})," and rather use ",(0,r.jsx)(i.code,{children:"p.complete(someEffect"})," unless executing ",(0,r.jsx)(i.code,{children:"someEffect"})," by each ",(0,r.jsx)(i.code,{children:"await"}),"ing fiber is intent"]}),"\n",(0,r.jsxs)(i.li,{children:["simply fail with ",(0,r.jsx)(i.code,{children:"E"})," using ",(0,r.jsx)(i.code,{children:"fail"})]}),"\n",(0,r.jsxs)(i.li,{children:["simply defect with ",(0,r.jsx)(i.code,{children:"Throwable"})," using ",(0,r.jsx)(i.code,{children:"die"})]}),"\n",(0,r.jsxs)(i.li,{children:["fail or defect with ",(0,r.jsx)(i.code,{children:"Cause[E]"})," using ",(0,r.jsx)(i.code,{children:"halt"})]}),"\n",(0,r.jsxs)(i.li,{children:["interrupt it with ",(0,r.jsx)(i.code,{children:"interrupt"})]}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"Following example shows usage of all of them:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-scala",children:'import zio._\n\nval race: IO[String, Int] = for {\n    p     <- Promise.make[String, Int]\n    _     <- p.succeed(1).fork\n    _     <- p.complete(ZIO.succeed(2)).fork\n    _     <- p.completeWith(ZIO.succeed(3)).fork\n    _     <- p.done(Exit.succeed(4)).fork\n    _     <- p.fail("5")\n    _     <- p.halt(Cause.die(new Error("6")))\n    _     <- p.die(new Error("7"))\n    _     <- p.interrupt.fork\n    value <- p.await\n  } yield value\n'})}),"\n",(0,r.jsxs)(i.p,{children:["The act of completing a Promise results in an ",(0,r.jsx)(i.code,{children:"UIO[Boolean]"}),", where the ",(0,r.jsx)(i.code,{children:"Boolean"})," represents whether the promise value has been set (",(0,r.jsx)(i.code,{children:"true"}),") or whether it was already set (",(0,r.jsx)(i.code,{children:"false"}),"). This is demonstrated below:"]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-scala",children:'val ioPromise1: UIO[Promise[Exception, String]] = Promise.make[Exception, String]\nval ioBooleanSucceeded: UIO[Boolean] = ioPromise1.flatMap(promise => promise.succeed("I\'m done"))\n'})}),"\n",(0,r.jsxs)(i.p,{children:["Another example with ",(0,r.jsx)(i.code,{children:"fail(...)"}),":"]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-scala",children:'val ioPromise2: UIO[Promise[Exception, Nothing]] = Promise.make[Exception, Nothing]\nval ioBooleanFailed: UIO[Boolean] = ioPromise2.flatMap(promise => promise.fail(new Exception("boom")))\n'})}),"\n",(0,r.jsxs)(i.p,{children:["To re-iterate, the ",(0,r.jsx)(i.code,{children:"Boolean"})," tells us whether or not the operation took place successfully (",(0,r.jsx)(i.code,{children:"true"}),") i.e. the Promise\nwas set with the value or the error."]}),"\n",(0,r.jsx)(i.h3,{id:"awaiting",children:"Awaiting"}),"\n",(0,r.jsxs)(i.p,{children:["We can get a value from a Promise using ",(0,r.jsx)(i.code,{children:"await"}),", calling fiber will suspend until Promise is completed."]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-scala",children:"val ioPromise3: UIO[Promise[Exception, String]] = Promise.make[Exception, String]\nval ioGet: IO[Exception, String] = ioPromise3.flatMap(promise => promise.await)\n"})}),"\n",(0,r.jsx)(i.h3,{id:"polling",children:"Polling"}),"\n",(0,r.jsx)(i.p,{children:"The computation will suspend (in a non-blocking fashion) until the Promise is completed with a value or an error."}),"\n",(0,r.jsxs)(i.p,{children:["If we don't want to suspend, and we only want to query the state of whether or not the Promise has been completed, we can use ",(0,r.jsx)(i.code,{children:"poll"}),":"]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-scala",children:"val ioPromise4: UIO[Promise[Exception, String]] = Promise.make[Exception, String]\nval ioIsItDone: UIO[Option[IO[Exception, String]]] = ioPromise4.flatMap(p => p.poll)\nval ioIsItDone2: IO[Option[Nothing], IO[Exception, String]] = ioPromise4.flatMap(p => p.poll.get)\n"})}),"\n",(0,r.jsxs)(i.p,{children:["If the Promise was not completed when we called ",(0,r.jsx)(i.code,{children:"poll"})," then the IO will fail with the ",(0,r.jsx)(i.code,{children:"Unit"})," value otherwise, we obtain an ",(0,r.jsx)(i.code,{children:"IO[E, A]"}),", where ",(0,r.jsx)(i.code,{children:"E"})," represents if the Promise completed with an error and ",(0,r.jsx)(i.code,{children:"A"})," indicates that the Promise successfully completed with an ",(0,r.jsx)(i.code,{children:"A"})," value."]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.code,{children:"isDone"})," returns ",(0,r.jsx)(i.code,{children:"UIO[Boolean]"})," that evaluates to ",(0,r.jsx)(i.code,{children:"true"})," if promise is already completed."]}),"\n",(0,r.jsx)(i.h2,{id:"example-usage",children:"Example Usage"}),"\n",(0,r.jsxs)(i.p,{children:["Here is a scenario where we use a ",(0,r.jsx)(i.code,{children:"Promise"})," to hand-off a value between two ",(0,r.jsx)(i.code,{children:"Fiber"}),"s"]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-scala",children:'import java.io.IOException\nimport zio.console._\nimport zio.duration._\nimport zio.clock._\n\nval program: ZIO[Console with Clock, IOException, Unit] = \n  for {\n    promise         <-  Promise.make[Nothing, String]\n    sendHelloWorld  =   (IO.succeed("hello world") <* sleep(1.second)).flatMap(promise.succeed)\n    getAndPrint     =   promise.await.flatMap(putStrLn(_))\n    fiberA          <-  sendHelloWorld.fork\n    fiberB          <-  getAndPrint.fork\n    _               <-  (fiberA zip fiberB).join\n  } yield ()\n'})}),"\n",(0,r.jsxs)(i.p,{children:["In the example above, we create a Promise and have a Fiber (",(0,r.jsx)(i.code,{children:"fiberA"}),") complete that promise after 1 second and a second Fiber (",(0,r.jsx)(i.code,{children:"fiberB"}),") will call ",(0,r.jsx)(i.code,{children:"await"})," on that Promise to obtain a ",(0,r.jsx)(i.code,{children:"String"})," and then print it to screen. The example prints ",(0,r.jsx)(i.code,{children:"hello world"})," to the screen after 1 second. Remember, this is just a description of the program and not the execution\nitself."]})]})}function h(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);