"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[85036],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>c});var i=t(96540);const o={},l=i.createContext(o);function r(e){const n=i.useContext(l);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(l.Provider,{value:n},e.children)}},79598:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>c,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"reference/sync/reentrantlock","title":"ReentrantLock","description":"A ReentrantLock is a lock which can be acquired multiple times by the same fiber. When a fiber acquires (lock) a reentrant lock, it will become the owner of that lock. Other fibers cannot obtain the lock unless the lock owner releases (unlock) the lock. As the lock is reentrant, the lock owner can call the lock again, multiple times.","source":"@site/docs/reference/sync/reentrantlock.md","sourceDirName":"reference/sync","slug":"/reference/sync/reentrantlock","permalink":"/reference/sync/reentrantlock","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/sync/reentrantlock.md","tags":[],"version":"current","frontMatter":{"id":"reentrantlock","title":"ReentrantLock"},"sidebar":"reference-sidebar","previous":{"title":"Introduction to ZIO\'s Synchronization Primitives","permalink":"/reference/sync/"},"next":{"title":"CountdownLatch","permalink":"/reference/sync/countdownlatch"}}');var o=t(74848),l=t(28453);const r={id:"reentrantlock",title:"ReentrantLock"},c=void 0,s={},a=[{value:"Reentrancy",id:"reentrancy",level:2},{value:"Creating ReentrantLocks",id:"creating-reentrantlocks",level:2},{value:"Locking and Unlocking",id:"locking-and-unlocking",level:2},{value:"Fairness Policy",id:"fairness-policy",level:2},{value:"Convenience Operations",id:"convenience-operations",level:2},{value:"Querying ReentrantLocks",id:"querying-reentrantlocks",level:2},{value:"Examples",id:"examples",level:2},{value:"Example of Simple Locking Mechanism",id:"example-of-simple-locking-mechanism",level:3},{value:"Example of Reentrancy",id:"example-of-reentrancy",level:3},{value:"Example of Producing Deadlock",id:"example-of-producing-deadlock",level:3}];function h(e){const n={code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:["A ",(0,o.jsx)(n.code,{children:"ReentrantLock"})," is a lock which can be acquired multiple times by the same fiber. When a fiber acquires (",(0,o.jsx)(n.code,{children:"lock"}),") a reentrant lock, it will become the owner of that lock. Other fibers cannot obtain the lock unless the lock owner releases (",(0,o.jsx)(n.code,{children:"unlock"}),") the lock. As the lock is reentrant, the lock owner can call the ",(0,o.jsx)(n.code,{children:"lock"})," again, multiple times."]}),"\n",(0,o.jsx)(n.h2,{id:"reentrancy",children:"Reentrancy"}),"\n",(0,o.jsx)(n.p,{children:"In reentrancy, only the current working fiber can access a shared resource, preventing any other fibers from doing so. Reentrant locks allow their owner (the fiber that owns the lock) to re-enter them multiple times."}),"\n",(0,o.jsx)(n.p,{children:"Therefore, in reentrancy locks are acquired per-fiber instead of per-invocation. In other words, if a fiber is not reentrant, and tries to acquire a lock that it already holds, the request won\u2019t succeed."}),"\n",(0,o.jsx)(n.h2,{id:"creating-reentrantlocks",children:"Creating ReentrantLocks"}),"\n",(0,o.jsxs)(n.p,{children:["Using ",(0,o.jsx)(n.code,{children:"ReentrantLocks.make"})," we can create a reentrant lock in the ",(0,o.jsx)(n.em,{children:"unlocked state"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"object ReentrantLock {\n  def make(fairness: Boolean = false): UIO[ReentrantLock] = ???\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["By default, it creates a reentrant lock with an unfair policy, so waiters will be picked randomly. If we set the ",(0,o.jsx)(n.code,{children:"fairness"})," parameter to ",(0,o.jsx)(n.code,{children:"true"}),", the reentrant lock will pick the longest waiting fiber."]}),"\n",(0,o.jsx)(n.h2,{id:"locking-and-unlocking",children:"Locking and Unlocking"}),"\n",(0,o.jsxs)(n.p,{children:["The two basic operations on reentrant locks are ",(0,o.jsx)(n.code,{children:"lock"})," and ",(0,o.jsx)(n.code,{children:"unlock"}),". They acquire and release the lock, respectively:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"trait ReentrantLock {\n  lazy val lock:   UIO[Unit]\n  lazy val unlock: UIO[Unit]\n}\n"})}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"ReentrantLock#lock"})}),"\u2014 When a fiber attempt to acquire the lock one of the following cases will happen:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["When the state is ",(0,o.jsx)(n.em,{children:"unlocked"})," and in another word if the lock is not held by another fiber, it will acquire the lock and returns immediately and the ",(0,o.jsx)(n.em,{children:"hold count"})," increased by one."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["When the state is ",(0,o.jsx)(n.em,{children:"locked"})," and the current fiber already holds the lock, then the ",(0,o.jsx)(n.em,{children:"hold count"})," is incremented by one, and the method returns immediately."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["When the state is ",(0,o.jsx)(n.em,{children:"locked"})," and the lock is held by another fiber, then the current fiber will be put to sleep until the lock has been acquired, at which point the lock hold count will be reset to one."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"ReentrantLock#unlock"})}),"\u2014 When a fiber attempt to release the lock, one of the following cases will happen:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"If the current fiber is the holder of this lock then the hold count is decremented. If the hold count is now zero then the lock is released. So if there are any fibers blocked on acquire, one fiber will be picked using (fairness or unfairness policy) and woken up."}),"\n",(0,o.jsx)(n.li,{children:"If the current fiber is not the holder of this lock then nothing happens."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"fairness-policy",children:"Fairness Policy"}),"\n",(0,o.jsx)(n.p,{children:"The ReentrantLock constructor offers two fairness policies:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"unfair policy (the default)"}),"\n",(0,o.jsx)(n.li,{children:"fair policy"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"When a fiber fails to acquire the lock, it is placed in the waiting queue. So when the owning fiber releases the lock, the next waiting fiber chosen by the fairness policy is allowed to try acquiring the lock:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"In the case of a fairness policy, fibers always acquire a lock in the order in which they requested it. So the reentrant lock will pick the longest waiting fiber from the waiting queue."}),"\n",(0,o.jsx)(n.li,{children:"In case of unfair policy, the reentrant lock will pick a random fiber from the waiting queue."}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"convenience-operations",children:"Convenience Operations"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"ReentrantLock#tryLock"})}),"\u2014 Acquires the lock only if it is not held by another fiber at the time of invocation otherwise it will return immediately, so it is a non-blocking operation."]}),"\n"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["When the state is ",(0,o.jsx)(n.em,{children:"unlocked"})," ",(0,o.jsx)(n.code,{children:"tryLock"})," changes the state to ",(0,o.jsx)(n.em,{children:"locked"})," (with the current fiber as owner and a hold count of 1) and returns ",(0,o.jsx)(n.code,{children:"true"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["When the state is ",(0,o.jsx)(n.em,{children:"locked"})," ",(0,o.jsx)(n.code,{children:"tryLock"})," leaves the state ",(0,o.jsx)(n.em,{children:"unchanged"})," and returns ",(0,o.jsx)(n.code,{children:"false"}),"."]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"trait ReentrantLock {\n  lazy val tryLock: UIO[Boolean]\n}\n"})}),"\n",(0,o.jsxs)(n.ol,{start:"2",children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"ReentrantLock#withLock"})}),"\u2014 Acquires and releases the lock as a scoped effect. By using this method, the unlock method will be called automatically at the end of the scope."]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"trait ReentrantLock {\n  lazy val withLock: URIO[Scope, Int]\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"querying-reentrantlocks",children:"Querying ReentrantLocks"}),"\n",(0,o.jsxs)(n.p,{children:["A reentrant lock has two states: ",(0,o.jsx)(n.em,{children:"locked"})," or ",(0,o.jsx)(n.em,{children:"unlocked"}),". When the reentrant lock is in ",(0,o.jsx)(n.em,{children:"locked"})," state it has these properties:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Owner"})," indicates which fiber has acquired the lock. This can be queried by calling the ",(0,o.jsx)(n.code,{children:"ReentrantLock#owner"})," method."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Hold Count"})," indicates how many times its owner acquired the lock. This can be queried using by calling the ",(0,o.jsx)(n.code,{children:"ReentrantLock#holdCount"})," method."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Waiters"})," is a collection of fibers that are waiting to acquire this lock. We can query all of them using the ",(0,o.jsx)(n.code,{children:"ReentrantLock#queuedFibers"})," method."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,o.jsx)(n.h3,{id:"example-of-simple-locking-mechanism",children:"Example of Simple Locking Mechanism"}),"\n",(0,o.jsx)(n.p,{children:"In the following example, the main fiber acquires the lock, and then we try to acquire the lock from its child fiber. We will see that the child fiber will be blocked when it attempts to acquire the lock until the parent fiber releases it:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.concurrent._\n\nobject MainApp extends ZIOAppDefault {\n\n  def run =\n    for {\n      l  <- ReentrantLock.make()\n      fn <- ZIO.fiberId.map(_.threadName)\n      _  <- l.lock\n      _  <- ZIO.debug(s"$fn acquired the lock.")\n      task =\n        for {\n          fn <- ZIO.fiberId.map(_.threadName)\n          _  <- ZIO.debug(s"$fn attempted to acquire the lock.")\n          _  <- l.lock\n          _  <- ZIO.debug(s"$fn acquired the lock.")\n          _  <- ZIO.debug(s"$fn will release the lock after 5 second.")\n          _  <- ZIO.sleep(5.second)\n          _  <- l.unlock\n          _  <- ZIO.debug(s"$fn released the lock.")\n        } yield ()\n      f <- task.fork\n      _ <- ZIO.debug(s"$fn will release the lock after 10 second.")\n      _ <- ZIO.sleep(10.second)\n      _ <- (l.unlock *> ZIO.debug(s"$fn released the lock.")).uninterruptible\n      _ <- f.join\n    } yield ()\n    \n}\n// Output:\n// zio-fiber-2 acquired the lock.\n// zio-fiber-2 will release the lock after 10 second.\n// zio-fiber-7 attempted to acquire the lock.\n// zio-fiber-2 released the lock.\n// zio-fiber-7 acquired the lock.\n// zio-fiber-7 will release the lock after 5 second.\n// zio-fiber-7 released the lock.\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Parent fiber (",(0,o.jsx)(n.code,{children:"zio-fiber-2"}),") acquires the lock and then releases it after 10 seconds. Meanwhile, the child fiber (",(0,o.jsx)(n.code,{children:"zio-fiber-7"}),") tries to acquire the lock, but it cannot. The attempt to acquire the lock in the child fiber causes the fiber to go into sleep mode. Following the release of the lock by the parent fiber, the child fiber will awaken and acquire the lock."]}),"\n",(0,o.jsx)(n.h3,{id:"example-of-reentrancy",children:"Example of Reentrancy"}),"\n",(0,o.jsx)(n.p,{children:"In the previous example, we used the simplest use-case of a locking mechanism that doesn't involve reentrancy. To illustrate how reentrancy works, let's look at another example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.concurrent._\n\nobject MainApp extends ZIOAppDefault {\n\n  def task(l: ReentrantLock, i: Int): ZIO[Any, Nothing, Unit] = for {\n    fn <- ZIO.fiberId.map(_.threadName)\n    _  <- l.lock\n    hc <- l.holdCount\n    _  <- ZIO.debug(s"$fn (re)entered the critical section and now the hold count is $hc")\n    _  <- ZIO.when(i > 0)(task(l, i - 1))\n    _  <- l.unlock\n    hc <- l.holdCount\n    _  <- ZIO.debug(s"$fn exited the critical section and now the hold count is $hc")\n  } yield ()\n\n  def run =\n    for {\n      l <- ReentrantLock.make()\n      _ <- task(l, 2) zipPar task(l, 3)\n    } yield ()\n}\n// One possible output:\n// zio-fiber-8 (re)entered the critical section and now the hold count is 1\n// zio-fiber-8 (re)entered the critical section and now the hold count is 2\n// zio-fiber-8 (re)entered the critical section and now the hold count is 3\n// zio-fiber-8 (re)entered the critical section and now the hold count is 4\n// zio-fiber-8 exited the critical section and now the hold count is 3\n// zio-fiber-8 exited the critical section and now the hold count is 2\n// zio-fiber-8 exited the critical section and now the hold count is 1\n// zio-fiber-8 exited the critical section and now the hold count is 0\n// zio-fiber-7 (re)entered the critical section and now the hold count is 1\n// zio-fiber-7 (re)entered the critical section and now the hold count is 2\n// zio-fiber-7 (re)entered the critical section and now the hold count is 3\n// zio-fiber-7 exited the critical section and now the hold count is 2\n// zio-fiber-7 exited the critical section and now the hold count is 1\n// zio-fiber-7 exited the critical section and now the hold count is 0\n'})}),"\n",(0,o.jsxs)(n.p,{children:["In this example, inside the ",(0,o.jsx)(n.code,{children:"task"})," function, we have a critical section. Also, the ",(0,o.jsx)(n.code,{children:"task"})," itself is recursive and inside the critical section, it will call itself. When a fiber tries to enter the critical section and that fiber is the owner of that critical section, the ",(0,o.jsx)(n.code,{children:"ReentrantLock"})," allows that fiber to reenter, and it will increment the ",(0,o.jsx)(n.code,{children:"holdCount"})," by one."]}),"\n",(0,o.jsx)(n.h3,{id:"example-of-producing-deadlock",children:"Example of Producing Deadlock"}),"\n",(0,o.jsx)(n.p,{children:"When two or more fibers wait forever for a lock held by another fiber, they have reached a deadlock. So when we are working with locks, we should be careful of avoiding deadlocks."}),"\n",(0,o.jsx)(n.p,{children:"In this example, we are just trying to show a simple possible deadlock example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.concurrent._\n\nobject MainApp extends ZIOAppDefault {\n  def workflow1(l1: ReentrantLock, l2: ReentrantLock) =\n    for {\n      f <- ZIO.fiberId.map(_.threadName)\n      _ <- l1.lock *> ZIO.debug(s"$f locked the l1")\n      o <- l2.owner.map(_.map(_.threadName))\n      _ <- ZIO.debug(s"$f trying to lock the l2 while the $o is its owner") *>\n        l2.lock *>\n        ZIO.debug(s"$f locked the l2")\n      _ <- l2.unlock\n      _ <- l1.unlock\n    } yield ()\n\n  def workflow2(l1: ReentrantLock, l2: ReentrantLock) =\n    for {\n      f <- ZIO.fiberId.map(_.threadName)\n      _ <- l2.lock *> ZIO.debug(s"$f locked the l2")\n      o <- l1.owner.map(_.map(_.threadName))\n      _ <- ZIO.debug(s"$f trying to lock the l1 while the $o is its owner") *>\n        l1.lock *>\n        ZIO.debug(s"$f locked the l1")\n      _ <- l1.unlock\n      _ <- l2.unlock\n    } yield ()\n\n  def run =\n    for {\n      l1 <- ReentrantLock.make()\n      l2 <- ReentrantLock.make()\n      _ <- workflow1(l1, l2) <&> workflow2(l1, l2)\n    } yield ()\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"In we run this program, we have a possible deadlock situation, and it might print the following messages and lock forever:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"zio-fiber-7 locked the l1\nzio-fiber-8 locked the l2\nzio-fiber-7 trying to lock the l2 while the Some(zio-fiber-8) is its owner\nzio-fiber-8 trying to lock the l1 while the Some(zio-fiber-7) is its owner\n"})}),"\n",(0,o.jsxs)(n.p,{children:["When we run two workflows concurrently, it can cause a deadlock when the first workflow obtains ",(0,o.jsx)(n.code,{children:"l1"})," and in the meantime, the second workflow obtains ",(0,o.jsx)(n.code,{children:"l2"}),", now:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["When the first workflow tries to obtain ",(0,o.jsx)(n.code,{children:"l2"})," while ",(0,o.jsx)(n.code,{children:"l2"})," is being obtained by ",(0,o.jsx)(n.code,{children:"l1"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["When the second workflow tries to obtain the ",(0,o.jsx)(n.code,{children:"l1"})," while the ",(0,o.jsx)(n.code,{children:"l2"})," is being obtained by ",(0,o.jsx)(n.code,{children:"l1"}),".\nEventually, both fibers will enter a waiting state, and there will be a deadlock."]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}}}]);