"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[2065],{32118:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"zio-prelude/functional-abstractions/parameterized-types/identityboth","title":"IdentityBoth","description":"IdentityBoth[F] describes an associative way to combine two values F[A] and F[B] into a value F[(A, B)] that also has an identity element of type F[Any].","source":"@site/docs/zio-prelude/functional-abstractions/parameterized-types/identityboth.md","sourceDirName":"zio-prelude/functional-abstractions/parameterized-types","slug":"/zio-prelude/functional-abstractions/parameterized-types/identityboth","permalink":"/zio-prelude/functional-abstractions/parameterized-types/identityboth","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-prelude/functional-abstractions/parameterized-types/identityboth.md","tags":[],"version":"current","frontMatter":{"id":"identityboth","title":"IdentityBoth"},"sidebar":"ecosystem-sidebar","previous":{"title":"ForEach","permalink":"/zio-prelude/functional-abstractions/parameterized-types/foreach"},"next":{"title":"IdentityEither","permalink":"/zio-prelude/functional-abstractions/parameterized-types/identityeither"}}');var a=n(74848),o=n(28453);const s={id:"identityboth",title:"IdentityBoth"},r=void 0,c={},l=[];function d(e){const t={code:"code",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"IdentityBoth[F]"})," describes an associative way to combine two values ",(0,a.jsx)(t.code,{children:"F[A]"})," and ",(0,a.jsx)(t.code,{children:"F[B]"})," into a value ",(0,a.jsx)(t.code,{children:"F[(A, B)]"})," that also has an identity element of type ",(0,a.jsx)(t.code,{children:"F[Any]"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"Its signature is:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:"trait AssociativeBoth[F[_]] {\n  def both[A, B](fa: => F[A], fb: => F[B]): F[(A, B)]\n}\n\ntrait IdentityBoth[F[_]] extends AssociativeBoth[F] {\n  def any: F[Any]\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"any"})," value must be an identity element with respect to the ",(0,a.jsx)(t.code,{children:"both"})," operator, so that after removing unnecessary tuples the following property holds:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:"fa <*> identity === fa\nidentity <*> fa === fa\n"})}),"\n",(0,a.jsxs)(t.p,{children:["This is the same as the laws for the ",(0,a.jsx)(t.code,{children:"Identity"})," functional abstraction for concrete types except lifted into the context of parameterized types."]}),"\n",(0,a.jsxs)(t.p,{children:["To be an identity element, running the ",(0,a.jsx)(t.code,{children:"any"})," value must not do anything so we can always compose it as many times as we want with the ",(0,a.jsx)(t.code,{children:"both"})," operator without changing the result."]}),"\n",(0,a.jsxs)(t.p,{children:["As with the other abstractions for parameterized types we have looked at ",(0,a.jsx)(t.code,{children:"ZIO"})," provides a good initial example."]}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"any"})," value for ",(0,a.jsx)(t.code,{children:"ZIO"})," is ",(0,a.jsx)(t.code,{children:"unit"}),", the workflow that does not do anything, always succeeds, and produces no useful information. We can do nothing before or after another ",(0,a.jsx)(t.code,{children:"ZIO"})," workflow as many times as we want and we will always get a workflow that does the same thing."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:'import zio._\n\nimport java.io.IOException\n\nval helloUnit: ZIO[Console, IOException, Unit] =\n  Console.printLine("Hello") <*> ZIO.unit\n// helloUnit: ZIO[Console, IOException, Unit] = FlatMap(\n//   trace = "repl.MdocSession.MdocApp0.helloUnit(identityboth.md:31)",\n//   first = Stateful(\n//     trace = "repl.MdocSession.MdocApp0.helloUnit(identityboth.md:31)",\n//     onState = zio.FiberRef$unsafe$$anon$2$$Lambda$17011/0x00000008046a1840@4e2c1094\n//   ),\n//   successK = zio.ZIO$$Lambda$17013/0x00000008046a3040@6cdd263a\n// )\n\nval unitHello: ZIO[Console, IOException, Unit] =\n  ZIO.unit <*> Console.printLine("Hello")\n// unitHello: ZIO[Console, IOException, Unit] = FlatMap(\n//   trace = "repl.MdocSession.MdocApp0.unitHello(identityboth.md:35)",\n//   first = Sync(\n//     trace = "",\n//     eval = zio.ZIO$$$Lambda$16992/0x0000000804676840@3d6521f3\n//   ),\n//   successK = zio.ZIO$$Lambda$17013/0x00000008046a3040@13e33e7b\n// )\n'})}),"\n",(0,a.jsxs)(t.p,{children:["These programs are identical because ",(0,a.jsx)(t.code,{children:"ZIO.unit"})," does not do anything at all and always succeeds."]}),"\n",(0,a.jsxs)(t.p,{children:["Similarly, the ",(0,a.jsx)(t.code,{children:"any"})," with respect to data types such as ",(0,a.jsx)(t.code,{children:"Either"})," and ",(0,a.jsx)(t.code,{children:"Option"})," that model failure is a successful value that contains no useful information."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:"val anyEither: Either[Nothing, Any] =\n  Right(())\n// anyEither: Either[Nothing, Any] = Right(value = ())\n\nval anyOption: Option[Any] =\n  Some(())\n// anyOption: Option[Any] = Some(value = ())\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Since the ",(0,a.jsx)(t.code,{children:"both"})," operator for these data types corresponds to failing on the first error or returning a success with all the results, the ",(0,a.jsx)(t.code,{children:"any"})," value can never change the result. If ",(0,a.jsx)(t.code,{children:"any"})," is combined with a failed value the result will be that failure, and if it is combined with a successful value the result will be that success."]}),"\n",(0,a.jsxs)(t.p,{children:["For collection types the ",(0,a.jsx)(t.code,{children:"any"})," value is a collection with a single value containing no useful information."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:"val anyList: List[Any] =\n  List(())\n// anyList: List[Any] = List(())\n"})}),"\n",(0,a.jsxs)(t.p,{children:["We might be tempted to think that an empty collection would be the identity value but we can see this is not the case because the ",(0,a.jsx)(t.code,{children:"both"})," operator corresponds to the Cartesian product of two collections and the product of a collection with the empty collection is the empty collection, not the original collection."]}),"\n",(0,a.jsxs)(t.p,{children:["If we think of a collection as representing a set of possible states then we can think of this as the state that occurs with certainty. Or if we think of the ",(0,a.jsx)(t.code,{children:"both"})," operator as being the product of two collections the identity element for multiplication is one, not zero."]}),"\n",(0,a.jsx)(t.p,{children:"For a parser the identity element would be a parser that always succeeds with no useful information and does not change the parse state."}),"\n",(0,a.jsx)(t.p,{children:"We can also define identity values with respect to contravariant types."}),"\n",(0,a.jsxs)(t.p,{children:["For example, consider the ",(0,a.jsx)(t.code,{children:"Predicate"})," data type."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:"trait Predicate[-A] {\n  def run(a: A): Boolean\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["We could define an ",(0,a.jsx)(t.code,{children:"IdentityBoth"})," instance for it like this:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:"import zio.prelude._\n\nobject Predicate {\n  implicit val PredicateIdentityBoth: IdentityBoth[Predicate] =\n    new IdentityBoth[Predicate] {\n      val any: Predicate[Any] =\n        new Predicate[Any] {\n          def run(a: Any) =\n            true\n        }\n      def both[A, B](left: => Predicate[A], right: => Predicate[B]): Predicate[(A, B)] =\n        new Predicate[(A, B)] {\n          def run(tuple: (A, B)): Boolean =\n            left.run(tuple._1) && right.run(tuple._2)\n        }\n    }\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"both"})," operator for ",(0,a.jsx)(t.code,{children:"Predicate"})," combines two predicates to return a new predicate that is true if both of the original predicates are true. So we can always combine any predicate with the predicate that is always true without changing the result."]}),"\n",(0,a.jsx)(t.p,{children:"This again shows the value of separating abstractions for defining how parameterized types can be combined from abstractions for describing their variance. Otherwise we would face a proliferation of abstractions to describe the product of these various combinations of properties of the combining operation and the variance of the data type, as other functional programming libraries have experienced."}),"\n",(0,a.jsxs)(t.p,{children:["When a data type has both a ",(0,a.jsx)(t.code,{children:"IdentityBoth"})," and a ",(0,a.jsx)(t.code,{children:"Covariant"})," instance we can define a particularly useful operator for it called ",(0,a.jsx)(t.code,{children:"succeed"}),"."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:"def succeed[F[+_]: IdentityBoth : Covariant, A](a: => A): F[A] =\n  IdentityBoth[F].any.map(_ => a)\n"})}),"\n",(0,a.jsxs)(t.p,{children:['This says that if a data type is also covariant we can always "lift" any value into the data type by starting with the identity value and using ',(0,a.jsx)(t.code,{children:"map"})," to transform the output type to the specified value."]}),"\n",(0,a.jsx)(t.p,{children:"This is very useful for working with parameterized data types in general because it allows us to take ordinary values and use them in the context of our parameterized type."}),"\n",(0,a.jsxs)(t.p,{children:["For example we can use the ",(0,a.jsx)(t.code,{children:"succeed"})," operator on ",(0,a.jsx)(t.code,{children:"ZIO"})," to wrap any arbitrary block of Scala code in a ",(0,a.jsx)(t.code,{children:"ZIO"})," effect."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:'val helloScala: ZIO[Any, Nothing, Unit] =\n  ZIO.succeed(println("Hello, Scala!"))\n// helloScala: ZIO[Any, Nothing, Unit] = Sync(\n//   trace = "repl.MdocSession.MdocApp0.helloScala(identityboth.md:98)",\n//   eval = <function0>\n// )\n'})}),"\n",(0,a.jsxs)(t.p,{children:["This is also quite useful in ZIO Prelude in particular because many operators are only defined for data types that have an ",(0,a.jsx)(t.code,{children:"IdentityBoth"})," instance, such as the ",(0,a.jsx)(t.code,{children:"forEach"})," operator on the ",(0,a.jsx)(t.code,{children:"ForEach"})," abstraction."]}),"\n",(0,a.jsx)(t.p,{children:"As with concrete data types, it is quite useful to have an identity element with respect to the combining operator for parameterized types."}),"\n",(0,a.jsx)(t.p,{children:"Most of the time for working with existing data types from ZIO or the Scala standard library it will be less important directly because operators for that data type will already be defined for you."}),"\n",(0,a.jsxs)(t.p,{children:["However, it can still be helpful to think about what the identity value is with respect to a given operation. For example, you may not have thought of a ",(0,a.jsx)(t.code,{children:"Right"})," with no useful information as being an identity with respect to combining ",(0,a.jsx)(t.code,{children:"Either"})," values."]}),"\n",(0,a.jsx)(t.p,{children:"When defining your own parameterized data types, it can be helpful to think about whether an identity element exists with respect to combining values of your data type. If not, could it be refactored to have such an identity value, or does thinking about that tell you something about why it makes sense that your data type does not have one?"}),"\n",(0,a.jsxs)(t.p,{children:["Finally, if you are writing generic code in terms of the functional abstractions in ZIO Prelude this is likely to be another important abstraction. In particular the ability to lift a value into the parameterized type described by the combination of the ",(0,a.jsx)(t.code,{children:"CommutativeBoth"})," and ",(0,a.jsx)(t.code,{children:"Covariant"})," abstractions is often important."]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>r});var i=n(96540);const a={},o=i.createContext(a);function s(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);