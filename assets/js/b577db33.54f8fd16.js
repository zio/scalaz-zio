"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[41614],{28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var o=t(96540);const i={},c=o.createContext(i);function a(e){const n=o.useContext(c);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(c.Provider,{value:n},e.children)}},74714:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>a,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"reference/sync/countdownlatch","title":"CountdownLatch","description":"A synchronization aid that allows one or more fibers to wait until a set of operations being performed in other fibers completes.","source":"@site/docs/reference/sync/countdownlatch.md","sourceDirName":"reference/sync","slug":"/reference/sync/countdownlatch","permalink":"/reference/sync/countdownlatch","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/sync/countdownlatch.md","tags":[],"version":"current","frontMatter":{"id":"countdownlatch","title":"CountdownLatch"},"sidebar":"reference-sidebar","previous":{"title":"ReentrantLock","permalink":"/reference/sync/reentrantlock"},"next":{"title":"CyclicBarrier","permalink":"/reference/sync/cyclicbarrier"}}');var i=t(74848),c=t(28453);const a={id:"countdownlatch",title:"CountdownLatch"},r=void 0,s={},l=[{value:"Creation",id:"creation",level:2},{value:"Operations",id:"operations",level:2},{value:"Examples",id:"examples",level:2},{value:"Simple on/off Latch",id:"simple-onoff-latch",level:3},{value:"Advanced Latches",id:"advanced-latches",level:3}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,c.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"A synchronization aid that allows one or more fibers to wait until a set of operations being performed in other fibers completes."}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.code,{children:"CountDownLatch"})," is initialized with a given count. The ",(0,i.jsx)(n.code,{children:"await"})," method block until the current count reaches zero due to invocations of the ",(0,i.jsx)(n.code,{children:"countDown"})," method, after which all waiting fibers are released and any subsequent invocations of ",(0,i.jsx)(n.code,{children:"await"})," return immediately. This is a one-shot phenomenon -- the count cannot be reset. If you need a version that\nresets the count, consider using a ",(0,i.jsx)(n.a,{href:"/reference/sync/cyclicbarrier",children:(0,i.jsx)(n.code,{children:"CyclicBarrier"})}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.code,{children:"CountDownLatch"})," is a versatile synchronization tool and can be used for a number of purposes. A ",(0,i.jsx)(n.code,{children:"CountDownLatch"})," initialized with a count of one serves as a simple on/off latch, or gate: all fibers invoking ",(0,i.jsx)(n.code,{children:"await"})," wait at the gate until it is opened by a fiber invoking ",(0,i.jsx)(n.code,{children:"countDown"}),". A ",(0,i.jsx)(n.code,{children:"CountDownLatch"}),"initialized to N can be used to make one fiber wait until N fibers have completed some action, or some action has been completed N times."]}),"\n",(0,i.jsxs)(n.p,{children:["A useful property of a ",(0,i.jsx)(n.code,{children:"CountDownLatch"})," is that it doesn't require that fibers calling ",(0,i.jsx)(n.code,{children:"countDown"})," wait for the count to reach zero before proceeding, it simply prevents any fiber from proceeding past an ",(0,i.jsx)(n.code,{children:"await"}),"until all fibers could pass."]}),"\n",(0,i.jsx)(n.h2,{id:"creation",children:"Creation"}),"\n",(0,i.jsxs)(n.p,{children:["To create a ",(0,i.jsx)(n.code,{children:"CountDownLatch"})," we can simply use the ",(0,i.jsx)(n.code,{children:"make"})," constructor. It takes an initial number, for the countdown counter:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"object CountdownLatch {\n  def make(n: Int): IO[Option[Nothing], CountdownLatch]\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"operations",children:"Operations"}),"\n",(0,i.jsxs)(n.p,{children:["There are two important operations defined on ",(0,i.jsx)(n.code,{children:"CountdownLatch"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"class CountdownLatch {\n  val countDown: UIO[Unit]\n  val await: UIO[Unit]\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"countDown"})})," operation decrements the count of the latch, releasing all waiting fibers if the count reaches zero, and the ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"await"})})," operation causes the current fiber to wait until the latch has counted down to zero."]}),"\n",(0,i.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,i.jsx)(n.h3,{id:"simple-onoff-latch",children:"Simple on/off Latch"}),"\n",(0,i.jsxs)(n.p,{children:["We can simply create an on/off latch using ",(0,i.jsx)(n.code,{children:"Promise"}),". In the following example, we don't want to start the ",(0,i.jsx)(n.code,{children:"consume"})," process before the first ",(0,i.jsx)(n.code,{children:"50"})," number appears in the queue. As it requires a simple on/of latch we can implement that using the ",(0,i.jsx)(n.code,{children:"Promise"})," data type:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  def consume(queue: Queue[Int]): UIO[Nothing] =\n    queue.take\n      .flatMap(i => ZIO.debug(s"consumed: $i"))\n      .forever\n\n  def produce(queue: Queue[Int], latch: Promise[Nothing, Unit]): UIO[Nothing] =\n    (Random\n      .nextIntBounded(100)\n      .tap(i => queue.offer(i))\n      .tap(i => ZIO.when(i == 50)(latch.succeed(()))) *> ZIO.sleep(500.millis)).forever\n\n  def run =\n    for {\n      latch <- Promise.make[Nothing, Unit]\n      queue <- Queue.unbounded[Int]\n      _     <- produce(queue, latch) <&> (latch.await *> consume(queue))\n    } yield ()\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Alternatively, we can have an on/off latch using ",(0,i.jsx)(n.code,{children:"CountDownLatch"})," with an initial count of ",(0,i.jsx)(n.em,{children:"one"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.concurrent._\n\nobject MainApp extends ZIOAppDefault {\n\n  def consume(queue: Queue[Int]): UIO[Nothing] =\n    queue.take\n      .flatMap(i => ZIO.debug(s"consumed: $i"))\n      .forever\n\n  def produce(queue: Queue[Int], latch: CountdownLatch): UIO[Nothing] =\n    (Random\n      .nextIntBounded(100)\n      .tap(i => queue.offer(i))\n      .tap(i => ZIO.when(i == 50)(latch.countDown)) *> ZIO.sleep(500.millis)).forever\n\n  def run =\n    for {\n      latch <- CountdownLatch.make(1)\n      queue <- Queue.unbounded[Int]\n      _     <- produce(queue, latch) <&> (latch.await *> consume(queue))\n    } yield ()\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"advanced-latches",children:"Advanced Latches"}),"\n",(0,i.jsxs)(n.p,{children:["We can solve more advanced problems by increasing the initial count of ",(0,i.jsx)(n.code,{children:"CountdownLatch"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Assume we had several producers concurrently in the previous example and the consumer was required to wait until at least five 50 numbers were added to the queue before they were allowed to consume. We can do this as follows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.concurrent._\n\nobject MainApp extends ZIOAppDefault {\n\n  def consume(queue: Queue[Int]): UIO[Nothing] =\n    queue.take\n      .flatMap(i => ZIO.debug(s"consumed: $i"))\n      .forever\n\n  def produce(queue: Queue[Int], latch: CountdownLatch): UIO[Nothing] =\n    (Random\n      .nextIntBounded(100)\n      .tap(i => queue.offer(i))\n      .tap(i => ZIO.when(i == 50)(latch.countDown)) *> ZIO.sleep(500.millis)).forever\n\n  def run =\n    for {\n      latch <- CountdownLatch.make(5)\n      queue <- Queue.unbounded[Int]\n      p = ZIO.collectAllParDiscard(ZIO.replicate(10)(produce(queue, latch)))\n      c = latch.await *> consume(queue)\n      _     <-  p <&> c\n    } yield ()\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"In this example, 10 producers are producing numbers concurrently, and the consumer is waiting for its condition to be fulfilled to start the consumption process."})]})}function u(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);