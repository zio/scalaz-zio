"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[70917],{14883:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"reference/service-pattern/the-three-laws-of-zio-environment","title":"The Three Laws of ZIO Environment","description":"When we are working with the ZIO environment, one question might arise: \\"When should we use environment and when do we need to use constructors?\\".","source":"@site/docs/reference/service-pattern/the-three-laws-of-zio-environment.md","sourceDirName":"reference/service-pattern","slug":"/reference/service-pattern/the-three-laws-of-zio-environment","permalink":"/reference/service-pattern/the-three-laws-of-zio-environment","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/service-pattern/the-three-laws-of-zio-environment.md","tags":[],"version":"current","frontMatter":{"id":"the-three-laws-of-zio-environment","title":"The Three Laws of ZIO Environment","sidebar_label":"Three Laws of ZIO Environment"},"sidebar":"reference-sidebar","previous":{"title":"Polymorphic Services","permalink":"/reference/service-pattern/defining-polymorphic-services-in-zio"},"next":{"title":"Reloadable Services","permalink":"/reference/service-pattern/reloadable-services"}}');var i=t(74848),r=t(28453);const o={id:"the-three-laws-of-zio-environment",title:"The Three Laws of ZIO Environment",sidebar_label:"Three Laws of ZIO Environment"},s=void 0,c={},l=[{value:"1. Service Interface (Trait)",id:"1-service-interface-trait",level:2},{value:"2. Service Implementation (Class)",id:"2-service-implementation-class",level:2},{value:"3. Business Logic",id:"3-business-logic",level:2}];function d(e){const n={admonition:"admonition",code:"code",em:"em",h2:"h2",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:'When we are working with the ZIO environment, one question might arise: "When should we use environment and when do we need to use constructors?".'}),"\n",(0,i.jsx)(n.p,{children:"Using ZIO environment follows three laws:"}),"\n",(0,i.jsx)(n.h2,{id:"1-service-interface-trait",children:"1. Service Interface (Trait)"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["When we are defining service interfaces we should ",(0,i.jsx)(n.em,{children:"never"})," use the environment for dependencies of the service itself."]})}),"\n",(0,i.jsxs)(n.p,{children:["For example, if the implementation of service ",(0,i.jsx)(n.code,{children:"X"})," depends on service ",(0,i.jsx)(n.code,{children:"Y"})," and ",(0,i.jsx)(n.code,{children:"Z"})," then these should never be reflected in the trait that defines service ",(0,i.jsx)(n.code,{children:"X"}),". It's leaking implementation details."]}),"\n",(0,i.jsxs)(n.p,{children:["So the following service definition is wrong because the ",(0,i.jsx)(n.code,{children:"BlobStorage"})," and ",(0,i.jsx)(n.code,{children:"MetadataRepo"})," services are dependencies of the  ",(0,i.jsx)(n.code,{children:"DocRepo"})," service's implementation, not the ",(0,i.jsx)(n.code,{children:"DocRepo"})," interface itself:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"import zio._\n\ntrait DocRepo {\n  def save(document: Doc): ZIO[BlobStorage & MetadataRepo, Throwable, String]\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"2-service-implementation-class",children:"2. Service Implementation (Class)"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"When implementing service interfaces, we should accept all dependencies in the class constructor."})}),"\n",(0,i.jsxs)(n.p,{children:["Again, let's see how ",(0,i.jsx)(n.code,{children:"DocRepoImpl"})," accepts ",(0,i.jsx)(n.code,{children:"BlobStorage"})," and ",(0,i.jsx)(n.code,{children:"MetadataRepo"})," dependencies from the class constructor:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"case class DocRepoImpl(\n    metadataRepo: MetadataRepo,\n    blobStorage: BlobStorage\n) extends DocRepo {\n  override def delete(id: String): ZIO[Any, Throwable, Unit] =\n    for {\n      _ <- blobStorage.delete(id)\n      _ <- metadataRepo.delete(id)\n    } yield ()\n\n  override def get(id: String): ZIO[Any, Throwable, Doc] = ???\n\n  override def save(document: Doc): ZIO[Any, Throwable, String] = ???\n\n  override def findByTitle(title: String): ZIO[Any, Throwable, List[Doc]] = ???\n}\n\nobject DocRepoImpl {\n  val layer: ZLayer[BlobStorage with MetadataRepo, Nothing, DocRepo] =\n    ZLayer {\n      for {\n        metadataRepo <- ZIO.service[MetadataRepo]\n        blobStorage  <- ZIO.service[BlobStorage]\n      } yield DocRepoImpl(metadataRepo, blobStorage)\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"So keep in mind, we can't do something like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"case class DocRepoImpl() extends DocRepo {\n  override def delete(id: String): ZIO[Any, Throwable, Unit] =\n    for {\n      blobStorage  <- ZIO.service[BlobStorage]\n      metadataRepo <- ZIO.service[MetadataRepo]\n      _            <- blobStorage.delete(id)\n      _            <- metadataRepo.delete(id)\n    } yield ()\n\n  override def get(id: String): ZIO[Any, Throwable, Doc] = ???\n\n  override def save(document: Doc): ZIO[Any, Throwable, String] = ???\n\n  override def findByTitle(title: String): ZIO[Any, Throwable, List[Doc]] = ???\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"3-business-logic",children:"3. Business Logic"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Finally, in the business logic we should use the ZIO environment to consume services."})}),"\n",(0,i.jsx)(n.p,{children:"Therefore, in the last example, if we inline all accessor methods whenever we are using services, we are using the ZIO environment:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport java.io.IOException\n\nobject MainApp extends ZIOAppDefault {\n  val app =\n    for {\n      id <-\n        ZIO.serviceWithZIO[DocRepo](_.save(\n          Doc(\n              "How to write a ZIO application?",\n              "In this tutorial we will learn how to write a ZIO application.",\n              "en",\n              "text/plain",\n              "content".getBytes()\n            )\n          )\n        )\n      doc <- ZIO.serviceWithZIO[DocRepo](_.get(id))\n      _ <- Console.printLine(\n        s"""\n          |Downloaded the document with $id id:\n          |  title: ${doc.title}\n          |  description: ${doc.description}\n          |  language: ${doc.language}\n          |  format: ${doc.format}\n          |""".stripMargin\n      )\n      _ <- ZIO.serviceWithZIO[DocRepo](_.delete(id))\n      _ <- Console.printLine(s"Deleted the document with $id id")\n    } yield ()\n\n  def run =\n    app.provide(\n      DocRepoImpl.layer,\n      InmemoryBlobStorage.layer,\n      InmemoryMetadataRepo.layer\n    )\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"That's it! These are the most important rules we need to know about the ZIO environment."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsx)(n.p,{children:"The remaining part of this section can be skipped if you are not an advanced ZIO user."})}),"\n",(0,i.jsxs)(n.p,{children:["Now let's elaborate more on the first rule. On rare occasions, all of which involve local context that is independent of implementation, it's ",(0,i.jsx)(n.em,{children:"acceptable"})," to use the environment in the definition of a service."]}),"\n",(0,i.jsx)(n.p,{children:"Here are two examples:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["In a web application, a service may be defined only to operate in the context of an HTTP request. In such a case, the request itself could be stored in the environment: ",(0,i.jsx)(n.code,{children:"ZIO[HttpRequest, ...]"}),". This is acceptable because this use of the environment is part of the semantics of the trait itself, rather than leaking an implementation detail of some particular class that implements the service trait:"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.stream._\nimport java.net.URI\nimport java.nio.charset.StandardCharsets\n\ntype HttpApp = ZIO[HttpRequest, Throwable, HttpResponse]\ntype HttpRoute = Map[String, HttpApp]\n\ncase class HttpRequest(method: Int,\n                       uri: URI,\n                       headers: Map[String, String],\n                       body: UStream[Byte])\n\ncase class HttpResponse(status: Int,\n                        headers: Map[String, String],\n                        body: UStream[Byte])\n\nobject HttpResponse {\n  def apply(status: Int, message: String): HttpResponse =\n    HttpResponse(\n      status = status,\n      headers = Map.empty,\n      body = ZStream.fromChunk(\n        Chunk.fromArray(message.getBytes(StandardCharsets.UTF_8))\n      )\n    )\n\n  def ok(msg: String): HttpResponse = HttpResponse(200, msg)\n\n  def error(msg: String): HttpResponse = HttpResponse(500, msg)\n}\n\ntrait HttpServer {\n  def serve(map: HttpRoute, host: String, port: Int): ZIO[Any, Throwable, Unit]\n}\n\nobject HttpServer {\n  def serve(map: HttpRoute, host: String, port: Int): ZIO[HttpServer, Throwable, Unit] =\n    ZIO.serviceWithZIO(_.serve(map, host, port))\n}\n\ncase class HttpServerLive() extends HttpServer {\n  override def serve(map: HttpRoute, host: String, port: Int): ZIO[Any, Throwable, Unit] = ???\n}\n\nobject HttpServerLive {\n  val layer: URLayer[Any, HttpServer] = ZLayer.succeed(HttpServerLive())\n}\n\nobject MainWebApp extends ZIOAppDefault {\n\n  val myApp: ZIO[HttpServer, Throwable, Unit] = for {\n    _ <- ZIO.unit\n    healthcheck: HttpApp = ZIO.service[HttpRequest].map { _ =>\n      HttpResponse.ok("up")\n    }\n\n    pingpong = ZIO.service[HttpRequest].flatMap { req =>\n      ZIO.ifZIO(\n        req.body.via(ZPipeline.utf8Decode).runHead.map(_.contains("ping"))\n      )(\n        onTrue = ZIO.attempt(HttpResponse.ok("pong")),\n        onFalse = ZIO.attempt(HttpResponse.error("bad request"))\n      )\n    }\n\n    map = Map(\n      "/healthcheck" -> healthcheck,\n      "/pingpong" -> pingpong\n    )\n    _ <- HttpServer.serve(map, "localhost", 8080)\n  } yield ()\n\n  def run = myApp.provideLayer(HttpServerLive.layer)\n\n}\n'})}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsxs)(n.li,{children:["In a database application, a service may be defined only to operate in the context of a larger database transaction. In such a case, the transaction could be stored in the environment: ",(0,i.jsx)(n.code,{children:"ZIO[DatabaseTransaction, ...]"}),". As in the previous example, because this is part of the semantics of the trait itself (whose functionality all operates within a transaction), this is not leaking implementation details, and therefore it is valid:"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'trait DatabaseTransaction {\n  def get(key: String): Task[Int]\n  def put(key: String, value: Int): Task[Unit]\n}\n\nobject DatabaseTransaction {\n  def get(key: String): ZIO[DatabaseTransaction, Throwable, Int] =\n    ZIO.serviceWithZIO(_.get(key))\n\n  def put(key: String, value: Int): ZIO[DatabaseTransaction, Throwable, Unit] =\n    ZIO.serviceWithZIO(_.put(key, value))\n}\n\ntrait Database {\n  def atomically[E, A](zio: ZIO[DatabaseTransaction, E, A]): ZIO[Any, E, A]\n}\n\nobject Database {\n  def atomically[E, A](zio: ZIO[DatabaseTransaction, E, A]): ZIO[Database, E, A] =\n    ZIO.serviceWithZIO(_.atomically(zio))\n}\n\ncase class DatabaseLive() extends Database {\n  override def atomically[E, A](zio: ZIO[DatabaseTransaction, E, A]): ZIO[Any, E, A] = ???\n}\n\nobject DatabaseLive {\n  val layer = ZLayer.succeed(DatabaseLive())\n}\n\nobject MainDatabaseApp extends ZIOAppDefault {\n  val myApp: ZIO[Database, Throwable, Unit] =\n    for {\n      _ <- Database.atomically(DatabaseTransaction.put("counter", 0))\n      _ <- ZIO.foreachPar(List(1 to 10)) { _ =>\n        Database.atomically(\n          for {\n            value <- DatabaseTransaction.get("counter")\n            _ <- DatabaseTransaction.put("counter", value + 1)\n          } yield ()\n        )\n      }\n    } yield ()\n\n  def run = myApp.provideLayer(DatabaseLive.layer)\n\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"So while it's better to err on the side of \"don't put things into the environment of service interface\", there are cases where it's acceptable."})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>s});var a=t(96540);const i={},r=a.createContext(i);function o(e){const n=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);