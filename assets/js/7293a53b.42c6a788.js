"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[17533],{28453:(e,r,t)=>{t.d(r,{R:()=>i,x:()=>o});var n=t(96540);const a={},s=n.createContext(a);function i(e){const r=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),n.createElement(s.Provider,{value:r},e.children)}},29693:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"reference/error-management/best-practices/algebraic-data-types","title":"Model Domain Errors Using Algebraic Data Types","description":"It is best to use algebraic data types (ADTs) when modeling errors within the same domain or subdomain.","source":"@site/docs/reference/error-management/best-practices/algebraic-data-types.md","sourceDirName":"reference/error-management/best-practices","slug":"/reference/error-management/best-practices/algebraic-data-types","permalink":"/reference/error-management/best-practices/algebraic-data-types","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/error-management/best-practices/algebraic-data-types.md","tags":[],"version":"current","frontMatter":{"id":"algebraic-data-types","title":"Model Domain Errors Using Algebraic Data Types","sidebar_label":"Algebraic Data Types"},"sidebar":"reference-sidebar","previous":{"title":"Zooming In on Nested Values","permalink":"/reference/error-management/operations/zooming-in-on-nested-values"},"next":{"title":"Union Types","permalink":"/reference/error-management/best-practices/union-types"}}');var a=t(74848),s=t(28453);const i={id:"algebraic-data-types",title:"Model Domain Errors Using Algebraic Data Types",sidebar_label:"Algebraic Data Types"},o=void 0,c={},l=[];function d(e){const r={code:"code",em:"em",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(r.p,{children:["It is best to use ",(0,a.jsx)(r.em,{children:"algebraic data types (ADTs)"})," when modeling errors within the same domain or subdomain."]}),"\n",(0,a.jsx)(r.p,{children:"Sealed traits allow us to introduce an error type as a common supertype and all errors within a domain are part of that error type by extending that:"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-scala",children:"sealed trait UserServiceError extends Exception\n\ncase class InvalidUserId(id: ID) extends UserServiceError\ncase class ExpiredAuth(id: ID)   extends UserServiceError\n"})}),"\n",(0,a.jsxs)(r.p,{children:["In this case, the super error type is ",(0,a.jsx)(r.code,{children:"UserServiceError"}),". We sealed that trait, and we extend it by two cases, ",(0,a.jsx)(r.code,{children:"InvalidUserId"})," and ",(0,a.jsx)(r.code,{children:"ExpiredAuth"}),". Because it is sealed, if we have a reference to a ",(0,a.jsx)(r.code,{children:"UserServiceError"})," we can match against it and the Scala compiler knows there are two possibilities for a ",(0,a.jsx)(r.code,{children:"UserServiceError"}),":"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-scala",children:"userServiceError match {\n  case InvalidUserId(id) => ???\n  case ExpiredAuth(id)   => ???\n}\n"})}),"\n",(0,a.jsxs)(r.p,{children:["This is a sum type, and also an enumeration. The Scala compiler knows only two of these ",(0,a.jsx)(r.code,{children:"UserServiceError"})," exist. If we don't match on all of them, it is going to warn us. We can add the ",(0,a.jsx)(r.code,{children:"-Xfatal-warnings"})," compiler option which treats warnings as errors. By turning on the fatal warning, we will have type-safety control on expected errors. So sealing these traits gives us great power."]}),"\n",(0,a.jsx)(r.p,{children:"Also extending all of our errors from a common supertype helps the ZIO's combinators like flatMap to auto widen to the most specific error type."}),"\n",(0,a.jsxs)(r.p,{children:["Let's say we have this for-comprehension here that calls the ",(0,a.jsx)(r.code,{children:"userAuth"})," function, and it can fail with ",(0,a.jsx)(r.code,{children:"ExpiredAuth"}),", and then we call ",(0,a.jsx)(r.code,{children:"userProfile"})," that fails with ",(0,a.jsx)(r.code,{children:"InvalidUserID"}),", and then we call ",(0,a.jsx)(r.code,{children:"generateEmail"})," that can't fail at all, and finally we call ",(0,a.jsx)(r.code,{children:"sendEmail"})," which can fail with ",(0,a.jsx)(r.code,{children:"EmailDeliveryError"}),". We have got a lot of different errors here:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-scala",children:'val myApp: IO[Exception, Receipt] =\n  for {\n    service <- userAuth(token)                // IO[ExpiredAuth, UserService]\n    profile <- service.userProfile(userId)    // IO[InvalidUserId, Profile]\n    body    <- generateEmail(orderDetails)    // IO[Nothing, String]\n    receipt <- sendEmail("Your order detail",\n       body, profile.email)                   // IO[EmailDeliveryError, Unit]\n  } yield receipt\n'})}),"\n",(0,a.jsxs)(r.p,{children:["In this example, the flatMap operations auto widens the error type to the most specific error type possible. As a result, the inferred error type of this for-comprehension will be ",(0,a.jsx)(r.code,{children:"Exception"})," which gives us the best information we could hope to get out of this. We have lost information about the particulars of this. We no longer know which of these error types it is. We know it is some type of ",(0,a.jsx)(r.code,{children:"Exception"})," which is more information than nothing."]})]})}function h(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,a.jsx)(r,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);