"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[52621],{33266:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>s,contentTitle:()=>c,default:()=>p,frontMatter:()=>d,metadata:()=>o,toc:()=>a});const o=JSON.parse('{"id":"reference/di/dependency-propagation","title":"Dependency Propagation","description":"When we write an application, our application has a lot of dependencies. We need a way to provide implementations and to feed and propagate all dependencies throughout the whole application. We can solve the propagation problem by using ZIO environment.","source":"@site/docs/reference/di/dependency-propagation.md","sourceDirName":"reference/di","slug":"/reference/di/dependency-propagation","permalink":"/reference/di/dependency-propagation","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/di/dependency-propagation.md","tags":[],"version":"current","frontMatter":{"id":"dependency-propagation","title":"Dependency Propagation"},"sidebar":"reference-sidebar","previous":{"title":"Automatic Layer Construction","permalink":"/reference/di/automatic-layer-construction"},"next":{"title":"Multiple Implementations","permalink":"/reference/di/providing-different-implementation-of-a-service"}}');var t=i(74848),r=i(28453);const d={id:"dependency-propagation",title:"Dependency Propagation"},c=void 0,s={},a=[{value:"Using <code>ZIO#provideEnvironment</code> Method",id:"using-zioprovideenvironment-method",level:2},{value:"Using <code>ZIO#provide</code> Method",id:"using-zioprovide-method",level:2},{value:"Using <code>ZIO#provideSome</code> Method",id:"using-zioprovidesome-method",level:2}];function l(e){const n={admonition:"admonition",code:"code",em:"em",h2:"h2",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["When we write an application, our application has a lot of dependencies. We need a way to provide implementations and to feed and propagate all dependencies throughout the whole application. We can solve the propagation problem by using ",(0,t.jsx)(n.em,{children:"ZIO environment"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["During the development of an application, we don't care about implementations. Incrementally, when we use various effects with different requirements on their environment, all parts of our application compose together, and at the end of the day we have a ZIO effect which requires some services as an environment. Before running this effect by ",(0,t.jsx)(n.code,{children:"unsafeRun"})," we should provide an implementation of these services into the ZIO Environment of that effect."]}),"\n",(0,t.jsxs)(n.p,{children:["ZIO has some facilities for doing this. ",(0,t.jsx)(n.code,{children:"ZIO#provide"})," is the core function that allows us to ",(0,t.jsx)(n.em,{children:"feed"})," an ",(0,t.jsx)(n.code,{children:"R"})," to an effect that requires an ",(0,t.jsx)(n.code,{children:"R"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Notice that the act of ",(0,t.jsx)(n.code,{children:"provide"}),"ing an effect with its environment, eliminates the environment dependency in the resulting effect type, represented by type ",(0,t.jsx)(n.code,{children:"Any"})," of the resulting environment."]}),"\n",(0,t.jsxs)(n.h2,{id:"using-zioprovideenvironment-method",children:["Using ",(0,t.jsx)(n.code,{children:"ZIO#provideEnvironment"})," Method"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"ZIO#provideEnvironment"})," takes an instance of ",(0,t.jsx)(n.code,{children:"ZEnvironment[R]"})," and provides it to the ",(0,t.jsx)(n.code,{children:"ZIO"})," effect which eliminates its dependency on ",(0,t.jsx)(n.code,{children:"R"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"trait ZIO[-R, +E, +A] {\n  def provideEnvironment(r: => ZEnvironment[R]): IO[E, A]\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This is similar to dependency injection, and the ",(0,t.jsx)(n.code,{children:"provide*"})," function can be thought of as ",(0,t.jsx)(n.em,{children:"inject"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Assume we have the following services:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"trait EmailService {\n  def send(email: String, content: String): UIO[Unit]\n}\n\nobject EmailService {\n  def send(email: String, content: String) = ZIO.serviceWithZIO[EmailService](_.send(email, content))\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Let's write a simple program using ",(0,t.jsx)(n.code,{children:"EmailService"})," service:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'val app: ZIO[EmailService, Nothing, Unit] = EmailService.send("john@doe.com", "Hello John!")\n'})}),"\n",(0,t.jsxs)(n.p,{children:["We can ",(0,t.jsx)(n.code,{children:"provide"})," implementation of ",(0,t.jsx)(n.code,{children:"EmailService"})," service into the ",(0,t.jsx)(n.code,{children:"app"})," effect:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"val loggingImpl = new EmailService {\n  override def send(email: String, content: String): UIO[Unit] = ???\n}\n\nval effect = app.provideEnvironment(ZEnvironment(loggingImpl))\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Most of the time, we don't use ",(0,t.jsx)(n.code,{children:"ZIO#provideEnvironment"})," directly to provide our services; instead, we use ",(0,t.jsx)(n.code,{children:"ZLayer"})," to construct the dependency graph of our application, then we use methods like ",(0,t.jsx)(n.code,{children:"ZIO#provide"}),", ",(0,t.jsx)(n.code,{children:"ZIO#provideSome"})," and ",(0,t.jsx)(n.code,{children:"ZIO#provideCustom"})," to propagate dependencies into the environment of our ZIO effect."]}),"\n",(0,t.jsxs)(n.h2,{id:"using-zioprovide-method",children:["Using ",(0,t.jsx)(n.code,{children:"ZIO#provide"})," Method"]}),"\n",(0,t.jsxs)(n.p,{children:["Unlike the ",(0,t.jsx)(n.code,{children:"ZIO#provideEnvironment"})," which takes a ",(0,t.jsx)(n.code,{children:"ZEnvironment[R]"}),", the ",(0,t.jsx)(n.code,{children:"ZIO#provide"})," takes a ",(0,t.jsx)(n.code,{children:"ZLayer"})," to the ZIO effect and translates it to another level."]}),"\n",(0,t.jsxs)(n.p,{children:["Assume we have written this piece of program that requires ",(0,t.jsx)(n.code,{children:"Foo"})," and ",(0,t.jsx)(n.code,{children:"Bar"})," services:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'trait Foo {\n  def foo(): UIO[String]\n}\n\nobject Foo {\n  def foo(): ZIO[Foo, Nothing, String] = ZIO.serviceWithZIO[Foo](_.foo())\n}\n\ncase class FooLive() extends Foo {\n  override def foo(): UIO[String] = ZIO.succeed("foo")\n}\n\nobject FooLive {\n  val layer: ULayer[Foo] = ZLayer.succeed(FooLive())\n}\n\ntrait Bar {\n  def bar(): UIO[Int]\n}\n\nobject Bar {\n  def bar(): ZIO[Bar, Nothing, Int] = ZIO.serviceWithZIO[Bar](_.bar())\n}\n\ncase class BarLive() extends Bar {\n  override def bar(): UIO[Int] = ZIO.succeed(1)\n}\n\nobject BarLive {\n  val layer: ULayer[Bar] = ZLayer.succeed(BarLive())\n}\n\nval myApp: ZIO[Foo & Bar, Nothing, Unit] = for {\n  foo  <- Foo.foo()\n  bar  <- Bar.bar()\n  _    <- ZIO.debug(s"foo: $foo, bar: $bar")\n} yield ()\n'})}),"\n",(0,t.jsxs)(n.p,{children:["We provide implementations of ",(0,t.jsx)(n.code,{children:"Foo"}),", ",(0,t.jsx)(n.code,{children:"Bar"})," services to the ",(0,t.jsx)(n.code,{children:"myApp"})," effect by using ",(0,t.jsx)(n.code,{children:"ZIO#provide"})," method:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"val mainEffect: ZIO[Any, Nothing, Unit] = \n  myApp.provide(FooLive.layer, BarLive.layer)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["As we see, the type of our effect converted from ",(0,t.jsx)(n.code,{children:"ZIO[Foo & Bar, Nothing, Unit]"})," which requires two services to ",(0,t.jsx)(n.code,{children:"ZIO[Any, Nothing, Unit]"})," effect which doesn't require any services."]}),"\n",(0,t.jsxs)(n.h2,{id:"using-zioprovidesome-method",children:["Using ",(0,t.jsx)(n.code,{children:"ZIO#provideSome"})," Method"]}),"\n",(0,t.jsxs)(n.p,{children:["Sometimes we have written a program, and we don't want to provide all its requirements. In these cases, we can use ",(0,t.jsx)(n.code,{children:"ZIO#provideSome"})," to partially apply some layers to the ",(0,t.jsx)(n.code,{children:"ZIO"})," effect."]}),"\n",(0,t.jsxs)(n.p,{children:["In the previous example, if we just want to provide the ",(0,t.jsx)(n.code,{children:"Foo"}),", we should use ",(0,t.jsx)(n.code,{children:"ZIO#provideSome"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"val mainEffectSome: ZIO[Bar, Nothing, Unit] = \n  myApp.provideSome(FooLive.layer)\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"caution",children:(0,t.jsxs)(n.p,{children:["When using ",(0,t.jsx)(n.code,{children:"ZIO#provideSome[R0]"}),", we should provide the remaining type as ",(0,t.jsx)(n.code,{children:"R0"})," type parameter. This workaround helps the compiler to infer the proper types."]})})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>d,x:()=>c});var o=i(96540);const t={},r=o.createContext(t);function d(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:d(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);