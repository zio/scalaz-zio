"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[13194],{28453:(e,n,a)=>{a.d(n,{R:()=>o,x:()=>r});var t=a(96540);const i={},s=t.createContext(i);function o(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(s.Provider,{value:n},e.children)}},81203:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"zio-schema/operations/dynamic-data-representation","title":"Dynamic Data Representation","description":"DynamicValue is a way to describe the entire universe of possibilities for schema values. It does that in a way that we can interact with and introspect the data with its structure (type information). The structure of the data is baked into the data itself.","source":"@site/docs/zio-schema/operations/dynamic-data-representation.md","sourceDirName":"zio-schema/operations","slug":"/zio-schema/operations/dynamic-data-representation","permalink":"/zio-schema/operations/dynamic-data-representation","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-schema/operations/dynamic-data-representation.md","tags":[],"version":"current","frontMatter":{"id":"dynamic-data-representation","title":"Dynamic Data Representation"},"sidebar":"ecosystem-sidebar","previous":{"title":"Schema Serialization","permalink":"/zio-schema/operations/schema-serialization"},"next":{"title":"Ordering Derivation","permalink":"/zio-schema/derivations/ordering-derivation"}}');var i=a(74848),s=a(28453);const o={id:"dynamic-data-representation",title:"Dynamic Data Representation"},r=void 0,c={},d=[{value:"Schema: Converting to/from DynamicValue",id:"schema-converting-tofrom-dynamicvalue",level:2},{value:"Manipulating Dynamic Values",id:"manipulating-dynamic-values",level:2}];function l(e){const n={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"DynamicValue is a way to describe the entire universe of possibilities for schema values. It does that in a way that we can interact with and introspect the data with its structure (type information). The structure of the data is baked into the data itself."}),"\n",(0,i.jsxs)(n.p,{children:["We can create a ",(0,i.jsx)(n.code,{children:"DynamicValue"})," from a schema and a value using ",(0,i.jsx)(n.code,{children:"DynamicValue.fromSchemaAndValue"})," (or ",(0,i.jsx)(n.code,{children:"Schema#toDynamic"}),"). We can turn it back into a typed value using ",(0,i.jsx)(n.code,{children:"DynamicValue#toTypedValue"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"trait DynamicValue {\n  def toTypedValue[A](implicit schema: Schema[A]): Either[String, A] =\n}\n\nobject DynamicValue {\n  def fromSchemaAndValue[A](schema: Schema[A], value: A): DynamicValue\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Let's create a simple instance of ",(0,i.jsx)(n.code,{children:'Person("John Doe", 42)'})," and convert it to ",(0,i.jsx)(n.code,{children:"DynamicValue"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'import zio.schema._\n\ncase class Person(name: String, age: Int)\n\nobject Person {\n  implicit val schema: Schema[Person] = DeriveSchema.gen[Person]\n}\n\nval person        = Person("John Doe", 42)\nval dynamicPerson = DynamicValue.fromSchemaAndValue(Person.schema, person)\n// or we can call `toDynamic` on the schema directly:\n// val dynamicPerson = Person.schema.toDynamic(person)\nprintln(dynamicPerson)\n'})}),"\n",(0,i.jsxs)(n.p,{children:["As we can see, the dynamic value of ",(0,i.jsx)(n.code,{children:"person"})," is the mixure of the data and its structure:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"// The output pretty printed manually\nRecord(\n  Nominal(Chunk(dev,zio,quickstart),Chunk(),Person),\n  ListMap(\n    name -> Primitive(John Doe,string),\n    age -> Primitive(42,int)\n  )\n)\n"})}),"\n",(0,i.jsx)(n.p,{children:"This is in contrast to the relational database model, where the data structure is stored in the database schema and the data itself is stored in a separate location."}),"\n",(0,i.jsx)(n.p,{children:"However, when we switch to document-based database models, such as JSON or XML, we can store both the data and its structure together. The JSON data model serves as a good example of self-describing data, as it allows us not only to include the data itself but also to add type information within the JSON. In this way, there is no need for a separate schema and data; everything is combined into a single entity."}),"\n",(0,i.jsx)(n.h2,{id:"schema-converting-tofrom-dynamicvalue",children:"Schema: Converting to/from DynamicValue"}),"\n",(0,i.jsxs)(n.p,{children:["With a ",(0,i.jsx)(n.code,{children:"Schema[A]"}),", we can convert any value of type ",(0,i.jsx)(n.code,{children:"A"})," to a ",(0,i.jsx)(n.code,{children:"DynamicValue"})," and conversely we can convert it back to ",(0,i.jsx)(n.code,{children:"A"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"sealed trait Schema[A] {\n  def toDynamic(value: A): DynamicValue\n\n  def fromDynamic(value: DynamicValue): scala.util.Either[String, A]\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"toDynamic"})," operation erases the type information of the value and places it into the value (the dynamic value) itself. The ",(0,i.jsx)(n.code,{children:"fromDynamic"})," operation does the opposite: it takes the type information from the dynamic value and uses it to reconstruct the original value."]}),"\n",(0,i.jsxs)(n.p,{children:["Please note that, if we have two types ",(0,i.jsx)(n.code,{children:"A"})," and ",(0,i.jsx)(n.code,{children:"B"})," that are isomorphic, we can convert a dynamic value of type ",(0,i.jsx)(n.code,{children:"A"})," to a typed value of type ",(0,i.jsx)(n.code,{children:"B"})," and vice versa:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'import zio.schema._\n\ncase class Person(name: String, age: Int)\n\nobject Person {\n  implicit val schema: Schema[Person] = DeriveSchema.gen\n}\n\ncase class User(name: String, age: Int)\n\nobject User {\n  implicit val schema: Schema[User] = DeriveSchema.gen\n}\n\nval johnPerson = Person("John Doe", 42)\nval johnUser   = User("John Doe", 42)\n\nval dynamicJohnPerson = Person.schema.toDynamic(johnPerson)\nval dynamicJohnUser   = User.schema.toDynamic(johnUser)\n\nprintln(dynamicJohnPerson)\n// Output: Record(Nominal(Chunk(dev,zio,quickstart),Chunk(Main),Person),ListMap(name -> Primitive(John Doe,string), age -> Primitive(42,int)))\nprintln(dynamicJohnUser)\n// Output: Record(Nominal(Chunk(dev,zio,quickstart),Chunk(Main),User),ListMap(name -> Primitive(John Doe,string), age -> Primitive(42,int)))\n\nassert(dynamicJohnPerson.toTypedValue[User] == Right(johnUser))\nassert(dynamicJohnUser.toTypedValue[Person] == Right(johnPerson))\n'})}),"\n",(0,i.jsx)(n.h2,{id:"manipulating-dynamic-values",children:"Manipulating Dynamic Values"}),"\n",(0,i.jsxs)(n.p,{children:["When we turn a typed value ",(0,i.jsx)(n.code,{children:"A"})," into a ",(0,i.jsx)(n.code,{children:"DynamicValue"}),", we can manipulate its structure and data dynamically. For example, we can add a new field to a record or change the type of a field. This process is called dynamic value migration, which we will discuss in the ",(0,i.jsx)(n.a,{href:"/zio-schema/operations/schema-migration",children:"schema migration"})," section."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}}}]);