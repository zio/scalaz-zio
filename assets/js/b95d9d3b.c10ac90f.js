"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[70067],{56506:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"reference/error-management/best-practices/unexpected-errors","title":"Don\'t Type Unexpected Errors","description":"When we first discover typed errors, it may be tempting to put every error into the error type parameter. That is a mistake because we can\'t recover from all types of errors. When we encounter unexpected errors we can\'t do anything in those cases. We should let the application die. Let it crash is the erlang philosophy. It is a good philosophy for all unexpected errors. At best, we can sandbox it, but we should let it crash.","source":"@site/docs/reference/error-management/best-practices/dont-type-unexpected-errors.md","sourceDirName":"reference/error-management/best-practices","slug":"/reference/error-management/best-practices/unexpected-errors","permalink":"/reference/error-management/best-practices/unexpected-errors","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/error-management/best-practices/dont-type-unexpected-errors.md","tags":[],"version":"current","frontMatter":{"id":"unexpected-errors","title":"Don\'t Type Unexpected Errors"},"sidebar":"reference-sidebar","previous":{"title":"Union Types","permalink":"/reference/error-management/best-practices/union-types"},"next":{"title":"Don\'t Reflexively Log Errors","permalink":"/reference/error-management/best-practices/logging-errors"}}');var o=t(74848),s=t(28453);const a={id:"unexpected-errors",title:"Don't Type Unexpected Errors"},i=void 0,c={},l=[];function h(e){const r={code:"code",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(r.p,{children:"When we first discover typed errors, it may be tempting to put every error into the error type parameter. That is a mistake because we can't recover from all types of errors. When we encounter unexpected errors we can't do anything in those cases. We should let the application die. Let it crash is the erlang philosophy. It is a good philosophy for all unexpected errors. At best, we can sandbox it, but we should let it crash."}),"\n",(0,o.jsx)(r.p,{children:"The context of a domain determines whether an error is expected or unexpected. When using typed errors, sometimes it is necessary to make a typed-error un-typed because in that case, we can't handle the error, and we should let the application crash."}),"\n",(0,o.jsxs)(r.p,{children:["For example, in the following example, we don't want to handle the ",(0,o.jsx)(r.code,{children:"IOException"})," so we can call ",(0,o.jsx)(r.code,{children:"ZIO#orDie"})," to make the effect's failure unchecked. This will translate effect's failure to the death of the fiber running it:"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-scala",children:'import zio._\n\nConsole.printLine("Hello, World") // ZIO[Any, IOException, Unit]\n  .orDie                          // ZIO[Any, Nothing, Unit]\n'})}),"\n",(0,o.jsxs)(r.p,{children:["If we have an effect that fails for some ",(0,o.jsx)(r.code,{children:"Throwable"})," we can pick certain recoverable errors out of that, and then we can just let the rest of them kill the fiber that is running that effect. The ZIO effect has a method called ",(0,o.jsx)(r.code,{children:"ZIO#refineOrDie"})," that allows us to do that."]}),"\n",(0,o.jsxs)(r.p,{children:["In the following example, calling ",(0,o.jsx)(r.code,{children:"ZIO#refineOrDie"})," on an effect that has an error type ",(0,o.jsx)(r.code,{children:"Throwable"})," allows us to refine it to have an error type of ",(0,o.jsx)(r.code,{children:"TemporaryUnavailable"}),":"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-scala",children:"import zio._\n\nval response: ZIO[Any, Nothing, Response] =\n  ZIO\n    .attemptBlocking(\n      httpClient.fetchUrl(url)\n    ) // ZIO[Any, Throwable, Response]\n    .refineOrDie[TemporaryUnavailable] {\n      case e: TemporaryUnavailable => e\n    } // ZIO[Any, TemporaryUnavailable, Response]\n    .retry(\n      Schedule.fibonacci(1.second)\n    ) // ZIO[Any, TemporaryUnavailable, Response]\n    .orDie // ZIO[Any, Nothing, Response]\n"})}),"\n",(0,o.jsxs)(r.p,{children:["In this example, we are importing the ",(0,o.jsx)(r.code,{children:"fetchUrl"})," which is a blocking operation into a ",(0,o.jsx)(r.code,{children:"ZIO"})," value. We know that in case of a service outage it will throw the ",(0,o.jsx)(r.code,{children:"TemporaryUnavailable"})," exception. This is an expected error, so we want that to be typed. We are going to reflect that in the error type. We only expect it, so we know how to recover from it."]}),"\n",(0,o.jsxs)(r.p,{children:["Also, this operation may throw unexpected errors like ",(0,o.jsx)(r.code,{children:"OutOfMemoryError"}),", ",(0,o.jsx)(r.code,{children:"StackOverflowError"}),", and so forth. Therefore, we don't include these errors since we won't be handling them at runtime. They are defects, and in case of unexpected errors, we should let the application crash."]}),"\n",(0,o.jsxs)(r.p,{children:["Therefore, it is quite common to import a code that may throw exceptions, whether that uses expected errors for error handling or can fail for a wide variety of unexpected errors like disk unavailable, service unavailable, and so on. Generally, importing these operations end up represented as a ",(0,o.jsx)(r.code,{children:"Task"})," (",(0,o.jsx)(r.code,{children:"ZIO[Any, Throwable, A]"}),"). So in order to make recoverable errors typed, we use the ",(0,o.jsx)(r.code,{children:"ZIO#refineOrDie"})," method."]})]})}function d(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,o.jsx)(r,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},28453:(e,r,t)=>{t.d(r,{R:()=>a,x:()=>i});var n=t(96540);const o={},s=n.createContext(o);function a(e){const r=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),n.createElement(s.Provider,{value:r},e.children)}}}]);