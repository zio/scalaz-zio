"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[97792],{28453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>t});var o=s(96540);const i={},a=o.createContext(i);function r(e){const n=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),o.createElement(a.Provider,{value:n},e.children)}},56709:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>t,default:()=>p,frontMatter:()=>r,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"zio-json/configuration","title":"Configuration","description":"Field naming","source":"@site/docs/zio-json/configuration.md","sourceDirName":"zio-json","slug":"/zio-json/configuration","permalink":"/zio-json/configuration","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-json/configuration.md","tags":[],"version":"current","frontMatter":{"id":"configuration","title":"Configuration"},"sidebar":"ecosystem-sidebar","previous":{"title":"Encoding","permalink":"/zio-json/encoding"},"next":{"title":"Manual Instances","permalink":"/zio-json/manual-instances"}}');var i=s(74848),a=s(28453);const r={id:"configuration",title:"Configuration"},t=void 0,l={},c=[{value:"Field naming",id:"field-naming",level:2},{value:"jsonDiscriminator",id:"jsondiscriminator",level:2},{value:"Extra fields",id:"extra-fields",level:2},{value:"Aliases",id:"aliases",level:2},{value:"Nulls, explicitNulls",id:"nulls-explicitnulls",level:2},{value:"Empty Collections, explicitEmptyCollections",id:"empty-collections-explicitemptycollections",level:2},{value:"@jsonDerive",id:"jsonderive",level:2}];function d(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"field-naming",children:"Field naming"}),"\n",(0,i.jsxs)(n.p,{children:["By default, the field names of a case class are used as the JSON fields, but it is easy to override this with an annotation ",(0,i.jsx)(n.code,{children:"@jsonField"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Moreover, you can also mark a whole case class with a member name transformation that will be applied to all members using ",(0,i.jsx)(n.code,{children:"@jsonMemberNames"})," annotation. It takes an argument of type ",(0,i.jsx)(n.code,{children:"JsonMemberFormat"})," which encodes the transformation that will be applied to member names."]}),"\n",(0,i.jsxs)(n.p,{children:["Four most popular transformations are already provided: KebabCase, SnakeCase, PascalCase and CamelCase. If you require something more specific you can also use CustomCase which takes a function of shape ",(0,i.jsx)(n.code,{children:"String => String"})," as an argument and can be used to perform any arbitrary transformation. ",(0,i.jsx)(n.code,{children:"@jsonField"})," annotation takes priority over the transformation defined by ",(0,i.jsx)(n.code,{children:"@jsonMemberNames"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Here's an example json with most fields snake_cased and one kebab-cased:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "passion_fruit": true,\n  "granny_smith": true,\n  "dragon_fruit": true,\n  "blood-orange": false\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"And here's the target case class:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'import zio.json._\n\n@jsonMemberNames(SnakeCase)\ncase class FruitBasket(\n  passionFruit: Boolean, \n  grannySmith: Boolean, \n  dragonFruit: Boolean, \n  @jsonField("blood-orange") bloodOrange: Boolean\n)\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Notice that all fields are camelCased in Scala and will be both encoded and decoded correctly to snake_case in JSON except ",(0,i.jsx)(n.code,{children:"bloodOrange"})," field that is annotated with a ",(0,i.jsx)(n.code,{children:"@jsonField"})," override that will force it to become ",(0,i.jsx)(n.code,{children:'"blood-orange"'})," after serialization."]}),"\n",(0,i.jsxs)(n.p,{children:["It is also possible to change the type hint that is used to discriminate case classes with ",(0,i.jsx)(n.code,{children:"@jsonHint"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["For example, these annotations change the expected JSON of our ",(0,i.jsx)(n.code,{children:"Fruit"})," family"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'import zio.json._\n\nsealed trait Fruit\n\n@jsonHint("banaani") case class Banana(\n  @jsonField("bendiness") curvature: Double\n) extends Fruit\n\n@jsonHint("omena") case class Apple(\n  @jsonField("bad") poison: Boolean\n) extends Fruit\n\nobject Fruit {\n  implicit val codec: JsonCodec[Fruit] =\n    DeriveJsonCodec.gen[Fruit]\n}\n\nval banana: Fruit = Banana(0.5)\n// banana: Fruit = Banana(curvature = 0.5)\nval apple: Fruit = Apple(false)\n// apple: Fruit = Apple(poison = false)\n'})}),"\n",(0,i.jsx)(n.p,{children:"from"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{"Banana":{"curvature":0.5}}\n{"Apple":{"poison":false}}\n'})}),"\n",(0,i.jsx)(n.p,{children:"to"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'banana.toJson\n// res1: String = {"banaani":{"bendiness":0.5}}\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'apple.toJson\n// res2: String = {"omena":{"bad":false}}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Another way of changing type hint is using ",(0,i.jsx)(n.code,{children:"@jsonHintNames"})," annotation on sealed class. It allows to apply transformation\nto all type hint values in hierarchy. Same transformations are provided as for ",(0,i.jsx)(n.code,{children:"@jsonMemberNames"})," annotation."]}),"\n",(0,i.jsx)(n.p,{children:"Here's an example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'import zio.json._\n\n@jsonHintNames(SnakeCase)\nsealed trait FruitKind\n\ncase class GoodFruit(good: Boolean) extends FruitKind\n\ncase class BadFruit(bad: Boolean) extends FruitKind\n\nobject FruitKind {\n  implicit val codec: JsonCodec[FruitKind] =\n    DeriveJsonCodec.gen[FruitKind]\n}\n\nval goodFruit: FruitKind = GoodFruit(true)\n// goodFruit: FruitKind = GoodFruit(good = true)\nval badFruit: FruitKind = BadFruit(true)\n// badFruit: FruitKind = BadFruit(bad = true)\n\ngoodFruit.toJson\n// res3: String = "{\\"good_fruit\\":{\\"good\\":true}}"\nbadFruit.toJson\n// res4: String = "{\\"bad_fruit\\":{\\"bad\\":true}}"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Note that with this code, you can't directly decode the subclasses of ",(0,i.jsx)(n.code,{children:"FruitKind"}),". You would need to create a dedicated decoder for each subclass."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"object GoodFruit {\n  implicit val codec: JsonCodec[GoodFruit] =\n    DeriveJsonCodec.gen[GoodFruit]\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Since ",(0,i.jsx)(n.code,{children:"GoodFruit"})," is only a case class, it will not require any kind of discriminator to be decoded."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'"""{"good":true}""".fromJson[GoodFruit]\n// res5: Either[String, GoodFruit] = Right(value = GoodFruit(good = true))\n'})}),"\n",(0,i.jsxs)(n.p,{children:["If you want for some reason to decode only for a specific type of ",(0,i.jsx)(n.code,{children:"FruitKind"})," that has a discriminator, don't derive the codec for the subtype, but transform the ",(0,i.jsx)(n.code,{children:"FruitKind"})," codec."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'object BadFruit {\n  implicit val decoder: JsonDecoder[BadFruit] =\n    FruitKind.codec.decoder.mapOrFail {\n        case GoodFruit(_) => Left("Expected BadFruit, got GoodFruit")\n        case BadFruit(bad) => Right(BadFruit(bad))\n      }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"jsondiscriminator",children:"jsonDiscriminator"}),"\n",(0,i.jsx)(n.p,{children:"A popular alternative way to encode sealed traits:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{"type":"banaani", "bendiness":0.5}\n\n{"type":"omena", "bad":false}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["is discouraged for performance reasons. However, if we have no choice in the matter, it may be accommodated with the ",(0,i.jsx)(n.code,{children:"@jsonDiscriminator"})," annotation"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'@jsonDiscriminator("type") sealed trait Fruit\n'})}),"\n",(0,i.jsx)(n.h2,{id:"extra-fields",children:"Extra fields"}),"\n",(0,i.jsxs)(n.p,{children:["We can raise an error if we encounter unexpected fields by using the ",(0,i.jsx)(n.code,{children:"@jsonNoExtraFields"})," annotation on a case class."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"@jsonNoExtraFields case class Watermelon(pips: Int)\n\nobject Watermelon {\n  implicit val decoder: JsonDecoder[Watermelon] =\n    DeriveJsonDecoder.gen[Watermelon]\n}\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'"""{ "pips": 32 }""".fromJson[Watermelon]\n// res7: Either[String, Watermelon] = Right(value = Watermelon(pips = 32))\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'"""{ "pips": 32, "color": "yellow" }""".fromJson[Watermelon]\n// res8: Either[String, Watermelon] = Left(value = "(invalid extra field)")\n'})}),"\n",(0,i.jsx)(n.h2,{id:"aliases",children:"Aliases"}),"\n",(0,i.jsx)(n.p,{children:"Since zio-json 0.4.3."}),"\n",(0,i.jsxs)(n.p,{children:["After a case class field has changed name, you may still want to read JSON documents that use the old name. This is supported by the ",(0,i.jsx)(n.code,{children:"@jsonAliases"})," annotation."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'case class Strawberry(\n  @jsonAliases("seeds") seedCount: Int\n)\n\nobject Strawberry {\n  implicit val decoder: JsonDecoder[Strawberry] =\n    DeriveJsonDecoder.gen[Strawberry]\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"The following two expressions result in an equal value:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'"""{ "seeds": 32 }""".fromJson[Strawberry]\n// res9: Either[String, Strawberry] = Right(value = Strawberry(seedCount = 32))\n"""{ "seedCount": 32 }""".fromJson[Strawberry]\n// res10: Either[String, Strawberry] = Right(\n//   value = Strawberry(seedCount = 32)\n// )\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"@jsonAliases"})," annotation supports multiple aliases. The annotation has no effect on encoding."]}),"\n",(0,i.jsx)(n.h2,{id:"nulls-explicitnulls",children:"Nulls, explicitNulls"}),"\n",(0,i.jsxs)(n.p,{children:["By default ",(0,i.jsx)(n.code,{children:"null"})," values are omitted from the JSON output. This behavior can be changed by using the ",(0,i.jsx)(n.code,{children:"@jsonExplicitNull"})," annotation on a case class, field or setting ",(0,i.jsx)(n.code,{children:"JsonCodecConfiguration.explicitNulls"})," to ",(0,i.jsx)(n.code,{children:"true"}),".\nMissing nulls on decoding are always allowed."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"@jsonExplicitNull\ncase class Mango(ripeness: Option[Int])\n\nobject Mango {\n  implicit val codec: JsonCodec[Mango] = DeriveJsonCodec.gen[Mango]\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The following expression results in a JSON document with a ",(0,i.jsx)(n.code,{children:"null"})," value:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'Mango(None).toJson\n// res11: String = "{\\"ripeness\\":null}"\n"""{}""".fromJson[Mango]\n// res12: Either[String, Mango] = Right(value = Mango(ripeness = None))\n'})}),"\n",(0,i.jsx)(n.h2,{id:"empty-collections-explicitemptycollections",children:"Empty Collections, explicitEmptyCollections"}),"\n",(0,i.jsxs)(n.p,{children:["By default ",(0,i.jsx)(n.code,{children:"empty collections"})," (all supported collection types and case classes) are included from the JSON output an decoding requires empty collections to be present. This behavior can be changed by using the ",(0,i.jsx)(n.code,{children:"@jsonExplicitEmptyCollections(encoding = false, decoding = false)"})," annotation on a case class, field or setting ",(0,i.jsx)(n.code,{children:"JsonCodecConfiguration.explicitEmptyCollections"})," to ",(0,i.jsx)(n.code,{children:"ExplicitEmptyCollections(encoding = false, decoding = false)"}),". The result is that empty collections are omitted from the JSON output and when decoding empty collections are created. It is also possible to have different values for encoding and decoding by using ",(0,i.jsx)(n.code,{children:"@jsonExplicitEmptyCollections(encoding = true, decoding = false)"})," or ",(0,i.jsx)(n.code,{children:"@jsonExplicitEmptyCollections(encoding = false, decoding = true)"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"@jsonExplicitEmptyCollections(encoding = false, decoding = false)\ncase class Pineapple(leaves: List[String])\n\nobject Pineapple {\n  implicit val codec: JsonCodec[Pineapple] = DeriveJsonCodec.gen[Pineapple]\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"The following expression results in a JSON document with an empty collection:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'Pineapple(Nil).toJson\n// res13: String = "{}"\n"""{}""".fromJson[Pineapple]\n// res14: Either[String, Pineapple] = Right(value = Pineapple(leaves = List()))\n'})}),"\n",(0,i.jsx)(n.h2,{id:"jsonderive",children:"@jsonDerive"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Requires zio-json-macros"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"@jsonDerive"})," allows to reduce that needs to be written using an annotation macro to generate JsonDecoder/JsonEncoder at build-time."]}),"\n",(0,i.jsx)(n.p,{children:"For generating both Encoder and Decoder, simply use jsonDerive"}),"\n",(0,i.jsx)(n.p,{children:"For example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"import zio.json._\n\n@jsonDerive case class Watermelon(pips: Int)\n"})}),"\n",(0,i.jsx)(n.p,{children:"It is equivalent to:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"import zio.json._\n\ncase class Watermelon(pips: Int)\n\nobject Watermelon {\n  implicit val codec: JsonCodec[Watermelon] =\n    DeriveJsonCodec.gen[Watermelon]\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"To generate only an encoder, we can set it as config parameter:"}),"\n",(0,i.jsx)(n.p,{children:"For example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"import zio.json._\n\n@jsonDerive(JsonDeriveConfig.Encoder) case class Watermelon(pips: Int)\n"})}),"\n",(0,i.jsx)(n.p,{children:"It is equivalent to:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"import zio.json._\n\ncase class Watermelon(pips: Int)\n\nobject Watermelon {\n  implicit val encoder: JsonEncoder[Watermelon] =\n    DeriveJsonEncoder.gen[Watermelon]\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"To generate only a decoder, we can set it as config parameter:"}),"\n",(0,i.jsx)(n.p,{children:"For example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",metastring:"modc:compile-only",children:"import zio.json._\n\n@jsonDerive(JsonDeriveConfig.Decoder) case class Watermelon(pips: Int)\n"})}),"\n",(0,i.jsx)(n.p,{children:"It is equivalent to:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"import zio.json._\n\ncase class Watermelon(pips: Int)\n\nobject Watermelon {\n  implicit val decoder: JsonDecoder[Watermelon] =\n    DeriveJsonDecoder.gen[Watermelon]\n}\n"})})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);