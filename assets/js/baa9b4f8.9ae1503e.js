"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[93150],{19748:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>h,contentTitle:()=>c,default:()=>o,frontMatter:()=>d,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"guides/use-test-assertions","title":"How to Use Test Assertions","description":"Using the Assertion type effectively often involves finding the best fitting","source":"@site/versioned_docs/version-1.0.18/guides/use-test-assertions.md","sourceDirName":"guides","slug":"/guides/use-test-assertions","permalink":"/1.0.18/guides/use-test-assertions","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/versioned_docs/version-1.0.18/guides/use-test-assertions.md","tags":[],"version":"1.0.18","frontMatter":{"id":"use-test-assertions","title":"How to Use Test Assertions"},"sidebar":"overview_sidebar","previous":{"title":"Guides","permalink":"/1.0.18/guides/"},"next":{"title":"How to Test effects?","permalink":"/1.0.18/guides/test-effects"}}');var i=t(74848),r=t(28453);const d={id:"use-test-assertions",title:"How to Use Test Assertions"},c="Values",h={},l=[{value:"Any",id:"any",level:2},{value:"A",id:"a",level:2},{value:"Numeric",id:"numeric",level:2},{value:"Ordering",id:"ordering",level:2},{value:"Ordering",id:"ordering-1",level:2},{value:"Seq",id:"seq",level:2}];function a(e){const s={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(s.p,{children:["Using the ",(0,i.jsx)(s.code,{children:"Assertion"})," type effectively often involves finding the best fitting\nfunction for the type of assumptions you would like to verify."]}),"\n",(0,i.jsxs)(s.p,{children:["This list is intended to break up the available functions into groups based on\nthe ",(0,i.jsx)(s.em,{children:"Result type"}),". The types of the functions are included as well, to guide\nintuition."]}),"\n",(0,i.jsxs)(s.p,{children:["For instance, if we wanted to assert that the fourth element of a ",(0,i.jsx)(s.code,{children:"Vector[Int]"}),"\nwas a value equal to the number ",(0,i.jsx)(s.code,{children:"5"}),", we would first look at assertions that\noperate on ",(0,i.jsx)(s.code,{children:"Seq[A]"}),", with the type ",(0,i.jsx)(s.code,{children:"Assertion[Seq[A]]"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["For this example, I would select ",(0,i.jsx)(s.code,{children:"hasAt"}),", as it accepts both the position into\na sequence, as well as an ",(0,i.jsx)(s.code,{children:"Assertion[A]"})," to apply at that position:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-scala",children:"Assertion.hasAt[A](pos: Int)(assertion: Assertion[A]): Assertion[Seq[A]]\n"})}),"\n",(0,i.jsx)(s.p,{children:"I could start by writing:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-scala",children:'val xs = Vector(0, 1, 2, 3)\n// xs: Vector[Int] = Vector(0, 1, 2, 3)\n\ntest("Fourth value is equal to 5") {\n  assert(xs)(hasAt(3)(???))\n}\n// res1: ZSpec[Any, Nothing] = Spec(\n//   caseValue = LabeledCase(\n//     label = "Fourth value is equal to 5",\n//     spec = Spec(\n//       caseValue = TestCase(\n//         test = <function1>,\n//         annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(use-test-assertions.md,20)))\n//       )\n//     )\n//   )\n// )\n'})}),"\n",(0,i.jsxs)(s.p,{children:["The second parameter to ",(0,i.jsx)(s.code,{children:"hasAt"})," is an ",(0,i.jsx)(s.code,{children:"Assertion[A]"})," that applies to the third\nelement of that sequence, so I would look for functions that operate on ",(0,i.jsx)(s.code,{children:"A"}),",\nof the return type ",(0,i.jsx)(s.code,{children:"Assertion[A]"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["I could select ",(0,i.jsx)(s.code,{children:"equalTo"}),", as it accepts an ",(0,i.jsx)(s.code,{children:"A"})," as a parameter, allowing me to\nsupply ",(0,i.jsx)(s.code,{children:"5"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-scala",children:'val xs = Vector(0, 1, 2, 3)\n// xs: Vector[Int] = Vector(0, 1, 2, 3)\n\ntest("Fourth value is equal to 5") {\n  assert(xs)(hasAt(3)(equalTo(5)))\n}\n// res3: ZSpec[Any, Nothing] = Spec(\n//   caseValue = LabeledCase(\n//     label = "Fourth value is equal to 5",\n//     spec = Spec(\n//       caseValue = TestCase(\n//         test = <function1>,\n//         annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(use-test-assertions.md,40)))\n//       )\n//     )\n//   )\n// )\n'})}),"\n",(0,i.jsxs)(s.p,{children:["Let's say this is too restrictive, and I would prefer to assert that a value is\n",(0,i.jsx)(s.em,{children:"near"})," the number five, with a tolerance of two. This requires a little more\nknowledge of the type ",(0,i.jsx)(s.code,{children:"A"}),", so I'll look for an assertion in the ",(0,i.jsx)(s.code,{children:"Numeric"}),"\nsection. ",(0,i.jsx)(s.code,{children:"approximatelyEquals"})," looks like what we want, as it permits the\nstarting value ",(0,i.jsx)(s.code,{children:"reference"}),", as well as a ",(0,i.jsx)(s.code,{children:"tolerance"}),", for any ",(0,i.jsx)(s.code,{children:"A"})," that is\n",(0,i.jsx)(s.code,{children:"Numeric"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-scala",children:"Assertion.approximatelyEquals[A: Numeric](reference: A, tolerance: A): Assertion[A]\n"})}),"\n",(0,i.jsxs)(s.p,{children:["Changing out ",(0,i.jsx)(s.code,{children:"equalTo"})," with ",(0,i.jsx)(s.code,{children:"approximatelyEquals"})," leaves us with:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-scala",children:'val xs = Vector(0, 1, 2, 3)\n// xs: Vector[Int] = Vector(0, 1, 2, 3)\n\ntest("Fourth value is approximately equal to 5") {\n  assert(xs)(hasAt(3)(approximatelyEquals(5, 2)))\n}\n// res5: ZSpec[Any, Nothing] = Spec(\n//   caseValue = LabeledCase(\n//     label = "Fourth value is approximately equal to 5",\n//     spec = Spec(\n//       caseValue = TestCase(\n//         test = <function1>,\n//         annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(use-test-assertions.md,60)))\n//       )\n//     )\n//   )\n// )\n'})}),"\n",(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"values",children:"Values"})}),"\n",(0,i.jsx)(s.p,{children:"Assertions that apply to plain values."}),"\n",(0,i.jsx)(s.h2,{id:"any",children:"Any"}),"\n",(0,i.jsxs)(s.p,{children:["Assertions that apply to ",(0,i.jsx)(s.code,{children:"Any"})," value."]}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Function"}),(0,i.jsx)(s.th,{children:"Result type"}),(0,i.jsx)(s.th,{children:"Description"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"anything"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Any]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that always succeeds."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"isNull"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Any]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires a null value."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"isSubtype[A](assertion: Assertion[A])(implicit C: ClassTag[A])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Any]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires a value have the specified type."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"nothing"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Any]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that always fails."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"throwsA[E: ClassTag]"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Any]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires the expression to throw."})]})]})]}),"\n",(0,i.jsx)(s.h2,{id:"a",children:"A"}),"\n",(0,i.jsx)(s.p,{children:"Assertions that apply to specific values."}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Function"}),(0,i.jsx)(s.th,{children:"Result type"}),(0,i.jsx)(s.th,{children:"Description"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"equalTo[A](expected: A)"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[A]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires a value equal the specified value."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"hasField[A, B](name: String, proj: A => B, assertion: Assertion[B])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[A]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that focuses in on a field in a case class."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"isOneOf[A](values: Iterable[A])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[A]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires a value to be equal to one of the specified values."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"not[A](assertion: Assertion[A])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[A]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that negates the specified assertion."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"throws[A](assertion: Assertion[Throwable])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[A]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires the expression to throw."})]})]})]}),"\n",(0,i.jsx)(s.h2,{id:"numeric",children:"Numeric"}),"\n",(0,i.jsxs)(s.p,{children:["Assertions on ",(0,i.jsx)(s.code,{children:"Numeric"})," types"]}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Function"}),(0,i.jsx)(s.th,{children:"Result type"}),(0,i.jsx)(s.th,{children:"Description"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"approximatelyEquals[A: Numeric](reference: A, tolerance: A)"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[A]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires a given numeric value to match a value with some tolerance."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"isNegative[A](implicit num: Numeric[A])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[A]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires a numeric value is negative."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"isPositive[A](implicit num: Numeric[A])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[A]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires a numeric value is positive."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"isZero[A](implicit num: Numeric[A])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[A]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires a numeric value is zero."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"nonNegative[A](implicit num: Numeric[A])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[A]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires a numeric value is non negative."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"nonPositive[A](implicit num: Numeric[A])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[A]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires a numeric value is non positive."})]})]})]}),"\n",(0,i.jsx)(s.h2,{id:"ordering",children:"Ordering"}),"\n",(0,i.jsxs)(s.p,{children:["Assertions on types that support ",(0,i.jsx)(s.code,{children:"Ordering"})]}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Function"}),(0,i.jsx)(s.th,{children:"Result type"}),(0,i.jsx)(s.th,{children:"Description"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"isGreaterThan[A](reference: A)(implicit ord: Ordering[A])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[A]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires the value be greater than the specified reference value."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"isGreaterThanEqualTo[A](reference: A)(implicit ord: Ordering[A])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[A]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires the value be greater than or equal to the specified reference value."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"isLessThan[A](reference: A)(implicit ord: Ordering[A])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[A]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires the value be less than the specified reference value."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"isLessThanEqualTo[A](reference: A)(implicit ord: Ordering[A])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[A]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires the value be less than or equal to the specified reference value."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"isWithin[A](min: A, max: A)(implicit ord: Ordering[A])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[A]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires a value to fall within a specified min and max (inclusive)."})]})]})]}),"\n",(0,i.jsx)(s.h1,{id:"iterable",children:"Iterable"}),"\n",(0,i.jsxs)(s.p,{children:["Assertions on types that extend ",(0,i.jsx)(s.code,{children:"Iterable"}),", like ",(0,i.jsx)(s.code,{children:"List"}),", ",(0,i.jsx)(s.code,{children:"Seq"}),", ",(0,i.jsx)(s.code,{children:"Set"}),", ",(0,i.jsx)(s.code,{children:"Map"}),", and many others."]}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Function"}),(0,i.jsx)(s.th,{children:"Result type"}),(0,i.jsx)(s.th,{children:"Description"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"contains[A](element: A)"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Iterable[A]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires an Iterable contain the specified element. See Assertion.exists if you want to require an Iterable to contain an element satisfying an assertion."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"exists[A](assertion: Assertion[A])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Iterable[A]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires an Iterable contain an element satisfying the given assertion."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"forall[A](assertion: Assertion[A])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Iterable[A]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires an Iterable contain only elements satisfying the given assertion."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"hasFirst[A](assertion: Assertion[A])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Iterable[A]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires an Iterable to contain the first element satisfying the given assertion."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"hasIntersection[A](other: Iterable[A])(assertion: Assertion[Iterable[A]])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Iterable[A]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires the intersection of two Iterables satisfy the given assertion."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"hasLast[A](assertion: Assertion[A])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Iterable[A]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires an Iterable to contain the last element satisfying the given assertion."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"hasSize[A](assertion: Assertion[Int])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Iterable[A]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires the size of an Iterable be satisfied by the specified assertion."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"hasAtLeastOneOf[A](other: Iterable[A])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Iterable[A]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires an Iterable contain at least one of the specified elements."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"hasAtMostOneOf[A](other: Iterable[A])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Iterable[A]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires an Iterable contain at most one of the specified elements."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"hasNoneOf[A](other: Iterable[A])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Iterable[A]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires an Iterable contain none of the specified elements."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"hasOneOf[A](other: Iterable[A])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Iterable[A]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires an Iterable contain exactly one of the specified elements."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"hasSameElements[A](other: Iterable[A])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Iterable[A]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires an Iterable to have the same elements as the specified Iterable, though not necessarily in the same order."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"hasSameElementsDistinct[A](other: Iterable[A])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Iterable[A]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires an Iterable to have the same distinct elements as the other Iterable, though not necessarily in the same order."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"hasSubset[A](other: Iterable[A])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Iterable[A]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires the specified Iterable to be a subset of the other Iterable."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"isDistinct"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Iterable[Any]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires an Iterable is distinct."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"isEmpty"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Iterable[Any]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires an Iterable to be empty."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"isNonEmpty"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Iterable[Any]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires an Iterable to be non empty."})]})]})]}),"\n",(0,i.jsx)(s.h2,{id:"ordering-1",children:"Ordering"}),"\n",(0,i.jsxs)(s.p,{children:["Assertions that apply to ordered ",(0,i.jsx)(s.code,{children:"Iterable"}),"s"]}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Function"}),(0,i.jsx)(s.th,{children:"Result type"}),(0,i.jsx)(s.th,{children:"Description"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"isSorted[A](implicit ord: Ordering[A])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Iterable[A]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires an Iterable is sorted."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"isSortedReverse[A](implicit ord: Ordering[A])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Iterable[A]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires an Iterable is sorted in reverse order."})]})]})]}),"\n",(0,i.jsx)(s.h2,{id:"seq",children:"Seq"}),"\n",(0,i.jsxs)(s.p,{children:["Assertions that operate on sequences (",(0,i.jsx)(s.code,{children:"List"}),", ",(0,i.jsx)(s.code,{children:"Vector"}),", ",(0,i.jsx)(s.code,{children:"Map"}),", and many others)"]}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Function"}),(0,i.jsx)(s.th,{children:"Result type"}),(0,i.jsx)(s.th,{children:"Description"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"endsWith[A](suffix: Seq[A])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Seq[A]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires a given string to end with the specified suffix."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"hasAt[A](pos: Int)(assertion: Assertion[A])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Seq[A]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires a sequence to contain an element satisfying the given assertion on the given position."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"startsWith[A](prefix: Seq[A])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Seq[A]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires a given sequence to start with the specified prefix."})]})]})]}),"\n",(0,i.jsx)(s.h1,{id:"either",children:"Either"}),"\n",(0,i.jsxs)(s.p,{children:["Assertions for ",(0,i.jsx)(s.code,{children:"Either"})," values."]}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Function"}),(0,i.jsx)(s.th,{children:"Result type"}),(0,i.jsx)(s.th,{children:"Description"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"isLeft[A](assertion: Assertion[A])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Either[A, Any]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires a Left value satisfying a specified assertion."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"isLeft"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Either[Any, Any]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires an Either is Left."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"isRight[A](assertion: Assertion[A])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Either[Any, A]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires a Right value satisfying a specified assertion."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"isRight"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Either[Any, Any]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires an Either is Right."})]})]})]}),"\n",(0,i.jsx)(s.h1,{id:"exitcausethrowable",children:"Exit/Cause/Throwable"}),"\n",(0,i.jsxs)(s.p,{children:["Assertions for ",(0,i.jsx)(s.code,{children:"Exit"})," or ",(0,i.jsx)(s.code,{children:"Cause"})," results."]}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Function"}),(0,i.jsx)(s.th,{children:"Result type"}),(0,i.jsx)(s.th,{children:"Description"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"containsCause[E](cause: Cause[E])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Cause[E]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires a Cause contain the specified cause."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"dies(assertion: Assertion[Throwable])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Exit[Any, Any]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires an exit value to die."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"failsCause[E](assertion: Assertion[Cause[E]])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Exit[E, Any]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires an exit value to fail with a cause that meets the specified assertion."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"fails[E](assertion: Assertion[E])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Exit[E, Any]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires an exit value to fail."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"isInterrupted"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Exit[Any, Any]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires an exit value to be interrupted."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"succeeds[A](assertion: Assertion[A])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Exit[Any, A]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires an exit value to succeed."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"hasMessage(message: Assertion[String])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Throwable]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires an exception to have a certain message."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"hasThrowableCause(cause: Assertion[Throwable])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Throwable]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires an exception to have a certain cause."})]})]})]}),"\n",(0,i.jsx)(s.h1,{id:"try",children:"Try"}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Function"}),(0,i.jsx)(s.th,{children:"Result type"}),(0,i.jsx)(s.th,{children:"Description"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"isFailure(assertion: Assertion[Throwable])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Try[Any]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires a Failure value satisfying the specified assertion."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"isFailure"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Try[Any]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires a Try value is Failure."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"isSuccess[A](assertion: Assertion[A])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Try[A]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires a Success value satisfying the specified assertion."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"isSuccess"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Try[Any]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires a Try value is Success."})]})]})]}),"\n",(0,i.jsx)(s.h1,{id:"sum-type",children:"Sum type"}),"\n",(0,i.jsx)(s.p,{children:"An assertion that applies to some type, giving a method to transform the source\ntype into another type, then assert a property on that projected type."}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Function"}),(0,i.jsx)(s.th,{children:"Result type"}),(0,i.jsx)(s.th,{children:"Description"})]})}),(0,i.jsx)(s.tbody,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"isCase[Sum, Proj]( termName: String, term: Sum => Option[Proj], assertion: Assertion[Proj])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Sum]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires the sum type be a specified term."})]})})]}),"\n",(0,i.jsx)(s.h1,{id:"map",children:"Map"}),"\n",(0,i.jsxs)(s.p,{children:["Assertions for ",(0,i.jsx)(s.code,{children:"Map[K, V]"})]}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Function"}),(0,i.jsx)(s.th,{children:"Result type"}),(0,i.jsx)(s.th,{children:"Description"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"hasKey[K, V](key: K)"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Map[K, V]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires a Map to have the specified key."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"hasKey[K, V](key: K, assertion: Assertion[V])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Map[K, V]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires a Map to have the specified key with value satisfying the specified assertion."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"hasKeys[K, V](assertion: Assertion[Iterable[K]])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Map[K, V]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires a Map have keys satisfying the specified assertion."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"hasValues[K, V](assertion: Assertion[Iterable[V]])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Map[K, V]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires a Map have values satisfying the specified assertion."})]})]})]}),"\n",(0,i.jsx)(s.h1,{id:"string",children:"String"}),"\n",(0,i.jsx)(s.p,{children:"Assertions for Strings"}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Function"}),(0,i.jsx)(s.th,{children:"Result type"}),(0,i.jsx)(s.th,{children:"Description"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"containsString(element: String)"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[String]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires a substring to be present."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"endsWithString(suffix: String)"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[String]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires a given string to end with the specified suffix."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"equalsIgnoreCase(other: String)"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[String]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires a given string to equal another ignoring case."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"hasSizeString(assertion: Assertion[Int])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[String]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires the size of a string be satisfied by the specified assertion."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"isEmptyString"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[String]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires a given string to be empty."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"isNonEmptyString"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[String]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires a given string to be non empty."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"matchesRegex(regex: String)"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[String]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires a given string to match the specified regular expression."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"startsWithString(prefix: String)"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[String]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires a given string to start with a specified prefix."})]})]})]}),"\n",(0,i.jsx)(s.h1,{id:"boolean",children:"Boolean"}),"\n",(0,i.jsx)(s.p,{children:"Assertions for Booleans"}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Function"}),(0,i.jsx)(s.th,{children:"Result type"}),(0,i.jsx)(s.th,{children:"Description"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"isFalse"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Boolean]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires a value be false."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"isTrue"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Boolean]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires a value be true."})]})]})]}),"\n",(0,i.jsx)(s.h1,{id:"option",children:"Option"}),"\n",(0,i.jsx)(s.p,{children:"Assertions for Optional values"}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Function"}),(0,i.jsx)(s.th,{children:"Result type"}),(0,i.jsx)(s.th,{children:"Description"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"isNone"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Option[Any]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires a None value."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"isSome[A](assertion: Assertion[A])"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Option[A]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires a Some value satisfying the specified assertion."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"isSome"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Option[Any]]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires an Option is Some."})]})]})]}),"\n",(0,i.jsx)(s.h1,{id:"unit",children:"Unit"}),"\n",(0,i.jsx)(s.p,{children:"Assertion for Unit"}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Function"}),(0,i.jsx)(s.th,{children:"Result type"}),(0,i.jsx)(s.th,{children:"Description"})]})}),(0,i.jsx)(s.tbody,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"isUnit"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Assertion[Unit]"})}),(0,i.jsx)(s.td,{children:"Makes a new assertion that requires the value be unit."})]})})]})]})}function o(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},28453:(e,s,t)=>{t.d(s,{R:()=>d,x:()=>c});var n=t(96540);const i={},r=n.createContext(i);function d(e){const s=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),n.createElement(r.Provider,{value:s},e.children)}}}]);