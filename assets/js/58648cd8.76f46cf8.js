"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[56177],{28453:(e,n,c)=>{c.d(n,{R:()=>o,x:()=>i});var s=c(96540);const t={},r=s.createContext(t);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:n},e.children)}},33747:(e,n,c)=>{c.r(n),c.d(n,{assets:()=>a,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"overview/overview_creating_effects","title":"Creating Effects","description":"This section explores some of the common ways to create ZIO effects from values, from common Scala types, and from both synchronous and asynchronous side-effects.","source":"@site/versioned_docs/version-1.0.18/overview/creating_effects.md","sourceDirName":"overview","slug":"/overview/overview_creating_effects","permalink":"/1.0.18/overview/overview_creating_effects","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/versioned_docs/version-1.0.18/overview/creating_effects.md","tags":[],"version":"1.0.18","frontMatter":{"id":"overview_creating_effects","title":"Creating Effects"},"sidebar":"overview_sidebar","previous":{"title":"Summary","permalink":"/1.0.18/overview/"},"next":{"title":"Basic Operations","permalink":"/1.0.18/overview/overview_basic_operations"}}');var t=c(74848),r=c(28453);const o={id:"overview_creating_effects",title:"Creating Effects"},i=void 0,a={},l=[{value:"From Success Values",id:"from-success-values",level:2},{value:"From Failure Values",id:"from-failure-values",level:2},{value:"From Scala Values",id:"from-scala-values",level:2},{value:"Option",id:"option",level:3},{value:"Either",id:"either",level:3},{value:"Try",id:"try",level:3},{value:"Function",id:"function",level:3},{value:"Future",id:"future",level:3},{value:"From Side-Effects",id:"from-side-effects",level:2},{value:"Synchronous Side-Effects",id:"synchronous-side-effects",level:3},{value:"Asynchronous Side-Effects",id:"asynchronous-side-effects",level:3},{value:"Blocking Synchronous Side-Effects",id:"blocking-synchronous-side-effects",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"This section explores some of the common ways to create ZIO effects from values, from common Scala types, and from both synchronous and asynchronous side-effects."}),"\n",(0,t.jsx)(n.h2,{id:"from-success-values",children:"From Success Values"}),"\n",(0,t.jsxs)(n.p,{children:["Using the ",(0,t.jsx)(n.code,{children:"ZIO.succeed"})," method, you can create an effect that succeeds with the specified value:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"val s1 = ZIO.succeed(42)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["You can also use methods in the companion objects of the ",(0,t.jsx)(n.code,{children:"ZIO"})," type aliases:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"val s2: Task[Int] = Task.succeed(42)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"succeed"})," method takes a by-name parameter to make sure that any accidental side effects from constructing the value can be properly managed by the ZIO Runtime. However, ",(0,t.jsx)(n.code,{children:"succeed"})," is intended for values which do not have any side effects. If you know that your value does have side effects consider using ",(0,t.jsx)(n.code,{children:"ZIO.effectTotal"})," for clarity."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"val now = ZIO.effectTotal(System.currentTimeMillis())\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The value inside a successful effect constructed with ",(0,t.jsx)(n.code,{children:"ZIO.effectTotal"})," will only be constructed if absolutely required."]}),"\n",(0,t.jsx)(n.h2,{id:"from-failure-values",children:"From Failure Values"}),"\n",(0,t.jsxs)(n.p,{children:["Using the ",(0,t.jsx)(n.code,{children:"ZIO.fail"})," method, you can create an effect that models failure:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'val f1 = ZIO.fail("Uh oh!")\n'})}),"\n",(0,t.jsxs)(n.p,{children:["For the ",(0,t.jsx)(n.code,{children:"ZIO"})," data type, there is no restriction on the error type. You may use strings, exceptions, or custom data types appropriate for your application."]}),"\n",(0,t.jsxs)(n.p,{children:["Many applications will model failures with classes that extend ",(0,t.jsx)(n.code,{children:"Throwable"})," or ",(0,t.jsx)(n.code,{children:"Exception"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'val f2 = Task.fail(new Exception("Uh oh!"))\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Note that unlike the other effect companion objects, the ",(0,t.jsx)(n.code,{children:"UIO"})," companion object does not have ",(0,t.jsx)(n.code,{children:"UIO.fail"}),", because ",(0,t.jsx)(n.code,{children:"UIO"})," values cannot fail."]}),"\n",(0,t.jsx)(n.h2,{id:"from-scala-values",children:"From Scala Values"}),"\n",(0,t.jsx)(n.p,{children:"Scala's standard library contains a number of data types that can be converted into ZIO effects."}),"\n",(0,t.jsx)(n.h3,{id:"option",children:"Option"}),"\n",(0,t.jsxs)(n.p,{children:["An ",(0,t.jsx)(n.code,{children:"Option"})," can be converted into a ZIO effect using ",(0,t.jsx)(n.code,{children:"ZIO.fromOption"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"val zoption: IO[Option[Nothing], Int] = ZIO.fromOption(Some(2))\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The error type of the resulting effect is ",(0,t.jsx)(n.code,{children:"Option[Nothing]"}),", which provides no information on why the value is not there. You can change the ",(0,t.jsx)(n.code,{children:"Option[Nothing]"})," into a more specific error type using ",(0,t.jsx)(n.code,{children:"ZIO#mapError"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'val zoption2: IO[String, Int] = zoption.mapError(_ => "It wasn\'t there!")\n'})}),"\n",(0,t.jsxs)(n.p,{children:["You can also readily compose it with other operators while preserving the optional nature of the result (similar to an ",(0,t.jsx)(n.code,{children:"OptionT"}),")"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'val maybeId: IO[Option[Nothing], String] = ZIO.fromOption(Some("abc123"))\ndef getUser(userId: String): IO[Throwable, Option[User]] = ???\ndef getTeam(teamId: String): IO[Throwable, Team] = ???\n\n\nval result: IO[Throwable, Option[(User, Team)]] = (for {\n  id   <- maybeId\n  user <- getUser(id).some\n  team <- getTeam(user.teamId).asSomeError \n} yield (user, team)).optional \n'})}),"\n",(0,t.jsx)(n.h3,{id:"either",children:"Either"}),"\n",(0,t.jsxs)(n.p,{children:["An ",(0,t.jsx)(n.code,{children:"Either"})," can be converted into a ZIO effect using ",(0,t.jsx)(n.code,{children:"ZIO.fromEither"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'val zeither = ZIO.fromEither(Right("Success!"))\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The error type of the resulting effect will be whatever type the ",(0,t.jsx)(n.code,{children:"Left"})," case has, while the success type will be whatever type the ",(0,t.jsx)(n.code,{children:"Right"})," case has."]}),"\n",(0,t.jsx)(n.h3,{id:"try",children:"Try"}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.code,{children:"Try"})," value can be converted into a ZIO effect using ",(0,t.jsx)(n.code,{children:"ZIO.fromTry"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import scala.util.Try\n\nval ztry = ZIO.fromTry(Try(42 / 0))\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The error type of the resulting effect will always be ",(0,t.jsx)(n.code,{children:"Throwable"}),", because ",(0,t.jsx)(n.code,{children:"Try"})," can only fail with values of type ",(0,t.jsx)(n.code,{children:"Throwable"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"function",children:"Function"}),"\n",(0,t.jsxs)(n.p,{children:["A function ",(0,t.jsx)(n.code,{children:"A => B"})," can be converted into a ZIO effect with ",(0,t.jsx)(n.code,{children:"ZIO.fromFunction"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"val zfun: URIO[Int, Int] =\n  ZIO.fromFunction((i: Int) => i * i)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The environment type of the effect is ",(0,t.jsx)(n.code,{children:"A"})," (the input type of the function), because in order to run the effect, it must be supplied with a value of this type."]}),"\n",(0,t.jsx)(n.h3,{id:"future",children:"Future"}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.code,{children:"Future"})," can be converted into a ZIO effect using ",(0,t.jsx)(n.code,{children:"ZIO.fromFuture"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'import scala.concurrent.Future\n\nlazy val future = Future.successful("Hello!")\n\nval zfuture: Task[String] =\n  ZIO.fromFuture { implicit ec =>\n    future.map(_ => "Goodbye!")\n  }\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The function passed to ",(0,t.jsx)(n.code,{children:"fromFuture"})," is passed an ",(0,t.jsx)(n.code,{children:"ExecutionContext"}),", which allows ZIO to manage where the ",(0,t.jsx)(n.code,{children:"Future"})," runs (of course, you can ignore this ",(0,t.jsx)(n.code,{children:"ExecutionContext"}),")."]}),"\n",(0,t.jsxs)(n.p,{children:["The error type of the resulting effect will always be ",(0,t.jsx)(n.code,{children:"Throwable"}),", because ",(0,t.jsx)(n.code,{children:"Future"})," can only fail with values of type ",(0,t.jsx)(n.code,{children:"Throwable"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"from-side-effects",children:"From Side-Effects"}),"\n",(0,t.jsx)(n.p,{children:"ZIO can convert both synchronous and asynchronous side-effects into ZIO effects (pure values)."}),"\n",(0,t.jsx)(n.p,{children:"These functions can be used to wrap procedural code, allowing you to seamlessly use all features of ZIO with legacy Scala and Java code, as well as third-party libraries."}),"\n",(0,t.jsx)(n.h3,{id:"synchronous-side-effects",children:"Synchronous Side-Effects"}),"\n",(0,t.jsxs)(n.p,{children:["A synchronous side-effect can be converted into a ZIO effect using ",(0,t.jsx)(n.code,{children:"ZIO.effect"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import scala.io.StdIn\n\nval getStrLn: Task[String] =\n  ZIO.effect(StdIn.readLine())\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The error type of the resulting effect will always be ",(0,t.jsx)(n.code,{children:"Throwable"}),", because side-effects may throw exceptions with any value of type ",(0,t.jsx)(n.code,{children:"Throwable"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["If a given side-effect is known to not throw any exceptions, then the side-effect can be converted into a ZIO effect using ",(0,t.jsx)(n.code,{children:"ZIO.effectTotal"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"def putStrLn(line: String): UIO[Unit] =\n  ZIO.effectTotal(println(line))\n"})}),"\n",(0,t.jsxs)(n.p,{children:["You should be careful when using ",(0,t.jsx)(n.code,{children:"ZIO.effectTotal"}),"\u2014when in doubt about whether or not a side-effect is total, prefer ",(0,t.jsx)(n.code,{children:"ZIO.effect"})," to convert the effect."]}),"\n",(0,t.jsxs)(n.p,{children:["If you wish to refine the error type of an effect (by treating other errors as fatal), then you can use the ",(0,t.jsx)(n.code,{children:"ZIO#refineToOrDie"})," method:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import java.io.IOException\n\nval getStrLn2: IO[IOException, String] =\n  ZIO.effect(StdIn.readLine()).refineToOrDie[IOException]\n"})}),"\n",(0,t.jsx)(n.h3,{id:"asynchronous-side-effects",children:"Asynchronous Side-Effects"}),"\n",(0,t.jsxs)(n.p,{children:["An asynchronous side-effect with a callback-based API can be converted into a ZIO effect using ",(0,t.jsx)(n.code,{children:"ZIO.effectAsync"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"object legacy {\n  def login(\n    onSuccess: User => Unit,\n    onFailure: AuthError => Unit): Unit = ???\n}\n\nval login: IO[AuthError, User] =\n  IO.effectAsync[AuthError, User] { callback =>\n    legacy.login(\n      user => callback(IO.succeed(user)),\n      err  => callback(IO.fail(err))\n    )\n  }\n"})}),"\n",(0,t.jsx)(n.p,{children:"Asynchronous ZIO effects are much easier to use than callback-based APIs, and they benefit from ZIO features like interruption, resource-safety, and superior error handling."}),"\n",(0,t.jsx)(n.h2,{id:"blocking-synchronous-side-effects",children:"Blocking Synchronous Side-Effects"}),"\n",(0,t.jsx)(n.p,{children:"Some side-effects use blocking IO or otherwise put a thread into a waiting state. If not carefully managed, these side-effects can deplete threads from your application's main thread pool, resulting in work starvation."}),"\n",(0,t.jsxs)(n.p,{children:["ZIO provides the ",(0,t.jsx)(n.code,{children:"zio.blocking"})," package, which can be used to safely convert such blocking side-effects into ZIO effects."]}),"\n",(0,t.jsxs)(n.p,{children:["A blocking side-effect can be converted directly into a ZIO effect blocking with the ",(0,t.jsx)(n.code,{children:"effectBlocking"})," method:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import zio.blocking._\n\nval sleeping =\n  effectBlocking(Thread.sleep(Long.MaxValue))\n"})}),"\n",(0,t.jsx)(n.p,{children:"The resulting effect will be executed on a separate thread pool designed specifically for blocking effects."}),"\n",(0,t.jsxs)(n.p,{children:["Blocking side-effects can be interrupted by invoking ",(0,t.jsx)(n.code,{children:"Thread.interrupt"})," using the ",(0,t.jsx)(n.code,{children:"effectBlockingInterrupt"})," method."]}),"\n",(0,t.jsxs)(n.p,{children:["Some blocking side-effects can only be interrupted by invoking a cancellation effect. You can convert these side-effects using the ",(0,t.jsx)(n.code,{children:"effectBlockingCancelable"})," method:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import java.net.ServerSocket\nimport zio.UIO\n\ndef accept(l: ServerSocket) =\n  effectBlockingCancelable(l.accept())(UIO.effectTotal(l.close()))\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If a side-effect has already been converted into a ZIO effect, then instead of ",(0,t.jsx)(n.code,{children:"effectBlocking"}),", the ",(0,t.jsx)(n.code,{children:"blocking"})," method can be used to ensure the effect will be executed on the blocking thread pool:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import scala.io.{ Codec, Source }\n\ndef download(url: String) =\n  Task.effect {\n    Source.fromURL(url)(Codec.UTF8).mkString\n  }\n\ndef safeDownload(url: String) =\n  blocking(download(url))\n"})}),"\n",(0,t.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsxs)(n.p,{children:["If you are comfortable creating effects from values, Scala data types, and side-effects, the next step is learning ",(0,t.jsx)(n.a,{href:"/1.0.18/overview/overview_basic_operations",children:"basic operations"})," on effects."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);