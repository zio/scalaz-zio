"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[38337],{13482:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>i,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"reference/error-management/operations/flipping-error-and-success-channels","title":"Flipping Error and Success Channels","description":"Sometimes, we would like to apply some methods on the error channel which are specific for the success channel, or we want to apply some methods on the success channel which are specific for the error channel. Therefore, we can flip the error and success channel and before flipping back, we can perform the right operator on flipped channels:","source":"@site/docs/reference/error-management/operations/flipping-the-error-and-success-channel.md","sourceDirName":"reference/error-management/operations","slug":"/reference/error-management/operations/flipping-error-and-success-channels","permalink":"/reference/error-management/operations/flipping-error-and-success-channels","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/error-management/operations/flipping-the-error-and-success-channel.md","tags":[],"version":"current","frontMatter":{"id":"flipping-error-and-success-channels","title":"Flipping Error and Success Channels"},"sidebar":"reference-sidebar","previous":{"title":"Merging the Error Channel into the Success Channel","permalink":"/reference/error-management/operations/merging-the-error-channel-into-the-success-channel"},"next":{"title":"Rejecting Some Success Values","permalink":"/reference/error-management/operations/rejecting-some-success-values"}}');var t=r(74848),o=r(28453);const a={id:"flipping-error-and-success-channels",title:"Flipping Error and Success Channels"},c=void 0,i={},l=[];function p(e){const n={code:"code",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Sometimes, we would like to apply some methods on the error channel which are specific for the success channel, or we want to apply some methods on the success channel which are specific for the error channel. Therefore, we can flip the error and success channel and before flipping back, we can perform the right operator on flipped channels:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"trait ZIO[-R, +E, +A] {\n  def flip: ZIO[R, A, E]\n  def flipWith[R1, A1, E1](f: ZIO[R, A, E] => ZIO[R1, A1, E1]): ZIO[R1, E1, A1]\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Assume we have the following example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nval evens: ZIO[Any, List[String], List[Int]] =\n  ZIO.validate(List(1, 2, 3, 4, 5)) { n =>\n    if (n % 2 == 0)\n      ZIO.succeed(n)\n    else\n      ZIO.fail(s"$n is not even")\n  }\n'})}),"\n",(0,t.jsxs)(n.p,{children:["We want to reverse the order of errors. In order to do that instead of using ",(0,t.jsx)(n.code,{children:"ZIO#mapError"}),", we can map the error channel by using flip operators:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nval r1: ZIO[Any, List[String], List[Int]] = evens.mapError(_.reverse)\nval r2: ZIO[Any, List[String], List[Int]] = evens.flip.map(_.reverse).flip\nval r3: ZIO[Any, List[String], List[Int]] = evens.flipWith(_.map(_.reverse))\n"})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(p,{...e})}):p(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>c});var s=r(96540);const t={},o=s.createContext(t);function a(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);