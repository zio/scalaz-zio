"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[48320],{22532:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"zio-prelude/functional-abstractions/concrete-types/hash","title":"Hash","description":"Hash[A] describes the ability to hash a value of type A.","source":"@site/docs/zio-prelude/functional-abstractions/concrete-types/hash.md","sourceDirName":"zio-prelude/functional-abstractions/concrete-types","slug":"/zio-prelude/functional-abstractions/concrete-types/hash","permalink":"/zio-prelude/functional-abstractions/concrete-types/hash","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-prelude/functional-abstractions/concrete-types/hash.md","tags":[],"version":"current","frontMatter":{"id":"hash","title":"Hash"},"sidebar":"ecosystem-sidebar","previous":{"title":"Equal","permalink":"/zio-prelude/functional-abstractions/concrete-types/equal"},"next":{"title":"Identity","permalink":"/zio-prelude/functional-abstractions/concrete-types/identity"}}');var t=a(74848),i=a(28453);const o={id:"hash",title:"Hash"},r=void 0,c={},h=[{value:"Defining Hash Instances",id:"defining-hash-instances",level:2}];function l(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Hash[A]"})," describes the ability to hash a value of type ",(0,t.jsx)(n.code,{children:"A"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"The signature is:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"trait Equal[-A] {\n  def equal(left: A, right: A): Boolean\n}\n\ntrait Hash[-A] extends Equal[A] {\n  def equal(left: A, right: A): Boolean\n  def hash(a: A): Int\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Hash"})," builds on ",(0,t.jsx)(n.code,{children:"Equal"})," in a different way than ",(0,t.jsx)(n.code,{children:"Ord"})," by defining a way to ",(0,t.jsx)(n.code,{children:"Hash"})," two values of type ",(0,t.jsx)(n.code,{children:"A"})," in addition to a way to compare them for equality."]}),"\n",(0,t.jsxs)(n.p,{children:["If we import ",(0,t.jsx)(n.code,{children:"zio.prelude._"})," We can hash any data type that has a ",(0,t.jsx)(n.code,{children:"Hash"})," instance defined for it using the ",(0,t.jsx)(n.code,{children:"hash"})," operator or its symbolic alias ",(0,t.jsx)(n.code,{children:"##"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"In addition to hashing being generally useful, hashing allows us to determine whether a value already exists in a collection of values without individually testing for equality with each value. This allows us to implement some operators that would not otherwise be practical if all we could do was compare values for equality pairwise."}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"Hash"})," abstraction provides similar functionality as the ",(0,t.jsx)(n.code,{children:"hashCode"})," operator defined on any object in Scala with a few advantages."]}),"\n",(0,t.jsx)(n.p,{children:"First, it allows us to specify whether a data type has a meaningful definition of hash code."}),"\n",(0,t.jsxs)(n.p,{children:["For example, we can call ",(0,t.jsx)(n.code,{children:"hashCode"})," on a Scala function but there is not a meaningful way of comparing Scala functions for equality so the definition of ",(0,t.jsx)(n.code,{children:"hashCode"})," is just based on reference equality."]}),"\n",(0,t.jsxs)(n.p,{children:["While this could potentially be useful in some very low level parts of our code this is generally a potential source of bugs if we are not specifically trying to use reference equality. ZIO Prelude just doesn't define a ",(0,t.jsx)(n.code,{children:"Hash"})," instance for functions so this can never happen."]}),"\n",(0,t.jsxs)(n.p,{children:["Second, we can use the ",(0,t.jsx)(n.code,{children:"Hash"})," abstraction to define strategies for hashing data types that are not in our control. An existing data type may implement ",(0,t.jsx)(n.code,{children:"hashCode"})," in a way that doesn't make sense or is not what we want for whatever reason (e.g. creates too high a rate of hash collisions, is vulnerable to attacks, etc...)."]}),"\n",(0,t.jsxs)(n.p,{children:["With just the ",(0,t.jsx)(n.code,{children:"hashCode"})," defined in the Scala standard library we don't have any way of fixing this other than creating a new wrapper for the data type, which has potential performance implications and may require boilerplate in wrapping and unwrapping the new type or reimplementing existing methods. In contrast, with ZIO Prelude defining a different hashing strategy is as simple as implementing a new instance."]}),"\n",(0,t.jsxs)(n.p,{children:["Third, the ",(0,t.jsx)(n.code,{children:"Hash"})," abstraction guarantees that our definition of hashing is consistent with our definition of equality. That is, if two values are equal they should always have the same hash code."]}),"\n",(0,t.jsxs)(n.p,{children:["This is another common source of errors whenever we implement our own definition of ",(0,t.jsx)(n.code,{children:"equals"})," and ",(0,t.jsx)(n.code,{children:"hashCode"})," and ZIO Prelude can prevent it by automatically checking that all instances of ",(0,t.jsx)(n.code,{children:"Hash"})," define a consistent notion of equality and hashing."]}),"\n",(0,t.jsx)(n.p,{children:"For example, here is how we could test that ZIO Prelude's notions of hashing and equality for strings are consistent."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'import zio.prelude.Hash\nimport zio.prelude.laws.HashLaws\nimport zio.test._\nimport zio.test.laws._\n\nobject HashSpec extends ZIOSpecDefault {\n\n  def spec = suite("HashSpec") {\n    test("StringHash") {\n      val stringGen = Gen.string\n      checkAllLaws(HashLaws)(stringGen)\n    }\n  }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"This will automatically generate a large number of string values and test that the definition of hashing is consistent with equality for all of them, reporting any failures."}),"\n",(0,t.jsx)(n.h2,{id:"defining-hash-instances",children:"Defining Hash Instances"}),"\n",(0,t.jsxs)(n.p,{children:["ZIO Prelude automatically includes instances of ",(0,t.jsx)(n.code,{children:"Hash"})," for all data types in ZIO and the Scala standard library that support a meaningful definition of hashing. This also includes types like collections, tuples, and sum types like ",(0,t.jsx)(n.code,{children:"Option"})," and ",(0,t.jsx)(n.code,{children:"Either"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["If we are defining our own data types we can use the ",(0,t.jsx)(n.code,{children:"default"})," operator if we want to use the definition of ",(0,t.jsx)(n.code,{children:"equals"})," and ",(0,t.jsx)(n.code,{children:"hashCode"})," already defined on the type. This can be particularly useful if we are defining case classes that are made up of"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"case class Person(name: String, age: Int)\n\nobject Person {\n  implicit val PersonHash: Hash[Person] =\n    Hash.default\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If we are defining a ",(0,t.jsx)(n.code,{children:"Hash"})," instance for our own data type we can use the ",(0,t.jsx)(n.code,{children:"make"})," operator, which allows you to provide your own definition of hashing and equality."]}),"\n",(0,t.jsxs)(n.p,{children:["However, hashing can involve some low level logic so for the ",(0,t.jsx)(n.code,{children:"Hash"})," abstraction it can be particularly nice to use the ",(0,t.jsx)(n.code,{children:"contramap"})," operator."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"trait Hash[-A] {\n  def contramap[B](f: B => A): Hash[B]\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"contramap"})," operator says if we know how to turn a ",(0,t.jsx)(n.code,{children:"B"})," value into an ",(0,t.jsx)(n.code,{children:"A"})," value and we know how to hash an ",(0,t.jsx)(n.code,{children:"A"})," value then we can hash a ",(0,t.jsx)(n.code,{children:"B"})," value simply by turning it into an ",(0,t.jsx)(n.code,{children:"A"})," value and hashing that."]}),"\n",(0,t.jsxs)(n.p,{children:["This turns out to be quite useful because we can convert almost any date type we define into some data type in ZIO or the Scala library that there is already a ",(0,t.jsx)(n.code,{children:"Hash"})," instance defined for. The function ",(0,t.jsx)(n.code,{children:"f"})," should be information preserving so if we have two ",(0,t.jsx)(n.code,{children:"A"})," values that are not equal they should map to two ",(0,t.jsx)(n.code,{children:"B"})," values that are not equal and if we have two ",(0,t.jsx)(n.code,{children:"A"})," values that are equal they should map to two ",(0,t.jsx)(n.code,{children:"B"})," values that are equal."]}),"\n",(0,t.jsxs)(n.p,{children:["For example, here is how we can use ",(0,t.jsx)(n.code,{children:"contramap"})," to easily define a ",(0,t.jsx)(n.code,{children:"Hash"})," instance for a custom data type to keep track of different topics and the number of votes for each of them."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import zio.prelude.Hash\n\ncase class Topic(value: String)\n\ncase class Votes(value: Int)\n\nobject Votes {\n  implicit val VotesHash: Hash[Votes] =\n    Hash.default\n}\n\ncase class VoteMap(map: Map[Topic, Votes])\n\nobject VoteMap {\n  implicit val VoteMapHash: Hash[VoteMap] =\n    Hash[Map[Topic, Votes]].contramap(_.map)\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["ZIO Prelude knows how to hash values of type ",(0,t.jsx)(n.code,{children:"Map[A, B]"})," as long as there is a way of hashing the values in the map. And we know how to hash the values in the map because we defined a ",(0,t.jsx)(n.code,{children:"Hash"})," instance for ",(0,t.jsx)(n.code,{children:"Votes"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["So all we have to do is tell ZIO Prelude how to convert our ",(0,t.jsx)(n.code,{children:"VoteMap"})," into a ",(0,t.jsx)(n.code,{children:"Map"}),", which is quite easy because a ",(0,t.jsx)(n.code,{children:"VoteMap"})," just wraps a map!"]}),"\n",(0,t.jsxs)(n.p,{children:["This strategy turns out to be quite general because there are ",(0,t.jsx)(n.code,{children:"Hash"})," instances defined on so many data types such as collection types, product types like tuples, sum types like ",(0,t.jsx)(n.code,{children:"Either"})," and ",(0,t.jsx)(n.code,{children:"Option"}),", and primitive types. We can almost always convert our data type to some combination of those types."]}),"\n",(0,t.jsx)(n.p,{children:"By doing this we can easily define which data types it makes sense to hash, control the hashing strategies we use, and integrate hashing with the other functional abstractions in ZIO Prelude."})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},28453:(e,n,a)=>{a.d(n,{R:()=>o,x:()=>r});var s=a(96540);const t={},i=s.createContext(t);function o(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);