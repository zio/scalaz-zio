"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[60386],{15859:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>d,frontMatter:()=>i,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"reference/stream/chunk","title":"Chunk","description":"A Chunk[A] represents a chunk of values of type A. Chunks are usually backed by arrays, but expose a purely functional, safe interface to the underlying elements, and they become lazy on operations that would be costly with arrays, such as repeated concatenation. Like lists and arrays, Chunk is an ordered collection.","source":"@site/docs/reference/stream/chunk.md","sourceDirName":"reference/stream","slug":"/reference/stream/chunk","permalink":"/reference/stream/chunk","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/stream/chunk.md","tags":[],"version":"current","frontMatter":{"id":"chunk","title":"Chunk"},"sidebar":"reference-sidebar","previous":{"title":"Installation","permalink":"/reference/stream/installation"},"next":{"title":"Introduction to ZStream","permalink":"/reference/stream/zstream/"}}');var r=a(74848),s=a(28453);const i={id:"chunk",title:"Chunk"},c=void 0,l={},o=[{value:"Why Chunk?",id:"why-chunk",level:2},{value:"Immutability",id:"immutability",level:3},{value:"Ergonomic Design",id:"ergonomic-design",level:3},{value:"High Performance",id:"high-performance",level:3},{value:"Operations",id:"operations",level:2},{value:"Creating a Chunk",id:"creating-a-chunk",level:3},{value:"Concatenating chunk",id:"concatenating-chunk",level:3},{value:"Collecting chunk",id:"collecting-chunk",level:3},{value:"Dropping chunk",id:"dropping-chunk",level:3},{value:"Comparing chunks",id:"comparing-chunks",level:3},{value:"Converting chunks",id:"converting-chunks",level:3}];function h(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.code,{children:"Chunk[A]"})," represents a chunk of values of type ",(0,r.jsx)(n.code,{children:"A"}),". Chunks are usually backed by arrays, but expose a purely functional, safe interface to the underlying elements, and they become lazy on operations that would be costly with arrays, such as repeated concatenation. Like lists and arrays, Chunk is an ordered collection."]}),"\n",(0,r.jsx)(n.h2,{id:"why-chunk",children:"Why Chunk?"}),"\n",(0,r.jsxs)(n.p,{children:["Arrays are fast and don\u2019t box primitive values but due to ",(0,r.jsx)(n.code,{children:"ClassTag"})," requirements and mutability they are painful to use and don't integrate well info functional code. ZIO chunks are backed by arrays so they also have zero boxing for primitives while providing an immutable interface and avoiding ",(0,r.jsx)(n.code,{children:"ClassTag"})," requirements."]}),"\n",(0,r.jsx)(n.p,{children:"Lets to get more details behind why Chunk invented:"}),"\n",(0,r.jsx)(n.h3,{id:"immutability",children:"Immutability"}),"\n",(0,r.jsxs)(n.p,{children:["In Scala, there is no immutable data type that can efficiently represent primitive data types. There is Array, but Array is a mutable interface. The Array data type can efficiently represent primitives without boxing but only by exposing some unsafe mutable methods like ",(0,r.jsx)(n.code,{children:"update"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"ergonomic-design",children:"Ergonomic Design"}),"\n",(0,r.jsxs)(n.p,{children:["Every time, when we create an array of generic types in Scala, we need a ",(0,r.jsx)(n.a,{href:"https://www.scala-lang.org/api/current/scala/reflect/ClassTag.html",children:"ClassTag"})," to provide runtime information about that generic type, which is very inconvenient and isn't ergonomic. It leads us to a very cumbersome API."]}),"\n",(0,r.jsxs)(n.p,{children:["Chunk does not have the inconvenience of Array in Scala. ",(0,r.jsx)(n.strong,{children:"Chunk dispenses with the need to have ClassTags"}),". It utilizes a different approach to solve that problem."]}),"\n",(0,r.jsx)(n.h3,{id:"high-performance",children:"High Performance"}),"\n",(0,r.jsx)(n.p,{children:"In addition to being an immutable array and zero boxing of Chunks that leads us to a high performant data type, Chunk has specialized operations for things like appending a single element or concatenating two Chunks together which have significantly higher performance than doing these same operations on the Array. Many Chunk methods have been handwritten to achieve better performance than their corresponding Array implementations in the Scala standard library."}),"\n",(0,r.jsx)(n.p,{children:"Although Chunk is a common data type in ZIO, it exists primarily to support streaming use cases."}),"\n",(0,r.jsx)(n.p,{children:"When we are doing data streaming, a lot of times the source stream is a stream of bytes. Hence, internally we use a Chunk of bytes to represent that, so we don't have to box the bytes. Of course, it can be utilized for Chunks of Ints and many other types. Using Chunk is especially common when we are encoding and decoding at the level of streams. It is a very efficient, high-performance data type."}),"\n",(0,r.jsx)(n.h2,{id:"operations",children:"Operations"}),"\n",(0,r.jsx)(n.h3,{id:"creating-a-chunk",children:"Creating a Chunk"}),"\n",(0,r.jsxs)(n.p,{children:["Creating empty ",(0,r.jsx)(n.code,{children:"Chunk"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"val emptyChunk = Chunk.empty\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Creating a ",(0,r.jsx)(n.code,{children:"Chunk"})," with specified values:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"val specifiedValuesChunk = Chunk(1,2,3)\n// specifiedValuesChunk: Chunk[Int] = IndexedSeq(1, 2, 3)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Alternatively, we can create a ",(0,r.jsx)(n.code,{children:"Chunk"})," by providing a collection of values:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"val fromIterableChunk: Chunk[Int] = Chunk.fromIterable(List(1, 2, 3))\n// fromIterableChunk: Chunk[Int] = IndexedSeq(1, 2, 3)\nval fromArrayChunk: Chunk[Int] = Chunk.fromArray(Array(1, 2, 3))\n// fromArrayChunk: Chunk[Int] = IndexedSeq(1, 2, 3)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Creating a ",(0,r.jsx)(n.code,{children:"Chunk"})," using filling same n element into it:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"val chunk: Chunk[Int] = Chunk.fill(3)(0)\n// chunk: Chunk[Int] = IndexedSeq(0, 0, 0)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Creating a ",(0,r.jsx)(n.code,{children:"Chunk"})," using unfold method by repeatedly applying the given function, as long as it returns Some:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"val unfolded = Chunk.unfold(0)(n => if (n < 8) Some((n*2, n+2)) else None)\n// unfolded: Chunk[Int] = IndexedSeq(0, 4, 8, 12)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"concatenating-chunk",children:"Concatenating chunk"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"++"})," Returns the concatenation of this chunk with the specified chunk. For example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"Chunk(1,2,3) ++ Chunk(4,5,6)\n// res0: Chunk[Int] = IndexedSeq(1, 2, 3, 4, 5, 6)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"collecting-chunk",children:"Collecting chunk"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"collect"})," Returns a filtered, mapped subset of the elements of this chunk.\nHow to use ",(0,r.jsx)(n.code,{children:"collect"})," function to cherry-pick all strings from Chunk[A]:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'val collectChunk = Chunk("Hello ZIO", 1.5, "Hello ZIO NIO", 2.0, "Some string", 2.5)\n// collectChunk: Chunk[Any] = IndexedSeq(\n//   "Hello ZIO",\n//   1.5,\n//   "Hello ZIO NIO",\n//   2.0,\n//   "Some string",\n//   2.5\n// )\n\ncollectChunk.collect { case string: String => string }\n// res1: Chunk[String] = IndexedSeq(\n//   "Hello ZIO",\n//   "Hello ZIO NIO",\n//   "Some string"\n// )\n'})}),"\n",(0,r.jsxs)(n.p,{children:["How to use ",(0,r.jsx)(n.code,{children:"collect"})," function to cherry-pick all the digits from Chunk[A]:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"collectChunk.collect { case digit: Double => digit }\n// res2: Chunk[Double] = IndexedSeq(1.5, 2.0, 2.5)\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"collectWhile"}),' collects the elements (from left to right) until the predicate returns "false" for the first time:']}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'Chunk("Sarah", "Bob", "Jane").collectWhile { case element if element != "Bob" => true }\n// res3: Chunk[Boolean] = IndexedSeq(true)\n'})}),"\n",(0,r.jsx)(n.p,{children:"or another example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"Chunk(9, 2, 5, 1, 6).collectWhile { case element if element >= 2 => true }\n// res4: Chunk[Boolean] = IndexedSeq(true, true, true)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"dropping-chunk",children:"Dropping chunk"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"drop"})," drops the first ",(0,r.jsx)(n.code,{children:"n"})," elements of the chunk:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'Chunk("Sarah", "Bob", "Jane").drop(1)\n// res5: Chunk[String] = IndexedSeq("Bob", "Jane")\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"dropWhile"})," drops all elements so long as the predicate returns true:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"Chunk(9, 2, 5, 1, 6).dropWhile(_ >= 2)\n// res6: Chunk[Int] = IndexedSeq(1, 6)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"comparing-chunks",children:"Comparing chunks"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'Chunk("A","B") == Chunk("A", "C")\n// res7: Boolean = false\n'})}),"\n",(0,r.jsx)(n.h3,{id:"converting-chunks",children:"Converting chunks"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"toArray"})," converts the chunk into an Array."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"Chunk(1,2,3).toArray\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"toSeq"}),"converts the chunk into ",(0,r.jsx)(n.code,{children:"Seq"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",metastring:"mdoc",children:"Chunk(1,2,3).toSeq\n"})})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},28453:(e,n,a)=>{a.d(n,{R:()=>i,x:()=>c});var t=a(96540);const r={},s=t.createContext(r);function i(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);