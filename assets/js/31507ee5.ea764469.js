"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[8990],{20253:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>l,frontMatter:()=>s,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"reference/error-management/types/defects","title":"Defects","description":"By providing a Throwable value to the ZIO.die constructor, we can describe a dying effect:","source":"@site/docs/reference/error-management/types/defects.md","sourceDirName":"reference/error-management/types","slug":"/reference/error-management/types/defects","permalink":"/reference/error-management/types/defects","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/error-management/types/defects.md","tags":[],"version":"current","frontMatter":{"id":"defects","title":"Defects"},"sidebar":"reference-sidebar","previous":{"title":"Failures","permalink":"/reference/error-management/types/failures"},"next":{"title":"Fatal Errors","permalink":"/reference/error-management/types/fatals"}}');var r=t(74848),c=t(28453);const s={id:"defects",title:"Defects"},o=void 0,a={},d=[];function h(e){const n={code:"code",em:"em",li:"li",ol:"ol",p:"p",pre:"pre",...(0,c.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["By providing a ",(0,r.jsx)(n.code,{children:"Throwable"})," value to the ",(0,r.jsx)(n.code,{children:"ZIO.die"})," constructor, we can describe a dying effect:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"object ZIO {\n  def die(t: => Throwable): ZIO[Any, Nothing, Nothing]\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Here is an example of such effect, which will die because of encountering ",(0,r.jsx)(n.em,{children:"divide by zero"})," defect:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nval dyingEffect: ZIO[Any, Nothing, Nothing] =\n  ZIO.die(new ArithmeticException("divide by zero"))\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The result is the creation of a ZIO effect whose error channel and success channel are both ",(0,r.jsx)(n.code,{children:"Nothing"}),". In other words, this effect cannot fail and does not produce anything. Instead, it is an effect describing a ",(0,r.jsx)(n.em,{children:"defect"})," or an ",(0,r.jsx)(n.em,{children:"unexpected error"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Let's see what happens if we run this effect:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run = ZIO.die(new ArithmeticException("divide by zero"))\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"If we run this effect, ZIO runtime will print the stack trace that belongs to this defect. So, here is the output:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'timestamp=2022-02-16T13:02:44.057191215Z level=ERROR thread=#zio-fiber-0 message="Exception in thread "zio-fiber-2" java.lang.ArithmeticException: divide by zero\n\tat MainApp$.$anonfun$run$1(MainApp.scala:4)\n\tat zio.ZIO$.$anonfun$die$1(ZIO.scala:3384)\n\tat zio.internal.FiberContext.runUntil(FiberContext.scala:255)\n\tat zio.internal.FiberContext.run(FiberContext.scala:115)\n\tat zio.internal.ZScheduler$$anon$1.run(ZScheduler.scala:151)\n\tat <empty>.MainApp.run(MainApp.scala:4)"\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"ZIO.die"})," constructor is used to manually describe a dying effect because of a defect inside the code."]}),"\n",(0,r.jsxs)(n.p,{children:["For example, assume we want to write a ",(0,r.jsx)(n.code,{children:"divide"})," function that takes two numbers and divides the first number by the second. We know that the ",(0,r.jsx)(n.code,{children:"divide"})," function is not defined for zero dominators. Therefore, we should signal an error if division by zero occurs."]}),"\n",(0,r.jsx)(n.p,{children:"We have two choices to implement this function using the ZIO effect:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["We can divide the first number by the second, and if the second number was zero, we can fail the effect using ",(0,r.jsx)(n.code,{children:"ZIO.fail"})," with the ",(0,r.jsx)(n.code,{children:"ArithmeticException"})," failure value:"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio._\n\ndef divide(a: Int, b: Int): ZIO[Any, ArithmeticException, Int] =\n  if (b == 0)\n    ZIO.fail(new ArithmeticException("divide by zero"))\n  else\n    ZIO.succeed(a / b)\n'})}),"\n",(0,r.jsxs)(n.ol,{start:"2",children:["\n",(0,r.jsxs)(n.li,{children:["We can divide the first number by the second. In the case of zero for the second number, we use ",(0,r.jsx)(n.code,{children:"ZIO.die"})," to kill the effect by sending a signal of ",(0,r.jsx)(n.code,{children:"ArithmeticException"})," as a defect:"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio._\n\ndef divide(a: Int, b: Int): ZIO[Any, Nothing, Int] =\n  if (b == 0)\n    ZIO.die(new ArithmeticException("divide by zero")) // Unexpected error\n  else\n    ZIO.succeed(a / b)\n'})}),"\n",(0,r.jsx)(n.p,{children:"So what is the difference between these two approaches? Let's compare the function signature:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"def divide(a: Int, b: Int): ZIO[Any, ArithmeticException, Int]   // using ZIO.fail\ndef divide(a: Int, b: Int): ZIO[Any, Nothing,             Int]   // using ZIO.die\n"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["The first approach, models the ",(0,r.jsx)(n.em,{children:"divide by zero"})," error by ",(0,r.jsx)(n.em,{children:"failing"})," the effect. We call these failures ",(0,r.jsx)(n.em,{children:"expected errors"})," or ",(0,r.jsx)(n.em,{children:"typed error"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["While the second approach models the ",(0,r.jsx)(n.em,{children:"divide by zero"})," error by ",(0,r.jsx)(n.em,{children:"dying"})," the effect. We call these kinds of errors ",(0,r.jsx)(n.em,{children:"unexpected errors"}),", ",(0,r.jsx)(n.em,{children:"defects"})," or ",(0,r.jsx)(n.em,{children:"untyped errors"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["We use the first method when we are handling errors as we expect them, and thus we know how to handle them. In contrast, the second method is used when we aren't expecting those errors in our domain, and we don't know how to handle them. Therefore, we use the ",(0,r.jsx)(n.em,{children:"let it crash"})," philosophy."]}),"\n",(0,r.jsxs)(n.p,{children:["In the second approach, we can see that the ",(0,r.jsx)(n.code,{children:"divide"})," function indicates that it cannot fail because it's error channel is ",(0,r.jsx)(n.code,{children:"Nothing"}),". However, it doesn't mean that this function hasn't any defects. ZIO defects are not typed, so they cannot be seen in type parameters."]}),"\n",(0,r.jsxs)(n.p,{children:["Note that to create an effect that will die, we shouldn't throw an exception inside the ",(0,r.jsx)(n.code,{children:"ZIO.die"})," constructor, although it works. Instead, the idiomatic way of creating a dying effect is to provide a ",(0,r.jsx)(n.code,{children:"Throwable"})," value into the ",(0,r.jsx)(n.code,{children:"ZIO.die"})," constructor:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nval defect1 = ZIO.die(new ArithmeticException("divide by zero"))       // recommended\nval defect2 = ZIO.die(throw new ArithmeticException("divide by zero")) // not recommended\n'})}),"\n",(0,r.jsx)(n.p,{children:"Also, if we import a code that may throw an exception, all the exceptions will be translated to the ZIO defect:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nval defect3 = ZIO.succeed(throw new Exception("boom!"))\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Therefore, in the second approach of the ",(0,r.jsx)(n.code,{children:"divide"})," function, we do not require to manually die the effect in case of the ",(0,r.jsx)(n.em,{children:"dividing by zero"}),", because the JVM itself throws an ",(0,r.jsx)(n.code,{children:"ArithmeticException"})," when the denominator is zero."]}),"\n",(0,r.jsxs)(n.p,{children:["When we import any code into the ",(0,r.jsx)(n.code,{children:"ZIO"})," effect, any exception is thrown inside that code will be translated to ",(0,r.jsx)(n.em,{children:"ZIO defects"})," by default. So the following program is the same as the previous example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"import zio._\n\ndef divide(a: Int, b: Int): ZIO[Any, Nothing, Int] =\n  ZIO.succeed(a / b)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Another important note is that if we ",(0,r.jsx)(n.code,{children:"map"}),"/",(0,r.jsx)(n.code,{children:"flatMap"})," a ZIO effect and then accidentally throw an exception inside the map operation, that exception will be translated to a ZIO defect:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nval defect4 = ZIO.succeed(???).map(_ => throw new Exception("Boom!"))\nval defect5 = ZIO.attempt(???).map(_ => throw new Exception("Boom!"))\n'})})]})}function l(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var i=t(96540);const r={},c=i.createContext(r);function s(e){const n=i.useContext(c);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(c.Provider,{value:n},e.children)}}}]);