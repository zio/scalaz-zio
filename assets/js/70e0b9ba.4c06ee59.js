"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[20001],{22130:(e,i,r)=>{r.r(i),r.d(i,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>l,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"overview/overview_basic_concurrency","title":"Basic Concurrency","description":"ZIO has low-level support for concurrency using fibers. While fibers are very powerful, they are low-level. To improve productivity, ZIO provides high-level operations built on fibers.","source":"@site/versioned_docs/version-1.0.18/overview/basic_concurrency.md","sourceDirName":"overview","slug":"/overview/overview_basic_concurrency","permalink":"/1.0.18/overview/overview_basic_concurrency","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/versioned_docs/version-1.0.18/overview/basic_concurrency.md","tags":[],"version":"1.0.18","frontMatter":{"id":"overview_basic_concurrency","title":"Basic Concurrency"},"sidebar":"overview_sidebar","previous":{"title":"Handling Resources","permalink":"/1.0.18/overview/overview_handling_resources"},"next":{"title":"Testing Effects","permalink":"/1.0.18/overview/overview_testing_effects"}}');var t=r(74848),s=r(28453);const l={id:"overview_basic_concurrency",title:"Basic Concurrency"},c=void 0,o={},d=[{value:"Fibers",id:"fibers",level:2},{value:"The Fiber Data Type",id:"the-fiber-data-type",level:3},{value:"Forking Effects",id:"forking-effects",level:3},{value:"Joining Fibers",id:"joining-fibers",level:3},{value:"Awaiting Fibers",id:"awaiting-fibers",level:3},{value:"Interrupting Fibers",id:"interrupting-fibers",level:3},{value:"Composing Fibers",id:"composing-fibers",level:3},{value:"Parallelism",id:"parallelism",level:2},{value:"Racing",id:"racing",level:2},{value:"Timeout",id:"timeout",level:2},{value:"Next Steps",id:"next-steps",level:2}];function a(e){const i={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(i.p,{children:["ZIO has low-level support for concurrency using ",(0,t.jsx)(i.em,{children:"fibers"}),". While fibers are very powerful, they are low-level. To improve productivity, ZIO provides high-level operations built on fibers."]}),"\n",(0,t.jsx)(i.p,{children:"When you can, you should always use high-level operations, rather than working with fibers directly. For the sake of completeness, this section introduces both fibers and some of the high-level operations built on them."}),"\n",(0,t.jsx)(i.h2,{id:"fibers",children:"Fibers"}),"\n",(0,t.jsxs)(i.p,{children:["ZIO's concurrency is built on ",(0,t.jsx)(i.em,{children:"fibers"}),', which are lightweight "green threads" implemented by the ZIO runtime system.']}),"\n",(0,t.jsx)(i.p,{children:"Unlike operating system threads, fibers consume almost no memory, have growable and shrinkable stacks, don't waste resources blocking, and will be garbage collected automatically if they are suspended and unreachable."}),"\n",(0,t.jsx)(i.p,{children:"Fibers are scheduled by the ZIO runtime and will cooperatively yield to each other, which enables multitasking, even when operating in a single-threaded environment (like JavaScript, or even the JVM when configured with one thread)."}),"\n",(0,t.jsxs)(i.p,{children:["All effects in ZIO are executed by ",(0,t.jsx)(i.em,{children:"some"})," fiber. If you did not create the fiber, then the fiber was created by some operation you are using (if the operation is concurrent or parallel), or by the ZIO runtime system."]}),"\n",(0,t.jsx)(i.p,{children:'Even if you only write "single-threaded" code, with no parallel or concurrent operations, then there will be at least one fiber: the "main" fiber that executes your effect.'}),"\n",(0,t.jsx)(i.h3,{id:"the-fiber-data-type",children:"The Fiber Data Type"}),"\n",(0,t.jsxs)(i.p,{children:["Every ZIO fiber is responsible for executing some effect, and the ",(0,t.jsx)(i.code,{children:"Fiber"}),' data type in ZIO represents a "handle" on that running computation. The ',(0,t.jsx)(i.code,{children:"Fiber"})," data type is most similar to Scala's ",(0,t.jsx)(i.code,{children:"Future"})," data type."]}),"\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:"Fiber[E, A]"})," data type in ZIO has two type parameters:"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsxs)(i.strong,{children:[(0,t.jsx)(i.code,{children:"E"})," Failure Type"]}),". The fiber may fail with a value of this type."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsxs)(i.strong,{children:[(0,t.jsx)(i.code,{children:"A"})," Success Type"]}),". The fiber may succeed with a value of this type."]}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:["Fibers do not have an ",(0,t.jsx)(i.code,{children:"R"})," type parameter, because they model effects that are already running, and which already had their required environment provided to them."]}),"\n",(0,t.jsx)(i.h3,{id:"forking-effects",children:"Forking Effects"}),"\n",(0,t.jsxs)(i.p,{children:["The most fundamental way of creating a fiber is to take an existing effect and ",(0,t.jsx)(i.em,{children:"fork"})," it. Conceptually, ",(0,t.jsx)(i.em,{children:"forking"})," an effect begins executing the effect on a new fiber, giving you a reference to the newly-created ",(0,t.jsx)(i.code,{children:"Fiber"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["The following code creates a single fiber, which executes ",(0,t.jsx)(i.code,{children:"fib(100)"}),":"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-scala",children:"def fib(n: Long): UIO[Long] = UIO {\n  if (n <= 1) UIO.succeed(n)\n  else fib(n - 1).zipWith(fib(n - 2))(_ + _)\n}.flatten\n\nval fib100Fiber: UIO[Fiber[Nothing, Long]] = \n  for {\n    fiber <- fib(100).fork\n  } yield fiber\n"})}),"\n",(0,t.jsx)(i.h3,{id:"joining-fibers",children:"Joining Fibers"}),"\n",(0,t.jsxs)(i.p,{children:["One of the methods on ",(0,t.jsx)(i.code,{children:"Fiber"})," is ",(0,t.jsx)(i.code,{children:"Fiber#join"}),", which returns an effect. The effect returned by ",(0,t.jsx)(i.code,{children:"Fiber#join"})," will succeed or fail as per the fiber:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-scala",children:'for {\n  fiber   <- IO.succeed("Hi!").fork\n  message <- fiber.join\n} yield message\n'})}),"\n",(0,t.jsx)(i.h3,{id:"awaiting-fibers",children:"Awaiting Fibers"}),"\n",(0,t.jsxs)(i.p,{children:["Another method on ",(0,t.jsx)(i.code,{children:"Fiber"})," is ",(0,t.jsx)(i.code,{children:"Fiber#await"}),", which returns an effect containing an ",(0,t.jsx)(i.code,{children:"Exit"})," value, which provides full information on how the fiber completed."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-scala",children:'for {\n  fiber <- IO.succeed("Hi!").fork\n  exit  <- fiber.await\n} yield exit\n'})}),"\n",(0,t.jsx)(i.h3,{id:"interrupting-fibers",children:"Interrupting Fibers"}),"\n",(0,t.jsxs)(i.p,{children:["A fiber whose result is no longer needed may be ",(0,t.jsx)(i.em,{children:"interrupted"}),", which immediately terminates the fiber, safely releasing all resources and running all finalizers."]}),"\n",(0,t.jsxs)(i.p,{children:["Like ",(0,t.jsx)(i.code,{children:"await"}),", ",(0,t.jsx)(i.code,{children:"Fiber#interrupt"})," returns an ",(0,t.jsx)(i.code,{children:"Exit"})," describing how the fiber completed."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-scala",children:'for {\n  fiber <- IO.succeed("Hi!").forever.fork\n  exit  <- fiber.interrupt\n} yield exit\n'})}),"\n",(0,t.jsxs)(i.p,{children:["By design, the effect returned by ",(0,t.jsx)(i.code,{children:"Fiber#interrupt"})," does not resume until the fiber has completed. If this behavior is not desired, you can ",(0,t.jsx)(i.code,{children:"fork"})," the interruption itself:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-scala",children:'for {\n  fiber <- IO.succeed("Hi!").forever.fork\n  _     <- fiber.interrupt.fork // I don\'t care!\n} yield ()\n'})}),"\n",(0,t.jsx)(i.h3,{id:"composing-fibers",children:"Composing Fibers"}),"\n",(0,t.jsxs)(i.p,{children:["ZIO lets you compose fibers with ",(0,t.jsx)(i.code,{children:"Fiber#zip"})," or ",(0,t.jsx)(i.code,{children:"Fiber#zipWith"}),"."]}),"\n",(0,t.jsx)(i.p,{children:"These methods combine two fibers into a single fiber that produces the results of both. If either fiber fails, then the composed fiber will fail."}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-scala",children:'for {\n  fiber1 <- IO.succeed("Hi!").fork\n  fiber2 <- IO.succeed("Bye!").fork\n  fiber   = fiber1.zip(fiber2)\n  tuple  <- fiber.join\n} yield tuple\n'})}),"\n",(0,t.jsxs)(i.p,{children:["Another way fibers compose is with ",(0,t.jsx)(i.code,{children:"Fiber#orElse"}),". If the first fiber succeeds, the composed fiber will succeed with its result; otherwise, the composed fiber will complete with the exit value of the second fiber (whether success or failure)."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-scala",children:'for {\n  fiber1 <- IO.fail("Uh oh!").fork\n  fiber2 <- IO.succeed("Hurray!").fork\n  fiber   = fiber1.orElse(fiber2)\n  message  <- fiber.join\n} yield message\n'})}),"\n",(0,t.jsx)(i.h2,{id:"parallelism",children:"Parallelism"}),"\n",(0,t.jsxs)(i.p,{children:["ZIO provides many operations for performing effects in parallel. These methods are all named with a ",(0,t.jsx)(i.code,{children:"Par"})," suffix that helps you identify opportunities to parallelize your code."]}),"\n",(0,t.jsxs)(i.p,{children:["For example, the ordinary ",(0,t.jsx)(i.code,{children:"ZIO#zip"})," method zips two effects together, sequentially. But there is also a ",(0,t.jsx)(i.code,{children:"ZIO#zipPar"})," method, which zips two effects together in parallel."]}),"\n",(0,t.jsx)(i.p,{children:"The following table summarizes some of the sequential operations and their corresponding parallel versions:"}),"\n",(0,t.jsxs)(i.table,{children:[(0,t.jsx)(i.thead,{children:(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.th,{style:{textAlign:"right"},children:(0,t.jsx)(i.strong,{children:"Description"})}),(0,t.jsx)(i.th,{style:{textAlign:"center"},children:(0,t.jsx)(i.strong,{children:"Sequential"})}),(0,t.jsx)(i.th,{style:{textAlign:"center"},children:(0,t.jsx)(i.strong,{children:"Parallel"})})]})}),(0,t.jsxs)(i.tbody,{children:[(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{style:{textAlign:"right"},children:"Zips two effects into one"}),(0,t.jsx)(i.td,{style:{textAlign:"center"},children:(0,t.jsx)(i.code,{children:"ZIO#zip"})}),(0,t.jsx)(i.td,{style:{textAlign:"center"},children:(0,t.jsx)(i.code,{children:"ZIO#zipPar"})})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{style:{textAlign:"right"},children:"Zips two effects into one"}),(0,t.jsx)(i.td,{style:{textAlign:"center"},children:(0,t.jsx)(i.code,{children:"ZIO#zipWith"})}),(0,t.jsx)(i.td,{style:{textAlign:"center"},children:(0,t.jsx)(i.code,{children:"ZIO#zipWithPar"})})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{style:{textAlign:"right"},children:"Zips multiple effects into one"}),(0,t.jsx)(i.td,{style:{textAlign:"center"},children:(0,t.jsx)(i.code,{children:"ZIO#tupled"})}),(0,t.jsx)(i.td,{style:{textAlign:"center"},children:(0,t.jsx)(i.code,{children:"ZIO#tupledPar"})})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{style:{textAlign:"right"},children:"Collects from many effects"}),(0,t.jsx)(i.td,{style:{textAlign:"center"},children:(0,t.jsx)(i.code,{children:"ZIO.collectAll"})}),(0,t.jsx)(i.td,{style:{textAlign:"center"},children:(0,t.jsx)(i.code,{children:"ZIO.collectAllPar"})})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{style:{textAlign:"right"},children:"Effectfully loop over values"}),(0,t.jsx)(i.td,{style:{textAlign:"center"},children:(0,t.jsx)(i.code,{children:"ZIO.foreach"})}),(0,t.jsx)(i.td,{style:{textAlign:"center"},children:(0,t.jsx)(i.code,{children:"ZIO.foreachPar"})})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{style:{textAlign:"right"},children:"Reduces many values"}),(0,t.jsx)(i.td,{style:{textAlign:"center"},children:(0,t.jsx)(i.code,{children:"ZIO.reduceAll"})}),(0,t.jsx)(i.td,{style:{textAlign:"center"},children:(0,t.jsx)(i.code,{children:"ZIO.reduceAllPar"})})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{style:{textAlign:"right"},children:"Merges many values"}),(0,t.jsx)(i.td,{style:{textAlign:"center"},children:(0,t.jsx)(i.code,{children:"ZIO.mergeAll"})}),(0,t.jsx)(i.td,{style:{textAlign:"center"},children:(0,t.jsx)(i.code,{children:"ZIO.mergeAllPar"})})]})]})]}),"\n",(0,t.jsx)(i.p,{children:"For all the parallel operations, if one effect fails, then others will be interrupted, to minimize unnecessary computation."}),"\n",(0,t.jsxs)(i.p,{children:["If the fail-fast behavior is not desired, potentially failing effects can be first converted into infallible effects using the ",(0,t.jsx)(i.code,{children:"ZIO#either"})," or ",(0,t.jsx)(i.code,{children:"ZIO#option"})," methods."]}),"\n",(0,t.jsx)(i.h2,{id:"racing",children:"Racing"}),"\n",(0,t.jsx)(i.p,{children:"ZIO lets you race multiple effects in parallel, returning the first successful result:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-scala",children:'for {\n  winner <- IO.succeed("Hello").race(IO.succeed("Goodbye"))\n} yield winner\n'})}),"\n",(0,t.jsxs)(i.p,{children:["If you want the first success or failure, rather than the first success, then you can use ",(0,t.jsx)(i.code,{children:"left.either race right.either"}),", for any effects ",(0,t.jsx)(i.code,{children:"left"})," and ",(0,t.jsx)(i.code,{children:"right"}),"."]}),"\n",(0,t.jsx)(i.h2,{id:"timeout",children:"Timeout"}),"\n",(0,t.jsxs)(i.p,{children:["ZIO lets you timeout any effect using the ",(0,t.jsx)(i.code,{children:"ZIO#timeout"})," method, which returns a new effect that succeeds with an ",(0,t.jsx)(i.code,{children:"Option"}),". A value of ",(0,t.jsx)(i.code,{children:"None"})," indicates the timeout elapsed before the effect completed."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-scala",children:'import zio.duration._\n\nIO.succeed("Hello").timeout(10.seconds)\n'})}),"\n",(0,t.jsx)(i.p,{children:"If an effect times out, then instead of continuing to execute in the background, it will be interrupted so no resources will be wasted."}),"\n",(0,t.jsx)(i.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsxs)(i.p,{children:["If you are comfortable with basic concurrency, then the next step is to learn about ",(0,t.jsx)(i.a,{href:"/1.0.18/overview/overview_testing_effects",children:"testing effects"}),"."]})]})}function h(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},28453:(e,i,r)=>{r.d(i,{R:()=>l,x:()=>c});var n=r(96540);const t={},s=n.createContext(t);function l(e){const i=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function c(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),n.createElement(s.Provider,{value:i},e.children)}}}]);