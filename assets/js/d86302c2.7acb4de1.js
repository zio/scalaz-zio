"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[75543],{64813:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"zio-connect/file-connector","title":"File Connector","description":"Setup","source":"@site/docs/zio-connect/file-connector.md","sourceDirName":"zio-connect","slug":"/zio-connect/file-connector","permalink":"/zio-connect/file-connector","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-connect/file-connector.md","tags":[],"version":"current","frontMatter":{"id":"file-connector","title":"File Connector"},"sidebar":"ecosystem-sidebar","previous":{"title":"DynamoDB Connector","permalink":"/zio-connect/dynamodb-connector"},"next":{"title":"S3 Connector","permalink":"/zio-connect/s3-connector"}}');var l=i(74848),a=i(28453);const r={id:"file-connector",title:"File Connector"},s=void 0,c={},o=[{value:"Setup",id:"setup",level:2},{value:"How to use it ?",id:"how-to-use-it-",level:2},{value:"Test / Stub",id:"test--stub",level:2},{value:"Operators &amp; Examples",id:"operators--examples",level:2},{value:"readX",id:"readx",level:2},{value:"writeX",id:"writex",level:2},{value:"tailX",id:"tailx",level:2},{value:"tailXUsingWatchService",id:"tailxusingwatchservice",level:2},{value:"deleteX",id:"deletex",level:2},{value:"deleteXRecursively",id:"deletexrecursively",level:2},{value:"existsX",id:"existsx",level:2},{value:"listX",id:"listx",level:2},{value:"moveX",id:"movex",level:2},{value:"moveXZIO",id:"movexzio",level:2},{value:"tempX / tempXIn / tempDirX / tempDirXIn",id:"tempx--tempxin--tempdirx--tempdirxin",level:2}];function d(e){const n={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.h2,{id:"setup",children:"Setup"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:'libraryDependencies += "dev.zio" %% "zio-connect-file" % "0.4.4"\n'})}),"\n",(0,l.jsx)(n.h2,{id:"how-to-use-it-",children:"How to use it ?"}),"\n",(0,l.jsxs)(n.p,{children:["All available FileConnector combinators and operations are available in the package object ",(0,l.jsx)(n.code,{children:"zio.connect.file"}),", you only\nneed to import ",(0,l.jsx)(n.code,{children:"zio.connect.file._"})]}),"\n",(0,l.jsx)(n.p,{children:"For instance the code below uses at each step a FileConnector operator."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:'import zio.connect.file._\n\nval stream: ZStream[Any, Nothing, Byte] = ???\nval sink: ZSink[Any, Nothing, Byte, Nothing, Unit] = ???\n\nfor {\n  dir        <- tempDirPath\n  path       <- tempPathIn(dir)\n  fileExists <- ZStream.fromZIO((ZStream(path) >>> existsPath(file)).tap(a => ZIO.debug(s"$path exists? $a")))\n  _          <- ZStream.fromZIO(stream >>> writePath(file))\n  _          <- ZStream.fromZIO(readPath(file) >>> sink)\n} yield fileExists\n'})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"tempDirPath - creates a directory and returns a ZStream with a single Path value, it will delete it once the for\ncomprehension completes"}),"\n",(0,l.jsx)(n.li,{children:"tempPathIn - creates a file in the given directory and returns a ZStream with a single Path value, it will delete it\nonce the for comprehension completes"}),"\n",(0,l.jsx)(n.li,{children:"existsPath - creates a ZStream with a single value"}),"\n",(0,l.jsx)(n.li,{children:"writePath - creates ZSink for writing to given file"}),"\n",(0,l.jsx)(n.li,{children:"readPath - creates a ZStream for reading from given file"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"test--stub",children:"Test / Stub"}),"\n",(0,l.jsxs)(n.p,{children:["A stub implementation of FileConnector is provided for testing purposes via the ",(0,l.jsx)(n.code,{children:"TestFileConnector.layer"}),". It uses\ninternally an in memory filesystem to avoid the actual creation of files."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:'package zio.connect.file\n\nimport zio.Scope\n\nobject MyTestSpec extends ZIOSpecDefault{\n\n  override def spec =\n    suite("MyTestSpec")(???)\n      .provide(zio.connect.file.fileConnectorTestLayer)\n\n}\n'})}),"\n",(0,l.jsx)(n.h2,{id:"operators--examples",children:"Operators & Examples"}),"\n",(0,l.jsx)(n.h2,{id:"readx",children:"readX"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"readFile | readFileName | readPath | readURI"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Creates a ZStream for reading a file's content from a path/file/...\nThe stream ends once all content is read."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"import zio.connect.file._\n\ndef example(path: Path): ZStream[Any, IOException, Byte] =\n   readPath(path)\n"})}),"\n",(0,l.jsx)(n.h2,{id:"writex",children:"writeX"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"writeFile | writeFileName | writePath | writeURI"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Creates a ZSink for writing to a file.\nThe stream ends once all content is read."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"import zio.connect.file._\n\ndef example(path: Path): ZSink[Any, IOException, Byte, Nothing, Unit] =\n   writePath(path)\n"})}),"\n",(0,l.jsx)(n.h2,{id:"tailx",children:"tailX"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"tailFile | tailFileName | tailPath | tailURI"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Creates a ZStream for reading a file's content from a path/file/...\nThe stream never ends emitting; it will keep polling the file (with given frequency) even after all content is read."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"import zio.connect.file._\n\ndef example(path: Path, freq: Duration): ZStream[Any, IOException, Byte] =\n   tailPath(path, freq)\n"})}),"\n",(0,l.jsx)(n.h2,{id:"tailxusingwatchservice",children:"tailXUsingWatchService"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"tailFileUsingWatchService | tailFileNameUsingWatchService | tailPathUsingWatchService | tailURIUsingWatchService"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Creates a ZStream for reading a file's content from a path/file/...\nThe stream never ends emitting; it will keep polling the file (with given frequency and if watchService detects\nchanges) even after all content is read."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"import zio.connect.file._\n\ndef example(path: Path, freq: Duration): ZStream[Any, IOException, Byte] =\n   tailPathUsingWatchService(path, freq)\n"})}),"\n",(0,l.jsx)(n.h2,{id:"deletex",children:"deleteX"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"deleteFile | deleteFileName | deletePath | deleteURI"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"It provides a sink that deletes the file or directory.\nTo delete non empty directories use the deleteRecursivelyX variants."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"import zio.connect.file._\n\ndef example(paths: ZStream[Any, Nothing, Path]) =\n   paths >>> deletePath\n"})}),"\n",(0,l.jsx)(n.h2,{id:"deletexrecursively",children:"deleteXRecursively"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"deleteFileRecursively | deleteFileNameRecursively | deletePathRecursively | deleteURIRecursively"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Same as deleteX operator + it can delete non empty directories."}),"\n",(0,l.jsx)(n.h2,{id:"existsx",children:"existsX"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"existsFile | existsFileName | existsPath | existsURI"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Creates a ZSink that emits true if the first path/file/... exists or a false\notherwise. The files received after the first one can be found in the sink's leftovers."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"import zio.connect.file._\n\ndef example(stream: ZStream[Any, IOException, Path]): ZIO[Any, IOException, Boolean] = \n    stream >>> existsPath\n"})}),"\n",(0,l.jsx)(n.h2,{id:"listx",children:"listX"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"listFile | listFileName | listPath | listURI"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Returns the files inside the given path/file/.... Fails if provided path is not a dir."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"import zio.connect.file._\n\ndef example(path: Path): ZStream[Any, IOException, Path] = \n    listPath(path)\n"})}),"\n",(0,l.jsx)(n.h2,{id:"movex",children:"moveX"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"moveFile | moveFileName | movePath | moveURI"}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["You can provide a function ",(0,l.jsx)(n.code,{children:"Path => Path"})," and you will get a Sink that when given a path p1 will call the function\nwith p1 and so get a p2, then move the file/dir at p1 to p2."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"import zio.connect.file._\n\ndef example(locator: Path => Path): ZSink[Any, IOException, Path, Nothing, Unit] = \n    movePath(locator)\n"})}),"\n",(0,l.jsx)(n.h2,{id:"movexzio",children:"moveXZIO"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"moveFileZIO | moveFileNameZIO | movePathZIO | moveURIZIO"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Same as moveX except determining the destination is effectful."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"import zio.connect.file._\n\ndef example(locator: Path => ZIO[Any, IOException, Path]): ZSink[Any, IOException, Path, Nothing, Unit] = \n    movePathZIO(locator)\n"})}),"\n",(0,l.jsx)(n.h2,{id:"tempx--tempxin--tempdirx--tempdirxin",children:"tempX / tempXIn / tempDirX / tempDirXIn"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"tempFile | tempFileName | tempPath | tempURI"}),"\n",(0,l.jsx)(n.li,{children:"tempFileIn | tempFileNameIn | tempPathIn | tempURIIn"}),"\n",(0,l.jsx)(n.li,{children:"tempDirFile | tempDirFileName | tempDirPath | tempDirURI"}),"\n",(0,l.jsx)(n.li,{children:"tempDirFileIn | tempDirFileNameIn | tempDirPathIn | tempDirURIIn"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"With this set of operators we can create temporary files and directories that will be cleaned up automatically once the\neffect using them completes."}),"\n",(0,l.jsx)(n.p,{children:"The below example creates the following structure:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"file"}),"\n",(0,l.jsxs)(n.li,{children:["baseDir","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["subDir","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"fileInSubDir"}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.li,{children:"fileInBaseDir"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"import zio.connect.file._\n\ndef example() = \n    for {\n       file          <- tempPath\n       baseDir       <- tempDirPath\n       subDir        <- tempDirPathIn(baseDir)\n       fileInBaseDir <- tempPathIn(baseDir)\n       fileInSubDir  <- tempPathIn(subDir)\n    } yield ()\n"})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>s});var t=i(96540);const l={},a=t.createContext(l);function r(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:r(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);