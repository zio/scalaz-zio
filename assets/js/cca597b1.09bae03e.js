"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[16484],{1790:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"reference/concurrency/semaphore","title":"Semaphore","description":"A Semaphore datatype which allows synchronization between fibers with the withPermit operation, which safely acquires and releases a permit.","source":"@site/versioned_docs/version-1.0.18/reference/concurrency/semaphore.md","sourceDirName":"reference/concurrency","slug":"/reference/concurrency/semaphore","permalink":"/1.0.18/reference/concurrency/semaphore","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/versioned_docs/version-1.0.18/reference/concurrency/semaphore.md","tags":[],"version":"1.0.18","frontMatter":{"id":"semaphore","title":"Semaphore"},"sidebar":"overview_sidebar","previous":{"title":"Hub","permalink":"/1.0.18/reference/concurrency/hub"},"next":{"title":"Introduction","permalink":"/1.0.18/reference/stm/"}}');var i=r(74848),t=r(28453);const o={id:"semaphore",title:"Semaphore"},a=void 0,c={},l=[{value:"Operations",id:"operations",level:2}];function d(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.code,{children:"Semaphore"})," datatype which allows synchronization between fibers with the ",(0,i.jsx)(n.code,{children:"withPermit"})," operation, which safely acquires and releases a permit.\n",(0,i.jsx)(n.code,{children:"Semaphore"})," is based on ",(0,i.jsx)(n.code,{children:"Ref[A]"})," datatype."]}),"\n",(0,i.jsx)(n.h2,{id:"operations",children:"Operations"}),"\n",(0,i.jsxs)(n.p,{children:["For example a synchronization of asynchronous tasks can\nbe done via acquiring and releasing a semaphore with given number of permits it can spend.\nWhen the acquire operation cannot be performed, due to insufficient ",(0,i.jsx)(n.code,{children:"permits"})," value in the semaphore, such task\nis placed in internal suspended fibers queue and will be awaken when ",(0,i.jsx)(n.code,{children:"permits"})," value is sufficient:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'import java.util.concurrent.TimeUnit\nimport zio._\nimport zio.console._\nimport zio.duration.Duration\n\nval task = for {\n  _ <- putStrLn("start")\n  _ <- ZIO.sleep(Duration(2, TimeUnit.SECONDS))\n  _ <- putStrLn("end")\n} yield ()\n\nval semTask = (sem: Semaphore) => for {\n  _ <- sem.withPermit(task)\n} yield ()\n\nval semTaskSeq = (sem: Semaphore) => (1 to 3).map(_ => semTask(sem))\n\nval program = for {\n\n  sem <- Semaphore.make(permits = 1)\n\n  seq <- ZIO.effectTotal(semTaskSeq(sem))\n\n  _ <- ZIO.collectAllPar(seq)\n\n} yield ()\n'})}),"\n",(0,i.jsx)(n.p,{children:"As the binary semaphore is a special case of counting semaphore\nwe can acquire and release any value, regarding semaphore's permits:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"val semTaskN = (sem: Semaphore) => for {\n  _ <- sem.withPermits(5)(task)\n} yield ()\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The guarantee of ",(0,i.jsx)(n.code,{children:"withPermit"})," (and its corresponding counting version ",(0,i.jsx)(n.code,{children:"withPermits"}),") is that acquisition will be followed by equivalent release, regardless of whether the task succeeds, fails, or is interrupted."]})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>a});var s=r(96540);const i={},t=s.createContext(i);function o(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);