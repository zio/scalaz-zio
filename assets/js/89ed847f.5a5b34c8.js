"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[64694],{21651:(e,r,i)=>{i.r(r),i.d(r,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>n,toc:()=>o});const n=JSON.parse('{"id":"reference/sync/cyclicbarrier","title":"CyclicBarrier","description":"A synchronization aid that allows a set of fibers to all wait for each other to reach a common barrier point.","source":"@site/docs/reference/sync/cyclicbarrier.md","sourceDirName":"reference/sync","slug":"/reference/sync/cyclicbarrier","permalink":"/reference/sync/cyclicbarrier","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/sync/cyclicbarrier.md","tags":[],"version":"current","frontMatter":{"id":"cyclicbarrier","title":"CyclicBarrier"},"sidebar":"reference-sidebar","previous":{"title":"CountdownLatch","permalink":"/reference/sync/countdownlatch"},"next":{"title":"ConcurrentMap","permalink":"/reference/sync/concurrentmap"}}');var t=i(74848),a=i(28453);const s={id:"cyclicbarrier",title:"CyclicBarrier"},l=void 0,c={},o=[{value:"Creation",id:"creation",level:2},{value:"Simple Example",id:"simple-example",level:2},{value:"Cyclic Example",id:"cyclic-example",level:2},{value:"Internals",id:"internals",level:2},{value:"Operations",id:"operations",level:2},{value:"reset",id:"reset",level:3},{value:"await",id:"await",level:3},{value:"Barrier Breakage Model",id:"barrier-breakage-model",level:3}];function d(e){const r={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.p,{children:"A synchronization aid that allows a set of fibers to all wait for each other to reach a common barrier point."}),"\n",(0,t.jsx)(r.p,{children:"CyclicBarriers are useful in programs involving a fixed sized party of fibers that must occasionally wait for each other. The barrier is called cyclic because it can be re-used after the waiting fibers are released."}),"\n",(0,t.jsx)(r.h2,{id:"creation",children:"Creation"}),"\n",(0,t.jsxs)(r.p,{children:["To create a ",(0,t.jsx)(r.code,{children:"CyclicBarrier"})," we must provide the number of parties, and we can also provide an optional action:"]}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"number of parties"}),"\u2014 The fibers that need to synchronize their execution are called ",(0,t.jsx)(r.em,{children:"parties"}),". This number denotes how many parties must occasionally wait for each other. In other words, it specifies the number of parties required to trip the barrier."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"action"}),"\u2014 An optional command that is run once per barrier point, after the last fiber in the party arrives, but before any fibers are resumed. This action is useful for updating the shared state before any of the parties continue."]}),"\n"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-scala",children:"object CyclicBarrier {\n  def make(parties: Int)                  : UIO[CyclicBarrier] = ???\n  def make(parties: Int, action: UIO[Any]): UIO[CyclicBarrier] = ???\n}\n"})}),"\n",(0,t.jsxs)(r.p,{children:["If we create a barrier and don't call ",(0,t.jsx)(r.code,{children:"await"})," on that, the barrier is not going to be released and the number of ",(0,t.jsx)(r.code,{children:"waiting"})," fibers remains zero:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-scala",children:'import zio._\nimport zio.concurrent.CyclicBarrier\n\nfor {\n  barrier  <- CyclicBarrier.make(100, ZIO.debug("This is a release action!"))\n  isBroken <- barrier.isBroken  \n  waiting  <- barrier.waiting\n} yield assert(!isBroken && waiting == 0)\n'})}),"\n",(0,t.jsx)(r.h2,{id:"simple-example",children:"Simple Example"}),"\n",(0,t.jsx)(r.p,{children:"In the following example, we started three tasks, each one has a different working time, but they won't return until the other parties finished their jobs:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-scala",children:'import zio._\nimport zio.concurrent.CyclicBarrier\n\nobject MainApp extends ZIOAppDefault {\n  def task(name: String) =\n    for {\n      b <- ZIO.service[CyclicBarrier]\n      _ <- ZIO.debug(s"task-$name: started my job right now!")\n      d <- Random.nextLongBetween(1000, 10000)\n      _ <- ZIO.sleep(Duration.fromMillis(d))\n      _ <- ZIO.debug(s"task-$name: finished my job and waiting for other parties to finish their jobs")\n      _ <- b.await \n      _ <- ZIO.debug(s"task-$name: the barrier is now broken, so I\'m going to exit immediately!")\n    } yield ()\n\n  def run =\n    for {\n      b    <- CyclicBarrier.make(3)\n      tasks = task("1") <&> task("2") <&> task("3")\n      _    <- tasks.provide(ZLayer.succeed(b))\n    } yield ()\n}\n'})}),"\n",(0,t.jsx)(r.h2,{id:"cyclic-example",children:"Cyclic Example"}),"\n",(0,t.jsxs)(r.p,{children:["\u0651If we change the previous example and add more than three tasks, the first three arriving tasks will be blocked and wait for synchronization. After the barrier is broken, the next three tasks will be blocked on the next barrier. ",(0,t.jsx)(r.strong,{children:"This process will be executed again and again for further tasks. This is why we say that the barrier is cyclic"}),":"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-scala",children:'import zio._\nimport zio.concurrent.CyclicBarrier\n\nobject MainApp extends ZIOAppDefault {\n\n  def task(name: String) =\n    for {\n      b <- ZIO.service[CyclicBarrier]\n      _ <- ZIO.debug(s"task-$name: started my job right now!")\n      d <- Random.nextLongBetween(1000, 10000)\n      _ <- ZIO.sleep(Duration.fromMillis(d))\n      _ <- ZIO.debug(s"task-$name: finished my job and waiting for other parties to finish their jobs")\n      _ <- b.await\n      _ <- ZIO.debug(s"task-$name: the barrier is now broken, so I\'m going to exit immediately!")\n    } yield ()\n\n  def run =\n    for {\n      b <- CyclicBarrier.make(\n             parties = 3,\n             action = ZIO.debug(\n               "The barrier is released right now!" +\n                 "I can do some effectful actions on release of barrier."\n             )\n           )\n      tasks = task("1") <&>\n                task("2") <&>\n                task("3") <&>\n                task("4") <&>\n                task("5")\n      _ <- tasks.provide(ZLayer.succeed(b))\n    } yield ()\n}\n'})}),"\n",(0,t.jsxs)(r.p,{children:["In this example after breakage of the barrier by proceeding with ",(0,t.jsx)(r.code,{children:"task 1"}),", ",(0,t.jsx)(r.code,{children:"task 2"}),", and ",(0,t.jsx)(r.code,{children:"task 3"}),", the ",(0,t.jsx)(r.code,{children:"CyclicBarrier"})," will be reset to the initial state, so other tasks can come in and ",(0,t.jsx)(r.code,{children:"await"})," on the barrier. So here, ",(0,t.jsx)(r.code,{children:"task 4"})," and ",(0,t.jsx)(r.code,{children:"task 5"}),", proceed with their job and finally wait for all parties to come into the barrier point, but in this example, as we didn't provide ",(0,t.jsx)(r.code,{children:"task 6"}),", the remaining tasks will block the execution of the whole program, infinitely; because the number of waiting fibers are not equal to ",(0,t.jsx)(r.code,{children:"parties"}),"."]}),"\n",(0,t.jsxs)(r.p,{children:["If we add another concurrent task (e.g. ",(0,t.jsx)(r.code,{children:'task("6")'}),") to our list of tasks, finally the next group of jobs that are waiting for each other will trip the barrier."]}),"\n",(0,t.jsx)(r.h2,{id:"internals",children:"Internals"}),"\n",(0,t.jsxs)(r.p,{children:["Each ",(0,t.jsx)(r.code,{children:"CyclicBarrier"})," has the following internal ",(0,t.jsx)(r.em,{children:"private"})," properties, knowing them helps us to have a deep understanding of how ",(0,t.jsx)(r.code,{children:"CyclicBarrier"})," works:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-scala",children:"class CyclicBarrier private (\n  private val _parties: Int,\n  private val _waiting: Ref[Int],\n  private val _lock: Ref[Promise[Unit, Unit]],\n  private val _action: UIO[Any],\n  private val _broken: Ref[Boolean]\n)\n"})}),"\n",(0,t.jsx)(r.p,{children:"Let's introduce each one:"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"_parties"}),"\u2014 The fibers that need to synchronize their execution are called ",(0,t.jsx)(r.em,{children:"parties"}),". It is an immutable property and will be assigned when we create a ",(0,t.jsx)(r.code,{children:"CyclicBarrier"})," using one of the ",(0,t.jsx)(r.code,{children:"make"})," constructors of the ",(0,t.jsx)(r.code,{children:"CyclicBarrier"}),"."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"_waiting"}),"\u2014 This is a mutable property that denotes the number of already fibers waiting for the release of the barrier. These fibers are waiting together for synchronization purpose. To access this property, we can use the ",(0,t.jsx)(r.code,{children:"waiting"})," member of a ",(0,t.jsx)(r.code,{children:"CyclicBarrier"})," which returns ",(0,t.jsx)(r.code,{children:"UIO[Int]"}),"."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"_lock"}),"\u2014 This is a mutable property that contains a ",(0,t.jsx)(r.code,{children:"Promise[Unit, Unit]"}),":"]}),"\n"]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["When a barrier is ",(0,t.jsx)(r.em,{children:"released"}),", the value of this promise internally will be succeeded with a ",(0,t.jsx)(r.code,{children:"Unit"})," value."]}),"\n",(0,t.jsxs)(r.li,{children:["When a barrier is ",(0,t.jsx)(r.em,{children:"broken"}),", the value of this promise internally will be failed with a ",(0,t.jsx)(r.code,{children:"Unit"})," value."]}),"\n",(0,t.jsx)(r.li,{children:"There is no public API for changing the value of this property."}),"\n"]}),"\n",(0,t.jsxs)(r.ol,{start:"4",children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"_action"}),"\u2014 When we create a ",(0,t.jsx)(r.code,{children:"CyclicBarrier"})," we can provide an effectful ",(0,t.jsx)(r.em,{children:"action"})," of type ",(0,t.jsx)(r.code,{children:"UIO[Any]"})," which will be executed when the barrier is released before any of the parties continue."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"_broken"}),"\u2014 This is a mutable property which denotes that whether the barrier is broken or not:"]}),"\n"]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["The default value of ",(0,t.jsx)(r.code,{children:"_broken"})," is ",(0,t.jsx)(r.code,{children:"false"}),"."]}),"\n",(0,t.jsxs)(r.li,{children:["When one of the ",(0,t.jsx)(r.code,{children:"_waiting"})," fibers is interrupted, the barrier will be broken and the value of ",(0,t.jsx)(r.code,{children:"_broken"})," will be changed to ",(0,t.jsx)(r.code,{children:"true"}),"."]}),"\n",(0,t.jsxs)(r.li,{children:["We can access this value using ",(0,t.jsx)(r.code,{children:"isBroken"})," method on a ",(0,t.jsx)(r.code,{children:"CyclicBarrier"}),"."]}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"operations",children:"Operations"}),"\n",(0,t.jsxs)(r.p,{children:["Let's take a look at the operations defined on a ",(0,t.jsx)(r.code,{children:"CyclicBarrier"}),", then we'll drill down to the important ones:"]}),"\n",(0,t.jsxs)(r.table,{children:[(0,t.jsx)(r.thead,{children:(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.th,{children:"Method"}),(0,t.jsx)(r.th,{children:"Definition"})]})}),(0,t.jsxs)(r.tbody,{children:[(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:(0,t.jsx)(r.code,{children:"parties: Int"})}),(0,t.jsx)(r.td,{children:"The number of parties required to trip this barrier."})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:(0,t.jsx)(r.code,{children:"waiting: UIO[Int]"})}),(0,t.jsx)(r.td,{children:"The number of parties currently waiting at the barrier."})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:(0,t.jsx)(r.code,{children:"await: IO[Unit, Int]"})}),(0,t.jsx)(r.td,{children:"Waits until all parties have invoked await on this barrier. Fails if the barrier is broken."})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:(0,t.jsx)(r.code,{children:"reset: UIO[Unit]"})}),(0,t.jsx)(r.td,{children:"Resets the barrier to its initial state. Breaks any waiting party."})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:(0,t.jsx)(r.code,{children:"isBroken: UIO[Boolean]"})}),(0,t.jsx)(r.td,{children:"Queries if this barrier is in a broken state."})]})]})]}),"\n",(0,t.jsx)(r.h3,{id:"reset",children:"reset"}),"\n",(0,t.jsxs)(r.p,{children:["When we reset a barrier, the barrier will be reset to its ",(0,t.jsx)(r.em,{children:"initial state"})," through the following uninterruptible steps:"]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["It breaks any waiting party. So all ",(0,t.jsx)(r.em,{children:"waiting"})," fibers will be interrupted correspondingly."]}),"\n",(0,t.jsxs)(r.li,{children:["The barrier will be ready to synchronize the next groups of parties. So further ",(0,t.jsx)(r.code,{children:"await"})," calls will be accepted for synchronization. This is why we say that the barrier is cyclic."]}),"\n",(0,t.jsxs)(r.li,{children:["Number of ",(0,t.jsx)(r.em,{children:"waiting"})," fibers will be reset to zero, so there is no fiber in a ",(0,t.jsx)(r.em,{children:"waiting"})," state."]}),"\n",(0,t.jsxs)(r.li,{children:["If the barrier is broken, it will set its ",(0,t.jsx)(r.em,{children:"broken status"})," to ",(0,t.jsx)(r.code,{children:"false"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:["Here is an example shows the mechanism of ",(0,t.jsx)(r.code,{children:"reset"})," method:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-scala",children:'import zio._\nimport zio.concurrent.CyclicBarrier\n\nobject MainApp extends ZIOAppDefault {\n  def task(name: String, b: CyclicBarrier) =\n    for {\n      _ <- ZIO.debug(s"task-$name: started my job right now!")\n      _ <- b.await\n      _ <- ZIO.debug(\n             s"task-$name: the barrier is now released, " +\n               s"so I\'m going to exit immediately!"\n           )\n    } yield ()\n\n  def run =\n    for {\n      b  <- CyclicBarrier.make(3)\n      f1 <- task("1", b).fork\n      f2 <- task("2", b).fork\n      f3 <-\n        (ZIO.sleep(1.second) *> task("3", b))\n          .onInterrupt(\n            ZIO.debug(\n              "task-3: I started my job with some delay! " +\n                "so before getting the chance to await on the barrier, " +\n                "the reset operation interrupted me!"\n            )\n          )\n          .fork\n      _ <- f1.status.repeatWhile(!_.isInstanceOf[Fiber.Status.Suspended])\n      _ <- f2.status.repeatWhile(!_.isInstanceOf[Fiber.Status.Suspended])\n      _ <- b.waiting.debug("waiting fibers before reset")\n      _ <- ZIO.whenZIO(f3.status.map(_.isInstanceOf[Fiber.Status.Running]))(b.reset)\n      _ <- b.waiting.debug("waiting fibers after reset")\n      _ <- f1.join\n      _ <- f2.join\n      _ <- f3.join\n    } yield ()\n}\n'})}),"\n",(0,t.jsx)(r.h3,{id:"await",children:"await"}),"\n",(0,t.jsxs)(r.p,{children:["When we call ",(0,t.jsx)(r.code,{children:"await"})," on a ",(0,t.jsx)(r.code,{children:"CyclicBarrier"}),", it will return a value of type ",(0,t.jsx)(r.code,{children:"IO[Unit, Int]"})," through the following uninterruptible steps:"]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["If the barrier is broken, it will fail with the type of ",(0,t.jsx)(r.code,{children:"Unit"}),"."]}),"\n",(0,t.jsxs)(r.li,{children:["Then, it will wait until all parties have invoked ",(0,t.jsx)(r.code,{children:"await"})," on this barrier:","\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["If the number of ",(0,t.jsx)(r.em,{children:"waiting"})," fibers reaches the number of ",(0,t.jsx)(r.em,{children:"parties"}),":","\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["First, the optional ",(0,t.jsx)(r.em,{children:"action"})," effect will be performed."]}),"\n",(0,t.jsxs)(r.li,{children:["Before resuming all ",(0,t.jsx)(r.em,{children:"waiting"})," fibers, the barrier will be reset to its ",(0,t.jsx)(r.em,{children:"initial state"})," using the ",(0,t.jsx)(r.code,{children:"reset"})," method."]}),"\n",(0,t.jsxs)(r.li,{children:["Accordingly, all parties that are in ",(0,t.jsx)(r.em,{children:"waiting"})," state due to the call to ",(0,t.jsx)(r.code,{children:"await"})," method will resume and continue processing."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["If the number of ",(0,t.jsx)(r.em,{children:"waiting"})," fibers is not reached the number of ",(0,t.jsx)(r.em,{children:"parties"}),", it will suspend the fiber (and that fiber will become one of the ",(0,t.jsx)(r.em,{children:"waiting"})," fibers) until all parties have invoked ",(0,t.jsx)(r.code,{children:"await"})," on this barrier. During this process, if any waiting fibers are interrupted, ",(0,t.jsx)(r.a,{href:"#barrier-breakage-model",children:"the barrier will be broken"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"barrier-breakage-model",children:"Barrier Breakage Model"}),"\n",(0,t.jsx)(r.p,{children:"A barrier can be broken in one of the following cases:"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:["The ",(0,t.jsx)(r.code,{children:"CyclicBarrier"})," uses an ",(0,t.jsx)(r.em,{children:"all-or-none breakage model"})," for failed synchronization attempts: If a fiber leaves a barrier point prematurely because of interruption, failure, or timeout, all other fibers waiting at that barrier point will break other parties."]}),"\n",(0,t.jsx)(r.li,{children:"Manual reset of a barrier will break all waiting parties."}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:"An example:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-scala",children:"import zio._\nimport zio.concurrent.CyclicBarrier\nimport zio.test.TestClock\n\nfor {\n  barrier   <- CyclicBarrier.make(100)\n  f1        <- barrier.await.timeout(1.second).fork\n  f2        <- barrier.await.fork\n  _         <- f1.status.repeatWhile(!_.isInstanceOf[Fiber.Status.Suspended])\n  _         <- f2.status.repeatWhile(!_.isInstanceOf[Fiber.Status.Suspended])\n  isBroken1 <- barrier.isBroken\n  _         <- TestClock.adjust(1.second)\n  isBroken2 <- barrier.isBroken\n  res1      <- f1.await\n  res2      <- f2.await\n} yield assert(!isBroken1 && isBroken2)\n"})})]})}function h(e={}){const{wrapper:r}={...(0,a.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,r,i)=>{i.d(r,{R:()=>s,x:()=>l});var n=i(96540);const t={},a=n.createContext(t);function s(e){const r=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function l(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),n.createElement(a.Provider,{value:r},e.children)}}}]);