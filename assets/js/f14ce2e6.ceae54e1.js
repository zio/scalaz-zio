"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[2087],{78911:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"reference/error-management/typed-errors-guarantees","title":"Typed Errors Guarantees","description":"Typed errors don\'t guarantee the absence of defects and interruptions. Having an effect of type ZIO[R, E, A], means it can fail because of some failure of type E, but it doesn\'t mean it can\'t die or be interrupted. So the error channel is only for failure errors.","source":"@site/docs/reference/error-management/typed-errors-guarantees.md","sourceDirName":"reference/error-management","slug":"/reference/error-management/typed-errors-guarantees","permalink":"/reference/error-management/typed-errors-guarantees","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/error-management/typed-errors-guarantees.md","tags":[],"version":"current","frontMatter":{"id":"typed-errors-guarantees","title":"Typed Errors Guarantees","sidebar_label":"Typed Errors Guarantees"},"sidebar":"reference-sidebar","previous":{"title":"Exceptional and Unexceptional Effects","permalink":"/reference/error-management/exceptional-and-unexceptional-effects"},"next":{"title":"Sequential and Parallel Errors","permalink":"/reference/error-management/sequential-and-parallel-errors"}}');var a=n(74848),o=n(28453);const i={id:"typed-errors-guarantees",title:"Typed Errors Guarantees",sidebar_label:"Typed Errors Guarantees"},s=void 0,c={},d=[];function l(e){const r={code:"code",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Typed errors don't guarantee the absence of defects and interruptions."})," Having an effect of type ",(0,a.jsx)(r.code,{children:"ZIO[R, E, A]"}),", means it can fail because of some failure of type ",(0,a.jsx)(r.code,{children:"E"}),", but it doesn't mean it can't die or be interrupted. So the error channel is only for ",(0,a.jsx)(r.code,{children:"failure"})," errors."]}),"\n",(0,a.jsxs)(r.p,{children:["In the following example, the type of the ",(0,a.jsx)(r.code,{children:"validateNonNegativeNumber"})," function is ",(0,a.jsx)(r.code,{children:"ZIO[Any, String, Int]"})," which denotes it is a typed exceptional effect. It can fail of type ",(0,a.jsx)(r.code,{children:"String"})," but it still can die with the type of ",(0,a.jsx)(r.code,{children:"NumberFormatException"})," defect:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-scala",children:'import zio._\n\ndef validateNonNegativeNumber(input: String): ZIO[Any, String, Int] =\n  input.toIntOption match {\n    case Some(value) if value >= 0 =>\n      ZIO.succeed(value)\n    case Some(other) =>\n      ZIO.fail(s"the entered number is negative: $other")\n    case None =>\n      ZIO.die(\n        new NumberFormatException(\n          s"the entered input is not in the correct number format: $input"\n        )\n      )\n  }\n'})}),"\n",(0,a.jsx)(r.p,{children:"Also, its underlying fiber can be interrupted without affecting the type of the error channel:"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-scala",children:'import zio._\n\nval myApp: ZIO[Any, String, Int] =\n  for {\n    f <- validateNonNegativeNumber("5").fork\n    _ <- f.interrupt\n    r <- f.join\n  } yield r\n'})}),"\n",(0,a.jsxs)(r.p,{children:["Therefore, if we run the ",(0,a.jsx)(r.code,{children:"myApp"})," effect, it will be interrupted before it gets the chance to finish."]})]})}function u(e={}){const{wrapper:r}={...(0,o.R)(),...e.components};return r?(0,a.jsx)(r,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},28453:(e,r,n)=>{n.d(r,{R:()=>i,x:()=>s});var t=n(96540);const a={},o=t.createContext(a);function i(e){const r=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function s(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(o.Provider,{value:r},e.children)}}}]);