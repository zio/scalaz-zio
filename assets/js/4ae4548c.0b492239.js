"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[95105],{38976:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>p,frontMatter:()=>o,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"reference/di/dependency-memoization","title":"Layers Are Shared by Default","description":"Layer memoization allows a layer to be created once and used multiple times in the dependency graph. So if we use the same layer twice, e.g. (a >>> b) ++ (a >>> c), then the a layer will be allocated only once.","source":"@site/docs/reference/di/dependency-memoization.md","sourceDirName":"reference/di","slug":"/reference/di/dependency-memoization","permalink":"/reference/di/dependency-memoization","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/di/dependency-memoization.md","tags":[],"version":"current","frontMatter":{"id":"dependency-memoization","title":"Layers Are Shared by Default","sidebar_label":"Dependency Memoization"},"sidebar":"reference-sidebar","previous":{"title":"Multiple Implementations","permalink":"/reference/di/providing-different-implementation-of-a-service"},"next":{"title":"Overriding Dependency Graph","permalink":"/reference/di/overriding-dependency-graph"}}');var r=i(74848),t=i(28453);const o={id:"dependency-memoization",title:"Layers Are Shared by Default",sidebar_label:"Dependency Memoization"},l=void 0,d={},c=[{value:"Layers are Memoized by Default When Providing Globally",id:"layers-are-memoized-by-default-when-providing-globally",level:2},{value:"Acquiring a Fresh Version",id:"acquiring-a-fresh-version",level:2},{value:"Layers Are Not Memoized When Providing Locally",id:"layers-are-not-memoized-when-providing-locally",level:2},{value:"Manual Memoization",id:"manual-memoization",level:2}];function s(e){const n={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["Layer memoization allows a layer to be created once and used multiple times in the dependency graph. So if we use the same layer twice, e.g. ",(0,r.jsx)(n.code,{children:"(a >>> b) ++ (a >>> c)"}),", then the ",(0,r.jsx)(n.code,{children:"a"})," layer will be allocated only once."]}),"\n",(0,r.jsx)(n.h2,{id:"layers-are-memoized-by-default-when-providing-globally",children:"Layers are Memoized by Default When Providing Globally"}),"\n",(0,r.jsxs)(n.p,{children:["One important feature of a ZIO application is that layers are shared by default, meaning that if the same layer is used twice, and if we provide the layer ",(0,r.jsx)(n.a,{href:"/reference/di/overriding-dependency-graph#global-environment",children:"globally"})," the layer will only be allocated a single time. For every layer in our dependency graph, there is only one instance of it that is shared between all the layers that depend on it."]}),"\n",(0,r.jsxs)(n.p,{children:["For example, assume we have the three ",(0,r.jsx)(n.code,{children:"A"}),", ",(0,r.jsx)(n.code,{children:"B"}),", and ",(0,r.jsx)(n.code,{children:"C"})," services. The implementation of both ",(0,r.jsx)(n.code,{children:"B"})," and ",(0,r.jsx)(n.code,{children:"C"})," are dependent on the ",(0,r.jsx)(n.code,{children:"A"})," service:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio._\n\ntrait A\ntrait B\ntrait C\n\ncase class BLive(a: A) extends B\ncase class CLive(a: A) extends C\n\nval a: ZLayer[Any, Nothing, A] =\n  ZLayer(ZIO.succeed(new A {}).debug("initialized"))\n\nval b: ZLayer[A, Nothing, B] =\n  ZLayer {\n    for {\n      a <- ZIO.service[A]\n    } yield BLive(a)\n  }\n\nval c: ZLayer[A, Nothing, C] =\n  ZLayer {\n    for {\n      a <- ZIO.service[A]\n    } yield CLive(a)\n  }\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Although both ",(0,r.jsx)(n.code,{children:"b"})," and ",(0,r.jsx)(n.code,{children:"c"})," layers require the ",(0,r.jsx)(n.code,{children:"a"})," layer, the ",(0,r.jsx)(n.code,{children:"a"})," layer is instantiated only once. It is shared with both ",(0,r.jsx)(n.code,{children:"b"})," and ",(0,r.jsx)(n.code,{children:"c"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  val myApp: ZIO[B & C, Nothing, Unit] =\n    for {\n      _ <- ZIO.service[B]\n      _ <- ZIO.service[C]\n    } yield ()\n    \n  // alternative: myApp.provideLayer((a >>> b) ++ (a >>> c))\n  def run = myApp.provide(a, b, c) \n}\n// Output:\n// initialized: MainApp3$$anon$32@62c8b8d3\n"})}),"\n",(0,r.jsx)(n.h2,{id:"acquiring-a-fresh-version",children:"Acquiring a Fresh Version"}),"\n",(0,r.jsxs)(n.p,{children:["If we don't want to share a module, we should create a fresh, non-shared version of it through ",(0,r.jsx)(n.code,{children:"ZLayer#fresh"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  val myApp: ZIO[B & C, Nothing, Unit] =\n    for {\n      _ <- ZIO.service[B]\n      _ <- ZIO.service[C]\n    } yield ()\n\n  def run = myApp.provideLayer((a.fresh >>> b) ++ (a.fresh >>> c))\n}\n// Output:\n// initialized: MainApp$$anon$22@7eb282da\n// initialized: MainApp$$anon$22@6397a26a\n"})}),"\n",(0,r.jsx)(n.h2,{id:"layers-are-not-memoized-when-providing-locally",children:"Layers Are Not Memoized When Providing Locally"}),"\n",(0,r.jsxs)(n.p,{children:["If we don't provide a layer globally but instead provide them ",(0,r.jsx)(n.a,{href:"/reference/di/overriding-dependency-graph#local-environment",children:"locally"}),", that layer doesn't support memoization by default."]}),"\n",(0,r.jsxs)(n.p,{children:["In the following example, we provided the ",(0,r.jsx)(n.code,{children:"A"})," layer two times locally and the ZIO doesn't memoize the construction of the ",(0,r.jsx)(n.code,{children:"A"})," layer. So, it will be initialized two times:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  val myApp: ZIO[Any, Nothing, Unit] =\n    for {\n      _ <- ZIO.service[A].provide(a) // providing locally\n      _ <- ZIO.service[A].provide(a) // providing locally\n    } yield ()\n\n  def run = myApp\n}\n// The output:\n// initialized: MainApp$$anon$1@cd60bde\n// initialized: MainApp$$anon$1@a984546\n"})}),"\n",(0,r.jsx)(n.h2,{id:"manual-memoization",children:"Manual Memoization"}),"\n",(0,r.jsxs)(n.p,{children:["We can memoize the ",(0,r.jsx)(n.code,{children:"A"})," layer manually using the ",(0,r.jsx)(n.code,{children:"ZLayer#memoize"})," operator. It will return a scoped effect that, if evaluated, will return the lazily computed result of this layer:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  val myApp: ZIO[Any, Nothing, Unit] =\n    ZIO.scoped {\n      a.memoize.flatMap { aLayer =>\n        for {\n          _ <- ZIO.service[A].provide(aLayer)\n          _ <- ZIO.service[A].provide(aLayer)\n        } yield ()\n      }\n    }\n    \n  def run = myApp\n}\n// The output:\n// initialized: MainApp$$anon$1@2bfc2bcc\n"})})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(s,{...e})}):s(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>l});var a=i(96540);const r={},t=a.createContext(r);function o(e){const n=a.useContext(t);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),a.createElement(t.Provider,{value:n},e.children)}}}]);