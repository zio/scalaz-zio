"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[72278],{86633:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"reference/test/assertions/classic-assertions","title":"Classic Assertions","description":"In almost all cases we encourage developers using smart assertions instead of classic assertions. They are more expressive and easier to use. So you can skip reading this section.","source":"@site/docs/reference/test/assertions/classic-assertions.md","sourceDirName":"reference/test/assertions","slug":"/reference/test/assertions/classic-assertions","permalink":"/reference/test/assertions/classic-assertions","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/test/assertions/classic-assertions.md","tags":[],"version":"current","frontMatter":{"id":"classic-assertions","title":"Classic Assertions"},"sidebar":"reference-sidebar","previous":{"title":"Introduction to ZIO Test Assertions","permalink":"/reference/test/assertions/"},"next":{"title":"Smart Assertions","permalink":"/reference/test/assertions/smart-assertions"}}');var r=t(74848),i=t(28453);const a={id:"classic-assertions",title:"Classic Assertions"},o=void 0,c={},l=[{value:"Asserting Ordinary Values",id:"asserting-ordinary-values",level:2},{value:"Asserting ZIO Effects",id:"asserting-zio-effects",level:2},{value:"The for-comprehension Style",id:"the-for-comprehension-style",level:2},{value:"Understanding the <code>test</code> Function",id:"understanding-the-test-function",level:2},{value:"Understanding the <code>assert</code> Function",id:"understanding-the-assert-function",level:2},{value:"Type-checker Macro",id:"type-checker-macro",level:2},{value:"Examples",id:"examples",level:2},{value:"Example 1: Equality Assertion",id:"example-1-equality-assertion",level:3},{value:"Example 2: Field-level Assertion",id:"example-2-field-level-assertion",level:3},{value:"Example 3: Test if a ZIO Effect Fails With a Particular Error Type",id:"example-3-test-if-a-zio-effect-fails-with-a-particular-error-type",level:3},{value:"Example 4: Test if a ZIO Effect Fails With a Subtype of a Particular Error Type",id:"example-4-test-if-a-zio-effect-fails-with-a-subtype-of-a-particular-error-type",level:3}];function d(e){const s={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(s.admonition,{type:"note",children:[(0,r.jsxs)(s.p,{children:["In almost all cases we encourage developers using ",(0,r.jsx)(s.em,{children:(0,r.jsx)(s.a,{href:"/reference/test/assertions/smart-assertions",children:"smart assertions"})})," instead of ",(0,r.jsx)(s.a,{href:"/reference/test/assertions/classic-assertions",children:"classic assertions"}),". They are more expressive and easier to use. So you can skip reading this section."]}),(0,r.jsxs)(s.p,{children:["Only use ",(0,r.jsx)(s.em,{children:"classic assertions"})," when you know what you are doing. There are some rare cases where the smart assertions are not enough."]})]}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.code,{children:"assert"})," and its effectful counterpart ",(0,r.jsx)(s.code,{children:"assertZIO"})," are the old way of asserting ordinary values and ZIO effects."]}),"\n",(0,r.jsx)(s.h2,{id:"asserting-ordinary-values",children:"Asserting Ordinary Values"}),"\n",(0,r.jsxs)(s.p,{children:["In order to test ordinary values, we should use ",(0,r.jsx)(s.code,{children:"assert"}),", like the example below:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:'import zio._\nimport zio.test.{test, _}\n\ntest("sum") {\n  assert(1 + 1)(Assertion.equalTo(2))\n}\n'})}),"\n",(0,r.jsx)(s.h2,{id:"asserting-zio-effects",children:"Asserting ZIO Effects"}),"\n",(0,r.jsxs)(s.p,{children:["If we are testing an effect, we should use the ",(0,r.jsx)(s.code,{children:"assertZIO"})," function:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:'import zio._\nimport zio.test.{test, _}\n\ntest("updating ref") {\n  val value = for {\n    r <- Ref.make(0)\n    _ <- r.update(_ + 1)\n    v <- r.get\n  } yield v\n  assertZIO(value)(Assertion.equalTo(1))\n}\n'})}),"\n",(0,r.jsx)(s.h2,{id:"the-for-comprehension-style",children:"The for-comprehension Style"}),"\n",(0,r.jsxs)(s.p,{children:["Having this all in mind, probably the most common and also most readable way of structuring tests is to pass a for-comprehension to ",(0,r.jsx)(s.code,{children:"test"})," function and yield a call to ",(0,r.jsx)(s.code,{children:"assert"})," function."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:'import zio._\nimport zio.test.{test, _}\n\ntest("updating ref") {\n  for {\n    r <- Ref.make(0)\n    _ <- r.update(_ + 1)\n    v <- r.get\n  } yield assert(v)(Assertion.equalTo(v))\n}\n'})}),"\n",(0,r.jsxs)(s.h2,{id:"understanding-the-test-function",children:["Understanding the ",(0,r.jsx)(s.code,{children:"test"})," Function"]}),"\n",(0,r.jsx)(s.admonition,{type:"note",children:(0,r.jsxs)(s.p,{children:["In this section we are going to learn about the internals of the ",(0,r.jsx)(s.code,{children:"Assertion"})," data type. So feel free to skip this section if you are not interested."]})}),"\n",(0,r.jsxs)(s.p,{children:["In order to understand the ",(0,r.jsx)(s.code,{children:"Assertion"})," data type, let's first look at the ",(0,r.jsx)(s.code,{children:"test"})," function:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:"def test[In](label: String)(assertion: => In)(implicit testConstructor: TestConstructor[Nothing, In]): testConstructor.Out\n"})}),"\n",(0,r.jsxs)(s.p,{children:["Its signature is a bit complicated and uses ",(0,r.jsx)(s.em,{children:"path-dependent types"}),", but it doesn't matter. We can think of a ",(0,r.jsx)(s.code,{children:"test"})," as a function from ",(0,r.jsx)(s.code,{children:"TestResult"})," (or its effectful versions such as ",(0,r.jsx)(s.code,{children:"ZIO[R, E, TestResult]"})," or ",(0,r.jsx)(s.code,{children:"ZSTM[R, E, TestResult]"}),") to the ",(0,r.jsx)(s.code,{children:"Spec[R, E]"})," data type:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:"def test(label: String)(assertion: => TestResult): Spec[Any, Nothing]\ndef test(label: String)(assertion: => ZIO[R, E, TestResult]): Spec[R, E]\n"})}),"\n",(0,r.jsxs)(s.p,{children:["Therefore, the function ",(0,r.jsx)(s.code,{children:"test"})," needs a ",(0,r.jsx)(s.code,{children:"TestResult"}),". The most common way to produce a ",(0,r.jsx)(s.code,{children:"TestResult"})," is to resort to ",(0,r.jsx)(s.code,{children:"assert"})," or its effectful counterpart ",(0,r.jsx)(s.code,{children:"assertZIO"}),". The former one is for creating ordinary ",(0,r.jsx)(s.code,{children:"TestResult"})," values and the latter one is for producing effectful ",(0,r.jsx)(s.code,{children:"TestResult"})," values. Both of them accept a value of type ",(0,r.jsx)(s.code,{children:"A"})," (effectful version wrapped in a ",(0,r.jsx)(s.code,{children:"ZIO"}),") and an ",(0,r.jsx)(s.code,{children:"Assertion[A]"}),"."]}),"\n",(0,r.jsxs)(s.h2,{id:"understanding-the-assert-function",children:["Understanding the ",(0,r.jsx)(s.code,{children:"assert"})," Function"]}),"\n",(0,r.jsxs)(s.p,{children:["Let's look at the ",(0,r.jsx)(s.code,{children:"assert"})," function:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:"def assert[A](expr: => A)(assertion: Assertion[A]): TestResult\n"})}),"\n",(0,r.jsxs)(s.p,{children:["It takes an expression of type ",(0,r.jsx)(s.code,{children:"A"})," and an ",(0,r.jsx)(s.code,{children:"Assertion[A]"})," and returns the ",(0,r.jsx)(s.code,{children:"TestResult"})," which is the boolean algebra of the ",(0,r.jsx)(s.code,{children:"AssertionResult"}),". Furthermore, we have an ",(0,r.jsx)(s.code,{children:"Assertion[A]"})," which is capable of producing ",(0,r.jsx)(s.em,{children:"assertion results"})," on any value of type ",(0,r.jsx)(s.code,{children:"A"}),". So the ",(0,r.jsx)(s.code,{children:"assert"})," function can apply the expression to the assertion and produce the ",(0,r.jsx)(s.code,{children:"TestResult"}),"."]}),"\n",(0,r.jsx)(s.h2,{id:"type-checker-macro",children:"Type-checker Macro"}),"\n",(0,r.jsxs)(s.p,{children:["To check if the code compiles, we can use the ",(0,r.jsx)(s.code,{children:"typeCheck"})," macro. It is useful when we want to test if the code compiles without running it. Here is an example of how to use it:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:'import zio.test._\nimport zio.test.Assertion._\n\ntest("lazy list") {\n  assertZIO(typeCheck(\n    """\n      |val lazyList: LazyList[Int] = LazyList(1, 2, 3, 4, 5)\n      |lazyList.foreach(println)\n      |""".stripMargin))(isRight)\n\n} @@ TestAspect.exceptScala212\n'})}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.code,{children:"LazyCheck"})," introduced in Scala 2.13, so we excluded this test from Scala 2.12."]}),"\n",(0,r.jsx)(s.h2,{id:"examples",children:"Examples"}),"\n",(0,r.jsx)(s.h3,{id:"example-1-equality-assertion",children:"Example 1: Equality Assertion"}),"\n",(0,r.jsx)(s.p,{children:'Assume we have a function that concatenates two strings. One simple property of this function would be "the sum of the length of all inputs should be equal to the length of the output". Let\'s see an example of how we can make an assertion about this property:'}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:'import zio.test._\n\ntest("The sum of the lengths of both inputs must equal the length of the output") {\n  check(Gen.string, Gen.string) { (a, b) =>\n    assert((a + b).length)(Assertion.equalTo(a.length + b.length))\n  }\n}\n'})}),"\n",(0,r.jsxs)(s.p,{children:["The syntax of assertion in the above code, is ",(0,r.jsx)(s.code,{children:"assert(expression)(assertion)"}),". The first section is an expression of type ",(0,r.jsx)(s.code,{children:"A"})," which is ",(0,r.jsx)(s.em,{children:"result"})," of our computation and the second one is the expected assertion of type ",(0,r.jsx)(s.code,{children:"Assertion[A]"}),"."]}),"\n",(0,r.jsx)(s.h3,{id:"example-2-field-level-assertion",children:"Example 2: Field-level Assertion"}),"\n",(0,r.jsxs)(s.p,{children:["There is also an easy way to test an object's data for certain assertions with ",(0,r.jsx)(s.code,{children:"hasField"})," which accepts besides a name, a mapping function from object to its tested property, and ",(0,r.jsx)(s.code,{children:"Assertion"})," object which will validate this property. Here our test checks if a person has at least 18 years and is not from the USA."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:'import zio.test._\nimport zio.test.Assertion.{isRight, isSome,equalTo, isGreaterThanEqualTo, not, hasField}\n\nfinal case class Address(country:String, city:String)\nfinal case class User(name:String, age:Int, address: Address)\n\ntest("Rich checking") {\n  assert(\n    User("Jonny", 26, Address("Denmark", "Copenhagen"))\n  )(\n    hasField("age", (u:User) => u.age, isGreaterThanEqualTo(18)) &&\n    hasField("country", (u:User) => u.address.country, not(equalTo("USA")))\n  )\n}\n'})}),"\n",(0,r.jsxs)(s.p,{children:["What is nice about those tests is that test reporters will tell you exactly which assertion was broken. Let's say we would change ",(0,r.jsx)(s.code,{children:"isGreaterThanEqualTo(18)"})," to ",(0,r.jsx)(s.code,{children:"isGreaterThanEqualTo(40)"})," which will fail. Print out on the console will be a nice detailed text explaining what exactly went wrong:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:'[info]       User(Jonny,26,Address(Denmark,Copenhagen)) did not satisfy (hasField("age", _.age, isGreaterThanEqualTo(45)) && hasField("country", _.country, not(equalTo(USA))))\n[info]       26 did not satisfy isGreaterThanEqualTo(45)\n'})}),"\n",(0,r.jsx)(s.h3,{id:"example-3-test-if-a-zio-effect-fails-with-a-particular-error-type",children:"Example 3: Test if a ZIO Effect Fails With a Particular Error Type"}),"\n",(0,r.jsxs)(s.p,{children:["The following example shows how to test if a ZIO effect fails with a particular error type. To test if a ZIO effect fails with a particular error type, we can use the ",(0,r.jsx)(s.code,{children:"ZIO#exit"})," to determine the exit type of that effect."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:'import zio._\nimport zio.test.{ test, _ }\nimport zio.test.Assertion._\n\ncase class MyError(msg: String) extends Exception\n\nval effect: ZIO[Any, MyError, Unit] = ZIO.fail(MyError("my error msg"))\n\ntest("test if a ZIO effect fails with a particular error type") {\n  for {\n    exit <- effect.exit\n  } yield assertTrue(exit == Exit.fail(MyError("my error msg")))\n}\n'})}),"\n",(0,r.jsxs)(s.p,{children:["The exit method on a ZIO effect returns an ",(0,r.jsx)(s.code,{children:"Exit"})," value, which represents the outcome of the effect. The ",(0,r.jsx)(s.code,{children:"Exit"})," value can be either ",(0,r.jsx)(s.code,{children:"Exit.succeed"})," or ",(0,r.jsx)(s.code,{children:"Exit.fail"}),". If the effect succeeded, the ",(0,r.jsx)(s.code,{children:"Exit.succeed"})," value will contain the result of the effect. If the effect failed, the ",(0,r.jsx)(s.code,{children:"Exit.fail"})," value will contain the error that caused the failure."]}),"\n",(0,r.jsx)(s.h3,{id:"example-4-test-if-a-zio-effect-fails-with-a-subtype-of-a-particular-error-type",children:"Example 4: Test if a ZIO Effect Fails With a Subtype of a Particular Error Type"}),"\n",(0,r.jsxs)(s.p,{children:["To test if a ZIO effect fails with a ",(0,r.jsx)(s.code,{children:"subtype"})," of a particular error type, we can use the ",(0,r.jsx)(s.code,{children:"assertZIO"})," function and the two ",(0,r.jsx)(s.code,{children:"fails"}),", and ",(0,r.jsx)(s.code,{children:"isSubtype"})," assertions from the zio-test library. The ",(0,r.jsx)(s.code,{children:"assertZIO"})," function takes a ZIO effect and an assertion. The assertion is called with the result of the ZIO effect. If the assertion returns true, then the ",(0,r.jsx)(s.code,{children:"assertZIO"})," will succeed, otherwise it will fail."]}),"\n",(0,r.jsx)(s.p,{children:"Assume we have these error types:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:"sealed trait MyError extends Exception\ncase class E1(msg: String) extends MyError\ncase class E2(msg: String) extends MyError\n"})}),"\n",(0,r.jsxs)(s.p,{children:["To assert if an error type is a subtype of a particular error type, we need to combine the ",(0,r.jsx)(s.code,{children:"fails"})," and ",(0,r.jsx)(s.code,{children:"isSubtype"})," assertions together:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:"import zio.test.Assertion._\n\nAssertion.fails(isSubtype[MyError](anything))\n"})}),"\n",(0,r.jsx)(s.p,{children:"Now let's look at an example:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:'import zio._\nimport zio.test.{ test, _ }\nimport zio.test.Assertion._\n\nval effect = ZIO.fail(E1("my error msg"))\n\ntest("Test if a ZIO effect fails with a MyError") {\n  assertZIO(effect.exit)(fails(isSubtype[MyError](anything)))\n}\n'})})]})}function h(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,s,t)=>{t.d(s,{R:()=>a,x:()=>o});var n=t(96540);const r={},i=n.createContext(r);function a(e){const s=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),n.createElement(i.Provider,{value:s},e.children)}}}]);