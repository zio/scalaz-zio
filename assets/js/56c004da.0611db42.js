"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[63962],{21664:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>o,default:()=>p,frontMatter:()=>c,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"guides/interop/with-cats-effect","title":"How to Interop with Cats Effect?","description":"Introduction","source":"@site/docs/guides/interop/with-cats-effect.md","sourceDirName":"guides/interop","slug":"/guides/interop/with-cats-effect","permalink":"/guides/interop/with-cats-effect","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/guides/interop/with-cats-effect.md","tags":[],"version":"current","frontMatter":{"id":"with-cats-effect","title":"How to Interop with Cats Effect?","sidebar_label":"Cats Effect"},"sidebar":"guides-sidebar","previous":{"title":"Gracefully Shutdown ZIO Applications","permalink":"/guides/tutorials/gracefully-shutdown-zio-application"},"next":{"title":"Scala\'s Future","permalink":"/guides/interop/with-future"}}');var s=t(74848),a=t(28453);const c={id:"with-cats-effect",title:"How to Interop with Cats Effect?",sidebar_label:"Cats Effect"},o=void 0,r={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Cats Effect Instances",id:"cats-effect-instances",level:2},{value:"Providing Runtime Manually",id:"providing-runtime-manually",level:3},{value:"Using <code>CatsApp</code> Runtime",id:"using-catsapp-runtime",level:3},{value:"Cats Effect 2.x",id:"cats-effect-2x",level:2},{value:"Timer Instance",id:"timer-instance",level:3},{value:"Converting Resource to ZManaged",id:"converting-resource-to-zmanaged",level:3},{value:"Converting ZManaged to Resource",id:"converting-zmanaged-to-resource",level:3},{value:"Converting Resource to Scoped",id:"converting-resource-to-scoped",level:3},{value:"Converting Scoped to Resource",id:"converting-scoped-to-resource",level:3},{value:"Cats Effect 3.x",id:"cats-effect-3x",level:2},{value:"Type class Instances for ZIO&#39;s Task",id:"type-class-instances-for-zios-task",level:3},{value:"Cats Core",id:"cats-core",level:2},{value:"FS2 Streams",id:"fs2-streams",level:2},{value:"From FS2 Stream to ZStream",id:"from-fs2-stream-to-zstream",level:3},{value:"From ZStream to FS2 Stream",id:"from-zstream-to-fs2-stream",level:3},{value:"Using Queue with Cats Effect",id:"using-queue-with-cats-effect",level:2},{value:"Cats Effect 2.x",id:"cats-effect-2x-1",level:3},{value:"Cats Effect 3.x",id:"cats-effect-3x-1",level:3},{value:"Using STM with Cats Effect",id:"using-stm-with-cats-effect",level:2},{value:"Examples",id:"examples",level:2},{value:"Using ZIO with Doobie",id:"using-zio-with-doobie",level:3},{value:"Customized Transactor (CE2)",id:"customized-transactor-ce2",level:4},{value:"Customized Transactor (CE3)",id:"customized-transactor-ce3",level:4},{value:"Http4s",id:"http4s",level:3},{value:"Cats Effect 2.x",id:"cats-effect-2x-2",level:4},{value:"Cats Effect 3.x",id:"cats-effect-3x-2",level:4}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://github.com/zio/interop-cats",children:(0,s.jsx)(n.code,{children:"interop-cats"})})," has instances for the ",(0,s.jsx)(n.a,{href:"https://typelevel.org/cats/",children:"Cats"}),", ",(0,s.jsx)(n.a,{href:"https://github.com/typelevel/cats-mtl",children:"Cats MTL"})," and ",(0,s.jsx)(n.a,{href:"https://typelevel.org/cats-effect/",children:"Cats Effect"})," libraries, which allow you to use ZIO with any libraries that rely on these, like ",(0,s.jsx)(n.a,{href:"https://github.com/tpolecat/doobie",children:"Doobie"}),", ",(0,s.jsx)(n.a,{href:"https://github.com/http4s/http4s",children:"Http4s"}),", ",(0,s.jsx)(n.a,{href:"https://github.com/functional-streams-for-scala/fs2",children:"FS2"})," or ",(0,s.jsx)(n.a,{href:"https://github.com/circe/circe",children:"Circe"})]}),"\n",(0,s.jsxs)(n.p,{children:["Depends on which version of Cats Effect we are using, we should pick the right version of ",(0,s.jsx)(n.code,{children:"zio-interop-cats"}),". In this tutorial, whenever we're working with Cats Effect 2.x, we are using:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'libraryDependencies += "dev.zio" %% "zio-interop-cats" % "2.5.1.0"\n'})}),"\n",(0,s.jsx)(n.p,{children:"And whenever we are using Cats Effect 3.x instances, we are using:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'libraryDependencies += "dev.zio" %% "zio-interop-cats" % "3.1.1.0"\n'})}),"\n",(0,s.jsx)(n.p,{children:"Most of the interop functionality resides in the following package:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"import zio.interop.catz._\n"})}),"\n",(0,s.jsx)(n.h2,{id:"cats-effect-instances",children:"Cats Effect Instances"}),"\n",(0,s.jsxs)(n.p,{children:["ZIO integrates with Typelevel libraries by providing instances of Cats Effect type classes. These type classes are used by ",(0,s.jsx)(n.code,{children:"fs2"}),", ",(0,s.jsx)(n.code,{children:"doobie"}),", ",(0,s.jsx)(n.code,{children:"http4s"}),", and a variety of other libraries in the functional Scala ecosystem."]}),"\n",(0,s.jsxs)(n.p,{children:["Due to the limitations of the Cats Effect, ZIO cannot provide instances for arbitrary error types. Instead, we can obtain instances only for effects whose error type extends ",(0,s.jsx)(n.code,{children:"Throwable"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["For convenience, ZIO includes the ",(0,s.jsx)(n.code,{children:"Task"})," and ",(0,s.jsx)(n.code,{children:"RIO"})," type aliases, which fix the error type to ",(0,s.jsx)(n.code,{children:"Throwable"}),", and may be useful for interop with Cats Effect:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"import zio.{ZIO, Task, RIO}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"type Task[+A]    = ZIO[Any, Throwable, A]\ntype RIO[-R, +A] = ZIO[  R, Throwable, A]\n"})}),"\n",(0,s.jsx)(n.h3,{id:"providing-runtime-manually",children:"Providing Runtime Manually"}),"\n",(0,s.jsxs)(n.p,{children:["To use Cats Effect instances for these types, we should have an implicit ",(0,s.jsx)(n.code,{children:"Runtime[R]"})," in scope for the environment type of our effects. The following code snippet creates an implicit ",(0,s.jsx)(n.code,{children:"Runtime"})," for all the modules built into ZIO:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import cats.implicits._\nimport zio.interop.catz._\n\nobject ZioCatsEffectInterop extends scala.App {\n  def catsEffectApp[F[_]: cats.effect.Sync]: F[Unit] =\n    cats.effect.Sync[F].delay(\n        println("Hello from Cats Effect World!")\n      )\n      \n  implicit val runtime: zio.Runtime[Any] = zio.Runtime.default\n\n  val zioApp: zio.Task[Unit] = catsEffectApp[zio.Task]\n  runtime.unsafeRun(zioApp.exitCode)\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["If we are working with Cats Effect 3.x, the ",(0,s.jsx)(n.code,{children:"catsEffectApp[Task]"})," will be expanded as if we called the following code explicitly:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"import ZioCatsEffectInterop.catsEffectApp\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"object ZioCatsEffectInterop extends scala.App {\n  val runtime: zio.Runtime[Any] = zio.Runtime.default\n  \n  val zioApp: zio.Task[Unit] = catsEffectApp[zio.Task](\n    zio.interop.catz.asyncRuntimeInstance(runtime) \n  )\n  \n  runtime.unsafeRun(zioApp.exitCode) \n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"And if we are working with Cats Effect 2.x, it will be expanded as if we called following code explicitly:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"object ZioCatsEffectInterop extends scala.App {\n  val runtime: zio.Runtime[Any] = zio.Runtime.default\n\n  val zioApp = catsEffectApp[zio.Task](zio.interop.catz.taskConcurrentInstance)\n  runtime.unsafeRun(zioApp.exitCode)\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If we are using ",(0,s.jsx)(n.code,{children:"RIO"})," for a custom environment ",(0,s.jsx)(n.code,{children:"R"}),", then we will have to create our own ",(0,s.jsx)(n.code,{children:"Runtime[R]"}),", and ensure that implicit wherever we need Cats Effect instances."]}),"\n",(0,s.jsxs)(n.h3,{id:"using-catsapp-runtime",children:["Using ",(0,s.jsx)(n.code,{children:"CatsApp"})," Runtime"]}),"\n",(0,s.jsxs)(n.p,{children:["As a convenience, our application can extend ",(0,s.jsx)(n.code,{children:"CatsApp"}),", which automatically brings an implicit ",(0,s.jsx)(n.code,{children:"Runtime[Any]"})," into our scope:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import zio.interop.catz._\nimport cats.implicits._\n\nobject ZioCatsEffectInteropWithCatsApp extends CatsApp {\n  def catsEffectApp[F[_]: cats.effect.Sync]: F[Unit] =\n    cats.effect.Sync[F].delay(println("Hello from Cats Effect World!"))\n\n  override def run(args: List[String]): zio.URIO[Any, zio.ExitCode] = \n    catsEffectApp[zio.Task].exitCode\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"This example works properly in both Cats Effect 2.x and 3.x versions."}),"\n",(0,s.jsx)(n.h2,{id:"cats-effect-2x",children:"Cats Effect 2.x"}),"\n",(0,s.jsx)(n.h3,{id:"timer-instance",children:"Timer Instance"}),"\n",(0,s.jsxs)(n.p,{children:["In order to get a ",(0,s.jsx)(n.code,{children:"cats.effect.Timer[zio.Task]"})," instance, we need an extra import (",(0,s.jsx)(n.code,{children:"zio.interop.catz.implicits._"}),"):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"import java.util.concurrent.TimeUnit\n\nimport cats.implicits._\nimport zio.interop.catz._\nimport zio.interop.catz.implicits._ // Provides `zio.Task instance` for `cats.effect.Time` type class\nimport zio.{ ExitCode, Task, URIO }\n\nimport scala.concurrent.duration.DurationInt\n\nobject ZioCatsEffectTimerInterop extends zio.interop.catz.CatsApp {\n  override def run(args: List[String]): zio.URIO[Any, zio.ExitCode] =\n    catsEffectTimerApp[zio.Task].exitCode\n\n  def catsEffectTimerApp[F[_]: cats.effect.Clock: cats.effect.Timer: cats.effect.Sync]: F[Unit] = for {\n    t2 <- cats.effect.Clock[F].monotonic(TimeUnit.SECONDS)\n    _  <- cats.effect.Timer[F].sleep(2.seconds)\n    t1 <- cats.effect.Clock[F].monotonic(TimeUnit.SECONDS)\n    _  <- cats.effect.Sync[F].delay(println(t1 - t2))\n  } yield ()\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The reason a ",(0,s.jsx)(n.code,{children:"cats.effect.Timer[zio.Task]"})," instance is not provided by the default ",(0,s.jsx)(n.em,{children:"interop"})," import is that it makes testing programs that require timing capabilities very difficult. The extra import (wherever needed) makes reasoning about timing-related effects much easier."]}),"\n",(0,s.jsxs)(n.p,{children:["If we're using ",(0,s.jsx)(n.code,{children:"RIO"})," for a custom environment then our environment must use the ",(0,s.jsx)(n.code,{children:"Clock"})," service, e.g. ",(0,s.jsx)(n.code,{children:"R <: Clock"})," to get a timer."]}),"\n",(0,s.jsx)(n.h3,{id:"converting-resource-to-zmanaged",children:"Converting Resource to ZManaged"}),"\n",(0,s.jsxs)(n.p,{children:["We have an extension method defined on ",(0,s.jsx)(n.code,{children:"Resource"})," called ",(0,s.jsx)(n.code,{children:"Resource#toManaged"})," which converts ",(0,s.jsx)(n.code,{children:"Resource"})," to ",(0,s.jsx)(n.code,{children:"ZManaged"}),".\nFor example, assume we have the following ",(0,s.jsx)(n.code,{children:"File"})," API:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'case class File[F[_]: cats.effect.Sync]() {\n  import cats.syntax.apply._\n  def read: F[String] =\n    cats.effect.Sync[F].delay(println("Reading file.")) *>\n      cats.effect.Sync[F].pure("Hello, World!")\n  def close: F[Unit]  =\n    cats.effect.Sync[F].delay(println("Closing file."))\n}\n\nobject File {\n  import cats.syntax.apply._\n  def open[F[_]: cats.effect.Sync](name: String): F[File[F]] =\n    cats.effect.Sync[F].delay(println(s"opening $name file")) *>\n      cats.effect.Sync[F].delay(File())\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["And, also assume we have ",(0,s.jsx)(n.code,{children:"fileResource"})," defined as follows:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"def fileResource[F[_]: cats.effect.Sync](name: String): cats.effect.Resource[F, File[F]] =\n  cats.effect.Resource.make(File.open[F](name))(_.close)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Let's convert that to ",(0,s.jsx)(n.code,{children:"ZManaged"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'val resource: zio.ZManaged[Any, Throwable, File[zio.Task]] =\n  fileResource[zio.Task]("log.txt").toManaged\n'})}),"\n",(0,s.jsx)(n.p,{children:"Here is a complete working example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import zio.interop.catz._\n\nobject CatsEffectResourceInterop extends CatsApp {\n  def fileResource[F[_]: cats.effect.Sync](name: String): cats.effect.Resource[F, File[F]] =\n    cats.effect.Resource.make(File.open[F](name))(_.close)\n\n  def myApp: zio.ZIO[Any, Throwable, Unit] = for {\n    c <- fileResource[zio.Task]("log.txt").toManaged.use(_.read)\n    _ <- zio.Console.printLine(s"file content: $c")\n  } yield ()\n\n  override def run(args: List[String]): zio.URIO[Any, zio.ExitCode] =\n    myApp.exitCode\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"converting-zmanaged-to-resource",children:"Converting ZManaged to Resource"}),"\n",(0,s.jsxs)(n.p,{children:["We have an extension method on ",(0,s.jsx)(n.code,{children:"ZManaged"})," called ",(0,s.jsx)(n.code,{children:"ZManaged#toResource"})," which converts a ZIO managed resource to Cats Effect resource:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"final class ZManagedSyntax[R, E, A](private val managed: ZManaged[R, E, A]) {\n  def toResource[F[_]](implicit\n      F: Async[F],\n      ev: Effect[ZIO[R, E, *]]\n  ): Resource[F, A] = ???\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Let's try an example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import zio.interop.catz._\n\nobject ZManagedToResource extends cats.effect.IOApp {\n  implicit val zioRuntime: zio.Runtime[Any] = zio.Runtime.default\n\n  val resource: cats.effect.Resource[cats.effect.IO, java.io.InputStream] =\n    zio.ZManaged\n      .fromAutoCloseable(\n        zio.ZIO.effect(\n          java.nio.file.Files.newInputStream(\n            java.nio.file.Paths.get("file.txt")\n          )\n        )\n      )\n      .toResource[cats.effect.IO]\n\n  val effect: cats.effect.IO[Unit] =\n    resource\n      .use { is =>\n        cats.effect.IO.delay(is.readAllBytes())\n      }\n      .flatMap(bytes =>\n        cats.effect.IO.delay(\n          println(s"file length: ${bytes.length}")\n        )\n      )\n\n  override def run(args: List[String]): cats.effect.IO[cats.effect.ExitCode] =\n    effect.as(cats.effect.ExitCode.Success)\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"converting-resource-to-scoped",children:"Converting Resource to Scoped"}),"\n",(0,s.jsxs)(n.p,{children:["We have an extension method defined on ",(0,s.jsx)(n.code,{children:"Resource"})," called ",(0,s.jsx)(n.code,{children:"Resource#toScoped"})," which converts ",(0,s.jsx)(n.code,{children:"Resource"})," to ",(0,s.jsx)(n.code,{children:"ZIO"})," with ",(0,s.jsx)(n.code,{children:"Scope"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, assume we have the following ",(0,s.jsx)(n.code,{children:"File"})," API:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'case class File[F[_]: cats.effect.Sync]() {\n  import cats.syntax.apply._\n  def read: F[String] =\n    cats.effect.Sync[F].delay(println("Reading file.")) *>\n      cats.effect.Sync[F].pure("Hello, World!")\n  def close: F[Unit]  =\n    cats.effect.Sync[F].delay(println("Closing file."))\n}\n\nobject File {\n  import cats.syntax.apply._\n  def open[F[_]: cats.effect.Sync](name: String): F[File[F]] =\n    cats.effect.Sync[F].delay(println(s"opening $name file")) *>\n      cats.effect.Sync[F].delay(File())\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["And, also assume we have ",(0,s.jsx)(n.code,{children:"fileResource"})," defined as follows:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"def fileResource[F[_]: cats.effect.Sync](name: String): cats.effect.Resource[F, File[F]] =\n  cats.effect.Resource.make(File.open[F](name))(_.close)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Let's convert that to scoped ",(0,s.jsx)(n.code,{children:"ZIO"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'val scoped: ZIO[Scope, Throwable, File[zio.Task]] =\n  fileResource[zio.Task]("log.txt").toScoped\n'})}),"\n",(0,s.jsx)(n.p,{children:"Here is a complete working example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import zio.interop.catz._\n\nobject CatsEffectResourceInterop extends CatsApp {\n  def fileResource[F[_]: cats.effect.Sync](name: String): cats.effect.Resource[F, File[F]] =\n    cats.effect.Resource.make(File.open[F](name))(_.close)\n\n  def myApp: zio.ZIO[Scope, Throwable, Unit] = for {\n    c <- fileResource[zio.Task]("log.txt").toScoped\n    _ <- zio.Console.printLine(s"file content: $c")\n  } yield ()\n\n  override def run(args: List[String]): zio.URIO[Scope, zio.ExitCode] =\n    myApp.exitCode\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"converting-scoped-to-resource",children:"Converting Scoped to Resource"}),"\n",(0,s.jsxs)(n.p,{children:["We have an extension method defined on ",(0,s.jsx)(n.code,{children:"Resource"})," called ",(0,s.jsx)(n.code,{children:"Resource#scoped"})," which creates a ",(0,s.jsx)(n.code,{children:"Resource"})," from ",(0,s.jsx)(n.code,{children:"ZIO"})," with ",(0,s.jsx)(n.code,{children:"Scope"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Let's try an example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import zio.interop.catz._\n\nobject ZManagedToResource extends cats.effect.IOApp {\n  implicit val zioRuntime: zio.Runtime[Any] = zio.Runtime.default\n\n  val resource: cats.effect.Resource[cats.effect.IO, java.io.InputStream] = {\n    val scopedZIO: ZIO[Any with Scope, Throwable, InputStream]= ZIO\n      .fromAutoCloseable(\n        zio.ZIO.attempt(\n          java.nio.file.Files.newInputStream(\n            java.nio.file.Paths.get("crawl.log")\n          )\n        )\n      )\n    \n    Resource.scoped[IO, Any](scopedZIO)\n  }\n\n  val effect: cats.effect.IO[Unit] =\n    resource\n      .use { is =>\n        cats.effect.IO.delay(is.readAllBytes())\n      }\n      .flatMap(bytes =>\n        cats.effect.IO.delay(\n          println(s"file length: ${bytes.length}")\n        )\n      )\n\n  override def run(args: List[String]): cats.effect.IO[cats.effect.ExitCode] =\n    effect.as(cats.effect.ExitCode.Success)\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"cats-effect-3x",children:"Cats Effect 3.x"}),"\n",(0,s.jsx)(n.h3,{id:"type-class-instances-for-zios-task",children:"Type class Instances for ZIO's Task"}),"\n",(0,s.jsxs)(n.p,{children:["ZIO integrates with Cats Effect 3.x as well as 2.x. The ",(0,s.jsx)(n.code,{children:"interop-cats"})," module provides ",(0,s.jsx)(n.code,{children:"Concurrent"}),", ",(0,s.jsx)(n.code,{children:"Temporal"})," and ",(0,s.jsx)(n.code,{children:"Async"})," for ",(0,s.jsx)(n.code,{children:"zio.Task"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"An example of ZIO interoperability with CE3:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"import cats.implicits._\nimport zio.interop.catz._\nimport scala.concurrent.duration.DurationInt\n\nobject ZioCatsEffectInterop extends zio.interop.catz.CatsApp {\n\n  def catsEffectTimerApp[F[_]: cats.effect.Async]: F[Unit] = for {\n    t2 <- cats.effect.Clock[F].monotonic\n    _  <- cats.effect.Temporal[F].sleep(2.seconds)\n    t1 <- cats.effect.Clock[F].monotonic\n    _  <- cats.effect.Sync[F].delay(println(t1 - t2))\n  } yield ()\n  \n  override def run(args: List[String]): zio.URIO[Any, zio.ExitCode] = {\n    catsEffectTimerApp[zio.Task].exitCode\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"cats-core",children:"Cats Core"}),"\n",(0,s.jsxs)(n.p,{children:["There is another package in ",(0,s.jsx)(n.code,{children:"interop-cats"})," module called ",(0,s.jsx)(n.code,{children:"zio.interop.catz.core._"})," which helps us to interop with core data types. This package contains instances of ",(0,s.jsx)(n.code,{children:"zio.Chunk"})," data type for Cats Core module like ",(0,s.jsx)(n.code,{children:"cats.Order"}),", ",(0,s.jsx)(n.code,{children:"cats.Hash"}),", ",(0,s.jsx)(n.code,{children:"cats.Traverse"}),", and so forth."]}),"\n",(0,s.jsxs)(n.p,{children:["In the following example, we are going to use ",(0,s.jsx)(n.code,{children:"zio.Chunk"})," in a Cats Effect application:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import cats.implicits._\nimport zio.interop.catz.core._\n\nobject ZioInteropWithCatsCore extends cats.effect.IOApp {\n  val chunk = zio.Chunk("1", "2", "3", "4", "5")\n\n  def parseInt(s: String): Option[Int] =\n    Either.catchOnly[NumberFormatException](s.toInt).toOption\n\n  val parseAll = cats.Traverse[zio.Chunk].traverse(chunk)(parseInt)\n\n  override def run(args: List[String]): cats.effect.IO[cats.effect.ExitCode] =\n    cats.effect.IO.println(parseAll).as(cats.effect.ExitCode.Success)\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This package also contains utilities to support ",(0,s.jsx)(n.code,{children:"zio.NonEmptyChunk"})," interoperability with Cats Core module."]}),"\n",(0,s.jsx)(n.h2,{id:"fs2-streams",children:"FS2 Streams"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"interop-cats"})," module contains extension methods to convert ",(0,s.jsx)(n.em,{children:"FS2 Stream"})," to ",(0,s.jsx)(n.em,{children:"ZStream"})," and vice versa. These methods support both FS2 series, 2.x and 3.x:"]}),"\n",(0,s.jsx)(n.h3,{id:"from-fs2-stream-to-zstream",children:"From FS2 Stream to ZStream"}),"\n",(0,s.jsxs)(n.p,{children:["By importing ",(0,s.jsx)(n.code,{children:"zio.stream.interop.fs2z._"})," into our application, the ",(0,s.jsx)(n.code,{children:"fs2.Stream#toZStream"})," extension method converts a ",(0,s.jsx)(n.code,{children:"fs2.Stream"})," to ",(0,s.jsx)(n.code,{children:"ZStream"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"import zio.stream.ZStream\nimport zio.stream.interop.fs2z._\nval zstream: ZStream[Any, Throwable, Int] = fs2.Stream.range(1, 10).toZStream()\n"})}),"\n",(0,s.jsx)(n.h3,{id:"from-zstream-to-fs2-stream",children:"From ZStream to FS2 Stream"}),"\n",(0,s.jsxs)(n.p,{children:["Also, the ",(0,s.jsx)(n.code,{children:"ZStream#toFs2Stream"})," converts a ZIO Stream into FS2 Stream:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"import zio.stream.ZStream\nimport zio.Chunk\nimport zio.stream.interop.fs2z._\nval fs2stream = ZStream.fromChunks(Chunk(1, 2, 3, 4)).toFs2Stream\n"})}),"\n",(0,s.jsx)(n.h2,{id:"using-queue-with-cats-effect",children:"Using Queue with Cats Effect"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"interop-cats"})," library has an ",(0,s.jsx)(n.code,{children:"import zio.interop.Queue"})," package to lift creation of ",(0,s.jsx)(n.code,{children:"Queue"})," effect from ",(0,s.jsx)(n.code,{children:"UIO[Queue[A]]"})," to ",(0,s.jsx)(n.code,{children:"F[Queue[F, A]]"})," which enables us to run ",(0,s.jsx)(n.code,{children:"Queue"})," under Cats Effect runtime. It supports all variants of ",(0,s.jsx)(n.code,{children:"Queue"})," like ",(0,s.jsx)(n.code,{children:"bounded"}),", ",(0,s.jsx)(n.code,{children:"unbounded"}),", ",(0,s.jsx)(n.code,{children:"sliding"})," and ",(0,s.jsx)(n.code,{children:"dropping"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"def bounded[F[+_], A](capacity: Int)(implicit R: Runtime[ZEnv], F: LiftIO[F]): F[Queue[F, A]]\n"})}),"\n",(0,s.jsx)(n.h3,{id:"cats-effect-2x-1",children:"Cats Effect 2.x"}),"\n",(0,s.jsxs)(n.p,{children:["In the following example, we are going to lift the ",(0,s.jsx)(n.code,{children:"Queue"})," creation effect to Cats ",(0,s.jsx)(n.code,{children:"IO"})," effect. If we are integrating with 2.x Cats Effect library, this snippet works properly:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"import zio.interop.Queue\nimport cats.effect.IO\n\nimplicit val runtime = Runtime.default\ndef liftedToIO: IO[List[Int]] = for {\n  q <- Queue.bounded[IO, Int](100)\n  _  <- q.offer(1)\n  _  <- q.offer(2)\n  r <- q.takeAll\n} yield (r)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"cats-effect-3x-1",children:"Cats Effect 3.x"}),"\n",(0,s.jsxs)(n.p,{children:["To run ",(0,s.jsx)(n.code,{children:"Queue"})," with Cats Effect 3.x we also need to provide an instance of ",(0,s.jsx)(n.code,{children:"Dispatcher"})," to our contextual environment:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import zio.interop.Queue\n\nobject ZioQueueInteropWithCats extends scala.App {\n\n  implicit val ceRuntime: cats.effect.unsafe.IORuntime =\n    cats.effect.unsafe.IORuntime.global\n\n  implicit val zioRuntime: zio.Runtime[Any] =\n    zio.Runtime.default\n\n  implicit val ec: scala.concurrent.ExecutionContextExecutor =\n    scala.concurrent.ExecutionContext.global\n\n  implicit val dispatcher: cats.effect.std.Dispatcher[cats.effect.IO] =\n    cats.effect.std\n      .Dispatcher[cats.effect.IO]\n      .allocated\n      .unsafeRunSync()\n      ._1\n\n  def liftedToIO: cats.effect.IO[List[Int]] = for {\n    q <- Queue.bounded[cats.effect.IO, Int](100)\n    _ <- q.offer(1)\n    _ <- q.offer(2)\n    r <- q.takeAll\n  } yield (r)\n\n  val catsApp = liftedToIO\n    .flatMap { e =>\n      cats.effect.IO.println(s"List of elements retrieved from Queue: $e")\n    }\n    .as(cats.effect.ExitCode.Success)\n\n  catsApp.unsafeRunSync()\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"using-stm-with-cats-effect",children:"Using STM with Cats Effect"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"zio.interop.stm"})," provides a wrapper data type on ",(0,s.jsx)(n.code,{children:"STM[Throwable, A]"})," which enables us to run ",(0,s.jsx)(n.code,{children:"STM"})," with the Cats Effect library."]}),"\n",(0,s.jsxs)(n.p,{children:["Currently, the ",(0,s.jsx)(n.code,{children:"interop-cats"})," support ",(0,s.jsx)(n.code,{children:"TRef"}),", ",(0,s.jsx)(n.code,{children:"TPromise"}),",  ",(0,s.jsx)(n.code,{children:"TQueue"})," and ",(0,s.jsx)(n.code,{children:"TSemaphore"})," data types."]}),"\n",(0,s.jsxs)(n.p,{children:["Let's try a working example using ",(0,s.jsx)(n.code,{children:"STM"})," and ",(0,s.jsx)(n.code,{children:"TRef"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import cats.effect.IO\nimport cats.effect.unsafe.IORuntime\nimport zio.interop.stm.{STM, TRef}\n\nimplicit val zioRuntime: zio.Runtime[Any] = zio.Runtime.default\nimplicit val catsRuntime: IORuntime            = IORuntime.global\n\ndef transferMoney(\n    from: TRef[IO, Long],\n    to: TRef[IO, Long],\n    amount: Long\n): STM[IO, Long] =\n  for {\n    senderBal <- from.get\n    _ <-\n      if (senderBal < amount)\n        STM.fail[IO](new Exception("Not enough money"))\n      else\n        STM.unit[IO]\n    _       <- from.update(existing => existing - amount)\n    _       <- to.update(existing => existing + amount)\n    recvBal <- to.get\n  } yield recvBal\n\nval program: IO[Long] = for {\n  sndAcc <- STM.atomically[cats.effect.IO, TRef[IO, Long]](\n    TRef.make[IO, Long](1000)\n  )\n  rcvAcc <- STM.atomically[cats.effect.IO, TRef[IO, Long]](\n    TRef.make[IO, Long](200)\n  )\n  recvAmt <- STM.atomically(transferMoney(sndAcc, rcvAcc, 500L))\n} yield recvAmt\n\nprogram\n  .flatMap(amount =>\n    IO.println(s"Balance of second account after transaction: $amount")\n  )\n  .unsafeRunSync()\n'})}),"\n",(0,s.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,s.jsx)(n.p,{children:"Cats Effect and Type-Level libraries are older than the ZIO ecosystem. So there are very nice libraries like doobie and http4s, that a ZIO user would like to use in its application."}),"\n",(0,s.jsx)(n.p,{children:"We have provided some full working example of using these important libraries:"}),"\n",(0,s.jsx)(n.h3,{id:"using-zio-with-doobie",children:"Using ZIO with Doobie"}),"\n",(0,s.jsx)(n.p,{children:"The following example shows how to use ZIO with Doobie (a library for JDBC access) and FS2 (a streaming library), which both rely on Cats Effect instances:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'// This snippet works with both CE2 and CE3\nimport doobie._\nimport doobie.implicits._\nimport fs2.Stream\nimport zio.Task\nimport zio.interop.catz._\n\nimplicit val zioRuntime: zio.Runtime[Any] = zio.Runtime.default\n\ncase class User(id: String, name: String, age: Int)\n\ndef xa: Transactor[Task] =\n  Transactor.fromDriverManager[Task](\n    "org.h2.Driver",\n    "jdbc:h2:mem:users;DB_CLOSE_DELAY=-1"\n  )\n\ndef createTable: doobie.ConnectionIO[Int] =\n  sql"""|CREATE TABLE IF NOT EXISTS USERS(\n        |id   INT SERIAL UNIQUE,\n        |name VARCHAR NOT NULL UNIQUE,\n        |age  SMALLINT\n        |)""".stripMargin.update.run\n\ndef dropTable: doobie.ConnectionIO[Int] =\n  sql"""DROP TABLE IF EXISTS USERS""".update.run\n\ndef insert(name: String, age: Int): doobie.ConnectionIO[Int] =\n  sql"insert into users (name, age) values ($name, $age)".update.run\n\ndef loadUsers: Stream[doobie.ConnectionIO, User] =\n  sql"""SELECT * FROM users""".query[User].stream\n\nval doobieApp: Stream[doobie.ConnectionIO, User] = for {\n  _ <- fs2.Stream.eval(dropTable)\n  _ <- fs2.Stream.eval(createTable)\n  _ <- fs2.Stream.eval(insert("Olivia", 21))\n  _ <- fs2.Stream.eval(insert("Oliver", 30))\n  u <- loadUsers\n} yield u\n\nval run: Stream[Task, User] = doobieApp.transact(xa)\n\nval allUsers: List[User] =\n  zioRuntime.unsafeRun(run.compile.toList)\n'})}),"\n",(0,s.jsx)(n.p,{children:"Sounds good, but how can we specify a specialized transactor than the default one? Creating a customized transactor in CE2 differs from CE3."}),"\n",(0,s.jsx)(n.p,{children:"Let's try doing that in each of which:"}),"\n",(0,s.jsx)(n.h4,{id:"customized-transactor-ce2",children:"Customized Transactor (CE2)"}),"\n",(0,s.jsxs)(n.p,{children:["ZIO provides a specific blocking thread pool for blocking operations. The ",(0,s.jsx)(n.code,{children:"doobie-hikari"})," module helps us create a transactor with two separated executors, one for blocking operations, and the other one for non-blocking operations. So we shouldn't run blocking JDBC operations or perform awaiting connections to the database on the main thread pool."]}),"\n",(0,s.jsxs)(n.p,{children:["So let's fix this issue in the previous example. In the following snippet we are going to create a ",(0,s.jsx)(n.code,{children:"ZMHikari"})," of Hikari transactor. In this example we are using ",(0,s.jsx)(n.code,{children:"0.13.4"})," version of doobie which supports CE2:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import zio.ZManaged\nimport zio.{ Runtime, Task, ZIO, ZManaged }\nimport doobie.hikari.HikariTransactor\nimport cats.effect.Blocker\nimport zio.interop.catz._\n\ndef transactor: ZManaged[Any, Throwable, HikariTransactor[Task]] =\n  for {\n    rt <- ZIO.runtime[Any].toManaged\n    be <- ZIO.blockingExecutor.toManaged                          // our blocking EC\n    xa <- HikariTransactor\n            .newHikariTransactor[Task](\n              "org.h2.Driver",                                    // driver classname\n              "jdbc:h2:mem:test;DB_CLOSE_DELAY=-1",               // connect URL\n              "sa",                                               // username\n              "",                                                 // password\n              be.asExecutionContext,                              // await connection here\n              Blocker.liftExecutionContext(be.asExecutionContext) // execute JDBC operations here\n            )\n            .toManagedZIO\n  } yield xa\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Now we can ",(0,s.jsx)(n.code,{children:"transact"})," our ",(0,s.jsx)(n.code,{children:"doobieApp"})," with this ",(0,s.jsx)(n.code,{children:"transactor"})," and convert that to the ",(0,s.jsx)(n.code,{children:"ZIO"})," effect:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"val zioApp: ZIO[Any, Throwable, List[User]] =\n  transactor.use(xa => doobieApp.transact(xa).compile.toList)\n"})}),"\n",(0,s.jsx)(n.h4,{id:"customized-transactor-ce3",children:"Customized Transactor (CE3)"}),"\n",(0,s.jsxs)(n.p,{children:["In Cats Effect 3.x, the ",(0,s.jsx)(n.code,{children:"cats.effect.Blocker"})," has been removed. So the transactor constructor doesn't require us a blocking executor; it happens under the hood using the ",(0,s.jsx)(n.code,{children:"Sync[F].blocking"})," operation."]}),"\n",(0,s.jsxs)(n.p,{children:["To create a ",(0,s.jsx)(n.code,{children:"Transactor"})," in CE3, we need to create an instance of ",(0,s.jsx)(n.code,{children:"Dispatcher"})," for ",(0,s.jsx)(n.code,{children:"zio.Task"}),". The following example is based on Doobie's ",(0,s.jsx)(n.code,{children:"1.0.0-M5"})," version which supports CE3:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import doobie.hikari.HikariTransactor\nimport zio.interop.catz._\nimport zio.{Task, ZIO, ZManaged}\n\nimplicit val zioRuntime: zio.Runtime[Any] =\n  zio.Runtime.default\n\nimplicit val dispatcher: cats.effect.std.Dispatcher[zio.Task] =\n  zioRuntime\n    .unsafeRun(\n      cats.effect.std\n        .Dispatcher[zio.Task]\n        .allocated\n    )\n    ._1\n\ndef transactor: ZManaged[Any, Throwable, HikariTransactor[Task]] =\n  for {\n    rt <- ZIO.runtime[Any].toManaged\n    xa <-\n      HikariTransactor\n        .newHikariTransactor[Task](\n          "org.h2.Driver",                             // driver classname\n          "jdbc:h2:mem:test;DB_CLOSE_DELAY=-1",        // connect URL\n          "sa",                                        // username\n          "",                                          // password\n          rt.runtimeConfig.executor.asExecutionContext // await connection here\n        )\n        .toManaged\n  } yield xa\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Now we can ",(0,s.jsx)(n.code,{children:"transact"})," our ",(0,s.jsx)(n.code,{children:"doobieApp"})," with this ",(0,s.jsx)(n.code,{children:"transactor"})," and convert that to the ",(0,s.jsx)(n.code,{children:"ZIO"})," effect:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"val zioApp: ZIO[Any, Throwable, List[User]] =\n  transactor.use(xa => doobieApp.transact(xa).compile.toList)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"http4s",children:"Http4s"}),"\n",(0,s.jsx)(n.p,{children:"Here is the full working example of using http4s in ZIO App:"}),"\n",(0,s.jsx)(n.h4,{id:"cats-effect-2x-2",children:"Cats Effect 2.x"}),"\n",(0,s.jsxs)(n.p,{children:["The following example is based on http4s's ",(0,s.jsx)(n.code,{children:"0.21.24"})," version which supports CE2:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import cats.effect.{ConcurrentEffect, Sync, Timer}\nimport cats.implicits._\nimport fs2.Stream\nimport org.http4s.HttpRoutes\nimport org.http4s.client.blaze.BlazeClientBuilder\nimport org.http4s.dsl.Http4sDsl\nimport org.http4s.server.blaze.BlazeServerBuilder\nimport zio.interop.catz._\nimport zio.interop.catz.implicits._ \nimport zio.{Task, URIO}\n\nimport scala.concurrent.ExecutionContext.global\n\nobject ZioHttp4sInterop extends CatsApp {\n  def run(args: List[String]): URIO[Any, zio.ExitCode] =\n    stream[Task].compile.drain.exitCode\n  \n  def stream[F[_]: ConcurrentEffect: Timer]: Stream[F, Nothing] = {\n    import org.http4s.implicits._\n    val httpApp = helloWorldRoute[F].orNotFound\n    for {\n      _ <- BlazeClientBuilder[F](global).stream\n      exitCode <- BlazeServerBuilder[F](global)\n        .bindHttp(8080, "0.0.0.0")\n        .withHttpApp(httpApp)\n        .serve\n    } yield exitCode\n  }.drain\n\n  def helloWorldRoute[F[_]: Sync]: HttpRoutes[F] = {\n    val dsl = new Http4sDsl[F]{}\n    import dsl._\n    HttpRoutes.strict[F] {\n      case GET -> Root =>\n        Ok("Hello, World!")\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"cats-effect-3x-2",children:"Cats Effect 3.x"}),"\n",(0,s.jsxs)(n.p,{children:["The following example is based on http4s's ",(0,s.jsx)(n.code,{children:"0.23.0-RC1"})," version which supports CE3:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import cats.Applicative\nimport cats.effect.Async\nimport fs2.Stream\nimport org.http4s.HttpRoutes\nimport org.http4s.blaze.client.BlazeClientBuilder\nimport org.http4s.blaze.server.BlazeServerBuilder\nimport org.http4s.dsl.Http4sDsl\nimport zio.interop.catz._\nimport zio.{Task, URIO}\n\nimport scala.concurrent.ExecutionContext.global\n\nobject ZioHttp4sInterop extends zio.interop.catz.CatsApp {\n  def stream[F[_]: Async]: Stream[F, Nothing] = {\n    import org.http4s.implicits._\n    val httpApp = helloWorldRoute[F].orNotFound\n    for {\n      _ <- BlazeClientBuilder[F](global).stream\n      exitCode <- BlazeServerBuilder[F](global)\n        .bindHttp(8080, "0.0.0.0")\n        .withHttpApp(httpApp)\n        .serve\n    } yield exitCode\n  }.drain\n\n  def helloWorldRoute[F[_]: Applicative]: HttpRoutes[F] = {\n    val dsl = new Http4sDsl[F] {}\n    import dsl._\n    HttpRoutes.strict[F] { case GET -> Root =>\n      Ok("Hello, World!")\n    }\n  }\n\n  def run(args: List[String]): URIO[Any, zio.ExitCode] =\n    stream[Task].compile.drain.exitCode\n}\n'})})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>o});var i=t(96540);const s={},a=i.createContext(s);function c(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);