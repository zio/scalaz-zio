"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[62832],{28453:(e,i,n)=>{n.d(i,{R:()=>r,x:()=>c});var a=n(96540);const t={},s=a.createContext(t);function r(e){const i=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function c(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),a.createElement(s.Provider,{value:i},e.children)}},98858:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"zio-dynamodb/guides/codec-customization","title":"Codec Customization","description":"Sealed trait members that are case classes","source":"@site/docs/zio-dynamodb/guides/codec-customization.md","sourceDirName":"zio-dynamodb/guides","slug":"/zio-dynamodb/guides/codec-customization","permalink":"/zio-dynamodb/guides/codec-customization","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-dynamodb/guides/codec-customization.md","tags":[],"version":"current","frontMatter":{"id":"codec-customization","title":"Codec Customization"},"sidebar":"ecosystem-sidebar","previous":{"title":"High Level API Data Modelling and Limitations","permalink":"/zio-dynamodb/guides/data-modelling"},"next":{"title":"DynamoDB Transactions","permalink":"/zio-dynamodb/guides/transactions"}}');var t=n(74848),s=n(28453);const r={id:"codec-customization",title:"Codec Customization"},c=void 0,o={},d=[{value:"Sealed trait members that are case classes",id:"sealed-trait-members-that-are-case-classes",level:2},{value:"Sealed trait members that are case objects",id:"sealed-trait-members-that-are-case-objects",level:2},{value:"Sealed trait members that are case classes",id:"sealed-trait-members-that-are-case-classes-1",level:2},{value:"Sealed trait members that are all case objects",id:"sealed-trait-members-that-are-all-case-objects",level:2},{value:"No disriminator codecs using @noDiscriminator annotation",id:"no-disriminator-codecs-using-nodiscriminator-annotation",level:2},{value:"Recommendations",id:"recommendations",level:2}];function l(e){const i={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.h2,{id:"sealed-trait-members-that-are-case-classes",children:"Sealed trait members that are case classes"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-scala",children:"sealed trait TrafficLight\nfinal case class Green(rgb: Int) extends TrafficLight \nfinal case class Red(rgb: Int) extends TrafficLight\nfinal case class Box(trafficLightColour: TrafficLight)\n"})}),"\n",(0,t.jsxs)(i.p,{children:["The default encoding for ",(0,t.jsx)(i.code,{children:"Box(Green(42))"})," is:"]}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.code,{children:"Map(trafficLightColour -> Map(String(Green) -> Map(String(rgb) -> Number(42))))"})}),"\n",(0,t.jsxs)(i.p,{children:["Here an intermediate map is used to identify the member of ",(0,t.jsx)(i.code,{children:"TrafficLight"})," using the member class name ie ",(0,t.jsx)(i.code,{children:"Map(String(Green) -> Map(...))"})]}),"\n",(0,t.jsx)(i.h2,{id:"sealed-trait-members-that-are-case-objects",children:"Sealed trait members that are case objects"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-scala",children:"sealed trait TrafficLight\ncase object GREEN extends TrafficLight \ncase object RED extends TrafficLight\nfinal case class Box(trafficLightColour: TrafficLight)\n"})}),"\n",(0,t.jsxs)(i.p,{children:["The default encoding for ",(0,t.jsx)(i.code,{children:"Box(GREEN)"})," is:"]}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.code,{children:"Map(trafficLightColour -> Map(String(GREEN) -> Null))"})}),"\n",(0,t.jsxs)(i.p,{children:["Here an intermediate map is used to identify the member of ",(0,t.jsx)(i.code,{children:"TrafficLight"})," ie ",(0,t.jsx)(i.code,{children:"Map(String(GREEN) -> Null)"}),"\nNote that the ",(0,t.jsx)(i.code,{children:"Null"})," is used as in this case we do not care about the value."]}),"\n",(0,t.jsx)(i.h1,{id:"customising-encodings-via-annotations",children:"Customising encodings via annotations"}),"\n",(0,t.jsxs)(i.p,{children:["Encodings can be customised through the use of the following annotations ",(0,t.jsx)(i.code,{children:"@discriminatorName"})," and ",(0,t.jsx)(i.code,{children:"@fieldName"}),".\nThese annotations are useful when working with a legacy DynamoDB database."]}),"\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:"@discriminatorName"})," encodings does not introduce another map for the purposes of identification but rather adds another\ndiscriminator field to the attribute Map."]}),"\n",(0,t.jsxs)(i.p,{children:["Concrete examples of using the ",(0,t.jsx)(i.code,{children:"@discriminatorName"})," and ",(0,t.jsx)(i.code,{children:"@field"})," annotations can be seen below."]}),"\n",(0,t.jsx)(i.h2,{id:"sealed-trait-members-that-are-case-classes-1",children:"Sealed trait members that are case classes"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-scala",children:'@discriminatorName("light_type")\nsealed trait TrafficLight\nfinal case class Green(rgb: Int) extends TrafficLight\n@caseName("red_traffic_light")\nfinal case class Red(rgb: Int) extends TrafficLight\nfinal case class Amber(@fieldName("red_green_blue") rgb: Int) extends TrafficLight\nfinal case class Box(trafficLightColour: TrafficLight)\n'})}),"\n",(0,t.jsxs)(i.p,{children:["encoding for an instance of ",(0,t.jsx)(i.code,{children:"Box(Green(42))"})," would be:"]}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.code,{children:"Map(trafficLightColour -> Map(String(rgb) -> Number(42), String(light_type) -> String(Green)))"})}),"\n",(0,t.jsxs)(i.p,{children:["We can specify the field name used to identify the case class through the ",(0,t.jsx)(i.code,{children:"@discriminatorName"})," annotation. The discriminator\nencoding removes the intermediate map and inserts a new field with a name specified by discriminator annotation and a\nvalue that identifies the member which defaults to the class name."]}),"\n",(0,t.jsxs)(i.p,{children:["This can be further customised using the ",(0,t.jsx)(i.code,{children:"@caseName"})," annotation - encoding for an instance of ",(0,t.jsx)(i.code,{children:"Box(Red(42))"})," would be:"]}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.code,{children:"Map(trafficLightColour -> Map(String(rgb) -> Number(42), String(light_type) -> String(red_traffic_light)))"})}),"\n",(0,t.jsxs)(i.p,{children:["The encoding for case class field names can also be customised via ",(0,t.jsx)(i.code,{children:"@fieldName"})," - encoding for an instance of ",(0,t.jsx)(i.code,{children:"Box(Amber(42))"})," would be:"]}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.code,{children:"Map(trafficLightColour -> Map(String(red_green_blue) -> Number(42), String(light_type) -> String(Amber)))"})}),"\n",(0,t.jsx)(i.h2,{id:"sealed-trait-members-that-are-all-case-objects",children:"Sealed trait members that are all case objects"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-scala",children:'sealed trait TrafficLight\ncase object GREEN extends TrafficLight \n@caseName("red_traffic_light")\ncase object RED extends TrafficLight\nfinal case class Box(trafficLightColour: TrafficLight)\n'})}),"\n",(0,t.jsxs)(i.p,{children:["We can get a more compact and intuitive encoding of trait members that are case objects by using the ",(0,t.jsx)(i.code,{children:"@simpleEnum"}),"\nannotation which encodes to just a value that is the member name. This annotation doesn't need to be added explicitly\nsince this is done by the ZIO Schema macro automatically.\nEncoding for an instance of ",(0,t.jsx)(i.code,{children:"Box(GREEN)"})," would be:"]}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.code,{children:"Map(trafficLightColour -> String(GREEN))"})}),"\n",(0,t.jsxs)(i.p,{children:["This can be further customised by using the ",(0,t.jsx)(i.code,{children:"@caseName"})," annotation again - encoding for ",(0,t.jsx)(i.code,{children:"Box(RED)"})," would be"]}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.code,{children:"Map(trafficLightColour -> String(red_traffic_light))"})}),"\n",(0,t.jsx)(i.h2,{id:"no-disriminator-codecs-using-nodiscriminator-annotation",children:"No disriminator codecs using @noDiscriminator annotation"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-scala",children:'@noDiscriminator\nsealed trait TrafficLight\n@caseName("blue")\nfinal case object Blue extends TrafficLight\nfinal case object Purple extends TrafficLight \nfinal case class Green(rgb: Int, i: Int) extends TrafficLight\n@caseName("red_traffic_light") // this annotation is ignored in the context of @noDiscriminator\nfinal case class Red(rgb: Int, j: Int) extends TrafficLight\nfinal case class Amber(@fieldName("red_green_blue") rgb: Int) extends TrafficLight\nfinal case class Box(trafficLightColour: TrafficLight)\n'})}),"\n",(0,t.jsx)(i.p,{children:"This primarily useful when working with legacy DynamoDB databases where a discriminator field is not present (some DynamoDB mapping libraries allow users to create codecs with no discriminators or tags to disambiguate each sum type case)."}),"\n",(0,t.jsx)(i.p,{children:"WARNING! - this leads to the inefficiency of having to try each case and checking for success, and also forces the dangerous assumption that all the sum type cases will be different when encoded. When decoding if there are ambiguities amongst the codecs for the sum type instances this is handled gracefully by returning a Left of a DynamoDBError.DecodingError"}),"\n",(0,t.jsxs)(i.p,{children:["Mapping for ",(0,t.jsx)(i.code,{children:"Box(Blue)"})," would be ",(0,t.jsx)(i.code,{children:"Map(trafficLightColour -> String(blue))"})]}),"\n",(0,t.jsxs)(i.p,{children:["Mapping for ",(0,t.jsx)(i.code,{children:"Box(Amber(42))"})," would be ",(0,t.jsx)(i.code,{children:"Map(trafficLightColour -> Map(String(red_green_blue) -> Number(42))"})]}),"\n",(0,t.jsx)(i.h2,{id:"recommendations",children:"Recommendations"}),"\n",(0,t.jsx)(i.p,{children:"For greenfield development it is recommended to use:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["the default encoding which uses an intermediate map (see the above default encoding) - (note this mapping does not work with top level sum types as it requires an intermediate map and partition keys must be scalar values) ",(0,t.jsx)(i.em,{children:"or"})]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"@discriminatorName"})," encoding (",(0,t.jsx)(i.a,{href:"#customising-encodings-via-annotations",children:"see above"}),") if you would like a more compact encoding - note this ",(0,t.jsx)(i.em,{children:"must"})," be used for top level sum types"]}),"\n",(0,t.jsxs)(i.li,{children:["for deeply nested hierarchies avoid a top level sum type altogether and have a concrete top level class - see ",(0,t.jsx)(i.a,{href:"data-modelling#deep-oo-style-hierarchies-are-not-supported---modelling-data-using-product-and-sum-types",children:"High Level API Data Modelling and Limitations"})]}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}}}]);