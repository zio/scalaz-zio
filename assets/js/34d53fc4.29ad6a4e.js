"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[69505],{28453:(e,t,s)=>{s.d(t,{R:()=>c,x:()=>o});var n=s(96540);const r={},i=n.createContext(r);function c(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),n.createElement(i.Provider,{value:t},e.children)}},36975:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>c,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"reference/test/aspects/restoring-state-of-test-services","title":"Restoring State of Test Services","description":"ZIO Test has some test aspects which restore the state of given restorable test services, such as TestClock, TestConsole, TestRandom and TestSystem, to their starting state after the test is run. Note that these test aspects are only useful when we are repeating tests.","source":"@site/docs/reference/test/aspects/restoring-state-of-test-services.md","sourceDirName":"reference/test/aspects","slug":"/reference/test/aspects/restoring-state-of-test-services","permalink":"/reference/test/aspects/restoring-state-of-test-services","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/test/aspects/restoring-state-of-test-services.md","tags":[],"version":"current","frontMatter":{"id":"restoring-state-of-test-services","title":"Restoring State of Test Services"},"sidebar":"reference-sidebar","previous":{"title":"Repeat and Retry","permalink":"/reference/test/aspects/repeat-and-retry"},"next":{"title":"Changing the Size of Sized Generators","permalink":"/reference/test/aspects/sized"}}');var r=s(74848),i=s(28453);const c={id:"restoring-state-of-test-services",title:"Restoring State of Test Services"},o=void 0,a={},l=[];function d(e){const t={code:"code",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:["ZIO Test has some test aspects which restore the state of given restorable test services, such as ",(0,r.jsx)(t.code,{children:"TestClock"}),", ",(0,r.jsx)(t.code,{children:"TestConsole"}),", ",(0,r.jsx)(t.code,{children:"TestRandom"})," and ",(0,r.jsx)(t.code,{children:"TestSystem"}),", to their starting state after the test is run. Note that these test aspects are only useful when we are repeating tests."]}),"\n",(0,r.jsx)(t.p,{children:"Here is a list of restore methods:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"TestAspect.restore"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"TestAspect.restoreTestClock"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"TestAspect.restoreTestConsole"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"TestAspect.restoreTestRandom"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"TestAspect.restoreTestSystem"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"TestAspect.restoreTestEnvironment"})}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Let's try an example. Assume we have written the following test aspect, which repeats the test 5 times:"}),"\n",(0,r.jsx)(t.p,{children:"When we run a test with this testing aspect, on each try, we have a polluted test environment:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-scala",children:'import zio._\nimport zio.test.{ test, _ }\nimport java.util.concurrent.TimeUnit\n\nsuite("clock suite")(\n  test("adjusting clock") {\n    for {\n      clock <- ZIO.clock\n      _     <- TestClock.adjust(1.second)\n      time  <- clock.currentTime(TimeUnit.SECONDS).debug("current time")\n    } yield assertTrue(time == 1)\n  } @@ repeat5\n)\n'})}),"\n",(0,r.jsx)(t.p,{children:"This test fails in the second retry:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"current time: 1\ncurrent time: 2\n- some suite\n  - clock suite\n    - adjusting clock\n      \u2717 2 was not equal to 1\n      time == 1\n      time = 2\n"})}),"\n",(0,r.jsxs)(t.p,{children:["It failed because of the first run of the test changed the state of the ",(0,r.jsx)(t.code,{children:"TestClock"})," service, so on the next run, the initial state of the test is not zero. In such a situation, when we are repeating a test, after each run we can restore the state of the test to its initial state, using ",(0,r.jsx)(t.code,{children:"TestAspect.restore*"})," test aspects:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-scala",children:'import zio._\nimport zio.test.{ test, _ }\nimport java.util.concurrent.TimeUnit\n\nsuite("clock suite")(\n  test("adjusting clock") {\n    for {\n      clock <- ZIO.clock\n      _     <- TestClock.adjust(1.second)\n      time  <- clock.currentTime(TimeUnit.SECONDS).debug("current time")\n    } yield assertTrue(time == 1)\n  } @@ TestAspect.restoreTestClock @@ repeat5\n)\n'})}),"\n",(0,r.jsx)(t.p,{children:"The output of running this test would be as follows:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"current time: 1\ncurrent time: 1\ncurrent time: 1\ncurrent time: 1\ncurrent time: 1\ncurrent time: 1\n+ clock suite\n  + adjusting clock\n  Ran 1 test in 470 ms: 1 succeeded, 0 ignored, 0 failed\n"})})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);