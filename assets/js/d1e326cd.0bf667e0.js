"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[1171],{77989:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"reference/stm/tset","title":"TSet","description":"A TSet[A] is a mutable set that can participate in transactions in STM.","source":"@site/versioned_docs/version-1.0.18/reference/stm/tset.md","sourceDirName":"reference/stm","slug":"/reference/stm/tset","permalink":"/1.0.18/reference/stm/tset","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/versioned_docs/version-1.0.18/reference/stm/tset.md","tags":[],"version":"1.0.18","frontMatter":{"id":"tset","title":"TSet"}}');var s=n(74848),o=n(28453);const a={id:"tset",title:"TSet"},r=void 0,l={},c=[{value:"Create a TSet",id:"create-a-tset",level:2},{value:"Put an element to a TSet",id:"put-an-element-to-a-tset",level:2},{value:"Remove an element from a TSet",id:"remove-an-element-from-a-tset",level:2},{value:"Union of a TSet",id:"union-of-a-tset",level:2},{value:"Intersection of a TSet",id:"intersection-of-a-tset",level:2},{value:"Difference of a TSet",id:"difference-of-a-tset",level:2},{value:"Transform elements of a TSet",id:"transform-elements-of-a-tset",level:2},{value:"Perform side-effect for TSet elements",id:"perform-side-effect-for-tset-elements",level:2},{value:"Check TSet membership",id:"check-tset-membership",level:2},{value:"Convert TSet to a List",id:"convert-tset-to-a-list",level:2},{value:"Size of a TSet",id:"size-of-a-tset",level:2}];function d(e){const t={code:"code",h2:"h2",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["A ",(0,s.jsx)(t.code,{children:"TSet[A]"})," is a mutable set that can participate in transactions in STM."]}),"\n",(0,s.jsx)(t.h2,{id:"create-a-tset",children:"Create a TSet"}),"\n",(0,s.jsxs)(t.p,{children:["Creating an empty ",(0,s.jsx)(t.code,{children:"TSet"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:"import zio._\nimport zio.stm._\n\nval emptyTSet: STM[Nothing, TSet[Int]] = TSet.empty[Int]\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Or creating a ",(0,s.jsx)(t.code,{children:"TSet"})," with specified values:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:"import zio._\nimport zio.stm._\n\nval specifiedValuesTSet: STM[Nothing, TSet[Int]] = TSet.make(1, 2, 3)\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Alternatively, you can create a ",(0,s.jsx)(t.code,{children:"TSet"})," by providing a collection of values:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:"import zio._\nimport zio.stm._\n\nval iterableTSet: STM[Nothing, TSet[Int]] = TSet.fromIterable(List(1, 2, 3))\n"})}),"\n",(0,s.jsx)(t.p,{children:"In case there are duplicates provided, the last one is taken."}),"\n",(0,s.jsx)(t.h2,{id:"put-an-element-to-a-tset",children:"Put an element to a TSet"}),"\n",(0,s.jsx)(t.p,{children:"The new element can be added to the set in the following way:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:"import zio._\nimport zio.stm._\n\nval putElem: UIO[TSet[Int]] = (for {\n  tSet <- TSet.make(1, 2)\n  _    <- tSet.put(3)\n} yield tSet).commit\n"})}),"\n",(0,s.jsx)(t.p,{children:"In case the set already contains the element, no modification will happen."}),"\n",(0,s.jsx)(t.h2,{id:"remove-an-element-from-a-tset",children:"Remove an element from a TSet"}),"\n",(0,s.jsxs)(t.p,{children:["The simplest way to remove an element from ",(0,s.jsx)(t.code,{children:"TSet"})," is using ",(0,s.jsx)(t.code,{children:"delete"})," method:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:"import zio._\nimport zio.stm._\n\nval deleteElem: UIO[TSet[Int]] = (for {\n  tSet <- TSet.make(1, 2, 3)\n  _    <- tSet.delete(1)\n} yield tSet).commit\n"})}),"\n",(0,s.jsx)(t.p,{children:"Also, it is possible to remove every element that satisfies provided predicate:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:"import zio._\nimport zio.stm._\n\nval removedEvenElems: UIO[TSet[Int]] = (for {\n  tSet <- TSet.make(1, 2, 3, 4)\n  _    <- tSet.removeIf(_ % 2 == 0)\n} yield tSet).commit\n"})}),"\n",(0,s.jsx)(t.p,{children:"Or you can keep all the elements that match predicate function:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:"import zio._\nimport zio.stm._\n\nval retainedEvenElems: UIO[TSet[Int]] = (for {\n  tSet <- TSet.make(1, 2, 3, 4)\n  _    <- tSet.retainIf(_ % 2 == 0)\n} yield tSet).commit\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Note that ",(0,s.jsx)(t.code,{children:"retainIf"})," and ",(0,s.jsx)(t.code,{children:"removeIf"})," serve the same purpose as ",(0,s.jsx)(t.code,{children:"filter"})," and ",(0,s.jsx)(t.code,{children:"filterNot"}),". The reason for naming them differently was to emphasize a distinction in their nature. Namely, both ",(0,s.jsx)(t.code,{children:"retainIf"})," and ",(0,s.jsx)(t.code,{children:"removeIf"})," are destructive - calling them can modify the collection."]}),"\n",(0,s.jsx)(t.h2,{id:"union-of-a-tset",children:"Union of a TSet"}),"\n",(0,s.jsxs)(t.p,{children:["Union of the sets A and B represents the set of elements belonging to set A or set B, or both.\nUsing ",(0,s.jsx)(t.code,{children:"A union B"})," method modifies set ",(0,s.jsx)(t.code,{children:"A"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:"import zio._\nimport zio.stm._\n\n// unionTSet = {1, 2, 3, 4, 5, 6}\nval unionTSet: UIO[TSet[Int]] = (for {\n  tSetA <- TSet.make(1, 2, 3, 4)\n  tSetB <- TSet.make(3, 4, 5, 6)\n  _     <- tSetA.union(tSetB)\n} yield tSetA).commit\n"})}),"\n",(0,s.jsx)(t.h2,{id:"intersection-of-a-tset",children:"Intersection of a TSet"}),"\n",(0,s.jsxs)(t.p,{children:["The intersection of the sets A and B is the set of elements belonging to both A and B.\nUsing ",(0,s.jsx)(t.code,{children:"A intersect B"})," method modifies set ",(0,s.jsx)(t.code,{children:"A"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:"import zio._\nimport zio.stm._\n\n// intersectionTSet = {3, 4}\nval intersectionTSet: UIO[TSet[Int]] = (for {\n  tSetA <- TSet.make(1, 2, 3, 4)\n  tSetB <- TSet.make(3, 4, 5, 6)\n  _     <- tSetA.intersect(tSetB)\n} yield tSetA).commit\n"})}),"\n",(0,s.jsx)(t.h2,{id:"difference-of-a-tset",children:"Difference of a TSet"}),"\n",(0,s.jsxs)(t.p,{children:["The difference between sets A and B is the set containing elements of set A but not in B.\nUsing ",(0,s.jsx)(t.code,{children:"A diff B"})," method modifies set ",(0,s.jsx)(t.code,{children:"A"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:"import zio._\nimport zio.stm._\n\n// diffTSet = {1, 2}\nval diffTSet: UIO[TSet[Int]] = (for {\n  tSetA <- TSet.make(1, 2, 3, 4)\n  tSetB <- TSet.make(3, 4, 5, 6)\n  _     <- tSetA.diff(tSetB)\n} yield tSetA).commit\n"})}),"\n",(0,s.jsx)(t.h2,{id:"transform-elements-of-a-tset",children:"Transform elements of a TSet"}),"\n",(0,s.jsxs)(t.p,{children:["The transform function ",(0,s.jsx)(t.code,{children:"A => A"})," allows computing a new value for every element in the set:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:"import zio._\nimport zio.stm._\n\nval transformTSet: UIO[TSet[Int]] = (for {\n  tSet <- TSet.make(1, 2, 3, 4)\n  _    <- tSet.transform(a => a * a)\n} yield tSet).commit\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Note that it is possible to shrink a ",(0,s.jsx)(t.code,{children:"TSet"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:"import zio._\nimport zio.stm._\n\nval shrinkTSet: UIO[TSet[Int]] = (for {\n  tSet <- TSet.make(1, 2, 3, 4)\n  _    <- tSet.transform(_ => 1)\n} yield tSet).commit\n"})}),"\n",(0,s.jsx)(t.p,{children:"Resulting set in example above has only one element."}),"\n",(0,s.jsxs)(t.p,{children:["Note that ",(0,s.jsx)(t.code,{children:"transform"})," serves the same purpose as ",(0,s.jsx)(t.code,{children:"map"}),". The reason for naming it differently was to emphasize a distinction in its nature. Namely, ",(0,s.jsx)(t.code,{children:"transform"})," is destructive - calling it can modify the collection."]}),"\n",(0,s.jsxs)(t.p,{children:["The elements can be mapped effectfully via ",(0,s.jsx)(t.code,{children:"transformM"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:"import zio._\nimport zio.stm._\n\nval transformMTSet: UIO[TSet[Int]] = (for {\n  tSet <- TSet.make(1, 2, 3, 4)\n  _    <- tSet.transformM(a => STM.succeed(a * a))\n} yield tSet).commit\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Folds the elements of a ",(0,s.jsx)(t.code,{children:"TSet"})," using the specified associative binary operator:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:"import zio._\nimport zio.stm._\n\nval foldTSet: UIO[Int] = (for {\n  tSet <- TSet.make(1, 2, 3, 4)\n  sum  <- tSet.fold(0)(_ + _)\n} yield sum).commit\n"})}),"\n",(0,s.jsxs)(t.p,{children:["The elements can be folded effectfully via ",(0,s.jsx)(t.code,{children:"foldM"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:"import zio._\nimport zio.stm._\n\nval foldMTSet: UIO[Int] = (for {\n  tSet <- TSet.make(1, 2, 3, 4)\n  sum  <- tSet.foldM(0)((acc, el) => STM.succeed(acc + el))\n} yield sum).commit\n"})}),"\n",(0,s.jsx)(t.h2,{id:"perform-side-effect-for-tset-elements",children:"Perform side-effect for TSet elements"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"foreach"})," is used for performing side-effect for each element in set:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:"import zio._\nimport zio.stm._\n\nval foreachTSet = (for {\n  tSet <- TSet.make(1, 2, 3, 4)\n  _    <- tSet.foreach(a => STM.succeed(println(a)))\n} yield tSet).commit\n"})}),"\n",(0,s.jsx)(t.h2,{id:"check-tset-membership",children:"Check TSet membership"}),"\n",(0,s.jsxs)(t.p,{children:["Checking whether the element is present in a ",(0,s.jsx)(t.code,{children:"TSet"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:"import zio._\nimport zio.stm._\n\nval tSetContainsElem: UIO[Boolean] = (for {\n  tSet <- TSet.make(1, 2, 3, 4)\n  res  <- tSet.contains(3)\n} yield res).commit\n"})}),"\n",(0,s.jsx)(t.h2,{id:"convert-tset-to-a-list",children:"Convert TSet to a List"}),"\n",(0,s.jsx)(t.p,{children:"List of set elements can be obtained as follows:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:"import zio._\nimport zio.stm._\n\nval tSetToList: UIO[List[Int]] = (for {\n  tSet <- TSet.make(1, 2, 3, 4)\n  list <- tSet.toList\n} yield list).commit\n"})}),"\n",(0,s.jsx)(t.h2,{id:"size-of-a-tset",children:"Size of a TSet"}),"\n",(0,s.jsx)(t.p,{children:"Set's size can be obtained as follows:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:"import zio._\nimport zio.stm._\n\nval tSetSize: UIO[Int] = (for {\n  tSet <- TSet.make(1, 2, 3, 4)\n  size <- tSet.size\n} yield size).commit\n"})})]})}function m(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>r});var i=n(96540);const s={},o=i.createContext(s);function a(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);