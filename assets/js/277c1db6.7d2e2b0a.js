"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[41691],{15160:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>a,toc:()=>h});const a=JSON.parse('{"id":"zio-schema/operations/transforming-schemas","title":"Transforming Schemas","description":"Using the Schema#transform method, we can transform a Schema[A] into a Schema[B] by supplying two functions that can transform between A and B.  In normal Scala code this would be the equivalent of map, but with isomorphism property.","source":"@site/docs/zio-schema/operations/transforming-schemas.md","sourceDirName":"zio-schema/operations","slug":"/zio-schema/operations/transforming-schemas","permalink":"/zio-schema/operations/transforming-schemas","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-schema/operations/transforming-schemas.md","tags":[],"version":"current","frontMatter":{"id":"transforming-schemas","title":"Transforming Schemas"},"sidebar":"ecosystem-sidebar","previous":{"title":"The Default Value","permalink":"/zio-schema/operations/the-default-value"},"next":{"title":"Validation","permalink":"/zio-schema/operations/validation"}}');var s=t(74848),o=t(28453);const i={id:"transforming-schemas",title:"Transforming Schemas"},r=void 0,c={},h=[];function m(e){const n={admonition:"admonition",code:"code",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Using the ",(0,s.jsx)(n.code,{children:"Schema#transform"})," method, we can transform a ",(0,s.jsx)(n.code,{children:"Schema[A]"})," into a ",(0,s.jsx)(n.code,{children:"Schema[B]"})," by supplying two functions that can transform between ",(0,s.jsx)(n.code,{children:"A"})," and ",(0,s.jsx)(n.code,{children:"B"}),".  In normal Scala code this would be the equivalent of ",(0,s.jsx)(n.code,{children:"map"}),", but with isomorphism property."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"object Schema {\n  def transform[B](f: A => B, g: B => A): Schema[B] = ???\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Therefore, if we have a schema for ",(0,s.jsx)(n.code,{children:"A"}),", and isomorphism between ",(0,s.jsx)(n.code,{children:"A"})," and ",(0,s.jsx)(n.code,{children:"B"}),", we can derive a schema for ",(0,s.jsx)(n.code,{children:"B"})," in terms of `Schema[A]."]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["In type theory, isomorphism refers to a relationship between two types that have a bijective correspondence or mapping between their elements. More specifically, if two types, let's say Type ",(0,s.jsx)(n.code,{children:"A"})," and Type ",(0,s.jsx)(n.code,{children:"B"}),", are isomorphic, it means that there exists a pair of functions\u2014one going from A to B (often called the forward function) and another going from B to A (often called the backward function)\u2014that satisfy certain properties."]})}),"\n",(0,s.jsxs)(n.p,{children:["In ZIO Schema this is modelled by the ",(0,s.jsx)(n.code,{children:"Transform"})," type class:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"object Schema {\n  final case class Transform[A, B](\n      codec: Schema[A],\n      f: A => Either[String, B],\n      g: B => Either[String, A]\n    ) extends Schema[B]\n}  \n"})}),"\n",(0,s.jsxs)(n.p,{children:["For example, assume we have a wrapper class ",(0,s.jsx)(n.code,{children:"Age"})," that wraps an ",(0,s.jsx)(n.code,{children:"Int"})," value, and it has some validation logic, e.g. the age must be between 0 and 120. We can define a ",(0,s.jsx)(n.code,{children:"Schema[Age]"})," by using the ",(0,s.jsx)(n.code,{children:"Schema.transform"})," method:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import zio.schema._\n\ncase class Age(i: Int)\n\nobject Age {\n  implicit val schema: Schema[Age] =\n    Schema[Int].transformOrFail(\n      (i: Int) =>\n        if (i >= 0 && i <= 120)\n          Right(Age(i))\n        else\n          Left("Age must be between 1 and 120"),\n      (age: Age) => Right(age.i)\n    )\n}\n'})})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(m,{...e})}):m(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>r});var a=t(96540);const s={},o=a.createContext(s);function i(e){const n=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(o.Provider,{value:n},e.children)}}}]);