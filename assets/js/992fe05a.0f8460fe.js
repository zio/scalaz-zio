"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[34048],{28453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>c});var a=i(96540);const o={},s=a.createContext(o);function t(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:t(e.components),a.createElement(s.Provider,{value:n},e.children)}},69984:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>c,default:()=>g,frontMatter:()=>t,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"zio-config/automatic-derivation-of-config","title":"Automatic Derivation of Config","description":"By bringing in zio-config-magnolia we  avoid all the boilerplate required to define the config. With a single import, Config is automatically derived.","source":"@site/docs/zio-config/automatic-derivation-of-config.md","sourceDirName":"zio-config","slug":"/zio-config/automatic-derivation-of-config","permalink":"/zio-config/automatic-derivation-of-config","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-config/automatic-derivation-of-config.md","tags":[],"version":"current","frontMatter":{"id":"automatic-derivation-of-config","title":"Automatic Derivation of Config"},"sidebar":"ecosystem-sidebar","previous":{"title":"Integrations","permalink":"/zio-config/integrations"},"next":{"title":"Read from various Sources","permalink":"/zio-config/read-from-various-sources"}}');var o=i(74848),s=i(28453);const t={id:"automatic-derivation-of-config",title:"Automatic Derivation of Config"},c=void 0,r={},l=[{value:"Example",id:"example",level:3},{value:"Config",id:"config",level:4},{value:"AutoDerivation",id:"autoderivation",level:4},{value:"Documentation while automatic derivation",id:"documentation-while-automatic-derivation",level:3},{value:"Custom Config",id:"custom-config",level:3},{value:"Where to place these implicits ?",id:"where-to-place-these-implicits-",level:3},{value:"Change Keys (CamelCase, kebab-case etc)",id:"change-keys-camelcase-kebab-case-etc",level:3},{value:"Scala3 Autoderivation",id:"scala3-autoderivation",level:2},{value:"Example:",id:"example-1",level:4},{value:"Example:",id:"example-2",level:4},{value:"Config derivation via <code>derives</code> keyword",id:"config-derivation-via-derives-keyword",level:3},{value:"No guaranteed behavior for scala-3 enum yet",id:"no-guaranteed-behavior-for-scala-3-enum-yet",level:3},{value:"No support for recursive config in auto-derivation, but we can make it work",id:"no-support-for-recursive-config-in-auto-derivation-but-we-can-make-it-work",level:3},{value:"Custom Keys",id:"custom-keys",level:3},{value:"Inbuilt support for pure-config",id:"inbuilt-support-for-pure-config",level:2}];function d(e){const n={code:"code",h2:"h2",h3:"h3",h4:"h4",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:["By bringing in ",(0,o.jsx)(n.code,{children:"zio-config-magnolia"})," we  avoid all the boilerplate required to define the config. With a single import, ",(0,o.jsx)(n.code,{children:"Config"})," is automatically derived."]}),"\n",(0,o.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,o.jsx)(n.h4,{id:"config",children:"Config"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"sealed trait X\n\nobject X {\n  case object A extends X\n  case object B extends X\n  case object C extends X\n  case class  DetailsWrapped(detail: Detail) extends X\n  \n  case class Detail(firstName: String, lastName: String, region: Region)\n  case class Region(suburb: String, city: String)\n}\n\ncase class MyConfig(x: X)\n"})}),"\n",(0,o.jsx)(n.h4,{id:"autoderivation",children:"AutoDerivation"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"// Setting up imports\n\nimport zio._\nimport zio.config._, \nimport zio.config.typesafe._\nimport zio.config.magnolia._\n\n  import X._\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'// Defining different possibility of HOCON source\n\nval aHoconSource =\n  ConfigProvider\n    .fromHoconString("x = A")\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'val bHoconSource =\n  ConfigProvider\n    .fromHoconString("x = B")\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'val cHoconSource =\n  ConfigProvider\n    .fromHoconString("x = C")\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'val dHoconSource =\n  ConfigProvider\n    .fromHoconString(\n      s"""\n         | x {\n         |   DetailsWrapped {\n         |    detail  {\n         |      firstName : ff\n         |      lastName  : ll\n         |      region {\n         |        city   : syd\n         |        suburb : strath\n         |     }\n         |   }\n         |  }\n         |}\n         |""".stripMargin\n    )\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'// Let\'s try automatic derivation\n\naHoconSource.load(deriveConfig[MyConfig])\n// res0: Right(MyConfig(A))\n\nbHoconSource.load(deriveConfig[MyConfig])\n// res0: Right(MyConfig(B))\n\ncHoconSource.load(deriveConfig[MyConfig])\n// res0: Right(MyConfig(C))\n\ndHoconSource.load(deriveConfig[MyConfig])\n// res0: Right(MyConfig(DetailsWrapped(Detail("ff", "ll", Region("strath", "syd")))))\n'})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"NOTE"})}),"\n",(0,o.jsx)(n.p,{children:"The fieldNames and class-names remain the same as that of case-classes and sealed-traits."}),"\n",(0,o.jsxs)(n.p,{children:["If you want custom names for your fields, use ",(0,o.jsx)(n.code,{children:"name"})," annotation."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'import zio.config.derivation.name\n\n@name("detailsWrapped")\ncase class  DetailsWrapped(detail: Detail) extends X\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio.config._\n\nderiveConfig[MyConfig].mapKey(toKebabCase)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["With the above change",(0,o.jsx)(n.code,{children:"firstName"})," and ",(0,o.jsx)(n.code,{children:"lastName"})," in the above HOCON example can be ",(0,o.jsx)(n.code,{children:"first-name"})," and ",(0,o.jsx)(n.code,{children:"last-name"}),"\nrespectively."]}),"\n",(0,o.jsx)(n.p,{children:"There are various ways in which you can customise the derivation of sealed traits.\nThis is a bit involving, and more documentations will be provided soon."}),"\n",(0,o.jsx)(n.h3,{id:"documentation-while-automatic-derivation",children:"Documentation while automatic derivation"}),"\n",(0,o.jsxs)(n.p,{children:["With ",(0,o.jsx)(n.code,{children:"describe"})," annotation you can still document your config while automatically generating the config"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import zio.config.magnolia.describe\n\n@describe("This config is about aws")\ncase class Aws(region: String, dburl: DbUrl)\ncase class DbUrl(value: String)\n'})}),"\n",(0,o.jsx)(n.p,{children:"This will be equivalent to the manual configuration of:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'string("region").zip(string("dburl").to[DbUrl]).to[Aws] ?? "This config is about aws"\n'})}),"\n",(0,o.jsxs)(n.p,{children:["You could provide ",(0,o.jsx)(n.code,{children:"describe"})," annotation at field level"]}),"\n",(0,o.jsx)(n.p,{children:"Example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'case class Aws(@describe("AWS region") region: String, dburl: DbUrl)\n'})}),"\n",(0,o.jsx)(n.p,{children:"This will be equivalent to the manual configuration of:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'(string("region") ?? "AWS region" zip string("dburl").to[DbUrl]).to[Aws] ?? "This config is about aws"\n'})}),"\n",(0,o.jsx)(n.h3,{id:"custom-config",children:"Custom Config"}),"\n",(0,o.jsxs)(n.p,{children:["Every field in a case class should have an instance of ",(0,o.jsx)(n.code,{children:"DeriveConfig"})," (and not ",(0,o.jsx)(n.code,{children:"Config"}),") in order for the automatic derivation to work.\nThis doesn't mean the entire design of zio-config is typeclass based. For the same reason, the typeclass\n",(0,o.jsx)(n.code,{children:"DeriveConfig"})," exists only in zio-config-magnolia."]}),"\n",(0,o.jsxs)(n.p,{children:["As an example, given below is a case class where automatic derivation won't work, and result in a compile time error:\nAssume that, ",(0,o.jsx)(n.code,{children:"AwsRegion"})," is a type that comes from AWS SDK."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"import java.time.ZonedDateTime\n\ncase class Execution(time: AwsRegion, id: Int)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In this case, ",(0,o.jsx)(n.code,{children:"deriveConfig[Execution]"})," will give us the following descriptive compile error."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"magnolia: could not find Descriptor.Typeclass for type <outside.library.package>.AwsRegion\n  in parameter 'time' of product type <your.packagename>.Execution\n"})}),"\n",(0,o.jsx)(n.p,{children:"This is because zio-config-magnolia failed to derive an instance of Descriptor for AwsRegion."}),"\n",(0,o.jsx)(n.p,{children:"In order to provide implicit instances, following choices are there"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"import zio.config.magnolia._\n\nimplicit val awsRegionConfig: DeriveConfig[Aws.Region] =\n  DeriveConfig[String].map(string => AwsRegion.from(string))\n\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Now ",(0,o.jsx)(n.code,{children:"deriveConfig[Execution]"})," compiles."]}),"\n",(0,o.jsx)(n.p,{children:"Custom descriptors are also needed in case you use value classes to describe your configuration. You can use them\ntogether with automatic derivation and those implicit custom descriptors will be taken automatically into account"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio.config.magnolia._\n\nfinal case class AwsRegion(value: String) extends AnyVal {\n  override def toString: String = value\n}\n\nobject AwsRegion {\n  implicit val descriptor: DeriveConfig[AwsRegion] = \n    DeriveConfig[String].map(AwsRegion(_))\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"where-to-place-these-implicits-",children:"Where to place these implicits ?"}),"\n",(0,o.jsx)(n.p,{children:"If the types are owned by us, then the best place to keep implicit instance is the companion object of that type."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'final case class MyAwsRegion(value: AwsRegion)\n\nobject MyAwsRegion {\n  implicit val awsRegionDescriptor: DeriveConfig[MyAwsRegion] =\n    DeriveConfig[String]\n      .map(\n        string => MyAwsRegion(AwsRegion.from(string))\n      ) ?? "value of type AWS.Region"\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"However, sometimes, the types are owned by an external library."}),"\n",(0,o.jsxs)(n.p,{children:["In these situations, better off place the implicit closer to where we call the automatic derivation.\nPlease find the example in ",(0,o.jsx)(n.code,{children:"magnolia"})," package in examples module."]}),"\n",(0,o.jsx)(n.h3,{id:"change-keys-camelcase-kebab-case-etc",children:"Change Keys (CamelCase, kebab-case etc)"}),"\n",(0,o.jsx)(n.p,{children:"Please find the examples in ChangeKeys.scala in magnolia module to find how to manipulate keys in an automatic derivation such as being able to specify keys as camelCase, kebabCase or snakeCase in the source config."}),"\n",(0,o.jsx)(n.h2,{id:"scala3-autoderivation",children:"Scala3 Autoderivation"}),"\n",(0,o.jsx)(n.p,{children:"Works just like scala-2.12 and scala-2.13.\nIf possible, we will make this behaviour consistent in scala-2.12 and scala-2.13 in future versions of zio-config."}),"\n",(0,o.jsx)(n.h4,{id:"example-1",children:"Example:"}),"\n",(0,o.jsxs)(n.p,{children:["The name of the sealed trait itself is skipped completely by default.\nHowever, if you put a ",(0,o.jsx)(n.code,{children:"name"})," annotation on top of the sealed-trait itself,\nthen it becomes part of the config."]}),"\n",(0,o.jsx)(n.p,{children:"The name of the case-class should be available in config-source,\nand by default it should the same name as that of the case-class."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"sealed trait A\ncase class B(x: String) extends A\ncase class C(y: String) extends A\n\ncase class Config(a: A) \n"})}),"\n",(0,o.jsxs)(n.p,{children:["With the above config, ",(0,o.jsx)(n.code,{children:"deriveConfig[A]"})," can read following source."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'{\n  "a" : {\n   "B" : {\n      "x" : "abc"\n     }\n   }\n  }\n}\n\n// or a.B.x="abc", if your source is just property file\n'})}),"\n",(0,o.jsxs)(n.p,{children:["However, if you give ",(0,o.jsx)(n.code,{children:"name"})," annotation for A, the name of the sealed trait\nshould be part of the config too. This is rarely used."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'@name("aaaaa")\nsealed trait A\ncase class B(x: String) extends A\ncase class C(y: String) extends A\n\ncase class Config(a: A) \n'})}),"\n",(0,o.jsxs)(n.p,{children:["With the above config, ",(0,o.jsx)(n.code,{children:"deriveConfig[A]"})," can read following source."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'{\n  "a" : {\n    "aaaaa" : \n      "B" : {\n        "x" : "abc"\n     }\n   }\n  }\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"Similar to scala-2.x, you can give name annotations to any case-class as well (similar to scala 2.x)"}),"\n",(0,o.jsx)(n.h4,{id:"example-2",children:"Example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'sealed trait A\n\n@name("b")\ncase class B(x: String) extends A\ncase class C(y: String) extends A\n\ncase class Config(a: A) \n'})}),"\n",(0,o.jsx)(n.p,{children:"In this case, the config should be"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'{\n  "a" : {\n   "b" : {\n      "x" : "abc"\n     }\n   }\n  }\n}\n'})}),"\n",(0,o.jsxs)(n.h3,{id:"config-derivation-via-derives-keyword",children:["Config derivation via ",(0,o.jsx)(n.code,{children:"derives"})," keyword"]}),"\n",(0,o.jsxs)(n.p,{children:["Scala 3 has introduced ",(0,o.jsx)(n.code,{children:"derives"})," keyword to derive typeclasses without the need of explicitely declaring the implicit / given.\nThis syntax can be enabled for ",(0,o.jsx)(n.code,{children:"zio.Config"})," by importing ",(0,o.jsx)(n.code,{children:"zio.config.magnolia.*"})," and then using the ",(0,o.jsx)(n.code,{children:"derives"})," keyword on the type that needs to be derived:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",metastring:"3",children:"import zio.config.magnolia.*\nimport zio.{Config, ZIO}\n\nsealed trait A\ncase class B(x: String) extends A\ncase class C(y: String) extends A\n\ncase class MyConfig(a: A) derives Config\n\n// And then simply summon the `Config[MyConfig]` instance as you would normally:\nval cfg = ZIO.config[MyConfig]\n"})}),"\n",(0,o.jsx)(n.h3,{id:"no-guaranteed-behavior-for-scala-3-enum-yet",children:"No guaranteed behavior for scala-3 enum yet"}),"\n",(0,o.jsxs)(n.p,{children:["With the current release, there is no guaranteed support of scala-3 enum.\nUse ",(0,o.jsx)(n.code,{children:"sealed trait"})," and ",(0,o.jsx)(n.code,{children:"case class"})," pattern."]}),"\n",(0,o.jsx)(n.h3,{id:"no-support-for-recursive-config-in-auto-derivation-but-we-can-make-it-work",children:"No support for recursive config in auto-derivation, but we can make it work"}),"\n",(0,o.jsx)(n.p,{children:"There is no support for auto-deriving recursive config with scala-3.\nPlease refer to examples in magnolia package (not in the main examples module)"}),"\n",(0,o.jsx)(n.h3,{id:"custom-keys",children:"Custom Keys"}),"\n",(0,o.jsx)(n.p,{children:"With zio-config-3.x, the only way to change keys is as follows:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"// mapKey is just a function in `Config` that pre-existed\n\nval config = deriveConfig[Config].mapKey(_.toUpperCase)\n"})}),"\n",(0,o.jsx)(n.h2,{id:"inbuilt-support-for-pure-config",children:"Inbuilt support for pure-config"}),"\n",(0,o.jsxs)(n.p,{children:["Many users make use of the label ",(0,o.jsx)(n.code,{children:"type"})," in HOCON files to annotate the type of the coproduct.\nJust put ",(0,o.jsx)(n.code,{children:"@nameWithLabel()"})," in sealed trait name. By default the ",(0,o.jsx)(n.code,{children:"label"})," name is ",(0,o.jsx)(n.code,{children:"type"}),", but you can provide\nany custom name ",(0,o.jsx)(n.code,{children:'@nameWithLabel("foo")'})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import zio.config._, typesafe._, magnolia._\n\n@nameWithLabel("type")\nsealed trait X\ncase class A(name: String) extends X\ncase class B(age: Int) extends X\n\ncase class AppConfig(x: X)\n\nval str =\n  s"""\n   x : {\n     type = A\n     name = jon\n   }\n  """\n\nread(deriveConfig[AppConfig] from ConfigProvider.fromHoconString(str))\n'})})]})}function g(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);