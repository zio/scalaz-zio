"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[48312],{48371:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"zio-json/security","title":"Security","description":"A Denial of Service (DOS) attack is a cyber-attack in which the perpetrator seeks to make a machine or network resource unavailable to its intended users by temporarily or indefinitely disrupting services. The vast majority of public-facing servers written in Scala are vulnerable to DOS attack.","source":"@site/docs/zio-json/security.md","sourceDirName":"zio-json","slug":"/zio-json/security","permalink":"/zio-json/security","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-json/security.md","tags":[],"version":"current","frontMatter":{"id":"security","title":"Security"},"sidebar":"ecosystem-sidebar","previous":{"title":"Performance","permalink":"/zio-json/performance"},"next":{"title":"Interop modules","permalink":"/zio-json/interop/"}}');var i=a(74848),n=a(28453);const o={id:"security",title:"Security"},r=void 0,c={},l=[{value:"Resource Attack: Larger Payload",id:"resource-attack-larger-payload",level:3},{value:"Redundant Data",id:"redundant-data",level:3},{value:"<code>hashCode</code> Collisions",id:"hashcode-collisions",level:3},{value:"Death by a Thousand Zeros",id:"death-by-a-thousand-zeros",level:3}];function d(e){const t={a:"a",code:"code",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,n.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["A ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Denial-of-service_attack",children:"Denial of Service"})," (DOS) attack is a cyber-attack in which the perpetrator seeks to make a machine or network resource unavailable to its intended users by temporarily or indefinitely disrupting services. The vast majority of public-facing servers written in Scala are vulnerable to DOS attack."]}),"\n",(0,i.jsxs)(t.p,{children:["Attacks that are in the form of a valid payload are designed to be stealthy and will produce the same end-result as a legitimate payload, but will consume more resources along the way. In this section we investigate specific attacks and how ",(0,i.jsx)(t.code,{children:"zio-json"})," mitigates against them."]}),"\n",(0,i.jsx)(t.h3,{id:"resource-attack-larger-payload",children:"Resource Attack: Larger Payload"}),"\n",(0,i.jsx)(t.p,{children:"An obvious way to slow down a server is to give it more data to read. JSON is particularly susceptible to this kind of attack because it has an in-built mechanism to expand the size of the message without altering the contents: pad with whitespace."}),"\n",(0,i.jsxs)(t.p,{children:["Many web frameworks will fully consume the contents of a payload into a ",(0,i.jsx)(t.code,{children:"String"})," before handing it off to the JSON library, so if we receive a JSON message consisting of 1GB of whitespace, we will consume 1GB of heap on that server."]}),"\n",(0,i.jsxs)(t.p,{children:["The best way to mitigate against message size attacks is to cap the ",(0,i.jsx)(t.code,{children:"Content-Length"})," to a reasonable size for the use case. A further mitigation is to use a streaming parser that does not require the entire message to be read into memory before parsing begins."]}),"\n",(0,i.jsx)(t.p,{children:"For all the remaining attacks, we will cap the malicious message size to 100KB (the original message is 25KB) and compare the attacks against this baseline. The benchmark results for the original (unedited) payload are given in parentheses, and we can immediately see a reduction in the ops/sec for all frameworks, accompanied by a reduction in memory usage."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"       ops/sec        MB/sec\nzio    10104 (14823)  1047 (1537)\ncirce   7456 ( 8832)  1533 (1816)\nplay    3589 ( 5756)  1344 (2260)\n"})}),"\n",(0,i.jsx)(t.h3,{id:"redundant-data",children:"Redundant Data"}),"\n",(0,i.jsxs)(t.p,{children:["Most JSON libraries (but not ",(0,i.jsx)(t.code,{children:"zio-json"}),") first create a representation of the JSON message in an Abstract Syntax Tree (AST) that represents all the objects, arrays and values in a generic way. Their decoders typically read what they need from the AST."]}),"\n",(0,i.jsxs)(t.p,{children:["An intermediate AST enables attack vectors that insert redundant data, for example in our Google Maps dataset we can add a new field called ",(0,i.jsx)(t.code,{children:"redundant"})," at top-level containing a 60K ",(0,i.jsx)(t.code,{children:"String"}),". If we do this, and run the benchmarks, we see that Circe is heavily impacted, with a 75% reduction in capacity and an increase in memory usage. Play is also impacted, although not as severely. ",(0,i.jsx)(t.code,{children:"zio-json"}),"'s ops/sec are reduced but the memory usage is in line which means that throughput is unlikely to be affected by this kind of attack."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"       ops/sec       MB/sec\nzio    5999 (10104)   622 (1047)\ncirce  2224 ( 7456)  1655 (1533)\nplay   2350 ( 3589)  1854 (1344)\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The reason why ",(0,i.jsx)(t.code,{children:"zio-json"})," is not as badly affected is because it skips values that are unexpected. We can completely mitigate this kind of attack by using the ",(0,i.jsx)(t.code,{children:"@jsonNoExtraFields"})," annotation which results in the payload being rejected at a rate of 5.5 million ops/sec."]}),"\n",(0,i.jsxs)(t.p,{children:["Other kinds of redundant values attacks are also possible, such as using an array of 60K full of high precision decimal numbers that require slow parsing (also known as ",(0,i.jsx)(t.a,{href:"https://www.exploringbinary.com/17-digits-gets-you-there-once-youve-found-your-way/",children:'"near halfway numbers"'}),"), attacking the CPU. However, the memory attack afforded to us by a redundant ",(0,i.jsx)(t.code,{children:"String"})," is already quite effective."]}),"\n",(0,i.jsxs)(t.h3,{id:"hashcode-collisions",children:[(0,i.jsx)(t.code,{children:"hashCode"})," Collisions"]}),"\n",(0,i.jsx)(t.p,{children:"Following on from the redundant data attack, we can place redundant data in the location of object fields."}),"\n",(0,i.jsxs)(t.p,{children:["JSON libraries that use an intermediate AST often store JSON objects as a stringy ",(0,i.jsx)(t.code,{children:"HashMap"})," (circe uses a ",(0,i.jsx)(t.a,{href:"https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/LinkedHashMap.html",children:(0,i.jsx)(t.code,{children:"java.util.LinkedHashMap"})}),"). If we insert redundant fields that have hashcode collisions with legitimate fields, we can successfully attack both memory and CPU. We need to know the hashing algorithm that is being used, which often falls down to some version of the default Java ",(0,i.jsx)(t.code,{children:"String.hashCode"})," ",(0,i.jsx)(t.a,{href:"https://github.com/plokhotnyuk/jsoniter-scala/blob/master/jsoniter-scala-benchmark/shared/src/main/scala/com/github/plokhotnyuk/jsoniter_scala/benchmark/HashCodeCollider.scala",children:"which is very easy to exploit"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"In this malicious payload, we add redundant fields that have hashcode collisions, up to 4 collisions per field; we could add more if we used a bruteforce search."}),"\n",(0,i.jsxs)(t.p,{children:["Again, ",(0,i.jsx)(t.code,{children:"zio-json"})," completely mitigates this attack if the ",(0,i.jsx)(t.code,{children:"@jsonNoExtraFields"})," annotation is used. Note that even if Circe and Play rejected payloads of this nature, it would be too late because the attack happens at the AST layer, not the decoders. However, for the sake of comparison, let's turn off the ",(0,i.jsx)(t.code,{children:"zio-json"})," mitigation:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"       ops/sec       MB/sec\nzio    3742 (10104)   695 (1047)\ncirce  1992 ( 7456)  1162 (1533)\nplay   1312 ( 3589)  1636 (1344)\n"})}),"\n",(0,i.jsxs)(t.p,{children:["ops/sec is down for all decoders relative to the baseline, but since ",(0,i.jsx)(t.code,{children:"zio-json"})," and Circe memory usage is also reduced the throughput on a server might not be impacted as badly as it sounds."]}),"\n",(0,i.jsx)(t.p,{children:"However, this attack hurts Play very badly; memory usage is up compared to the baseline with throughput reduced to 40% of the baseline (22% of the original)."}),"\n",(0,i.jsxs)(t.p,{children:["There is a variant of this attack that can be devastating for libraries that rely on ",(0,i.jsx)(t.code,{children:"HashMap"}),". In this attack, ",(0,i.jsx)(t.a,{href:"https://github.com/plokhotnyuk/jsoniter-scala/pull/325",children:"developed by plokhotnyuk to DOS ujson"}),", an object is filled with many fields that have a ",(0,i.jsx)(t.code,{children:"hashCode"})," of zero. This exploits two facts:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Java ",(0,i.jsx)(t.code,{children:"String"})," does not cache ",(0,i.jsx)(t.code,{children:"hashCode"})," of zero, recomputing every time it is requested"]}),"\n",(0,i.jsxs)(t.li,{children:["many ",(0,i.jsx)(t.code,{children:"HashMap"})," implementations re-request the hashes of all objects as the number of entries increases during construction."]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"death-by-a-thousand-zeros",children:"Death by a Thousand Zeros"}),"\n",(0,i.jsx)(t.p,{children:"Another kind of attack is to provide data that will cause the decoder for a specific value to do more work than it needs to. Numbers are always a great example of this."}),"\n",(0,i.jsxs)(t.p,{children:["The most brutal attack of this nature is to trick a deserialization library into constructing a gigantic number as a ",(0,i.jsx)(t.code,{children:"BigDecimal"})," and then to downcast to a ",(0,i.jsx)(t.code,{children:"BigInteger"}),". The JVM will happily attempt to reserve GBs of heap for the conversion. Try this in your REPL:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:'new java.math.BigDecimal("1e214748364").toBigInteger\n'})}),"\n",(0,i.jsx)(t.p,{children:"Fortunately, this kind of attack is prevented by all the mainstream libraries. But it is possible to perform a much weaker form of the attack on Circe, which (to its credit) goes to great effort to pre-validate numbers."}),"\n",(0,i.jsxs)(t.p,{children:["The Google Maps schema has fields of type ",(0,i.jsx)(t.code,{children:"Int"})," and Circe supports the conversion of floating point numbers to integers if the fractional part is zero: so we can pad an integer with as many zeros as possible."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"       ops/sec       MB/sec\ncirce  4529 ( 7456)  2037 (1533)\n"})}),"\n",(0,i.jsx)(t.p,{children:"This attack is very effective in schemas with lots of numbers, causing ops/sec to be halved with a 33% increase in memory usage."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"zio-json"})," is resistant to a wide range of number based attacks because it uses a from-scratch number parser that will exit early when the number of bits of any number exceeds 128 bits, which can be customized by the system property ",(0,i.jsx)(t.code,{children:"zio.json.number.bits"}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,t,a)=>{a.d(t,{R:()=>o,x:()=>r});var s=a(96540);const i={},n=s.createContext(i);function o(e){const t=s.useContext(n);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(n.Provider,{value:t},e.children)}}}]);