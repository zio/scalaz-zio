"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[92018],{98411:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"overview/overview_background","title":"Background","description":"Procedural Scala programs use procedural functions, which are:","source":"@site/versioned_docs/version-1.0.18/overview/background.md","sourceDirName":"overview","slug":"/overview/overview_background","permalink":"/1.0.18/overview/overview_background","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/versioned_docs/version-1.0.18/overview/background.md","tags":[],"version":"1.0.18","frontMatter":{"id":"overview_background","title":"Background"},"sidebar":"overview_sidebar","previous":{"title":"Running Effects","permalink":"/1.0.18/overview/overview_running_effects"},"next":{"title":"Performance","permalink":"/1.0.18/overview/overview_performance"}}');var s=t(74848),i=t(28453);const a={id:"overview_background",title:"Background"},o=void 0,l={},c=[{value:"Programs As Values",id:"programs-as-values",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Procedural Scala programs use ",(0,s.jsx)(n.em,{children:"procedural functions"}),", which are:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Partial"})," \u2014 Procedures do not return values for some inputs (for example, they throw exceptions)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Non-Deterministic"})," \u2014 Procedures return different outputs for the same input."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Impure"})," \u2014 Procedures perform side-effects, which mutate data or interact with the external world."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Unlike procedural Scala programs, functional Scala programs only use ",(0,s.jsx)(n.em,{children:"pure functions"}),", which are:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Total"})," \u2014 Functions always return an output for every input."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Deterministic"})," \u2014 Functions return the same output for the same input."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Pure"})," \u2014 The only effect of providing a function an input is computing the output."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Pure functions only combine or transform input values into output values in a total, deterministic way. Pure functions are easier to understand, easier to test, easier to refactor, and easier to abstract over."}),"\n",(0,s.jsxs)(n.p,{children:["Functional programs do not interact with the external world directly, because that involves partiality, non-determinism and side-effects. Instead, functional programs construct and return ",(0,s.jsx)(n.em,{children:"data structures"}),", which ",(0,s.jsx)(n.em,{children:"describe"})," (or ",(0,s.jsx)(n.em,{children:"model"}),") interaction with the real world."]}),"\n",(0,s.jsxs)(n.p,{children:["Immutable data structures that model procedural effects are called ",(0,s.jsx)(n.em,{children:"functional effects"}),". The concept of functional effects is critical to deeply understanding how ZIO works, and is introduced in the next section."]}),"\n",(0,s.jsx)(n.h2,{id:"programs-as-values",children:"Programs As Values"}),"\n",(0,s.jsx)(n.p,{children:"We can build a data structure to describe a console program with just three instructions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"sealed trait Console[+A]\nfinal case class Return[A](value: () => A) extends Console[A]\nfinal case class PrintLine[A](line: String, rest: Console[A]) extends Console[A]\nfinal case class ReadLine[A](rest: String => Console[A]) extends Console[A]\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In this model, ",(0,s.jsx)(n.code,{children:"Console[A]"})," is an immutable, type-safe value, which represents a console program that returns a value of type ",(0,s.jsx)(n.code,{children:"A"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Console"})," data structure is an ordered ",(0,s.jsx)(n.em,{children:"tree"}),', and at the very "end" of the program, you will find a ',(0,s.jsx)(n.code,{children:"Return"})," instruction that stores a value of type ",(0,s.jsx)(n.code,{children:"A"}),", which is the return value of the ",(0,s.jsx)(n.code,{children:"Console[A]"})," program."]}),"\n",(0,s.jsx)(n.p,{children:"Although very simple, this data structure is enough to build an interactive program:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'val example1: Console[Unit] = \n  PrintLine("Hello, what is your name?",\n    ReadLine(name =>\n      PrintLine(s"Good to meet you, ${name}", Return(() => ())))\n)\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This immutable value doesn't do anything\u2014it just ",(0,s.jsx)(n.em,{children:"describes"})," a program that prints out a message, asks for input, and prints out another message that depends on the input."]}),"\n",(0,s.jsxs)(n.p,{children:["Although this program is just a model, we can translate the model into procedural effects quite simply using an ",(0,s.jsx)(n.em,{children:"interpreter"}),", which recurses on the data structure, translating every instruction into the side-effect that it describes:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"def interpret[A](program: Console[A]): A = program match {\n  case Return(value) => \n    value()\n  case PrintLine(line, next) => \n    println(line)\n    interpret(next)\n  case ReadLine(next) =>\n    interpret(next(scala.io.StdIn.readLine()))\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Interpreting (also called ",(0,s.jsx)(n.em,{children:"running"})," or ",(0,s.jsx)(n.em,{children:"executing"}),") is not functional, because it may be partial, non-deterministic, and impure. In an ideal application, however, interpretation only needs to happen once: in the application's main function. The rest of the application can be purely functional."]}),"\n",(0,s.jsx)(n.p,{children:"In practice, it's not very convenient to build console programs using constructors directly. Instead, we can define helper functions, which look more like their effectful equivalents:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"def succeed[A](a: => A): Console[A] = Return(() => a)\ndef printLine(line: String): Console[Unit] =\n  PrintLine(line, succeed(()))\nval readLine: Console[String] =\n  ReadLine(line => succeed(line))\n"})}),"\n",(0,s.jsxs)(n.p,{children:['Composing these "leaf" instructions into larger programs becomes a lot easier if we define ',(0,s.jsx)(n.code,{children:"map"})," and ",(0,s.jsx)(n.code,{children:"flatMap"})," methods on ",(0,s.jsx)(n.code,{children:"Console"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"map"})," method lets you transform a console program that returns an ",(0,s.jsx)(n.code,{children:"A"})," into a console program that returns a ",(0,s.jsx)(n.code,{children:"B"}),", by supplying a function ",(0,s.jsx)(n.code,{children:"A => B"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"flatMap"})," method lets you sequentially compose a console program that returns an ",(0,s.jsx)(n.code,{children:"A"})," with a callback that returns another console program created from the ",(0,s.jsx)(n.code,{children:"A"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"These two methods are defined as follows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"implicit class ConsoleSyntax[+A](self: Console[A]) {\n  def map[B](f: A => B): Console[B] =\n    flatMap(a => succeed(f(a)))\n\n  def flatMap[B](f: A => Console[B]): Console[B] =\n    self match {\n      case Return(value) => f(value())\n      case PrintLine(line, next) =>\n        PrintLine(line, next.flatMap(f))\n      case ReadLine(next) =>\n        ReadLine(line => next(line).flatMap(f))\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["With these ",(0,s.jsx)(n.code,{children:"map"})," and ",(0,s.jsx)(n.code,{children:"flatMap"})," methods, we can now take advantage of Scala's ",(0,s.jsx)(n.code,{children:"for"})," comprehensions, and write programs that look like their procedural equivalents:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'val example2: Console[String] =\n  for {\n    _    <- printLine("What\'s your name?")\n    name <- readLine\n    _    <- printLine(s"Hello, ${name}, good to meet you!")\n  } yield name\n'})}),"\n",(0,s.jsxs)(n.p,{children:["When we wish to execute this program, we can call ",(0,s.jsx)(n.code,{children:"interpret"})," on the ",(0,s.jsx)(n.code,{children:"Console"})," value."]}),"\n",(0,s.jsxs)(n.p,{children:["All functional Scala programs are constructed like this: instead of interacting with the real world, they build a ",(0,s.jsx)(n.em,{children:"functional effect"}),", which is nothing more than an immutable, type-safe, tree-like data structure that models procedural effects."]}),"\n",(0,s.jsx)(n.p,{children:"Functional programmers use functional effects to build complex, real world software without giving up the equational reasoning, composability, and type safety afforded by purely functional programming."}),"\n",(0,s.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsxs)(n.p,{children:["If functional effects are starting to make more sense, then the next step is to learn more about the ",(0,s.jsx)(n.a,{href:"/1.0.18/overview/",children:"core effect type"})," in ZIO."]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var r=t(96540);const s={},i=r.createContext(s);function a(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);