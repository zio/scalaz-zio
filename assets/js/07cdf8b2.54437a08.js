"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[8491],{32544:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"zio-cli/args","title":"Args","description":"The Args data type models command-line arguments. Arguments are name-less, position-based parameters passed to a command-line program that modify its behavior. For example, the Git CLI has a command named git clone that creates a copy of an existing repository. It has an argument called \\"repository\\" that represents the existing repository\'s path. To clone the ZIO CLI repository, it can be called this way:","source":"@site/docs/zio-cli/args.md","sourceDirName":"zio-cli","slug":"/zio-cli/args","permalink":"/zio-cli/args","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-cli/args.md","tags":[],"version":"current","frontMatter":{"id":"args","title":"Args"},"sidebar":"ecosystem-sidebar","previous":{"title":"ZIO CLI","permalink":"/zio-cli/"},"next":{"title":"Options","permalink":"/zio-cli/options"}}');var r=n(74848),t=n(28453);const i={id:"args",title:"Args"},c=void 0,o={},l=[{value:"Construction of basic Args",id:"construction-of-basic-args",level:2},{value:"Boolean Args",id:"boolean-args",level:3},{value:"Path Args",id:"path-args",level:3},{value:"Text Args",id:"text-args",level:3},{value:"Numeric Args",id:"numeric-args",level:3},{value:"Date/Time Args",id:"datetime-args",level:3},{value:"Combining and transforming Args",id:"combining-and-transforming-args",level:2},{value:"Adding Args",id:"adding-args",level:3},{value:"Repeating Args",id:"repeating-args",level:3},{value:"Transforming Args",id:"transforming-args",level:3},{value:"Adding help",id:"adding-help",level:3}];function d(e){const s={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.code,{children:"Args"})," data type models command-line arguments. Arguments are name-less, position-based parameters passed to a command-line program that modify its behavior. For example, the Git CLI has a command named ",(0,r.jsx)(s.code,{children:"git clone"}),' that creates a copy of an existing repository. It has an argument called "repository" that represents the existing repository\'s path. To clone the ',(0,r.jsx)(s.strong,{children:"ZIO CLI"})," repository, it can be called this way:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{children:"git clone https://github.com/zio/zio-cli.git\n"})}),"\n",(0,r.jsxs)(s.p,{children:["where ",(0,r.jsx)(s.code,{children:"https://github.com/zio/zio-cli.git"})," is the path of the repository."]}),"\n",(0,r.jsxs)(s.p,{children:["In ",(0,r.jsx)(s.strong,{children:"ZIO CLI"}),", Arguments are represented by instances of class ",(0,r.jsx)(s.code,{children:"Args[_]"}),". ",(0,r.jsx)(s.code,{children:"Args[A]"})," is a description of the process of constructing an instance of ",(0,r.jsx)(s.code,{children:"A"})," from a valid input of the CLI. It is not yet a specified argument for the CLI. In other words, an ",(0,r.jsx)(s.code,{children:"Args[A]"})," defines a collection of valid arguments for a command and a way to construct a value ",(0,r.jsx)(s.code,{children:"A"})," from them."]}),"\n",(0,r.jsx)(s.h2,{id:"construction-of-basic-args",children:"Construction of basic Args"}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"ZIO CLI"})," offers a variety of methods to create basic ",(0,r.jsx)(s.code,{children:"Args"})," that takes a string from the user as input and transform it into a value of the corresponding type. The benefit of using these methods is that it is automatically checked if they describe a value of the given type and, in that case, are transformed into it. In case of an invalid input, a ",(0,r.jsx)(s.code,{children:"ValidationError"})," will be thrown. Note that each type has its own validation function."]}),"\n",(0,r.jsxs)(s.p,{children:["An ",(0,r.jsx)(s.code,{children:"Args"})," instance of a basic type carries a name attribute. This can be specified when being created, but it can also be skipped. In this last case, the name will be that of the type. An example with Boolean type:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:'import zio.cli._\n\nval name = "name"\n\nArgs.bool(name) // Boolean Args with name\nArgs.bool       // Boolean Args named "boolean"\n'})}),"\n",(0,r.jsx)(s.h3,{id:"boolean-args",children:"Boolean Args"}),"\n",(0,r.jsxs)(s.p,{children:["Produces an ",(0,r.jsx)(s.code,{children:"Args[Boolean]"}),". It accepts as input ",(0,r.jsx)(s.code,{children:"true"})," or ",(0,r.jsx)(s.code,{children:"false"}),", while other pieces of text are not valid."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:"Args.bool(name)\n"})}),"\n",(0,r.jsx)(s.h3,{id:"path-args",children:"Path Args"}),"\n",(0,r.jsxs)(s.p,{children:["They are used to produce an ",(0,r.jsx)(s.code,{children:"Args[Path]"}),"."]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Produces ",(0,r.jsx)(s.code,{children:"Args[java.nio.file.Path]"}),"."]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:"Args.file(name) // Used for a file\n"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Produces ",(0,r.jsx)(s.code,{children:"Args[java.nio.file.Path]"}),"."]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:"Args.directory(name) // Used for a directory\n"})}),"\n",(0,r.jsxs)(s.p,{children:["By default, the ",(0,r.jsx)(s.code,{children:"CliApp"})," accepts paths pointing to files or directories that might or not exist. If you need to work with one of them exclusively you can use the trait ",(0,r.jsx)(s.code,{children:"Exists"}),":"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:"// Path can point to both existing or non-existing files or directories\nArgs.file(name, exists = Exists.Either)\nArgs.directory(name, exists = Exists.Either)\n\n// Path must point to existing files or directories\nArgs.file(name, exists = Exists.Yes)\nArgs.directory(name, exists = Exists.Yes)\n\n// Path must point to non-existing files or directories\nArgs.file(name, exists = Exists.Yes)\nArgs.directory(name, exists = Exists.Yes)\n"})}),"\n",(0,r.jsx)(s.h3,{id:"text-args",children:"Text Args"}),"\n",(0,r.jsxs)(s.p,{children:["Produces an ",(0,r.jsx)(s.code,{children:"Args[String]"}),"."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:"Args.text(name)\n"})}),"\n",(0,r.jsx)(s.h3,{id:"numeric-args",children:"Numeric Args"}),"\n",(0,r.jsxs)(s.p,{children:["Numeric ",(0,r.jsx)(s.code,{children:"Args"})," produce ",(0,r.jsx)(s.code,{children:"BigInt"})," and ",(0,r.jsx)(s.code,{children:"BigDecimal"}),", so they can represent numbers of arbitrary size and precision. Note that the CLI checks that the input really represents a number."]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Produces ",(0,r.jsx)(s.code,{children:"Args[BigDecimal]"}),"."]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:"Args.decimal(name)\n"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Produces ",(0,r.jsx)(s.code,{children:"Args[BigInt]"}),"."]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:"Args.integer(name)\n"})}),"\n",(0,r.jsx)(s.h3,{id:"datetime-args",children:"Date/Time Args"}),"\n",(0,r.jsxs)(s.p,{children:["The following methods produce ",(0,r.jsx)(s.code,{children:"Args"})," whose type parameter is a Date/Time type of the ",(0,r.jsx)(s.code,{children:"java.time"})," library."]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Produces ",(0,r.jsx)(s.code,{children:"Args[java.time.Duration]"}),". The input must be a time-based amount of time in the ISO-8601 format, such as 'P1DT2H3M'."]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:"Args.duration(name)\n"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Produces ",(0,r.jsx)(s.code,{children:"Args[java.time.Instant]"}),". The input must be an instant in time in UTC format, such as 2007-12-03T10:15:30.00Z."]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:"Args.instant(name)\n"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Produces ",(0,r.jsx)(s.code,{children:"Args[java.time.LocalDate]"}),". The input must be a date in ISO_LOCAL_DATE format, such as 2007-12-03."]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:"Args.localDate(name)\n"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Produces ",(0,r.jsx)(s.code,{children:"Args[java.time.LocalDateTime]"}),". The input must be a date-time without a time-zone in the ISO-8601 format, such as 2007-12-03T10:15:30."]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:"Args.localDateTime(name)\n"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Produces ",(0,r.jsx)(s.code,{children:"Args[java.time.LocalTime]"}),". The input must be a time without a time-zone in the ISO-8601 format, such as 10:15:30."]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:"Args.localTime(name)\n"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Produces ",(0,r.jsx)(s.code,{children:"Args[java.time.MonthDay]"}),". The input must be a month-day in the ISO-8601 format such as 12-03."]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:"Args.monthDay(name)\n"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Produces ",(0,r.jsx)(s.code,{children:"Args[java.time.OffsetDateTime]"}),". The input must be a date-time with an offset from UTC/Greenwich in the ISO-8601 format, such as 2007-12-03T10:15:30+01:00."]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:"Args.offsetDateTime(name)\n"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Produces ",(0,r.jsx)(s.code,{children:"Args[java.time.OffsetTime]"}),". The input must be a time with an offset from UTC/Greenwich in the ISO-8601 format, such as 10:15:30+01:00."]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:"Args.offsetTime(name)\n"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Produces ",(0,r.jsx)(s.code,{children:"Args[java.time.Period]"}),". The input must be a date-based amount of time in the ISO-8601 format, such as 'P1Y2M3D'."]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:"Args.period(name)\n"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Produces ",(0,r.jsx)(s.code,{children:"Args[java.time.Year]"}),". The input must be a year in the ISO-8601 format, such as 2007."]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:"Args.year(name)\n"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Produces ",(0,r.jsx)(s.code,{children:"Args[java.time.YearMonth]"}),". The input must be a year-month in the ISO-8601 format, such as 2007-12."]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:"Args.yearMonth(name)\n"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Produces ",(0,r.jsx)(s.code,{children:"Args[java.time.ZonedDateTime]"}),". The input must be a date-time with a time-zone in the ISO-8601 format, such as 2007-12-03T10:15:30+01:00 Europe/Paris."]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:"Args.zonedDateTime(name)\n"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Produces ",(0,r.jsx)(s.code,{children:"Args[java.time.ZoneId]"}),". The input must be a time-zone ID, such as Europe/Paris."]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:"Args.zoneId(name)\n"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Produces ",(0,r.jsx)(s.code,{children:"Args[java.time.ZoneOffset]"}),". The input must be a time-zone offset from Greenwich/UTC, such as +02:00."]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:"Args.zoneOffset(name)\n"})}),"\n",(0,r.jsx)(s.h2,{id:"combining-and-transforming-args",children:"Combining and transforming Args"}),"\n",(0,r.jsxs)(s.p,{children:["When constructing a command, you can specify only one argument. Thus, to create more complex ",(0,r.jsx)(s.code,{children:"Args"})," it is necessary to use the following methods of the trait ",(0,r.jsx)(s.code,{children:"Args"}),":"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:"trait Args[A] {\n  def ++[B](that: Args[B]): Args[(A, B)]              // Zip two args\n  def +[A1 >: A]: Args[::[A1]]                        // Requires a non-empty list of Args of type A1\n  def * : Args[List[A]]                               // Requires a list of Args of same type\n  def atLeast(min: Int): Args[List[A]]                // Requires a list of Args with at least min elements\n  def atMost(max: Int): Args[List[A]]                 // Requires a list of Args with at most max elements\n  def between(min: Int, max: Int): Args[List[A]]      // Requires a list of Args with a bound on the number of elements\n  def map[B](f: A => B): Args[B]                      // Applies a function f to the result of the Args\n  def ??(that: String): Args[A]                       // Adds a string to the HelpDoc of the Args\n}\n"})}),"\n",(0,r.jsx)(s.h3,{id:"adding-args",children:"Adding Args"}),"\n",(0,r.jsxs)(s.p,{children:["Operator ",(0,r.jsx)(s.code,{children:"++"})," can be used to zip two arguments. It can be use to chain two arguments in a tuple. For example, ",(0,r.jsx)(s.code,{children:"git clone"})," command has arguments ",(0,r.jsx)(s.code,{children:"<repository>"})," and ",(0,r.jsx)(s.code,{children:"<directory>"}),". The argument of this command can be created in the following manner:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:'val cloneArgs = Args.text("repository") ++ Args.text("directory")\n'})}),"\n",(0,r.jsx)(s.p,{children:"The output of the CLI help will be:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{children:"COMMANDS\n\n  clone <repository> <directory>\n"})}),"\n",(0,r.jsx)(s.h3,{id:"repeating-args",children:"Repeating Args"}),"\n",(0,r.jsx)(s.p,{children:"If we need an argument a repeated number of times, we can use the following operators:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Method ",(0,r.jsx)(s.code,{children:"*"})]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["It creates a new ",(0,r.jsx)(s.code,{children:"Args"})," that accepts a list of arguments of the same type. There are no restrictions on length. Take into account that there is no limit, so if there are arguments or options after using this methods, the CLI app will not read them unless they are not valid!"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:"// Accepts a list, possibly empty, of texts.\nArgs.text.*\n"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Method ",(0,r.jsx)(s.code,{children:"+"})]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["It works as method ",(0,r.jsx)(s.code,{children:"*"})," but the list of arguments cannot be empty. Do not mistake with method ",(0,r.jsx)(s.code,{children:"++"}),"!"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Method ",(0,r.jsx)(s.code,{children:"between"})]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["It creates an argument accepting a list of arguments of the type before whose length must be between ",(0,r.jsx)(s.code,{children:"min"})," and ",(0,r.jsx)(s.code,{children:"max"})," parameters."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:"Args.text.between(2,5) // Creates an arguments accepting a list of String of length between 2 and 5.\n"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Method ",(0,r.jsx)(s.code,{children:"atLeast"})]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["It creates an argument accepting a list of arguments of the type before whose length must be more than ",(0,r.jsx)(s.code,{children:"min"})," parameter."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:"Args.text.atLeast(2) // Creates an arguments accepting a list of String of length more than 2.\n"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Method ",(0,r.jsx)(s.code,{children:"atMost"})]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["It creates an argument accepting a list of arguments of the type before whose length must be less than ",(0,r.jsx)(s.code,{children:"max"}),"parameter"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:"Args.text.atMost(5) // Creates an arguments accepting a list of String of length less than 5.\n"})}),"\n",(0,r.jsx)(s.h3,{id:"transforming-args",children:"Transforming Args"}),"\n",(0,r.jsxs)(s.p,{children:["Method ",(0,r.jsx)(s.code,{children:"map"})," allows to transform the type parameter of ",(0,r.jsx)(s.code,{children:"Args[A]"}),". It takes a function ",(0,r.jsx)(s.code,{children:"f: A => B"})," as parameter that is applied when processing a user's input in a CLI app and returns ",(0,r.jsx)(s.code,{children:"Args[B]"}),". This makes it easier to implement the business logic of a CLI app. For example, we will construct an ",(0,r.jsx)(s.code,{children:"Args"})," that asks for a list of 12 decimals (one for each month) and a year. Then, it will create a new ",(0,r.jsx)(s.code,{children:"Args"})," that store the year and the mean value in a custom type."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:"import zio.cli._\n\nval data: Args[BigDecimal] = Args.decimal\nval args: Args[(List[BigDecimal], BigInt)] = data.between(12, 12) ++ Args.integer\n\ncase class YearAndMean(year: BigInt, mean: BigDecimal)\n\nval mappedArgs: Args[YearAndMean] = args.map {\n  case (months, year) => YearAndMean(year, months.sum/12)\n}\n"})}),"\n",(0,r.jsx)(s.h3,{id:"adding-help",children:"Adding help"}),"\n",(0,r.jsxs)(s.p,{children:["Method ",(0,r.jsx)(s.code,{children:"??"})," allows adding information about an argument. The string is added after the current ",(0,r.jsx)(s.code,{children:"HelpDoc"})," of the ",(0,r.jsx)(s.code,{children:"Args"}),". We are going to create the ",(0,r.jsx)(s.code,{children:"<repository>"})," argument of ",(0,r.jsx)(s.code,{children:"git clone"})," to observe the effect of using ",(0,r.jsx)(s.code,{children:"??"}),"."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:'val repository = Args.text("repository")\n  \n/* HelpDoc of repository:\n *\n * <repository>\n *   A user-defined piece of text.\n * \n */\n\n'})}),"\n",(0,r.jsx)(s.p,{children:"Now we add a description of the argument:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:'val repositoryWithHelp = repository ?? "Path of the repository to be cloned."\n\n/* HelpDoc of repositoryWithHelp:\n *\n * <repository>\n *   A user-defined piece of text.\n * \n *   Path of the repository to be cloned.\n */\n'})})]})}function h(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,s,n)=>{n.d(s,{R:()=>i,x:()=>c});var a=n(96540);const r={},t=a.createContext(r);function i(e){const s=a.useContext(t);return a.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),a.createElement(t.Provider,{value:s},e.children)}}}]);