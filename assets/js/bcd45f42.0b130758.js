"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[39693],{28453:(e,t,n)=>{n.d(t,{R:()=>c,x:()=>s});var a=n(96540);const o={},i=a.createContext(o);function c(e){const t=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:c(e.components),a.createElement(i.Provider,{value:t},e.children)}},68748:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>s,default:()=>h,frontMatter:()=>c,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"zio-prelude/functional-abstractions/parameterized-types/nonemptyforeach","title":"NonEmptyForEach","description":"NomEmptyForEach[F] describes a parameterized type F[A] that contains one or more values of type A.","source":"@site/docs/zio-prelude/functional-abstractions/parameterized-types/nonemptyforeach.md","sourceDirName":"zio-prelude/functional-abstractions/parameterized-types","slug":"/zio-prelude/functional-abstractions/parameterized-types/nonemptyforeach","permalink":"/zio-prelude/functional-abstractions/parameterized-types/nonemptyforeach","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-prelude/functional-abstractions/parameterized-types/nonemptyforeach.md","tags":[],"version":"current","frontMatter":{"id":"nonemptyforeach","title":"NonEmptyForEach"},"sidebar":"ecosystem-sidebar","previous":{"title":"Invariant","permalink":"/zio-prelude/functional-abstractions/parameterized-types/invariant"},"next":{"title":"Functional Data Types","permalink":"/zio-prelude/functional-data-types/"}}');var o=n(74848),i=n(28453);const c={id:"nonemptyforeach",title:"NonEmptyForEach"},s=void 0,r={},d=[];function l(e){const t={code:"code",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"NomEmptyForEach[F]"})," describes a parameterized type ",(0,o.jsx)(t.code,{children:"F[A]"})," that contains one or more values of type ",(0,o.jsx)(t.code,{children:"A"}),"."]}),"\n",(0,o.jsx)(t.p,{children:"Its signature is:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:"trait ForEach[F[+_]] {\n  def forEach[G[+_]: IdentityBoth: Covariant, A, B](fa: F[A])(f: A => G[B]): G[F[B]]\n}\n\ntrait NonEmptyForEach[F[+_]] extends ForEach[F] {\n  def forEach1[G[+_]: AssociativeBoth : Covariant, A, B](fa: F[A])(f: A => G[B]): G[F[B]]\n  final def forEach[G[+_]: IdentityBoth: Covariant, A, B](fa: F[A])(f: A => G[B]): G[F[B]] =\n    forEach1(fa)(f)\n}\n\ntrait Covariant[F[+_]] {\n  def map[A, B](f: A => B): F[A] => F[B]\n}\n\ntrait AssociativeBoth[F[_]] {\n  def both[A, B](fa: => F[A], b: => F[B]): F[(A, B)]\n}\n\ntrait IdentityBoth[F[_]] extends AssociativeBoth[F] {\n  def any: F[Any]\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"NonEmptyForEach"})," functional abstraction builds on the ",(0,o.jsx)(t.code,{children:"ForEach"})," abstraction to describe a type that contains one or more ",(0,o.jsx)(t.code,{children:"A"})," values rather than zero or more ",(0,o.jsx)(t.code,{children:"A"})," values."]}),"\n",(0,o.jsxs)(t.p,{children:["For example ",(0,o.jsx)(t.code,{children:"NonEmptyChunk"})," has a ",(0,o.jsx)(t.code,{children:"NonEmptyForEach"})," instance defined for it because it always contains at least one value. In contrast ",(0,o.jsx)(t.code,{children:"Chunk"})," only has a ",(0,o.jsx)(t.code,{children:"ForEach"})," instance defined for it because it could be empty."]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"NonEmptyForEach"})," generalizes over collection types and types that always contain at least one value, such as ",(0,o.jsx)(t.code,{children:"NonEmptyChunk"}),", ",(0,o.jsx)(t.code,{children:"NonEmptyList"}),", and certain tree data structures."]}),"\n",(0,o.jsxs)(t.p,{children:["The defining operator of the ",(0,o.jsx)(t.code,{children:"NonEmptyForEach"})," abstraction is ",(0,o.jsx)(t.code,{children:"forEach1"}),", which has the same signature as the ",(0,o.jsx)(t.code,{children:"forEach"})," operator defined by the ",(0,o.jsx)(t.code,{children:"ForEach"})," abstraction except that it doesn't require an identity element with respect to the combining operator for ",(0,o.jsx)(t.code,{children:"G"})," values."]}),"\n",(0,o.jsxs)(t.p,{children:["Recall that if instances of ",(0,o.jsx)(t.code,{children:"Covariant"})," and ",(0,o.jsx)(t.code,{children:"AssociativeBoth"})," exist for a data type we can define the ",(0,o.jsx)(t.code,{children:"map"})," and ",(0,o.jsx)(t.code,{children:"zipWith"})," operators and if an instance of ",(0,o.jsx)(t.code,{children:"IdentityBoth"})," exists as well we can define the ",(0,o.jsx)(t.code,{children:"succeed"})," operator."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:"def map[F[+_], A, B](fa: F[A])(f: A => B)(implicit covariant: Covariant[F]): F[B] =\n  covariant.map(f)(fa)\n\ndef succeed[F[+_], A](a: => A)(implicit covariant: Covariant[F], both: IdentityBoth[F]): F[A] =\n  covariant.map[Any, A](_ => a)(both.any)\n\ndef zipWith[F[+_], A, B, C](\n  fa: F[A],\n  fb: F[B]\n)(f: (A, B) => C)(implicit covariant: Covariant[F], both: AssociativeBoth[F]): F[C] =\n  covariant.map(f.tupled)(both.both(fa, fb))\n"})}),"\n",(0,o.jsxs)(t.p,{children:["To see why we don't need an identity element for the combining operator when the collection contains at least one value let's compare the implementation of the ",(0,o.jsx)(t.code,{children:"ForEach"})," instance for ",(0,o.jsx)(t.code,{children:"List"})," with the implementation of the ",(0,o.jsx)(t.code,{children:"NonEmptyForEach"})," instance for the ",(0,o.jsx)(t.code,{children:"NonEmptyList"})," data type from ZIO Prelude."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:"import zio.prelude.NonEmptyList\n\nimplicit val ListForEach: ForEach[List] =\n  new ForEach[List] {\n    def forEach[G[+_]: IdentityBoth: Covariant, A, B](fa: List[A])(f: A => G[B]): G[List[B]] =\n      fa.foldRight(succeed[G, List[B]](List.empty)) { (a, gbs) =>\n        zipWith(f(a), gbs)(_ :: _)\n      }\n  }\n// ListForEach: ForEach[List] = repl.MdocSession$MdocApp$$anon$1@6b648e23\n\nimplicit val NonEmptyListNonEmptyForEach: ForEach[NonEmptyList] =\n  new NonEmptyForEach[NonEmptyList] {\n    def forEach1[G[+_]: AssociativeBoth: Covariant, A, B](fa: NonEmptyList[A])(f: A => G[B]): G[NonEmptyList[B]] =\n      fa.reduceMapRight(a => map(f(a))(NonEmptyList.single))((a, gbs) => zipWith(f(a), gbs)(NonEmptyList.cons))\n  }\n// NonEmptyListNonEmptyForEach: ForEach[NonEmptyList] = repl.MdocSession$MdocApp$$anon$2@4491ea4b\n"})}),"\n",(0,o.jsxs)(t.p,{children:["In our implementation of ",(0,o.jsx)(t.code,{children:"ForEach"})," for ",(0,o.jsx)(t.code,{children:"List"})," we needed to use the ",(0,o.jsx)(t.code,{children:"succeed"})," operator to handle the case where the collection was empty, because in that case we had to be able to lift an empty collection into the context of ",(0,o.jsx)(t.code,{children:"G"}),". The ",(0,o.jsx)(t.code,{children:"succeed"})," operator requires an ",(0,o.jsx)(t.code,{children:"IdentityBoth"})," instance because we have to be able to construct a neutral value of type ",(0,o.jsx)(t.code,{children:"G"})," that we can then fill with the value we are lifting using the ",(0,o.jsx)(t.code,{children:"map"})," operator."]}),"\n",(0,o.jsxs)(t.p,{children:["In contrast, in our implementation of ",(0,o.jsx)(t.code,{children:"NonEmptyForEach"})," we never need to call ",(0,o.jsx)(t.code,{children:"succeed"})," because there is always at least one one element in the collection. So we can just apply the function ",(0,o.jsx)(t.code,{children:"f"})," to each element in the collection and then use the ",(0,o.jsx)(t.code,{children:"zipWith"})," operator to combine the results."]}),"\n",(0,o.jsx)(t.p,{children:"The fact that the collection can never be empty allows us to relax constraints on other operators as well."}),"\n",(0,o.jsxs)(t.p,{children:["For example, we can define an operator called ",(0,o.jsx)(t.code,{children:"reduceMapLeft"})," that is a more powerful version of ",(0,o.jsx)(t.code,{children:"foldLeft"})," that does not require an initial value."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:"import zio.prelude._\n\ndef reduceMapLeft[F[+_]: ForEach, A, S](as: F[A])(map: A => S)(reduce: (S, S) => S): S =\n  as.foldLeft[Option[S]](None) {\n    case (Some(s), a) => Some(reduce(s, map(a)))\n    case (None, a) => Some(map(a))\n  }.get\n"})}),"\n",(0,o.jsxs)(t.p,{children:["We know it is safe to call ",(0,o.jsx)(t.code,{children:"get"})," here because the collection is guaranteed to have at least one element."]}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"reduceMapLeft"})," operator allows us to define additional operators for reducing a collection to a summary value that would not be safe to call on a collection that might be empty."]}),"\n",(0,o.jsxs)(t.p,{children:["In particular, we can define a more powerful version of the ",(0,o.jsx)(t.code,{children:"foldMap"})," operator defined on the ",(0,o.jsx)(t.code,{children:"ForEach"})," abstraction called ",(0,o.jsx)(t.code,{children:"reduceMap"}),"."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:"def reduceMap[F[+_]: ForEach, A, B: Associative](as: F[A])(f: A => B): B =\n  reduceMapLeft(as)(f)(_ <> _)\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Since we know the collection contains at least one element we do not need an ",(0,o.jsx)(t.code,{children:"identity"})," value with respect to the associative ",(0,o.jsx)(t.code,{children:"combine"})," operator, just like we did not need an ",(0,o.jsx)(t.code,{children:"any"})," value with respect to the ",(0,o.jsx)(t.code,{children:"both"})," operator in ",(0,o.jsx)(t.code,{children:"forEach1"}),"."]}),"\n",(0,o.jsx)(t.p,{children:"With this we can easily do something like calculate the sum, product, min, and max of a collection in a single pass."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:"import zio.prelude.newtypes._\n\ndef stats[F[+_]: ForEach, A](as: F[A])(\n  implicit sum: Associative[Sum[A]],\n  prod: Associative[Prod[A]],\n  min: Associative[Min[A]],\n  max: Associative[Max[A]]\n): (A, A, A, A) =\n  reduceMap(as)(a => (Sum[A](a), Prod[A](a), Min[A](a), Max[A](a)))\n"})}),"\n",(0,o.jsxs)(t.p,{children:["This is a very nice way to describe reducing a collection to a summary value and gives us additional flexibility to use ways of combining that are associative but do not have an identity element relative to the ",(0,o.jsx)(t.code,{children:"foldMap"})," operator."]}),"\n",(0,o.jsxs)(t.p,{children:["As we can see, the ",(0,o.jsx)(t.code,{children:"NonEmptyForEach"})," functional abstraction builds on the ",(0,o.jsx)(t.code,{children:"ForEach"})," functional abstraction to describe parameterized types that contain one or more values of the type they are parameterized on. This lets us define a wide variety of operators, even more than the ones we could define for the ",(0,o.jsx)(t.code,{children:"ForEach"})," abstraction."]}),"\n",(0,o.jsxs)(t.p,{children:["So if you are defining your own data type like a collection and it will never be empty you should definitely define a ",(0,o.jsx)(t.code,{children:"NonEmptyForEach"})," instance for it so you can take advantage of all the nice operators that are defined in terms of it."]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}}}]);