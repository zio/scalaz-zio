"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[90247],{43704:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>u,frontMatter:()=>s,metadata:()=>t,toc:()=>r});const t=JSON.parse('{"id":"guides/tutorials/debug-a-zio-application","title":"Tutorial: How to Debug a ZIO Application?","description":"Introduction","source":"@site/docs/guides/tutorials/debug-a-zio-application.md","sourceDirName":"guides/tutorials","slug":"/guides/tutorials/debug-a-zio-application","permalink":"/guides/tutorials/debug-a-zio-application","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/guides/tutorials/debug-a-zio-application.md","tags":[],"version":"current","frontMatter":{"id":"debug-a-zio-application","title":"Tutorial: How to Debug a ZIO Application?","sidebar_label":"Debugging a ZIO Application"},"sidebar":"guides-sidebar","previous":{"title":"Monitoring a ZIO Application Using ZIO\'s Built-in Metric System","permalink":"/guides/tutorials/monitor-a-zio-application-using-zio-built-in-metric-system"},"next":{"title":"Building a RESTful Web Service","permalink":"/guides/tutorials/build-a-restful-webservice"}}');var a=i(74848),o=i(28453);const s={id:"debug-a-zio-application",title:"Tutorial: How to Debug a ZIO Application?",sidebar_label:"Debugging a ZIO Application"},c=void 0,l={},r=[{value:"Introduction",id:"introduction",level:2},{value:"Debugging an Ordinary Scala Application",id:"debugging-an-ordinary-scala-application",level:2},{value:"Debugging a ZIO Application Using <code>debug</code> Effect",id:"debugging-a-zio-application-using-debug-effect",level:2},{value:"Debugging Using a Debugger",id:"debugging-using-a-debugger",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsx)(n.p,{children:"Writing applications using functional programming helps us to write a base code that is less error-prone and more predictable. However, we often make mistakes when developing applications. Even though we have written lots of tests, we might have missed some areas of our code that could have caused errors. Finally, in the middle of one night, the alarm starts calling and paging us to take the right action for the error in production. This is where debugging comes in. It is a process of finding the root cause of the error and then fixing it. Sometimes this process takes a large amount of time and effort."}),"\n",(0,a.jsx)(n.p,{children:"In this article, we are going to learn how to debug a ZIO application. We will start with the simplest example of a ZIO application and then move to the more complex ones."}),"\n",(0,a.jsx)(n.h2,{id:"debugging-an-ordinary-scala-application",children:"Debugging an Ordinary Scala Application"}),"\n",(0,a.jsxs)(n.p,{children:["Before talking about debugging functional effects, we need to understand how to debug an ordinary Scala application. In scala, one simple way to debug a code is to use ",(0,a.jsx)(n.code,{children:"print"})," statements to print the intermediate values of the computation to the console."]}),"\n",(0,a.jsx)(n.p,{children:"Assume we have the following fibonacci function:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"def fib(n: Int): Int = {\n  @annotation.tailrec\n  def go(n: Int, a: Int, b: Int): Int =\n    if (n == 0) a\n    else go(n - 1, b, a + b) \n  go(n, 0, 1)\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"The implementation of this function is correct, but for pedagogical purposes, let's debug it by printing the intermediate values of the computation:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'def fib(n: Int): Int = {\n  @annotation.tailrec\n  def go(n: Int, a: Int, b: Int): Int =\n    if (n == 0) {\n      println(s"final result: $a")\n      a\n    } else {\n      println(s"go(${n - 1}, $b, ${a + b})")\n      go(n - 1, b, a + b)\n    }\n  println(s"go($n, 0, 1)")\n  go(n, 0, 1)\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Now if we call ",(0,a.jsx)(n.code,{children:"fib(3)"}),", we will see the following output:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"go(3, 0, 1)\ngo(2, 1, 1)\ngo(1, 1, 2)\ngo(0, 2, 3)\nfinal result: 2\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"print"})," statements are the easiest way for lazy programmers to debug their code. However, they are not the most efficient way to debug code."]}),"\n",(0,a.jsxs)(n.h2,{id:"debugging-a-zio-application-using-debug-effect",children:["Debugging a ZIO Application Using ",(0,a.jsx)(n.code,{children:"debug"})," Effect"]}),"\n",(0,a.jsxs)(n.p,{children:["When we use functional effects like ",(0,a.jsx)(n.code,{children:"ZIO"}),", we are creating the description of the computation that we want to run. For example, assume we have the following code:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nval effect: ZIO[Any, Nothing, Unit] = ZIO.succeed(3).map(_ * 2)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"effect"})," itself is a description of the computation that we want to run. So we can't use print statements to debug effects directly. For example, if we write ",(0,a.jsx)(n.code,{children:"println(effect)"}),", we will get something like this:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"OnSuccess(<empty>.MainApp.effect(MainApp.scala:4),Sync(<empty>.MainApp.effect(MainApp.scala:4),MainApp$$$Lambda$23/0x00000008000bc440@44a3ec6b),zio.ZIO$$Lambda$25/0x00000008000ba040@71623278)\n"})}),"\n",(0,a.jsx)(n.p,{children:"This is not the expected output. We want to see the result of the computation, not the description of the computation. Why did this happen? Because we haven't run the computation yet."}),"\n",(0,a.jsx)(n.p,{children:"So keep in mind that, unlike the ordinary scala print statements, we can't use print statements directly to debug functional effects, unless we unsafely run the computation:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nval effect: ZIO[Any, Nothing, Int] = \n  ZIO.succeed(3).map(_ * 2)\n\nval executedEffect: Int =\n  Unsafe.unsafe { implicit unsafe =>\n    Runtime.default.unsafe.run(effect).getOrThrowFiberFailure()\n  }\n  \nprintln(s"executedEffect: $executedEffect")\n'})}),"\n",(0,a.jsx)(n.p,{children:"This will print the result of the computation. But, this is not the idiomatic way to debug functional effects."}),"\n",(0,a.jsxs)(n.p,{children:["Simple ",(0,a.jsx)(n.em,{children:"print statements"})," are not composable with ZIO applications. So we can't use them to debug ZIO applications easily. So instead of print statements, we should use ZIO effects to debug ZIO applications. We can use ",(0,a.jsx)(n.code,{children:"Console.printLine"})," effect to debug ZIO applications, but the ZIO itself has a specialized effect called ",(0,a.jsx)(n.code,{children:"ZIO.debug"}),"/",(0,a.jsx)(n.code,{children:"ZIO#debug"})," which allows us to print intermediate values easily."]}),"\n",(0,a.jsxs)(n.p,{children:["For example, assume we have written the Fibonacci function using the ",(0,a.jsx)(n.code,{children:"ZIO"})," data type:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"import zio._\n\ndef fib(n: Int): ZIO[Any, Nothing, Int] = {\n  if (n <= 1) ZIO.succeed(n)\n  else fib(n - 1).zipWith(fib(n - 2))(_ + _)\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["We can debug this program by utilizing the ",(0,a.jsx)(n.code,{children:"ZIO#debug"})," effect:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'import zio._\n\ndef fib(n: Int): ZIO[Any, Nothing, Int] = {\n  if (n <= 1) ZIO.succeed(n).debug(s"fib($n) = $n")\n  else {\n    fib(n - 1)\n      .zipWith(fib(n - 2))(_ + _)\n      .debug(s"fib($n) = fib(${n - 1}) + fib(${n - 2})")\n  }\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"If we run the above program, we will see the following output:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"fib(1) = 1: 1\nfib(0) = 0: 0\nfib(2) = fib(1) + fib(0): 1\nfib(1) = 1: 1\nfib(3) = fib(2) + fib(1): 2\nfib(1) = 1: 1\nfib(0) = 0: 0\nfib(2) = fib(1) + fib(0): 1\nfib(4) = fib(3) + fib(2): 3\nfib(1) = 1: 1\nfib(0) = 0: 0\nfib(2) = fib(1) + fib(0): 1\nfib(1) = 1: 1\nfib(3) = fib(2) + fib(1): 2\nfib(5) = fib(4) + fib(3): 5\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"ZIO#debug"})," effect taps into the called function and prints its output. It doesn't change the result of a computation. We also can use ",(0,a.jsx)(n.code,{children:"ZIO.debug"})," to print any arbitrary message."]}),"\n",(0,a.jsx)(n.p,{children:"We have the same effect as the following:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'import zio.stream._\n\nZStream\n  .fromIterable(1 to 3)\n  .debug("before map")\n  .map(_ * 2)\n  .debug("after map")\n  .runDrain\n'})}),"\n",(0,a.jsx)(n.p,{children:"The output is:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"before map: 1\nafter map: 2\nbefore map: 2\nafter map: 4\nbefore map: 3\nafter map: 6\n"})}),"\n",(0,a.jsx)(n.h2,{id:"debugging-using-a-debugger",children:"Debugging Using a Debugger"}),"\n",(0,a.jsx)(n.p,{children:"Debugging using print statements is usable in some cases, and sometimes it is not performant. Another way to debug a code is to use a debugger. A debugger is a program that allows us to step through the code and see the intermediate values of the computation. Some IDEs like IntelliJ IDEA or Visual Studio Code have built-in debuggers. We can use these to debug our code, whether we are debugging a functional effect or an ordinary scala program."}),"\n",(0,a.jsx)(n.p,{children:"To learn how to use a debugger in each of the IDEs, we can look at the following links:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://www.jetbrains.com/help/idea/run-debug-and-test-scala.html",children:"IntelliJ IDEA"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://code.visualstudio.com/docs/editor/debugging",children:"Visual Studio Code"})}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsxs)(n.p,{children:["In this article we discussed how to debug functional effects using ",(0,a.jsx)(n.code,{children:"debug"})," effect and also debuggers. We saw that debugging with functional effects can be even easier than debugging ordinary scala programs."]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>c});var t=i(96540);const a={},o=t.createContext(a);function s(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);