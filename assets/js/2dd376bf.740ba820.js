"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[62261],{51426:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"reference/state-management/index","title":"Introduction to State Management in ZIO","description":"When we write a program, more often we need to keep track of some sort of state during the execution of the program. If an object has a state, its behavior is influenced by passing the time.","source":"@site/docs/reference/state-management/index.md","sourceDirName":"reference/state-management","slug":"/reference/state-management/","permalink":"/reference/state-management/","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/state-management/index.md","tags":[],"version":"current","frontMatter":{"id":"index","title":"Introduction to State Management in ZIO"},"sidebar":"reference-sidebar","previous":{"title":"Examples","permalink":"/reference/schedule/examples"},"next":{"title":"Recursion","permalink":"/reference/state-management/recursion"}}');var s=n(74848),r=n(28453);const i={id:"index",title:"Introduction to State Management in ZIO"},o=void 0,c={},l=[];function h(e){const t={a:"a",code:"code",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"When we write a program, more often we need to keep track of some sort of state during the execution of the program. If an object has a state, its behavior is influenced by passing the time."}),"\n",(0,s.jsx)(t.p,{children:"Here are some examples:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Counter"}),"\u2014 Assume a RESTful API, which has a set of endpoints, and wants to keep track of how many requests have been made to each endpoint."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Bank Account Balance"}),"\u2014 Each bank account has a balance, and it can be deposited or withdrawn. So its value is changing over time."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Temperature"}),"\u2014 The temperature of a room is changing over time."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"List length"}),"\u2014 When we are iterating over a list of items, we might need to keep track of the number of items we have seen so far. So during the calculation of the length of the list, we need an intermediate state that records the number of items we have seen so far."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"In imperative programming, one common way to store the state is using a variable. So we can update their values in place. But this approach can introduce bugs, especially when the state is shared between multiple components. So it is better to avoid using variables to keep track of the state."}),"\n",(0,s.jsx)(t.p,{children:"From the aspect of concurrency, we have two general approaches to maintaining the state in functional programming:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.a,{href:"/reference/state-management/recursion",children:"Recursion"})}),"\u2014 In this approach, we can update the state by passing the new state to the next component. This is a very easy way to maintain the state, but it can't be used in a concurrent environment, because we can't share the state between multiple fibers."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Concurrent\u2014 The concurrent state management is also has two variant, global and fiber-local state management:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.a,{href:"/reference/state-management/global-shared-state",children:"Global Shared State"})}),"- ZIO has a powerful data type called ",(0,s.jsx)(t.code,{children:"Ref"}),", which is the description of a mutable reference. We can use ",(0,s.jsx)(t.code,{children:"Ref"})," to share the state between multiple fibers, e.g. producer and consumer components."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.a,{href:"/reference/state-management/fiber-local-state",children:"Fiber-local State"})}),"\u2014 ZIO provides two data types called ",(0,s.jsx)(t.code,{children:"FiberRef"})," and ",(0,s.jsx)(t.code,{children:"ZState"})," that can be used to maintain the state in a concurrent environment, but each fiber has its own state. Their states are not shared between other fibers. This prevents them from clobbering each other's state."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"In this section, we will talk about these approaches."})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>o});var a=n(96540);const s={},r=a.createContext(s);function i(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);