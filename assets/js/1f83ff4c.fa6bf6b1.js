"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[83646],{87240:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"reference/test/test-hierarchies-and-organization","title":"Test Hierarchies and Organization","description":"A Spec[R, E] is the backbone of ZIO Test. All specs require an environment of type R and may potentially fail with an error of type E.","source":"@site/docs/reference/test/test-hierarchies-and-organization.md","sourceDirName":"reference/test","slug":"/reference/test/test-hierarchies-and-organization","permalink":"/reference/test/test-hierarchies-and-organization","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/test/test-hierarchies-and-organization.md","tags":[],"version":"current","frontMatter":{"id":"test-hierarchies-and-organization","title":"Test Hierarchies and Organization"},"sidebar":"reference-sidebar","previous":{"title":"Built-in Assertions","permalink":"/reference/test/assertions/built-in-assertions"},"next":{"title":"Sharing Layers within the Same File","permalink":"/reference/test/sharing-layers-within-the-same-file"}}');var i=s(74848),a=s(28453);const r={id:"test-hierarchies-and-organization",title:"Test Hierarchies and Organization"},o=void 0,l={},c=[{value:"A Single Spec",id:"a-single-spec",level:2},{value:"Collection of Multiple Specs",id:"collection-of-multiple-specs",level:2},{value:"Collection of Multiple <strong>Smart</strong> Specs",id:"collection-of-multiple-smart-specs",level:2},{value:"Sharing the result of an effectful value between tests",id:"sharing-the-result-of-an-effectful-value-between-tests",level:2}];function u(e){const t={code:"code",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["A ",(0,i.jsx)(t.code,{children:"Spec[R, E]"})," is the backbone of ZIO Test. All specs require an environment of type ",(0,i.jsx)(t.code,{children:"R"})," and may potentially fail with an error of type ",(0,i.jsx)(t.code,{children:"E"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"We can think of a spec as just a collection of tests. It is essentially a recursive data structure where every spec is just one individual test or a suite that itself can have multiple specs inside that each could be tests or sub suites. We can go down as far as we want in a recursive tree-like data structure."}),"\n",(0,i.jsx)(t.h2,{id:"a-single-spec",children:"A Single Spec"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"test"})," constructor creates one single spec:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:'import zio.test._\n\nval mySpec = test("true is true") {\n  assertTrue(true)\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Real tests that run some logic and return testing result are created mostly with ",(0,i.jsx)(t.code,{children:"test"})," function. It expects two arguments, first one will be the label of test which will be used for visual reporting back to the user, and an assertion which contains some testable logic specified about a target under the test."]}),"\n",(0,i.jsx)(t.h2,{id:"collection-of-multiple-specs",children:"Collection of Multiple Specs"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"suite"})," creates a suite which contains other specs (tests or suites):"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:'import zio.test._\n\nval mySuite =\n  suite("A suite containing multiple tests")(\n    test("the first test") {\n      assertTrue(1 + 1 == 2)\n    },\n    test("the second test") {\n      assertTrue(2 * 2 == 4)\n    }\n  )\n'})}),"\n",(0,i.jsx)(t.p,{children:"Suites can contain other suites. We can have multiple suites and one big suite that will aggregate them all:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:'import zio.test._\n\nsuite("int and string")(\n  suite("int suite")(\n    test("minus")(assertTrue(2 - 1 == 1)),\n    test("plus")(assertTrue(1 + 1 == 2))\n  ),\n  suite("string suite")(\n    test("concat")(assertTrue("a" + "b" == "ab")),\n    test("length")(assertTrue("abc".length == 3))\n  )\n)\n'})}),"\n",(0,i.jsxs)(t.h2,{id:"collection-of-multiple-smart-specs",children:["Collection of Multiple ",(0,i.jsx)(t.strong,{children:"Smart"})," Specs"]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"suite"})," method creates a spec from a collection of specs. So what we can do is to provide it with a collection of specs:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:'import zio.test._\n\nobject ExampleSpec extends ZIOSpecDefault {\n\n  def spec =\n    suite("some suite")(\n      test("test 1") {\n        val stuff = 1\n        assertTrue(stuff == 1)\n      },\n      test("test 2") {\n        val stuff = Some(1)\n        assertTrue(stuff == Some(1))\n      }\n    )\n\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["But what if we wanted to have a suite of tests that work on a common value, e.g. the same ",(0,i.jsx)(t.code,{children:"stuff"}),"? ZIO provides the ",(0,i.jsx)(t.code,{children:"suiteAll"})," method that helps us to share the same ",(0,i.jsx)(t.code,{children:"stuff"})," between all tests:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:'import zio.test._\n\nobject ExampleSpec extends ZIOSpecDefault {\n\n  def spec =\n    suiteAll("some suite") {\n\n      val stuff = "hello"\n\n      test("test 1") {\n        assertTrue(stuff.startsWith("h"))\n      }\n\n      val stuff2 = 5\n\n      test("test 2") {\n        assertTrue(stuff.length == stuff2)\n      }\n    }\n\n}\n'})}),"\n",(0,i.jsx)(t.h2,{id:"sharing-the-result-of-an-effectful-value-between-tests",children:"Sharing the result of an effectful value between tests"}),"\n",(0,i.jsxs)(t.p,{children:["As we saw in the previous section, the ",(0,i.jsx)(t.code,{children:"suiteAll"})," method allows tests to work with common values. But what if the value is a result of some effect and we want to use it in several tests, without running the effect every time? Suites in ",(0,i.jsx)(t.code,{children:"zio-test"})," can be effectual, so we can use this feature to share effectual values:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:'import zio._\nimport zio.test._\n\nobject ExampleSpec extends ZIOSpecDefault {\n  val spec =\n    suite("some suite") {\n      for {\n        stuff <- ZIO.succeed("hello")\n        stuff2 = 5\n      } yield Chunk(\n\n        test("test 1") {\n          assertTrue(stuff.startsWith("h"))\n        },\n\n        test("test 2") {\n          assertTrue(stuff.length == stuff2)\n        }\n\n      )\n    }\n}\n'})})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},28453:(e,t,s)=>{s.d(t,{R:()=>r,x:()=>o});var n=s(96540);const i={},a=n.createContext(i);function r(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);