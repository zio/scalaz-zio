"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[72964],{28453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>c});var t=i(96540);const r={},o=t.createContext(r);function s(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(o.Provider,{value:n},e.children)}},53116:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"reference/contextual/index","title":"Introduction to the ZIO\'s Contextual Data Types","description":"ZIO provides a contextual abstraction that encodes the environment of the running effect. This means, every effect can work within a specific context, called an environment.","source":"@site/docs/reference/contextual/index.md","sourceDirName":"reference/contextual","slug":"/reference/contextual/","permalink":"/reference/contextual/","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/contextual/index.md","tags":[],"version":"current","frontMatter":{"id":"index","title":"Introduction to the ZIO\'s Contextual Data Types","sidebar_label":"Introduction"},"sidebar":"reference-sidebar","previous":{"title":"Examples","permalink":"/reference/di/examples"},"next":{"title":"ZEnvironment","permalink":"/reference/contextual/zenvironment"}}');var r=i(74848),o=i(28453);const s={id:"index",title:"Introduction to the ZIO's Contextual Data Types",sidebar_label:"Introduction"},c=void 0,a={},l=[{value:"1. ZIO Environment",id:"1-zio-environment",level:2},{value:"Motivation",id:"motivation",level:3},{value:"Advantage of Using ZIO Environment",id:"advantage-of-using-zio-environment",level:3},{value:"Accessing ZIO Environment",id:"accessing-zio-environment",level:3},{value:"Service Accessor",id:"service-accessor",level:4},{value:"Service Member Accessors",id:"service-member-accessors",level:4},{value:"2. ZEnvironment",id:"2-zenvironment",level:2},{value:"3. ZLayer",id:"3-zlayer",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"ZIO provides a contextual abstraction that encodes the environment of the running effect. This means, every effect can work within a specific context, called an environment."}),"\n",(0,r.jsxs)(n.p,{children:["So when we have a ",(0,r.jsx)(n.code,{children:"ZIO[R, E, A]"}),' effect, we can say "given ',(0,r.jsx)(n.code,{children:"R"})," as the environment of the effect, the effect may fail with an error type of ",(0,r.jsx)(n.code,{children:"E"}),", or may succeed with a value of type ",(0,r.jsx)(n.code,{children:"A"}),'".']}),"\n",(0,r.jsxs)(n.p,{children:["For example, when we have an effect of type ",(0,r.jsx)(n.code,{children:"ZIO[DatabaseConnection, IOException, String]"}),", we can say that our effect works within the context of ",(0,r.jsx)(n.code,{children:"DatabaseConnection"}),". In other words, we can say that our effect requires the ",(0,r.jsx)(n.code,{children:"DatabaseConnection"})," service as a context to run."]}),"\n",(0,r.jsx)(n.p,{children:"We will see how layers can be used to eliminate the environment of an effect:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nimport java.io.IOException\n\ntrait DatabaseConnection\n\n// An effect which requires DatabaseConnection to run\nval effect: ZIO[DatabaseConnection, IOException, String] = ???\n\n// A layer that produces DatabaseConnection service\nval dbConnection: ZLayer[Any, IOException, DatabaseConnection] = ???\n\n// After applying dbConnection to our environmental effect the reurned\n// effect has no dependency on the DatabaseConnection\nval eliminated: ZIO[Any, IOException, String] = \n  dbConnection { // Provides DatabaseConnection context\n    effect       // An effect running within `DatabaseConnection` context\n  }\n"})}),"\n",(0,r.jsx)(n.p,{children:"ZIO provides this facility through the following concepts and data types:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"#1-zio-environment",children:"ZIO Environment"})," \u2014 The ",(0,r.jsx)(n.code,{children:"R"})," type parameter of ",(0,r.jsx)(n.code,{children:"ZIO[R, E, A]"})," data type."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"#2-zenvironment",children:"ZEnvironment"})," \u2014 Built-in type-level map for maintaining the environment of a ",(0,r.jsx)(n.code,{children:"ZIO"})," data type."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"#3-zlayer",children:"ZLayer"})," \u2014 Describes how to build one or more services in our application."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Next, we will discuss ",(0,r.jsx)(n.em,{children:"ZIO Environment"})," and ",(0,r.jsx)(n.em,{children:"ZLayer"})," and finally how to write ZIO services using the ",(0,r.jsx)(n.em,{children:"Service Pattern"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"1-zio-environment",children:"1. ZIO Environment"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"ZIO[-R, +E, +A]"})," data type describes an effect that requires an input of type ",(0,r.jsx)(n.code,{children:"R"}),", as an environment, may fail with an error of type ",(0,r.jsx)(n.code,{children:"E"}),", or succeed with a value of type ",(0,r.jsx)(n.code,{children:"A"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The input type is also known as ",(0,r.jsx)(n.em,{children:"environment type"}),". This type-parameter indicates that to run an effect we need one or some services as an environment of that effect. In other word, ",(0,r.jsx)(n.code,{children:"R"})," represents the ",(0,r.jsx)(n.em,{children:"requirement"})," for the effect to run, meaning we need to fulfill the requirement in order to make the effect ",(0,r.jsx)(n.em,{children:"runnable"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["So we can think of ",(0,r.jsx)(n.code,{children:"ZIO[R, E, A]"})," as a mental model of a function from a value of type ",(0,r.jsx)(n.code,{children:"R"})," to the ",(0,r.jsx)(n.code,{children:"Either[E, A]"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"type ZIO[R, E, A] = R => Either[E, A]\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"R"})," represents dependencies; whatever services, config, or wiring a part of a ZIO program depends upon to work. We will explore what we can do with ",(0,r.jsx)(n.code,{children:"R"}),", as it plays a crucial role in ",(0,r.jsx)(n.code,{children:"ZIO"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"motivation",children:"Motivation"}),"\n",(0,r.jsxs)(n.p,{children:['One might ask "What is the motivation behind encoding the dependency in the type parameter of ',(0,r.jsx)(n.code,{children:"ZIO"}),' data type"? What is the benefit of doing so?']}),"\n",(0,r.jsxs)(n.p,{children:["Let's see how writing an application which requires reading from or writing to the terminal. As part of making the application ",(0,r.jsx)(n.em,{children:"modular"})," and ",(0,r.jsx)(n.em,{children:"testable"})," we define a separate service called ",(0,r.jsx)(n.code,{children:"Terminal"})," which is responsible for reading from and writing to the terminal. We do that simply by writing an interface:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"import zio._\n\ntrait Terminal {\n  def print(line: Any): Task[Unit]\n\n  def printLine(line: Any): Task[Unit]\n\n  def readLine: Task[String]\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Now we can write our application that accepts the ",(0,r.jsx)(n.code,{children:"Terminal"})," interface as a parameter:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio._\n\ndef myApp(c: Terminal): Task[Unit] =\n  for {\n    _    <- c.print("Please enter your name: ")\n    name <- c.readLine\n    _    <- c.printLine(s"Hello, $name!")\n  } yield ()\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Similar to the object-oriented paradigm we code to interface not implementation. In order to run the application, we need to implement a production version of the ",(0,r.jsx)(n.code,{children:"Terminal"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nobject TerminalLive extends Terminal {\n  override def print(line: Any): Task[Unit] =\n    ZIO.attemptBlocking(scala.Predef.print(line))\n\n  override def printLine(line: Any): Task[Unit] =\n    ZIO.attemptBlocking(scala.Predef.println(line))\n\n  override def readLine: Task[String] =\n    ZIO.attemptBlocking(scala.io.StdIn.readLine())\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Finally, we can provide the ",(0,r.jsx)(n.code,{children:"TerminalLive"})," to our application and run the whole:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def myApp(c: Terminal): Task[Unit] =\n    for {\n      _    <- c.print("Please enter your name: ")\n      name <- c.readLine\n      _    <- c.printLine(s"Hello, $name!")\n    } yield ()\n\n  def run = myApp(TerminalLive)\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["In the above example, we discard the fact that we could use the ZIO environment and utilize the ",(0,r.jsx)(n.code,{children:"R"})," parameter of the ",(0,r.jsx)(n.code,{children:"ZIO"})," data type. So instead we tried to write the application with the ",(0,r.jsx)(n.code,{children:"Task"})," data type, which ignores the ZIO environment. To create our application testable, we gathered all terminal functionalities into the same interface called ",(0,r.jsx)(n.code,{children:"Terminal"}),", and implemented that in another object called ",(0,r.jsx)(n.code,{children:"TerminalLive"}),". Finally, at the end of the day, we provide the implementation of the ",(0,r.jsx)(n.code,{children:"Terminal"})," service, i.e. ",(0,r.jsx)(n.code,{children:"TerminalLive"}),", to our application."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"While this technique works for small programs, it doesn't scale."})," Assume we have multiple services, and we use them in our application logic like below:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'def foo(\n   s1: Service1,\n   s2: Service2,\n   s3: Service3\n)(arg1: String, arg2: String, arg3: Int): Task[Int] = ???\n\ndef bar(\n  s1: Service1,\n  s12: Service12,\n  s18: Service18, \n  sn: ServiceN\n)(arg1: Int, arg2: String, arg3: Double, arg4: Int): Task[Unit]\n\ndef myApp(s1: Service1, s2: Service2, ..., sn: ServiceN): Task[Unit] = \n  for {\n    a <- foo(s1, s2, s3)("arg1", "arg2", 4) \n    _ <- bar(s1, s12, s18, sn)(7, "arg2", 1.2, a)\n      ...\n  } yield ()\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Writing real applications using this technique is tedious and cumbersome because all dependencies have to be passed across all methods. We can simplify the process of writing our application by using the ZIO environment and ",(0,r.jsx)(n.a,{href:"/reference/service-pattern/",children:"Service Pattern"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"def foo(arg1: String, arg2: String, arg3: Int): ZIO[Service1 & Service2 & Service3, Throwable, Int] = \n  for {\n    s1 <- ZIO.service[Service1]\n    s2 <- ZIO.service[Service2] \n      ...\n  } yield ()\n\ndef bar(arg1: Int, arg2: String, arg3: Double, arg4: Int): ZIO[Service1 & Service12 & Service18 & ServiceN, Throwable, Unit] =\n  for {\n    s1  <- ZIO.service[Service1] \n    s12 <- ZIO.service[Service12]\n      ...\n  } yield ()\n"})}),"\n",(0,r.jsx)(n.h3,{id:"advantage-of-using-zio-environment",children:"Advantage of Using ZIO Environment"}),"\n",(0,r.jsx)(n.p,{children:"ZIO environment facility enables us to:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Code to Interface"})," \u2014 Like object-oriented paradigm, in ZIO we are encouraged to code to interface and defer the implementation. It is the best practice, but ZIO does not enforce us to do that."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Write a Testable Code"})," \u2014 By coding to an interface, whenever we want to test our effects, we can easily mock any external services, by providing a ",(0,r.jsx)(n.em,{children:"test"})," version of those instead of the ",(0,r.jsx)(n.em,{children:"live"})," version."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Compose Services with Strong Type Inference Facility"})," \u2014 We can compose multiple effects that require various services, so the final effect requires the intersection of all those services:"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"import zio._\n\ntrait ServiceA\ntrait ServiceB\ntrait ServiceC\n\n// Requires ServiceA and produces a value of type Int\ndef foo: ZIO[ServiceA, Nothing, Int] = ???\n\n// Requires ServiceB and ServiceC and produces a value of type String\ndef bar: ZIO[ServiceB & ServiceC, Throwable, String] = ???\n\n// Requires ServicB and produces a value of type Double\ndef baz(a: Int, b: String): ZIO[ServiceB, Nothing, Double] = ???\n\n// Requires ServiceA and ServiceB and ServiceC and produces a value of type Double\nval myApp: ZIO[ServiceA & ServiceB & ServiceC, Throwable, Double] =\n  for {\n    a <- foo\n    b <- bar\n    c <- baz(a, b)\n  } yield c\n"})}),"\n",(0,r.jsx)(n.p,{children:"Another important note about the ZIO environment is that the type inference works well on effect composition. After we composed all the application logic together, the compiler and also IDE can infer the proper type for the environment of the final effect."}),"\n",(0,r.jsxs)(n.p,{children:["In the example above, the compiler can infer the environment type of the ",(0,r.jsx)(n.code,{children:"myApp"})," effect which is ",(0,r.jsx)(n.code,{children:"ServiceA & ServiceB & ServiceC"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"accessing-zio-environment",children:"Accessing ZIO Environment"}),"\n",(0,r.jsx)(n.p,{children:"We have two types of accessors for the ZIO environment:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["Service Accessor (",(0,r.jsx)(n.code,{children:"ZIO.service"}),")"]})," is used to access a specific service from the environment."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["Service Member Accessors (",(0,r.jsx)(n.code,{children:"ZIO.serviceWith"})," and ",(0,r.jsx)(n.code,{children:"ZIO.serviceWithZIO"}),")"]})," are used to access capabilities of a specific service from the environment."]}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsxs)(n.p,{children:["To access the entire ZIO environment we can use ",(0,r.jsx)(n.code,{children:"ZIO.environment*"}),", but we do not use these methods regularly to access ZIO services. Instead, we use service accessors and service member accessors."]})}),"\n",(0,r.jsx)(n.h4,{id:"service-accessor",children:"Service Accessor"}),"\n",(0,r.jsxs)(n.p,{children:["To access a service from the ZIO environment, we can use the ",(0,r.jsx)(n.code,{children:"ZIO.service"})," constructor. For example, in the following program we are going to access the ",(0,r.jsx)(n.code,{children:"AppConfig"})," from the environment:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio._\n\ncase class AppConfig(host: String, port: Int)\n\nval myApp: ZIO[AppConfig, Nothing, Unit] =\n  for {\n    config <- ZIO.service[AppConfig]\n    _      <- ZIO.logInfo(s"Application started with config: $config")\n  } yield ()\n'})}),"\n",(0,r.jsxs)(n.p,{children:["To run the ",(0,r.jsx)(n.code,{children:"myApp"})," effect, we should provide the ",(0,r.jsx)(n.code,{children:"AppConfig"})," layer (we will talk about ",(0,r.jsx)(n.code,{children:"ZLayer"})," on the next section):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'object MainApp extends ZIOAppDefault {\n  def run = myApp.provide(ZLayer.succeed(AppConfig("localhost", 8080)))\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"To access multiple services from the ZIO environment, we can do the same:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"import zio._\n\ntrait Foo\ntrait Bar\ntrait Baz\n\nfor {\n  foo <- ZIO.service[Foo]  \n  bar <- ZIO.service[Bar]\n  bax <- ZIO.service[Baz]\n} yield ()\n"})}),"\n",(0,r.jsxs)(n.p,{children:["When creating ZIO layers that have multiple dependencies, this can be helpful. We will discuss this pattern in the ",(0,r.jsx)(n.a,{href:"/reference/service-pattern/",children:"Service Pattern"})," section."]}),"\n",(0,r.jsx)(n.h4,{id:"service-member-accessors",children:"Service Member Accessors"}),"\n",(0,r.jsx)(n.p,{children:"Sometimes instead of accessing a service, we need to access the capabilities (members) of a service. Based on the return type of each capability, we can use one of these accessors:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"ZIO.serviceWith"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"ZIO.serviceWithZIO"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["In ",(0,r.jsx)(n.a,{href:"/reference/service-pattern/",children:"Service Pattern"}),', we use these accessors to write "accessor methods" for ZIO services.']}),"\n",(0,r.jsx)(n.p,{children:"Let's look at each one in more detail:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ZIO.serviceWith"})," \u2014 When we are accessing service members whose return type is an ordinary value, we should use the ",(0,r.jsx)(n.code,{children:"ZIO.serviceWith"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["In the following example, we need to use the ",(0,r.jsx)(n.code,{children:"ZIO.serviceWith"})," to write accessor methods for all of the ",(0,r.jsx)(n.code,{children:"AppConfig"})," members:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio._\n\ncase class AppConfig(host: String, port: Int, poolSize: Int)\n\nobject AppConfig {\n  // Accessor Methods\n  def host: ZIO[AppConfig, Nothing, String]  = ZIO.serviceWith(_.host) \n  def port: ZIO[AppConfig, Nothing, Int]     = ZIO.serviceWith(_.port)\n  def poolSize: ZIO[AppConfig, Nothing, Int] = ZIO.serviceWith(_.poolSize)\n}\n\nval myApp: ZIO[AppConfig, Nothing, Unit] =\n  for {\n    host     <- AppConfig.host\n    port     <- AppConfig.port\n    _        <- ZIO.logInfo(s"The service will be service at $host:$port")\n    poolSize <- AppConfig.poolSize\n    _        <- ZIO.logInfo(s"Application started with $poolSize pool size")\n  } yield ()\n'})}),"\n",(0,r.jsxs)(n.ol,{start:"2",children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ZIO.serviceWithZIO"})," \u2014 When we are accessing service members whose return type is a ZIO effect, we should use the ",(0,r.jsx)(n.code,{children:"ZIO.serviceWithZIO"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["For example, in order to write the accessor method for the ",(0,r.jsx)(n.code,{children:"foo"})," member of the ",(0,r.jsx)(n.code,{children:"Foo"})," service, we need to use the ",(0,r.jsx)(n.code,{children:"ZIO.serviceWithZIO"})," function:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"import zio._\n\ntrait Foo {\n  def foo(input: String): Task[Unit]\n}\n\nobject Foo {\n  // Accessor Method\n  def foo(input: String): ZIO[Foo, Throwable, Unit] =\n    ZIO.serviceWithZIO(_.foo(input))\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"2-zenvironment",children:"2. ZEnvironment"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"ZEnvironment"})," is a built-in type-level map for maintaining the environment of a ",(0,r.jsx)(n.code,{children:"ZIO"})," data type. We don't typically use this data type directly. It's okay to skip learning it at the moment. We have a ",(0,r.jsx)(n.a,{href:"/reference/contextual/zenvironment",children:"separate article"})," about this data type."]}),"\n",(0,r.jsx)(n.h2,{id:"3-zlayer",children:"3. ZLayer"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"ZLayer[-RIn, +E, +ROut]"})," is a recipe to build an environment of type ",(0,r.jsx)(n.code,{children:"ROut"}),", starting from a value ",(0,r.jsx)(n.code,{children:"RIn"}),", and possibly producing an error ",(0,r.jsx)(n.code,{children:"E"})," during creation."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);