"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[42488],{87067:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>s,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"reference/service-pattern/generating-accessor-methods-using-macros","title":"Generating Accessor Methods Using Macros","description":"Writing accessor methods is a repetitive task and would be cumbersome in services with many methods. We can automate the generation of accessor methods using zio-macro module.","source":"@site/docs/reference/service-pattern/generating-accessor-methods-using-macros.md","sourceDirName":"reference/service-pattern","slug":"/reference/service-pattern/generating-accessor-methods-using-macros","permalink":"/reference/service-pattern/generating-accessor-methods-using-macros","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/service-pattern/generating-accessor-methods-using-macros.md","tags":[],"version":"current","frontMatter":{"id":"generating-accessor-methods-using-macros","title":"Generating Accessor Methods Using Macros","sidebar_label":"Generating Accessor Methods"},"sidebar":"reference-sidebar","previous":{"title":"Polymorphic Services","permalink":"/reference/service-pattern/defining-polymorphic-services-in-zio"},"next":{"title":"Three Laws of ZIO Environment","permalink":"/reference/service-pattern/the-three-laws-of-zio-environment"}}');var t=r(74848),a=r(28453);const s={id:"generating-accessor-methods-using-macros",title:"Generating Accessor Methods Using Macros",sidebar_label:"Generating Accessor Methods"},o=void 0,c={},l=[{value:"Monomorphic Services",id:"monomorphic-services",level:2},{value:"Writing Polymorphic Services",id:"writing-polymorphic-services",level:2},{value:"With Proper Type Parameters",id:"with-proper-type-parameters",level:3},{value:"With Higher-Kinded Type Parameters (<code>F[_]</code>)",id:"with-higher-kinded-type-parameters-f_",level:3},{value:"With Higher-Kinded Type Parameters (<code>F[_, _]</code>)",id:"with-higher-kinded-type-parameters-f_-_",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["Writing accessor methods is a repetitive task and would be cumbersome in services with many methods. We can automate the generation of accessor methods using ",(0,t.jsx)(n.code,{children:"zio-macro"})," module."]}),"\n",(0,t.jsxs)(n.p,{children:["To install the ",(0,t.jsx)(n.code,{children:"zio-macro"})," we should add the following line in our ",(0,t.jsx)(n.code,{children:"build.sbt"})," file:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'libraryDependencies += "dev.zio" %% "zio-macros" % "<zio-version>"\n'})}),"\n",(0,t.jsx)(n.p,{children:"Also, to enable macro expansion we need to setup our project:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["for Scala ",(0,t.jsx)(n.code,{children:">= 2.13"})," add compiler option:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'scalacOptions += "-Ymacro-annotations"\n'})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["for Scala ",(0,t.jsx)(n.code,{children:"< 2.13"})," add macro paradise compiler plugin:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'compilerPlugin(("org.scalamacros" % "paradise"  % "2.1.1") cross CrossVersion.full)\n'})}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["If you are using IntelliJ, macro generated accessors will not be available in IDE hints without ",(0,t.jsx)(n.a,{href:"/guides/tutorials/run-our-first-zio-project-with-intellij-idea",children:"ZIO plugin"}),"."]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["At the moment these are only available for Scala versions ",(0,t.jsx)(n.code,{children:"2.x"}),", however their equivalents for Scala 3 are on our roadmap."]})}),"\n",(0,t.jsx)(n.h2,{id:"monomorphic-services",children:"Monomorphic Services"}),"\n",(0,t.jsxs)(n.p,{children:["We can use the ",(0,t.jsx)(n.code,{children:"@accessible"})," macro to generate ",(0,t.jsx)(n.em,{children:"service member accessors"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import zio._\nimport zio.macros.accessible\n\n@accessible\ntrait ServiceA {\n  def method(input: Something): UIO[Unit]\n}\n\n// below will be autogenerated\nobject ServiceA {\n  def method(input: Something) =\n    ZIO.serviceWithZIO[ServiceA](_.method(input))\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["For normal values, a ",(0,t.jsx)(n.code,{children:"ZIO"})," with ",(0,t.jsx)(n.code,{children:"Nothing"})," on error channel is generated:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import zio._\nimport zio.macros.accessible\n\n@accessible\ntrait ServiceB {\n  def pureMethod(input: Something): SomethingElse\n}\n\n// below will be autogenerated\nobject ServiceB {\n  def pureMethod(input: Something): ZIO[ServiceB, Nothing, SomethingElse] =\n    ZIO.serviceWith[ServiceB](_.pureMethod(input))\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"@throwing"})," annotation will mark impure methods. Using this annotation will request ZIO to push the error on the error channel:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import zio._\nimport zio.macros.accessible\nimport zio.macros.throwing\n\n@accessible\ntrait ServiceC {\n  @throwing\n  def impureMethod(input: Something): SomethingElse\n}\n\n// below will be autogenerated\nobject ServiceC {\n  def impureMethod(input: Something): ZIO[ServiceC, Throwable, SomethingElse] =\n    ZIO.serviceWithZIO[ServiceC](s => ZIO(s.impureMethod(input)))\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Below is a fully working example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.macros.accessible\n\n@accessible\ntrait KeyValueStore {\n  def set(key: String, value: Int): Task[Int]\n\n  def get(key: String): Task[Int]\n}\n\n\ncase class InmemoryKeyValueStore(map: Ref[Map[String, Int]])\n  extends KeyValueStore {\n  override def set(key: String, value: Int): Task[Int] =\n    map.update(_.updated(key, value)).map(_ => value)\n\n  override def get(key: String): Task[Int] =\n    map.get.map(_.get(key)).someOrFailException\n}\n\nobject InmemoryKeyValueStore {\n  val layer: ULayer[KeyValueStore] =\n    ZLayer {\n      for {\n        map <- Ref.make(Map[String, Int]())\n      } yield InmemoryKeyValueStore(map)\n    }\n}\n\nobject MainApp extends ZIOAppDefault {\n  val myApp =\n    for {\n      _   <- KeyValueStore.set("key", 5)\n      key <- KeyValueStore.get("key")\n    } yield key\n    \n  def run = myApp.provide(InmemoryKeyValueStore.layer).debug\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"writing-polymorphic-services",children:"Writing Polymorphic Services"}),"\n",(0,t.jsx)(n.h3,{id:"with-proper-type-parameters",children:"With Proper Type Parameters"}),"\n",(0,t.jsxs)(n.p,{children:["If the service is polymorphic for some proper types, we can use the ",(0,t.jsx)(n.code,{children:"@accessible"})," macro like previous examples."]}),"\n",(0,t.jsxs)(n.p,{children:["Assume we have a ",(0,t.jsx)(n.code,{children:"KeyValueStore"})," like below, as we will see using ",(0,t.jsx)(n.code,{children:"@accessible"})," will generate us the accessor methods:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.macros.accessible\n\n\n@accessible\ntrait KeyValueStore[K, V] {\n  def set(key: K, value: V): Task[V]\n\n  def get(key: K): Task[V]\n}\n\n\ncase class InmemoryKeyValueStore(map: Ref[Map[String, Int]])\n  extends KeyValueStore[String, Int] {\n  override def set(key: String, value: Int): Task[Int] =\n    map.update(_.updated(key, value)).map(_ => value)\n\n  override def get(key: String): Task[Int] =\n    map.get.map(_.get(key)).someOrFailException\n}\n\nobject InmemoryKeyValueStore {\n  val layer: ULayer[KeyValueStore[String, Int]] =\n    ZLayer {\n      for {\n        map <- Ref.make(Map[String, Int]())\n      } yield InmemoryKeyValueStore(map)\n    }\n}\n\nobject MainApp extends ZIOAppDefault {\n  val myApp =\n    for {\n      _ <- KeyValueStore.set("key", 5)\n      key <- KeyValueStore.get[String, Int]("key")\n    } yield key\n\n  def run = myApp.provide(InmemoryKeyValueStore.layer).debug\n}\n'})}),"\n",(0,t.jsxs)(n.h3,{id:"with-higher-kinded-type-parameters-f_",children:["With Higher-Kinded Type Parameters (",(0,t.jsx)(n.code,{children:"F[_]"}),")"]}),"\n",(0,t.jsxs)(n.p,{children:["If a service has a higher-kinded type parameter like ",(0,t.jsx)(n.code,{children:"F[_]"})," we should use the ",(0,t.jsx)(n.code,{children:"accessibleM"})," macro. Here is an example of such a service:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.macros.accessibleM\n\n@accessibleM[Task]\ntrait KeyValueStore[K, V, F[_]] {\n  def set(key: K, value: V): F[V]\n\n  def get(key: K): F[V]\n}\n\ncase class InmemoryKeyValueStore(map: Ref[Map[String, Int]])\n  extends KeyValueStore[String, Int, Task] {\n  override def set(key: String, value: Int): Task[Int] =\n    map.update(_.updated(key, value)).map(_ => value)\n\n  override def get(key: String): Task[Int] =\n    map.get.map(_.get(key)).someOrFailException\n\n}\n\nobject InmemoryKeyValueStore {\n  val layer: ULayer[KeyValueStore[String, Int, Task]] =\n    ZLayer {\n      for {\n        map <- Ref.make(Map[String, Int]())\n      } yield InmemoryKeyValueStore(map)\n    }\n}\n\n\nobject MainApp extends ZIOAppDefault {\n  val myApp =\n    for {\n      key <- KeyValueStore.set[String, Int]("key", 5)\n      _   <- KeyValueStore.get[String, Int]("key")\n    } yield key\n\n  def run = myApp.provide(InmemoryKeyValueStore.layer).debug\n}\n\n'})}),"\n",(0,t.jsxs)(n.h3,{id:"with-higher-kinded-type-parameters-f_-_",children:["With Higher-Kinded Type Parameters (",(0,t.jsx)(n.code,{children:"F[_, _]"}),")"]}),"\n",(0,t.jsxs)(n.p,{children:["If the service has a higher-kinded type parameter like ",(0,t.jsx)(n.code,{children:"F[_, _]"})," we should use the ",(0,t.jsx)(n.code,{children:"accessibleMM"})," macro. Let's see an example:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.macros.accessibleMM\n\n@accessibleMM[IO]\ntrait KeyValueStore[K, V, E, F[_, _]] {\n  def set(key: K, value: V): F[E, V]\n\n  def get(key: K): F[E, V]\n}\n\ncase class InmemoryKeyValueStore(map: Ref[Map[String, Int]])\n  extends KeyValueStore[String, Int, String, IO] {\n  override def set(key: String, value: Int): IO[String, Int] =\n    map.update(_.updated(key, value)).map(_ => value)\n\n  override def get(key: String): IO[String, Int] =\n    map.get.map(_.get(key)).someOrFail(s"key not found: $key")\n}\n\nobject InmemoryKeyValueStore {\n  val layer: ULayer[KeyValueStore[String, Int, String, IO]] =\n    ZLayer {\n      for {\n        map <- Ref.make(Map[String, Int]())\n      } yield InmemoryKeyValueStore(map)\n    }\n}\n\nobject MainApp extends ZIOAppDefault {\n  val myApp =\n    for {\n      _   <- KeyValueStore.set[String, Int, String]("key", 5)\n      key <- KeyValueStore.get[String, Int, String]("key")\n    } yield key\n\n  def run = myApp.provide(InmemoryKeyValueStore.layer).debug\n\n}\n'})})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>o});var i=r(96540);const t={},a=i.createContext(t);function s(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);