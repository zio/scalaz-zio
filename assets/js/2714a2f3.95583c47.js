"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[25573],{28453:(e,n,i)=>{i.d(n,{R:()=>p,x:()=>a});var o=i(96540);const t={},r=o.createContext(t);function p(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:p(e.components),o.createElement(r.Provider,{value:n},e.children)}},99247:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>s,contentTitle:()=>a,default:()=>g,frontMatter:()=>p,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"reference/di/providing-different-implementation-of-a-service","title":"Providing Different Implementation of a Service","description":"One of the benefits of using dependency injection is that, we can write our application in a way that without modifying the application logic, we can provide different implementations of services to our application.","source":"@site/docs/reference/di/providing-different-implementation-of-a-service.md","sourceDirName":"reference/di","slug":"/reference/di/providing-different-implementation-of-a-service","permalink":"/reference/di/providing-different-implementation-of-a-service","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/di/providing-different-implementation-of-a-service.md","tags":[],"version":"current","frontMatter":{"id":"providing-different-implementation-of-a-service","title":"Providing Different Implementation of a Service","sidebar_label":"Multiple Implementations"},"sidebar":"reference-sidebar","previous":{"title":"Dependency Propagation","permalink":"/reference/di/dependency-propagation"},"next":{"title":"Dependency Memoization","permalink":"/reference/di/dependency-memoization"}}');var t=i(74848),r=i(28453);const p={id:"providing-different-implementation-of-a-service",title:"Providing Different Implementation of a Service",sidebar_label:"Multiple Implementations"},a=void 0,s={},c=[{value:"Example 1: Config Service",id:"example-1-config-service",level:2},{value:"Example 2: Logging Service",id:"example-2-logging-service",level:2}];function l(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"One of the benefits of using dependency injection is that, we can write our application in a way that without modifying the application logic, we can provide different implementations of services to our application."}),"\n",(0,t.jsx)(n.h2,{id:"example-1-config-service",children:"Example 1: Config Service"}),"\n",(0,t.jsxs)(n.p,{children:["In the next example, we have a ZIO application that uses the ",(0,t.jsx)(n.code,{children:"AppConfig"})," service:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'import zio._\n\ncase class AppConfig(poolSize: Int)\n\nobject AppConfig {\n  def poolSize: ZIO[AppConfig, Nothing, Int] =\n    ZIO.serviceWith[AppConfig](_.poolSize)\n\n  val appArgsLayer: ZLayer[ZIOAppArgs, Nothing, AppConfig] =\n    ZLayer {\n      ZIOAppArgs.getArgs\n        .map(_.headOption.map(_.toInt).getOrElse(8))\n        .map(poolSize => AppConfig(poolSize))\n    }\n\n  val systemEnvLayer: ZLayer[Any, SecurityException, AppConfig] =\n    ZLayer.fromZIO(\n      System\n        .env("POOL_SIZE")\n        .map(_.headOption.map(_.toInt).getOrElse(8))\n        .map(poolSize => AppConfig(poolSize))\n    )\n}\n\nobject MainApp extends ZIOAppDefault {\n  val myApp: ZIO[AppConfig, Nothing, Unit] =\n    for {\n      poolSize <- AppConfig.poolSize\n      _        <- ZIO.debug(s"Application started with $poolSize pool size.")\n    } yield ()\n\n  def run = myApp.provideSome[ZIOAppArgs](AppConfig.appArgsLayer)\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"AppConfig"})," has two layers, ",(0,t.jsx)(n.code,{children:"appArgsLayer"})," and ",(0,t.jsx)(n.code,{children:"systemEnvLayer"}),". The first one uses command-line arguments to create the ",(0,t.jsx)(n.code,{children:"AppConfig"})," and the second one uses environment variables. As we can see, without changing the core logic of our application, we can easily change the way we get the configuration:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-diff",children:'object MainApp extends ZIOAppDefault {\n  val myApp: ZIO[AppConfig, Nothing, Unit] =\n    for {\n      poolSize <- AppConfig.poolSize\n      _        <- ZIO.debug(s"Application started with $poolSize pool size.")\n    } yield ()\n\n-  def run = myApp.provideSome[ZIOAppArgs](AppConfig.appArgsLayer)\n+  def run = myApp.provide(AppConfig.systemEnvLayer)\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"example-2-logging-service",children:"Example 2: Logging Service"}),"\n",(0,t.jsxs)(n.p,{children:["In this example, we have a ZIO application that uses the ",(0,t.jsx)(n.code,{children:"Logging"})," service. And we provided two implementations of the ",(0,t.jsx)(n.code,{children:"Logging"})," service: ",(0,t.jsx)(n.code,{children:"SimpleLogger"})," and ",(0,t.jsx)(n.code,{children:"DateTimeLogger"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nimport java.io.IOException\n\ntrait Logging {\n  def log(msg: String): ZIO[Any, IOException, Unit]\n}\n\nobject Logging {\n  def log(msg: String): ZIO[Logging, IOException, Unit] =\n    ZIO.serviceWithZIO[Logging](_.log(msg))\n}\n\ncase class DateTimeLogger() extends Logging {\n  override def log(msg: String): ZIO[Any, IOException, Unit] =\n    for {\n      dt <- Clock.currentDateTime\n      _  <- Console.printLine(s"$dt: $msg")\n    } yield ()\n}\n\nobject DateTimeLogger {\n  val live: ULayer[DateTimeLogger] =\n    ZLayer.succeed(DateTimeLogger())\n}\n\ncase class SimpleLogger() extends Logging {\n  override def log(msg: String): ZIO[Any, IOException, Unit] =\n    Console.printLine(msg)\n}\nobject SimpleLogger {\n  val live: ULayer[SimpleLogger] =\n    ZLayer.succeed(SimpleLogger())\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Now, let's write a ZIO application that uses the ",(0,t.jsx)(n.code,{children:"Logging"})," service:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nval myApp: ZIO[Logging, IOException, Unit] =\n  for {\n    _ <- Logging.log("Application started.")\n    _ <- Logging.log("Application ended.")\n  } yield ()\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Now, we can run our application, just by providing one of the implementations of the ",(0,t.jsx)(n.code,{children:"Logging"})," service. Let's run it with the ",(0,t.jsx)(n.code,{children:"SimpleLogger"})," implementation:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"object MainApp extends ZIOAppDefault {\n  def run = myApp.provide(SimpleLogger.live)\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Now, we can see that, without changing the core logic of our application, we can easily change the logger implementation:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"object MainApp extends ZIOAppDefault {\n  def run = myApp.provide(DateTimeLogger.live)\n}\n"})})]})}function g(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}}}]);