"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[70979],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>s});var a=t(96540);const o={},i=a.createContext(o);function r(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),a.createElement(i.Provider,{value:n},e.children)}},98540:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"guides/interop/with-java","title":"How to Interop with Java?","description":"ZIO has full interoperability with foreign Java code. Let me show you how it works and then BOOM, tomorrow you can show off your purely functional Java at work.","source":"@site/docs/guides/interop/with-java.md","sourceDirName":"guides/interop","slug":"/guides/interop/with-java","permalink":"/guides/interop/with-java","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/guides/interop/with-java.md","tags":[],"version":"current","frontMatter":{"id":"with-java","title":"How to Interop with Java?","sidebar_label":"Java"},"sidebar":"guides-sidebar","previous":{"title":"Scala\'s Future","permalink":"/guides/interop/with-future"},"next":{"title":"JavaScript","permalink":"/guides/interop/with-javascript"}}');var o=t(74848),i=t(28453);const r={id:"with-java",title:"How to Interop with Java?",sidebar_label:"Java"},s=void 0,l={},c=[{value:"From Java CompletionStage and back",id:"from-java-completionstage-and-back",level:2},{value:"Java Future",id:"java-future",level:2},{value:"NIO Completion handler",id:"nio-completion-handler",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:["ZIO has full interoperability with foreign Java code. Let me show you how it works and then ",(0,o.jsx)(n.em,{children:"BOOM"}),", tomorrow you can show off your purely functional Java at work."]}),"\n",(0,o.jsxs)(n.p,{children:["ZIO has built-in conversion between ZIO data types (like ",(0,o.jsx)(n.code,{children:"ZIO"})," and ",(0,o.jsx)(n.code,{children:"Fiber"}),") and Java concurrent data types like ",(0,o.jsx)(n.a,{href:"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html",children:(0,o.jsx)(n.code,{children:"CompletionStage"})}),", ",(0,o.jsx)(n.a,{href:"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html",children:(0,o.jsx)(n.code,{children:"Future"})})," and ",(0,o.jsx)(n.a,{href:"https://docs.oracle.com/javase/8/docs/api/java/nio/channels/CompletionHandler.html",children:(0,o.jsx)(n.code,{children:"CompletionHandler"})}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"from-java-completionstage-and-back",children:"From Java CompletionStage and back"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"CompletionStage"})," is the interface that comes closest to emulate a functional asynchronous effects API like ZIO's, so we start with it. It's a breeze:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'def loggedStage[A](stage: => CompletionStage[A]): Task[A] =\n    ZIO.fromCompletionStage(UIO {\n        stage.thenApplyAsync { a =>\n            println("Stage completed with " + a)\n            a\n        }\n    })\n'})}),"\n",(0,o.jsx)(n.p,{children:"By Jove, you can even turn it into fiber!"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"def stageToFiber[A](stage: => CompletionStage[A]): Fiber[Throwable, A] = \n  Fiber.fromCompletionStage(future)\n"})}),"\n",(0,o.jsx)(n.p,{children:"This API creates a synthetic fiber which doesn't have any notion of identity."}),"\n",(0,o.jsxs)(n.p,{children:["Additionally, you may want to go the other way and convert a ZIO value into a ",(0,o.jsx)(n.code,{children:"CompletionStage"}),". Easy as pie:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"def taskToStage[A](task: Task[A]): UIO[CompletableFuture[A]] =\n    task.toCompletableFuture\n"})}),"\n",(0,o.jsxs)(n.p,{children:["As you can see, it commits to a concrete class implementing the ",(0,o.jsx)(n.code,{children:"CompletionStage"})," interface, i.e. ",(0,o.jsx)(n.code,{children:"CompletableFuture"}),". It is worth to point out that any ",(0,o.jsx)(n.code,{children:"IO[E, A]"})," can be turned into a completable future provided you can turn a value of type ",(0,o.jsx)(n.code,{children:"E"})," into a ",(0,o.jsx)(n.code,{children:"Throwable"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"def ioToStage[E, A](io: IO[E, A])(toThrowable: E => Throwable): UIO[CompletableFuture[A]] =\n    io.toCompletableFutureWith(toThrowable)\n"})}),"\n",(0,o.jsx)(n.h2,{id:"java-future",children:"Java Future"}),"\n",(0,o.jsxs)(n.p,{children:["You can embed any ",(0,o.jsx)(n.code,{children:"java.util.concurrent.Future"})," in a ZIO computation via ",(0,o.jsx)(n.code,{children:"ZIO.fromFutureJava"}),". A toy wrapper around Apache Async HTTP client could look like:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"def execute(client: HttpAsyncClient, request: HttpUriRequest): RIO[Blocking, HttpResponse] =\n    ZIO.fromFutureJava(UIO {\n        client.execute(request, null)\n    })\n"})}),"\n",(0,o.jsxs)(n.p,{children:["That's it. Just a bit of a warning here, mate. As you can see from the requirement on the produced value, ZIO uses the blocking ",(0,o.jsx)(n.code,{children:"Future#get"})," call internally. It is running on the blocking thread pool, of course, but I thought you should know. If possible, use ",(0,o.jsx)(n.code,{children:"ZIO.fromCompletionStage"})," instead, as detailed above."]}),"\n",(0,o.jsxs)(n.p,{children:["Should you need it, it is also possible to convert a future into a fiber using ",(0,o.jsx)(n.code,{children:"Fiber.fromFutureJava"}),". Same same, but different:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"def execute(client: HttpAsyncClient, request: HttpUriRequest): Fiber[Throwable, HttpResponse] =\n    Fiber.fromFutureJava {\n        client.execute(request, null)\n    }\n"})}),"\n",(0,o.jsx)(n.h2,{id:"nio-completion-handler",children:"NIO Completion handler"}),"\n",(0,o.jsx)(n.p,{children:"Java libraries using channels from the NIO API for asynchronous, interruptible I/O can be hooked into by providing completion handlers. As in, reading the contents of a file:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"def readFile(file: AsynchronousFileChannel): Task[Chunk[Byte]] = for {\n    pos <- Ref.make(0)\n    buf <- ZIO.succeed(ByteBuffer.allocate(1024))\n    contents <- Ref.make[Chunk[Byte]](Chunk.empty)\n    def go = pos.get.flatMap { p =>\n        ZIO.asyncWithCompletionHandler[Chunk[Byte]] { handler =>\n            file.read(buf, p, buf, handler)\n        }.flatMap {\n            case -1 => contents.get\n            case n  =>\n                ZIO.succeed {\n                    val arr = Array.ofDim[Byte](n)\n                    buf.get(arr, 0, n)\n                    buf.clear()\n                    Chunk.fromArray(arr)\n                }.flatMap { slice =>\n                    contents.update(_ ++ slice)\n                } *> pos.update(_ + n) *> go\n        }\n    }\n    dump <- go\n} yield dump\n"})}),"\n",(0,o.jsx)(n.p,{children:"As you can see, ZIO provides a CPS-style API here which is a bit different from the two sections above, but hey still super elegant."})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);