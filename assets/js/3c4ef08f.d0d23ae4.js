"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[77548],{68290:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>r,metadata:()=>n,toc:()=>a});const n=JSON.parse('{"id":"zio-sql/index","title":"Introduction to ZIO SQL","description":"ZIO SQL lets you write type-safe, type-inferred, and composable SQL queries in ordinary Scala, helping you prevent persistence bugs before they happen, and leverage your IDE to make writing SQL productive, safe, and fun.","source":"@site/docs/zio-sql/index.md","sourceDirName":"zio-sql","slug":"/zio-sql/","permalink":"/zio-sql/","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-sql/index.md","tags":[],"version":"current","frontMatter":{"id":"index","title":"Introduction to ZIO SQL","sidebar_label":"ZIO SQL"},"sidebar":"ecosystem-sidebar","previous":{"title":"ZIO SBT","permalink":"/zio-sbt/"},"next":{"title":"Deep dive","permalink":"/zio-sql/deep-dive"}}');var l=s(74848),i=s(28453);const r={id:"index",title:"Introduction to ZIO SQL",sidebar_label:"ZIO SQL"},d=void 0,o={},a=[{value:"Introduction",id:"introduction",level:2},{value:"Current status: Non-production release",id:"current-status-non-production-release",level:2},{value:"Progress report towards 0.1",id:"progress-report-towards-01",level:3},{value:"General features:",id:"general-features",level:4},{value:"Db-specific features:",id:"db-specific-features",level:4},{value:"Installation",id:"installation",level:2},{value:"Imports and modules",id:"imports-and-modules",level:2},{value:"Table schema",id:"table-schema",level:2},{value:"Table schema decomposition",id:"table-schema-decomposition",level:2},{value:"Selects",id:"selects",level:2},{value:"Inserts",id:"inserts",level:2},{value:"Updates",id:"updates",level:2},{value:"Deletes",id:"deletes",level:2},{value:"Transactions",id:"transactions",level:2},{value:"Printing queries",id:"printing-queries",level:2},{value:"Running queries",id:"running-queries",level:2}];function c(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(t.p,{children:"ZIO SQL lets you write type-safe, type-inferred, and composable SQL queries in ordinary Scala, helping you prevent persistence bugs before they happen, and leverage your IDE to make writing SQL productive, safe, and fun."}),"\n",(0,l.jsxs)(t.p,{children:[(0,l.jsx)(t.a,{href:"https://github.com/zio/zio/wiki/Project-Stages",children:(0,l.jsx)(t.img,{src:"https://img.shields.io/badge/Project%20Stage-Production%20Ready-brightgreen.svg",alt:"Production Ready"})})," ",(0,l.jsx)(t.img,{src:"https://github.com/zio/zio-sql/workflows/CI/badge.svg",alt:"CI Badge"})," ",(0,l.jsx)(t.a,{href:"https://oss.sonatype.org/content/repositories/releases/dev/zio/zio-sql_2.13/",children:(0,l.jsx)(t.img,{src:"https://img.shields.io/nexus/r/https/oss.sonatype.org/dev.zio/zio-sql_2.13.svg?label=Sonatype%20Release",alt:"Sonatype Releases"})})," ",(0,l.jsx)(t.a,{href:"https://oss.sonatype.org/content/repositories/snapshots/dev/zio/zio-sql_2.13/",children:(0,l.jsx)(t.img,{src:"https://img.shields.io/nexus/s/https/oss.sonatype.org/dev.zio/zio-sql_2.13.svg?label=Sonatype%20Snapshot",alt:"Sonatype Snapshots"})})," ",(0,l.jsx)(t.a,{href:"https://javadoc.io/doc/dev.zio/zio-sql-docs_2.13",children:(0,l.jsx)(t.img,{src:"https://javadoc.io/badge2/dev.zio/zio-sql-docs_2.13/javadoc.svg",alt:"javadoc"})})," ",(0,l.jsx)(t.a,{href:"https://github.com/zio/zio-sql",children:(0,l.jsx)(t.img,{src:"https://img.shields.io/github/stars/zio/zio-sql?style=social",alt:"ZIO SQL"})})]}),"\n",(0,l.jsx)(t.h2,{id:"introduction",children:"Introduction"}),"\n",(0,l.jsxs)(t.ul,{children:["\n",(0,l.jsxs)(t.li,{children:[(0,l.jsx)(t.strong,{children:"Type-safety"}),". ZIO SQL queries are type-safe by construction. Most classes of bugs can be detected at compile-time, shortening your feedback loop and helping you use your IDE to write correct queries."]}),"\n",(0,l.jsxs)(t.li,{children:[(0,l.jsx)(t.strong,{children:"Composable"}),". All ZIO SQL components are ordinary values, which can be transformed and composed in sensible ways. This uniformity and regularity means you have a lot of power in a small package."]}),"\n",(0,l.jsxs)(t.li,{children:[(0,l.jsx)(t.strong,{children:"Type-inferred"}),". ZIO SQL uses maximal variance and lower-kinded types, which means it features very good type inference. You can let Scala figure out the types required for type-safe SQL."]}),"\n",(0,l.jsxs)(t.li,{children:[(0,l.jsx)(t.strong,{children:"No magic"}),". ZIO SQL does not need any macros or plug-ins to operate (everything is a value!), and it works across both Scala 2.x and Scala 3. Optionally, Scala schema can be created from database schemas."]}),"\n"]}),"\n",(0,l.jsx)(t.p,{children:"ZIO SQL can be used as a library for modeling SQL in a type-safe ADT. In addition, ZIO SQL has a JDBC interface, which utilizes the type-safe SQL ADT for interacting with common JDBC databases."}),"\n",(0,l.jsx)(t.p,{children:"For the JDBC module:"}),"\n",(0,l.jsxs)(t.ul,{children:["\n",(0,l.jsx)(t.li,{children:"Like Slick, ZIO SQL has an emphasis on type-safe SQL construction using Scala values and methods. However, ZIO SQL utilizes reified lenses, contravariant intersection types, and in-query nullability to improve ergonomics for end-users. Unlike Slick, the intention is to use names resembling SQL instead of trying to mimic the Scala collections."}),"\n",(0,l.jsx)(t.li,{children:"Like Doobie, ZIO SQL is purely functional, but ZIO SQL does compile-time query validation that catches most issues, and has rich ZIO integration, offering improved type-safety compared to monofunctor effects and minimal dependencies (depending only on ZIO)."}),"\n"]}),"\n",(0,l.jsx)(t.p,{children:"ZIO SQL does not offer Language Integrated Queries (LINQ) or similar functionality. It is intended only as a data model for representing SQL queries and an accompanying lightweight JDBC-based executor."}),"\n",(0,l.jsx)(t.h2,{id:"current-status-non-production-release",children:"Current status: Non-production release"}),"\n",(0,l.jsx)(t.h3,{id:"progress-report-towards-01",children:"Progress report towards 0.1"}),"\n",(0,l.jsxs)(t.p,{children:["\u2714\ufe0f"," - good to go"]}),"\n",(0,l.jsxs)(t.p,{children:["\u2705"," - some more work needed"]}),"\n",(0,l.jsx)(t.h4,{id:"general-features",children:"General features:"}),"\n",(0,l.jsxs)(t.table,{children:[(0,l.jsx)(t.thead,{children:(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.th,{style:{textAlign:"left"},children:"Feature"}),(0,l.jsx)(t.th,{style:{textAlign:"left"},children:"Progress"})]})}),(0,l.jsxs)(t.tbody,{children:[(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"Type-safe schema"}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"\u2714\ufe0f"})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"Type-safe DSL"}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"\u2714\ufe0f"})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"Running Reads"}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"\u2714\ufe0f"})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"Running Deletes"}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"\u2714\ufe0f"})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"Running Updates"}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"\u2714\ufe0f"})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"Running Inserts"}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"\u2714\ufe0f"})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"Transactions"}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"\u2705"})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"Connection pool"}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"\u2705"})]})]})]}),"\n",(0,l.jsx)(t.h4,{id:"db-specific-features",children:"Db-specific features:"}),"\n",(0,l.jsxs)(t.table,{children:[(0,l.jsx)(t.thead,{children:(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.th,{style:{textAlign:"left"},children:"Feature"}),(0,l.jsx)(t.th,{style:{textAlign:"left"},children:"PostgreSQL"}),(0,l.jsx)(t.th,{style:{textAlign:"left"},children:"SQL Server"}),(0,l.jsx)(t.th,{style:{textAlign:"left"},children:"Oracle"}),(0,l.jsx)(t.th,{style:{textAlign:"left"},children:"MySQL"})]})}),(0,l.jsxs)(t.tbody,{children:[(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"Render Read"}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"\u2714\ufe0f"}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"\u2714\ufe0f"}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"\u2714\ufe0f"}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"\u2714\ufe0f"})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"Render Delete"}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"\u2714\ufe0f"}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"\u2714\ufe0f"}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"\u2714\ufe0f"}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"\u2714\ufe0f"})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"Render Update"}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"\u2714\ufe0f"}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"\u2714\ufe0f"}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"\u2714\ufe0f"}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"\u2714\ufe0f"})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"Render Insert"}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"\u2714\ufe0f"}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"\u2714\ufe0f"}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"\u2714\ufe0f"}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"\u2714\ufe0f"})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"Functions"}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"\u2714\ufe0f"}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"\u2714\ufe0f"}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"\u2714\ufe0f"}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"\u2714\ufe0f"})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"Types"}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"\u2705"}),(0,l.jsx)(t.td,{style:{textAlign:"left"}}),(0,l.jsx)(t.td,{style:{textAlign:"left"}}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"\u2705"})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"Operators"}),(0,l.jsx)(t.td,{style:{textAlign:"left"}}),(0,l.jsx)(t.td,{style:{textAlign:"left"}}),(0,l.jsx)(t.td,{style:{textAlign:"left"}}),(0,l.jsx)(t.td,{style:{textAlign:"left"}})]})]})]}),"\n",(0,l.jsx)(t.h2,{id:"installation",children:"Installation"}),"\n",(0,l.jsx)(t.p,{children:"ZIO SQL is packaged into separate modules for different databases. Depending on which of these (currently supported) systems you're using, you will need to add one of the following dependencies:"}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-scala",children:'//PostgreSQL\nlibraryDependencies += "dev.zio" %% "zio-sql-postgres" % "0.1.2" \n\n//MySQL\nlibraryDependencies += "dev.zio" %% "zio-sql-mysql" % "0.1.2"\n\n//Oracle\nlibraryDependencies += "dev.zio" %% "zio-sql-oracle" % "0.1.2"\n\n//SQL Server\nlibraryDependencies += "dev.zio" %% "zio-sql-sqlserver" % "0.1.2"\n'})}),"\n",(0,l.jsx)(t.h2,{id:"imports-and-modules",children:"Imports and modules"}),"\n",(0,l.jsx)(t.p,{children:"Most of the needed imports will be resolved with"}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-scala",children:"import zio.sql._\n"})}),"\n",(0,l.jsx)(t.p,{children:"ZIO SQL relies heavily on path dependent types, so to use most of the features you need to be in the scope of one of the database modules:"}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-scala",children:"trait MyRepositoryModule extends PostgresModule {\n\n  // your ZIO SQL code here\n\n}\n\n// other available modules are MysqlModule, OracleModule and SqlServerModule\n"})}),"\n",(0,l.jsx)(t.p,{children:"We will assume this scope in the following examples."}),"\n",(0,l.jsx)(t.h2,{id:"table-schema",children:"Table schema"}),"\n",(0,l.jsx)(t.p,{children:"In order to construct correct and type-safe queries, we need to describe tables by writing user defined data type - case class in which\nname of the case class represents table name, field names represent column names and field types represent column types."}),"\n",(0,l.jsxs)(t.p,{children:["Values that will represent tables in DSL are then created by calling ",(0,l.jsx)(t.code,{children:"defineTable"})," method which takes case class type parameter.\nIn order for ",(0,l.jsx)(t.code,{children:"defineTable"})," to work, user need to provide implicit ",(0,l.jsx)(t.code,{children:"Schema"})," of data type."]}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-scala",children:"import java.util.UUID\nimport zio.sql.postgresql.PostgresJdbcModule\nimport java.time._\n\nobject Repository extends PostgresJdbcModule {\n  final case class Product(id: UUID, name: String, price: BigDecimal)\n  implicit val productSchema = DeriveSchema.gen[Product]\n\n  val products = defineTableSmart[Product]\n  \n  final case class Order(id: UUID, productId: UUID, quantity: Int, orderDate: LocalDate)\n  implicit val orderSchema = DeriveSchema.gen[Order]\n  \n  val orders = defineTable[Order]\n}\n"})}),"\n",(0,l.jsxs)(t.p,{children:[(0,l.jsx)(t.code,{children:"defineTable"})," method is overloaded with an alternative that takes table name as an input. User can also specify table name using ",(0,l.jsx)(t.code,{children:"@name"})," annotation.\nAlternatively user can use ",(0,l.jsx)(t.code,{children:"defineTableSmart"})," method which will smartly pluralize table name according to english grammar.\n",(0,l.jsx)(t.code,{children:"OrderOrigin"})," -> ",(0,l.jsx)(t.code,{children:"order_origins"}),"\n",(0,l.jsx)(t.code,{children:"Foot"})," -> ",(0,l.jsx)(t.code,{children:"feet"}),"\n",(0,l.jsx)(t.code,{children:"PersonAddress"})," -> ",(0,l.jsx)(t.code,{children:"person_addresses"}),"\nField names are also converted to lowercase and snake case.\n",(0,l.jsx)(t.code,{children:"productId"})," -> ",(0,l.jsx)(t.code,{children:"product_id"})," and so on."]}),"\n",(0,l.jsx)(t.h2,{id:"table-schema-decomposition",children:"Table schema decomposition"}),"\n",(0,l.jsxs)(t.p,{children:["Once we have our table definition we need to decompose table into columns which we will use in queries.\nUsing the previous example with ",(0,l.jsx)(t.code,{children:"Product"})," and ",(0,l.jsx)(t.code,{children:"Order"})," table"]}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-scala",children:"val (id, name, price) = products.columns\n\nval (orderId, productId, quantity) = orders.columns\n"})}),"\n",(0,l.jsx)(t.h2,{id:"selects",children:"Selects"}),"\n",(0,l.jsx)(t.p,{children:"Simple select."}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-scala",children:"val allProducts = select(productId, name, price).from(products)\n"})}),"\n",(0,l.jsxs)(t.p,{children:["Using ",(0,l.jsx)(t.code,{children:"where"})," clause."]}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-scala",children:"def productById(id: UUID) = \n  select(productId, name, price).from(products).where(productId === id)\n"})}),"\n",(0,l.jsx)(t.p,{children:"Inner join."}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-scala",children:"val ordersWithProductNames = \n  select(orderId, name).from(products.join(orders).on(productId === fkProductId))\n"})}),"\n",(0,l.jsx)(t.p,{children:"Left outer join."}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-scala",children:"val leftOuter = \n  select(orderId, name).from(products.leftOuter(orders).on(productId === fkProductId))\n"})}),"\n",(0,l.jsx)(t.p,{children:"Right outer join."}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-scala",children:"val rightOuter = \n  select(orderId, name).from(products.rightOuter(orders).on(productId === fkProductId))\n"})}),"\n",(0,l.jsxs)(t.p,{children:["Using ",(0,l.jsx)(t.code,{children:"limit"})," and ",(0,l.jsx)(t.code,{children:"offset"})]}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-scala",children:"val limitedResults = \n  select(orderId, name)\n    .from(products.join(orders)\n    .on(productId === fkProductId))\n    .limit(5)\n    .offset(10)\n"})}),"\n",(0,l.jsx)(t.h2,{id:"inserts",children:"Inserts"}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-scala",children:'insertInto(products)\n    (productId, name, price)\n  .values((UUID.randomUUID(), "Zionomicon", 10.5))\n'})}),"\n",(0,l.jsx)(t.h2,{id:"updates",children:"Updates"}),"\n",(0,l.jsx)(t.p,{children:"TODO: details"}),"\n",(0,l.jsx)(t.h2,{id:"deletes",children:"Deletes"}),"\n",(0,l.jsx)(t.p,{children:"TODO: details"}),"\n",(0,l.jsx)(t.h2,{id:"transactions",children:"Transactions"}),"\n",(0,l.jsx)(t.p,{children:"TODO: details"}),"\n",(0,l.jsx)(t.h2,{id:"printing-queries",children:"Printing queries"}),"\n",(0,l.jsx)(t.p,{children:"TODO: details"}),"\n",(0,l.jsx)(t.h2,{id:"running-queries",children:"Running queries"}),"\n",(0,l.jsx)(t.p,{children:"TODO: details"})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,l.jsx)(t,{...e,children:(0,l.jsx)(c,{...e})}):c(e)}},28453:(e,t,s)=>{s.d(t,{R:()=>r,x:()=>d});var n=s(96540);const l={},i=n.createContext(l);function r(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:r(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);