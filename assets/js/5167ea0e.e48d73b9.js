"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[24811],{28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>s});var i=n(96540);const o={},a=i.createContext(o);function r(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(a.Provider,{value:t},e.children)}},38557:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>l,frontMatter:()=>r,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"zio-prelude/functional-abstractions/parameterized-types/identityeither","title":"IdentityEither","description":"IdentityEither[F] describes an associative way to combine two values F[A] and F[B] into a value F[Either[A, B]] with an identity value none of type F[Nothing].","source":"@site/docs/zio-prelude/functional-abstractions/parameterized-types/identityeither.md","sourceDirName":"zio-prelude/functional-abstractions/parameterized-types","slug":"/zio-prelude/functional-abstractions/parameterized-types/identityeither","permalink":"/zio-prelude/functional-abstractions/parameterized-types/identityeither","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-prelude/functional-abstractions/parameterized-types/identityeither.md","tags":[],"version":"current","frontMatter":{"id":"identityeither","title":"IdentityEither"},"sidebar":"ecosystem-sidebar","previous":{"title":"IdentityBoth","permalink":"/zio-prelude/functional-abstractions/parameterized-types/identityboth"},"next":{"title":"IdentityFlatten","permalink":"/zio-prelude/functional-abstractions/parameterized-types/identityflatten"}}');var o=n(74848),a=n(28453);const r={id:"identityeither",title:"IdentityEither"},s=void 0,c={},h=[];function d(e){const t={code:"code",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"IdentityEither[F]"})," describes an associative way to combine two values ",(0,o.jsx)(t.code,{children:"F[A]"})," and ",(0,o.jsx)(t.code,{children:"F[B]"})," into a value ",(0,o.jsx)(t.code,{children:"F[Either[A, B]]"})," with an identity value ",(0,o.jsx)(t.code,{children:"none"})," of type ",(0,o.jsx)(t.code,{children:"F[Nothing]"}),"."]}),"\n",(0,o.jsx)(t.p,{children:"Its signature is:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:"trait AssociativeEither[F[_]] {\n  def either[A, B](fa: => F[A], fb: => F[B]): F[Either[A, B]]\n}\n\ntrait IdentityEither[F[_]] extends AssociativeEither[F] {\n  def none: F[Nothing]\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"none"})," value must be an identity element with respect to the ",(0,o.jsx)(t.code,{children:"either"})," operator so that, after eliminating cases of ",(0,o.jsx)(t.code,{children:"Either"})," that can never contain values, the following property holds:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:"fa <+> none === fa\nnone <+> fa === fa\n"})}),"\n",(0,o.jsxs)(t.p,{children:["This is the same as the law for the ",(0,o.jsx)(t.code,{children:"Identity"})," abstraction for concrete types but lifted into the context of parameterized types."]}),"\n",(0,o.jsxs)(t.p,{children:["To satisfy these properties, rhe ",(0,o.jsx)(t.code,{children:"none"})," value  must must be a value that fails with no useful information."]}),"\n",(0,o.jsxs)(t.p,{children:["To see what this means, let's look at the ",(0,o.jsx)(t.code,{children:"IdentityEither"})," instance for ",(0,o.jsx)(t.code,{children:"Option"}),"."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:"import zio.prelude._\n\nimplicit val OptionIdentityEither: IdentityEither[Option] =\n  new IdentityEither[Option] {\n    def either[A, B](fa: => Option[A], fb: => Option[B]): Option[Either[A, B]] =\n      fa match {\n        case None =>\n          fb match {\n            case None    => None\n            case Some(b) => Some(Right(b))\n          }\n        case Some(a) => Some(Left(a))\n      }\n    val none: Option[Nothing] =\n      None\n  }\n// OptionIdentityEither: IdentityEither[Option] = repl.MdocSession$MdocApp0$$anon$1@54cca837\n"})}),"\n",(0,o.jsxs)(t.p,{children:["If we think of an ",(0,o.jsx)(t.code,{children:"Option[A]"})," as representing either a success with a value of type ",(0,o.jsx)(t.code,{children:"A"})," or a failure with no useful information, then the implementation of ",(0,o.jsx)(t.code,{children:"none"})," is ",(0,o.jsx)(t.code,{children:"None"}),". Combining any ",(0,o.jsx)(t.code,{children:"Option[A]"})," with ",(0,o.jsx)(t.code,{children:"None"})," with ",(0,o.jsx)(t.code,{children:"orElseEither"})," won't change its result."]}),"\n",(0,o.jsxs)(t.p,{children:["Now let's compare that to ",(0,o.jsx)(t.code,{children:"Either"})," to see why we can't define a ",(0,o.jsx)(t.code,{children:"IdentityEither"})," instance for ",(0,o.jsx)(t.code,{children:"Either"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["We said that the identity value must be a value that fails with no useful information but ",(0,o.jsx)(t.code,{children:"Either"})," is polymorphic in its error type so we can't define what a value that contains no information would be for an arbitrary type. We don't even know how to construct an value of that type."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:"def none[E]: Either[E, Nothing] =\n  Left(???)\n"})}),"\n",(0,o.jsxs)(t.p,{children:["To define an identity value we would have to have the concept of an empty error. For example, if we created a data type that could fail without any error then the empty failure would be the ",(0,o.jsx)(t.code,{children:"none"})," value."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:"import zio.Chunk\n\nval noneOption: Either[Option[Nothing], Nothing] =\n  Left(None)\n// noneOption: Either[Option[Nothing], Nothing] = Left(value = None)\n\nval noneChunk: Either[Chunk[Nothing], Nothing] =\n  Left(Chunk.empty)\n// noneChunk: Either[Chunk[Nothing], Nothing] = Left(value = IndexedSeq())\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Having this ",(0,o.jsx)(t.code,{children:"none"})," value can be useful in certain situations. For example, it can help us to define a ",(0,o.jsx)(t.code,{children:"filter"})," operator on a data type in combination with some of the other functional abstractions in ZIO Prelude."]}),"\n",(0,o.jsxs)(t.p,{children:["However, supporting a ",(0,o.jsx)(t.code,{children:"none"})," value requires allowing the possibility of that a value can fail without containing any errors, which is unattractive in many cases."]}),"\n",(0,o.jsxs)(t.p,{children:["For example, ",(0,o.jsx)(t.code,{children:"ZIO"})," and most effect types such as ",(0,o.jsx)(t.code,{children:"ZManaged"})," and ",(0,o.jsx)(t.code,{children:"ZStream"})," do not have an ",(0,o.jsx)(t.code,{children:"IdentityEither"})," instance defined for them because is they fail they always fail with a failure ",(0,o.jsx)(t.code,{children:"E"}),". Otherwise when we used an error handling operator we would have to deal with the error as well as the possibility that there is a failure but no error at all."]}),"\n",(0,o.jsxs)(t.p,{children:["Note that in the case of ",(0,o.jsx)(t.code,{children:"ZIO"})," a workflow can also die with a cause that can potentially be ",(0,o.jsx)(t.code,{children:"Cause.empty"}),", but since the associative operator ",(0,o.jsx)(t.code,{children:"orElseEither"})," does not recover from ",(0,o.jsx)(t.code,{children:"Die"})," failures that doesn't help us with our problem here."]}),"\n",(0,o.jsxs)(t.p,{children:["The other data types that do tend to have ",(0,o.jsx)(t.code,{children:"IdentityEither"})," instances are collection types that can be empty. For example, the ",(0,o.jsx)(t.code,{children:"IdentityEither"})," instance for ",(0,o.jsx)(t.code,{children:"Chunk"})," looks like this."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:"implicit val ChunkIdentityEither: IdentityEither[Chunk] =\n  new IdentityEither[Chunk] {\n    def either[A, B](as: => Chunk[A], bs: => Chunk[B]): Chunk[Either[A, B]] =\n      as.map(Left(_)) ++ bs.map(Right(_))\n    val none: Chunk[Nothing] =\n      Chunk.empty\n  }\n// ChunkIdentityEither: IdentityEither[Chunk] = repl.MdocSession$MdocApp0$$anon$2@6552df40\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Here the identity element is just the empty chunk. If we think of running a collection as producing a set of values and then failing when the collection is empty, ",(0,o.jsx)(t.code,{children:"none"})," is the collection that doesn't produce any values and fails immediately."]}),"\n",(0,o.jsxs)(t.p,{children:["Another more mathematical way to think about it is that if concatenation corresponds to addition then the empty collection corresponds to zero. or this reason, we can also see that collections that cannot be empty, such as ",(0,o.jsx)(t.code,{children:"NonEmptyChunk"})," from ZIO or ",(0,o.jsx)(t.code,{children:"NonEmptyList"})," from ZIO Prelude, cannot have ",(0,o.jsx)(t.code,{children:"IdentityEither"})," instances defined for them."]}),"\n",(0,o.jsxs)(t.p,{children:["We can also define ",(0,o.jsx)(t.code,{children:"none"})," values for contravariant types, though these tend to be less interesting."]}),"\n",(0,o.jsxs)(t.p,{children:["For contravariant types, the ",(0,o.jsx)(t.code,{children:"none"})," value corresponds to a value that can never be run because it has ",(0,o.jsx)(t.code,{children:"Nothing"})," as its input type and there are no values of type ",(0,o.jsx)(t.code,{children:"Nothing"}),". There the existence of the ",(0,o.jsx)(t.code,{children:"none"})," value and our ability to compose it with the ",(0,o.jsx)(t.code,{children:"orElseEither"})," operator in implies that values can be run independently of each other."]}),"\n",(0,o.jsxs)(t.p,{children:["For example, let's look at the ",(0,o.jsx)(t.code,{children:"IdentityEither"})," instance for ",(0,o.jsx)(t.code,{children:"Predicate"}),"."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:"trait Predicate[-A] {\n  def run(a: A): Boolean\n}\n\nobject Predicate {\n  implicit val PredicateIdentityEither: IdentityEither[Predicate] =\n    new IdentityEither[Predicate] {\n      def either[A, B](left: => Predicate[A], right: => Predicate[B]): Predicate[Either[A, B]] =\n        new Predicate[Either[A, B]] {\n          def run(either: Either[A, B]): Boolean =\n            either match {\n              case Left(a) => left.run(a)\n              case Right(b) => right.run(b)\n            }\n        }\n      val none: Predicate[Nothing] =\n        new Predicate[Nothing] {\n          def run(a: Nothing): Boolean =\n            a\n    }\n  }\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"none"})," predicate can never be run, but we can still safely compose it with other predicates with the ",(0,o.jsx)(t.code,{children:"either"})," operator because since there can never be a value of type ",(0,o.jsx)(t.code,{children:"Nothing"}),", there can also never be a case where the ",(0,o.jsx)(t.code,{children:"either"})," operator tries to run the ",(0,o.jsx)(t.code,{children:"none"})," predicate."]}),"\n",(0,o.jsxs)(t.p,{children:["Overall the ",(0,o.jsx)(t.code,{children:"IdentityEither"})," abstraction is a useful one to generalize over the concept of a value of a parameterized type that always fails with no information, complementing the concept of a value that always succeeds with no information from ",(0,o.jsx)(t.code,{children:"IdentityBoth"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["For concrete types that have such a ",(0,o.jsx)(t.code,{children:"none"})," value there tend to be existing operators defined on the data type that already take advantage of this this functionality, so ",(0,o.jsx)(t.code,{children:"IdentityEither"})," tends to be less helpful when working with concrete data types."]}),"\n",(0,o.jsxs)(t.p,{children:["For defining your own data types thinking about whether there is a ",(0,o.jsx)(t.code,{children:"none"})," value can be helpful for API design. As discussed above, there is often a trade off between having an identity element, which is generally a good thing, and providing the guarantee that all failures contain some useful information."]}),"\n",(0,o.jsxs)(t.p,{children:["Defining an ",(0,o.jsx)(t.code,{children:"IdentityEither"})," instance for your own data type will also let you work with generic code in ZIO Prelude that uses this abstraction."]}),"\n",(0,o.jsxs)(t.p,{children:["Finally ",(0,o.jsx)(t.code,{children:"IdentityEither"}),' can be useful when you are writing generic code to describe the concept that a data type must have this failure element with no information to provide a "default" failure value.']})]})}function l(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);