"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[7269],{932:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>t,toc:()=>f});const t=JSON.parse('{"id":"reference/error-management/operations/chaining-effects-based-on-errors","title":"Chaining Effects Based on Errors","description":"Unlike ZIO#flatMap the ZIO#flatMapError combinator chains two effects, where the second effect is dependent on the error channel of the first effect:","source":"@site/docs/reference/error-management/operations/chaining-effects-based-on-errors.md","sourceDirName":"reference/error-management/operations","slug":"/reference/error-management/operations/chaining-effects-based-on-errors","permalink":"/reference/error-management/operations/chaining-effects-based-on-errors","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/error-management/operations/chaining-effects-based-on-errors.md","tags":[],"version":"current","frontMatter":{"id":"chaining-effects-based-on-errors","title":"Chaining Effects Based on Errors"},"sidebar":"reference-sidebar","previous":{"title":"Map Operations","permalink":"/reference/error-management/operations/map-operations"},"next":{"title":"Filtering the Success Channel","permalink":"/reference/error-management/operations/filtering-the-success-channel"}}');var i=r(74848),o=r(28453);const s={id:"chaining-effects-based-on-errors",title:"Chaining Effects Based on Errors"},a=void 0,c={},f=[];function l(e){const n={code:"code",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Unlike ",(0,i.jsx)(n.code,{children:"ZIO#flatMap"})," the ",(0,i.jsx)(n.code,{children:"ZIO#flatMapError"})," combinator chains two effects, where the second effect is dependent on the error channel of the first effect:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"trait ZIO[-R, +E, +A] {\n  def flatMapError[R1 <: R, E2](\n    f: E => ZIO[R1, Nothing, E2]\n  ): ZIO[R1, E2, A]\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the following example, we are trying to find a random prime number between 1000 and 10000. We will use the ",(0,i.jsx)(n.code,{children:"ZIO#flatMapError"})," to collect all errors inside a ",(0,i.jsx)(n.code,{children:"Ref"})," of type ",(0,i.jsx)(n.code,{children:"List[String]"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def isPrime(n: Int): Boolean =\n    if (n <= 1) false else (2 until n).forall(i => n % i != 0)\n\n  def findPrimeBetween(\n      minInclusive: Int,\n      maxExclusive: Int\n  ): ZIO[Any, List[String], Int] =\n    for {\n      errors <- Ref.make(List.empty[String])\n      number <- Random\n        .nextIntBetween(minInclusive, maxExclusive)\n        .reject {\n          case n if !isPrime(n) =>\n            s"non-prime number rejected: $n"\n        }\n        .flatMapError(error => errors.updateAndGet(_ :+ error))\n        .retryUntil(_.length >= 5)\n    } yield number\n\n  val myApp: ZIO[Any, Nothing, Unit] =\n    findPrimeBetween(1000, 10000)\n      .flatMap(prime => Console.printLine(s"found a prime number: $prime").orDie)\n      .catchAll { (errors: List[String]) =>\n        Console.printLine(\n          s"failed to find a prime number after 5 attempts:\\n  ${errors.mkString("\\n  ")}"\n        )\n      }\n      .orDie\n\n  def run = myApp\n}\n'})})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>a});var t=r(96540);const i={},o=t.createContext(i);function s(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);