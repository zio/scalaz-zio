"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[56289],{28453:(e,a,n)=>{n.d(a,{R:()=>s,x:()=>o});var t=n(96540);const i={},r=t.createContext(i);function s(e){const a=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function o(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(r.Provider,{value:a},e.children)}},55473:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"reference/stm/tmap","title":"TMap","description":"A TMap[A] is a mutable map that can participate in transactions in STM.","source":"@site/versioned_docs/version-1.0.18/reference/stm/tmap.md","sourceDirName":"reference/stm","slug":"/reference/stm/tmap","permalink":"/1.0.18/reference/stm/tmap","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/versioned_docs/version-1.0.18/reference/stm/tmap.md","tags":[],"version":"1.0.18","frontMatter":{"id":"tmap","title":"TMap"}}');var i=n(74848),r=n(28453);const s={id:"tmap",title:"TMap"},o=void 0,l={},c=[{value:"Create a TMap",id:"create-a-tmap",level:2},{value:"Put a key-value pair to a TMap",id:"put-a-key-value-pair-to-a-tmap",level:2},{value:"Remove an element from a TMap",id:"remove-an-element-from-a-tmap",level:2},{value:"Retrieve the value from a TMap",id:"retrieve-the-value-from-a-tmap",level:2},{value:"Transform entries of a TMap",id:"transform-entries-of-a-tmap",level:2},{value:"Perform side-effect for TMap key-value pairs",id:"perform-side-effect-for-tmap-key-value-pairs",level:2},{value:"Check TMap membership",id:"check-tmap-membership",level:2},{value:"Convert TMap to a List",id:"convert-tmap-to-a-list",level:2}];function p(e){const a={code:"code",h2:"h2",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(a.p,{children:["A ",(0,i.jsx)(a.code,{children:"TMap[A]"})," is a mutable map that can participate in transactions in STM."]}),"\n",(0,i.jsx)(a.h2,{id:"create-a-tmap",children:"Create a TMap"}),"\n",(0,i.jsxs)(a.p,{children:["Creating an empty ",(0,i.jsx)(a.code,{children:"TMap"}),":"]}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-scala",children:"import zio._\nimport zio.stm._\n\nval emptyTMap: STM[Nothing, TMap[String, Int]] = TMap.empty[String, Int]\n"})}),"\n",(0,i.jsxs)(a.p,{children:["Or creating a ",(0,i.jsx)(a.code,{children:"TMap"})," with specified values:"]}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-scala",children:'import zio._\nimport zio.stm._\n\nval specifiedValuesTMap: STM[Nothing, TMap[String, Int]] = TMap.make(("a", 1), ("b", 2), ("c", 3))\n'})}),"\n",(0,i.jsxs)(a.p,{children:["Alternatively, you can create a ",(0,i.jsx)(a.code,{children:"TMap"})," by providing a collection of tuple values:"]}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-scala",children:'import zio._\nimport zio.stm._\n\nval iterableTMap: STM[Nothing, TMap[String, Int]] = TMap.fromIterable(List(("a", 1), ("b", 2), ("c", 3)))\n'})}),"\n",(0,i.jsx)(a.h2,{id:"put-a-key-value-pair-to-a-tmap",children:"Put a key-value pair to a TMap"}),"\n",(0,i.jsx)(a.p,{children:"New key-value pair can be added to the map in the following way:"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-scala",children:'import zio._\nimport zio.stm._\n\nval putElem: UIO[TMap[String, Int]] = (for {\n  tMap <- TMap.make(("a", 1), ("b", 2))\n  _    <- tMap.put("c", 3)\n} yield tMap).commit\n'})}),"\n",(0,i.jsxs)(a.p,{children:["Another way of adding an entry in the map is by using ",(0,i.jsx)(a.code,{children:"merge"}),":"]}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-scala",children:'import zio._\nimport zio.stm._\n\nval mergeElem: UIO[TMap[String, Int]] = (for {\n  tMap <- TMap.make(("a", 1), ("b", 2), ("c", 3))\n  _    <- tMap.merge("c", 4)((x, y) => x * y)\n} yield tMap).commit\n'})}),"\n",(0,i.jsxs)(a.p,{children:["If the key is not present in the map it behaves as a simple ",(0,i.jsx)(a.code,{children:"put"})," method. It merges the existing value with the new one using the provided function otherwise."]}),"\n",(0,i.jsx)(a.h2,{id:"remove-an-element-from-a-tmap",children:"Remove an element from a TMap"}),"\n",(0,i.jsxs)(a.p,{children:["The simplest way to remove a key-value pair from ",(0,i.jsx)(a.code,{children:"TMap"})," is using ",(0,i.jsx)(a.code,{children:"delete"})," method that takes key:"]}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-scala",children:'import zio._\nimport zio.stm._\n\nval deleteElem: UIO[TMap[String, Int]] = (for {\n  tMap <- TMap.make(("a", 1), ("b", 2), ("c", 3))\n  _    <- tMap.delete("b")\n} yield tMap).commit\n'})}),"\n",(0,i.jsx)(a.p,{children:"Also, it is possible to remove every key-value pairs that satisfy provided predicate:"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-scala",children:'import zio._\nimport zio.stm._\n\nval removedEvenValues: UIO[TMap[String, Int]] = (for {\n  tMap <- TMap.make(("a", 1), ("b", 2), ("c", 3), ("d", 4))\n  _    <- tMap.removeIf((_, v) => v % 2 == 0)\n} yield tMap).commit\n'})}),"\n",(0,i.jsx)(a.p,{children:"Or you can keep all key-value pairs that match predicate function:"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-scala",children:'import zio._\nimport zio.stm._\n\nval retainedEvenValues: UIO[TMap[String, Int]] = (for {\n  tMap <- TMap.make(("a", 1), ("b", 2), ("c", 3), ("d", 4))\n  _    <- tMap.retainIf((_, v) => v % 2 == 0)\n} yield tMap).commit\n'})}),"\n",(0,i.jsxs)(a.p,{children:["Note that ",(0,i.jsx)(a.code,{children:"retainIf"})," and ",(0,i.jsx)(a.code,{children:"removeIf"})," serve the same purpose as ",(0,i.jsx)(a.code,{children:"filter"})," and ",(0,i.jsx)(a.code,{children:"filterNot"}),". The reason for naming them differently was to emphasize a distinction in their nature. Namely, both ",(0,i.jsx)(a.code,{children:"retainIf"})," and ",(0,i.jsx)(a.code,{children:"removeIf"})," are destructive - calling them can modify the collection."]}),"\n",(0,i.jsx)(a.h2,{id:"retrieve-the-value-from-a-tmap",children:"Retrieve the value from a TMap"}),"\n",(0,i.jsx)(a.p,{children:"Value associated with the key can be obtained as follows:"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-scala",children:'import zio._\nimport zio.stm._\n\nval elemGet: UIO[Option[Int]] = (for {\n  tMap <- TMap.make(("a", 1), ("b", 2), ("c", 3))\n  elem <- tMap.get("c")\n} yield elem).commit\n'})}),"\n",(0,i.jsx)(a.p,{children:"Alternatively, you can provide a default value if entry by key is not present in the map:"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-scala",children:'import zio._\nimport zio.stm._\n\nval elemGetOrElse: UIO[Int] = (for {\n  tMap <- TMap.make(("a", 1), ("b", 2), ("c", 3))\n  elem <- tMap.getOrElse("d", 4)\n} yield elem).commit\n'})}),"\n",(0,i.jsx)(a.h2,{id:"transform-entries-of-a-tmap",children:"Transform entries of a TMap"}),"\n",(0,i.jsxs)(a.p,{children:["The transform function ",(0,i.jsx)(a.code,{children:"(K, V) => (K, V)"})," allows computing a new value for every entry in the map:"]}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-scala",children:'import zio._\nimport zio.stm._\n\nval transformTMap: UIO[TMap[String, Int]] = (for {\n  tMap <- TMap.make(("a", 1), ("b", 2), ("c", 3))\n  _    <- tMap.transform((k, v) => k -> v * v)\n} yield tMap).commit\n'})}),"\n",(0,i.jsxs)(a.p,{children:["Note that it is possible to shrink a ",(0,i.jsx)(a.code,{children:"TMap"}),":"]}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-scala",children:'import zio._\nimport zio.stm._\n\nval shrinkTMap: UIO[TMap[String, Int]] = (for {\n  tMap <- TMap.make(("a", 1), ("b", 2), ("c", 3))\n  _    <- tMap.transform((_, v) => "d" -> v)\n} yield tMap).commit\n'})}),"\n",(0,i.jsxs)(a.p,{children:["The entries can be mapped effectfully via ",(0,i.jsx)(a.code,{children:"transformM"}),":"]}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-scala",children:'import zio._\nimport zio.stm._\n\nval transformMTMap: UIO[TMap[String, Int]] = (for {\n  tMap <- TMap.make(("a", 1), ("b", 2), ("c", 3))\n  _    <- tMap.transformM((k, v) => STM.succeed(k -> v * v))\n} yield tMap).commit\n'})}),"\n",(0,i.jsxs)(a.p,{children:["The ",(0,i.jsx)(a.code,{children:"transformValues"})," function ",(0,i.jsx)(a.code,{children:"V => V"})," allows computing a new value for every value in the map:"]}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-scala",children:'import zio._\nimport zio.stm._\n\nval transformValuesTMap: UIO[TMap[String, Int]] = (for {\n  tMap <- TMap.make(("a", 1), ("b", 2), ("c", 3))\n  _    <- tMap.transformValues(v => v * v)\n} yield tMap).commit\n'})}),"\n",(0,i.jsxs)(a.p,{children:["The values can be mapped effectfully via ",(0,i.jsx)(a.code,{children:"transformValuesM"}),":"]}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-scala",children:'import zio._\nimport zio.stm._\n\nval transformValuesMTMap: UIO[TMap[String, Int]] = (for {\n  tMap <- TMap.make(("a", 1), ("b", 2), ("c", 3))\n  _    <- tMap.transformValuesM(v => STM.succeed(v * v))\n} yield tMap).commit\n'})}),"\n",(0,i.jsxs)(a.p,{children:["Note that both ",(0,i.jsx)(a.code,{children:"transform"})," and ",(0,i.jsx)(a.code,{children:"transformValues"})," serve the same purpose as ",(0,i.jsx)(a.code,{children:"map"})," and ",(0,i.jsx)(a.code,{children:"mapValues"}),". The reason for naming them differently was to emphasize a distinction in their nature. Namely, both ",(0,i.jsx)(a.code,{children:"transform"})," and ",(0,i.jsx)(a.code,{children:"transformValues"})," are destructive - calling them can modify the collection."]}),"\n",(0,i.jsxs)(a.p,{children:["Folds the elements of a ",(0,i.jsx)(a.code,{children:"TMap"})," using the specified associative binary operator:"]}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-scala",children:'import zio._\nimport zio.stm._\n\nval foldTMap: UIO[Int] = (for {\n  tMap <- TMap.make(("a", 1), ("b", 2), ("c", 3))\n  sum  <- tMap.fold(0) { case (acc, (_, v)) => acc + v }\n} yield sum).commit\n'})}),"\n",(0,i.jsxs)(a.p,{children:["The elements can be folded effectfully via ",(0,i.jsx)(a.code,{children:"foldM"}),":"]}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-scala",children:'import zio._\nimport zio.stm._\n\nval foldMTMap: UIO[Int] = (for {\n  tMap <- TMap.make(("a", 1), ("b", 2), ("c", 3))\n  sum  <- tMap.foldM(0) { case (acc, (_, v)) => STM.succeed(acc + v) }\n} yield sum).commit\n'})}),"\n",(0,i.jsx)(a.h2,{id:"perform-side-effect-for-tmap-key-value-pairs",children:"Perform side-effect for TMap key-value pairs"}),"\n",(0,i.jsxs)(a.p,{children:[(0,i.jsx)(a.code,{children:"foreach"})," is used for performing side-effect for each key-value pair in the map:"]}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-scala",children:'import zio._\nimport zio.stm._\n\nval foreachTMap = (for {\n  tMap <- TMap.make(("a", 1), ("b", 2), ("c", 3))\n  _    <- tMap.foreach((k, v) => STM.succeed(println(s"$k -> $v")))\n} yield tMap).commit\n'})}),"\n",(0,i.jsx)(a.h2,{id:"check-tmap-membership",children:"Check TMap membership"}),"\n",(0,i.jsxs)(a.p,{children:["Checking whether key-value pair is present in a ",(0,i.jsx)(a.code,{children:"TMap"}),":"]}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-scala",children:'import zio._\nimport zio.stm._\n\nval tMapContainsValue: UIO[Boolean] = (for {\n  tMap <- TMap.make(("a", 1), ("b", 2), ("c", 3))\n  res  <- tMap.contains("a")\n} yield res).commit\n'})}),"\n",(0,i.jsx)(a.h2,{id:"convert-tmap-to-a-list",children:"Convert TMap to a List"}),"\n",(0,i.jsx)(a.p,{children:"List of tuples can be obtained as follows:"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-scala",children:'import zio._\nimport zio.stm._\n\nval tMapTuplesList: UIO[List[(String, Int)]] = (for {\n  tMap <- TMap.make(("a", 1), ("b", 2), ("c", 3))\n  list <- tMap.toList\n} yield list).commit\n'})}),"\n",(0,i.jsx)(a.p,{children:"List of keys can be obtained as follows:"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-scala",children:'import zio._\nimport zio.stm._\n\nval tMapKeysList: UIO[List[String]] = (for {\n  tMap <- TMap.make(("a", 1), ("b", 2), ("c", 3))\n  list <- tMap.keys\n} yield list).commit\n'})}),"\n",(0,i.jsx)(a.p,{children:"List of values can be obtained as follows:"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-scala",children:'import zio._\nimport zio.stm._\n\nval tMapValuesList: UIO[List[Int]] = (for {\n  tMap <- TMap.make(("a", 1), ("b", 2), ("c", 3))\n  list <- tMap.values\n} yield list).commit\n'})})]})}function m(e={}){const{wrapper:a}={...(0,r.R)(),...e.components};return a?(0,i.jsx)(a,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}}}]);