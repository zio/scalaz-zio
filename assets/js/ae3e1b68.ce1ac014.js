"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[61386],{28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>r});var i=n(96540);const a={},o=i.createContext(a);function s(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(o.Provider,{value:t},e.children)}},47590:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"zio-prelude/functional-abstractions/concrete-types/commutative","title":"Commutative","description":"Commutative[A] describes a data type that has a combine operator that is commutative and associative.","source":"@site/docs/zio-prelude/functional-abstractions/concrete-types/commutative.md","sourceDirName":"zio-prelude/functional-abstractions/concrete-types","slug":"/zio-prelude/functional-abstractions/concrete-types/commutative","permalink":"/zio-prelude/functional-abstractions/concrete-types/commutative","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-prelude/functional-abstractions/concrete-types/commutative.md","tags":[],"version":"current","frontMatter":{"id":"commutative","title":"Commutative"},"sidebar":"ecosystem-sidebar","previous":{"title":"Associative","permalink":"/zio-prelude/functional-abstractions/concrete-types/associative"},"next":{"title":"Debug","permalink":"/zio-prelude/functional-abstractions/concrete-types/debug"}}');var a=n(74848),o=n(28453);const s={id:"commutative",title:"Commutative"},r=void 0,c={},l=[];function d(e){const t={code:"code",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"Commutative[A]"})," describes a data type that has a ",(0,a.jsx)(t.code,{children:"combine"})," operator that is commutative and associative."]}),"\n",(0,a.jsx)(t.p,{children:"Its signature is:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:"trait Associative[A] {\n  def combine(left: => A, right: => A): A\n}\n\ntrait Commutative[A] extends Associative[A]\n"})}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"Commutative"})," abstraction does not define any additional operators beyond the ",(0,a.jsx)(t.code,{children:"combine"})," operator defined by ",(0,a.jsx)(t.code,{children:"Associative"}),". However, it does provide additional structure to the ",(0,a.jsx)(t.code,{children:"combine"})," operator."]}),"\n",(0,a.jsxs)(t.p,{children:["Specifically, it says that the ",(0,a.jsx)(t.code,{children:"combine"})," operator is commutative in addition to being associative. This means that not only does the order of operations not matter, but the order in which we combine the values does not matter."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:"a <> b === b <> a\n"})}),"\n",(0,a.jsx)(t.p,{children:"Only some ways of combining that are associative are commutative."}),"\n",(0,a.jsxs)(t.p,{children:["For example, integer addition is both associative and commutative. ",(0,a.jsx)(t.code,{children:"2 + 3"})," is the same as ",(0,a.jsx)(t.code,{children:"3 + 2"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["On the other hand, string concatenation is associative but not commutative. ",(0,a.jsx)(t.code,{children:'"a" + "b"'})," is not the same as ",(0,a.jsx)(t.code,{children:'"b" + "a"'}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["We can use the ",(0,a.jsx)(t.code,{children:"Commutative"})," abstraction to specify at the type level whether one of our data types can be combined in a way that is associative and commutative or only associative. We can also test for it using the laws testing functionality provided by ZIO Prelude."]}),"\n",(0,a.jsxs)(t.p,{children:["For example, here is how we could define and test a ",(0,a.jsx)(t.code,{children:"Commutative"})," instance for a version of the ",(0,a.jsx)(t.code,{children:"RunningAverage"})," data type that we discussed in the introduction to functional abstractions:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:'import zio.prelude._\nimport zio.prelude.laws._\nimport zio.test._\nimport zio.test.laws._\n\ncase class RunningAverage(sum: Long, count: Int)\n\nobject RunningAverage {\n  implicit val RunningAverageCommutative: Commutative[RunningAverage] =\n    new Commutative[RunningAverage] {\n      def combine(left: => RunningAverage, right: => RunningAverage): RunningAverage =\n        RunningAverage(left.sum + right.sum, left.count + right.count)\n    }\n  implicit val RunningAverageEqual: Equal[RunningAverage] =\n    Equal.default\n}\n\nobject RunningAverageSpec extends ZIOSpecDefault {\n\n  def spec = suite("RunningAverageSpec") {\n    test("commutative") {\n      val runningAverageGen = Gen.long.zipWith(Gen.int)(RunningAverage(_, _))\n      checkAllLaws(CommutativeLaws)(runningAverageGen)\n    }\n  }\n}\n'})}),"\n",(0,a.jsxs)(t.p,{children:["The main advantage of having a ",(0,a.jsx)(t.code,{children:"Commutative"})," instance is that we don't have to worry about the order in which we combine values because we will get the same result no matter what."]}),"\n",(0,a.jsx)(t.p,{children:"To take a simple example, consider combining the values in a set."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:'val fruits: Set[String] =\n  Set("apple", "orange", "banana")\n// fruits: Set[String] = Set("apple", "orange", "banana")\n\nval ints: Set[Int] =\n  Set(1, 2, 3)\n// ints: Set[Int] = Set(1, 2, 3)\n\nval notCommutative: String =\n  fruits.foldLeft("")(_ + _)\n// notCommutative: String = "appleorangebanana"\n\nval commutative: Int =\n  ints.foldLeft(0)(_ + _)\n// commutative: Int = 6\n'})}),"\n",(0,a.jsx)(t.p,{children:"The order of values in a set is arbitrary. When we iterate over the values of a set we must do it in some order, and that order may be the same for a particular implementation of a set, but that is not something we can rely on."}),"\n",(0,a.jsxs)(t.p,{children:["As a result, the value of ",(0,a.jsx)(t.code,{children:"notCommutative"})," is not well defined. It could be ",(0,a.jsx)(t.code,{children:'"applebananaorange"'}),", ",(0,a.jsx)(t.code,{children:'"orangebananaapple"'}),", ",(0,a.jsx)(t.code,{children:'"bananaorangeapple"'}),", among others."]}),"\n",(0,a.jsxs)(t.p,{children:["We have to be very careful in dealing with ",(0,a.jsx)(t.code,{children:"notCommutative"}),". Either we must not use it at all or we must use it in very limited ways that will return the same result regardless of the order in which it was constructed (e.g. testing whether it contains the substring ",(0,a.jsx)(t.code,{children:'"apple"'}),")."]}),"\n",(0,a.jsxs)(t.p,{children:["In contrast, the value of ",(0,a.jsx)(t.code,{children:"commutative"})," is extremely well defined. It will always be ",(0,a.jsx)(t.code,{children:"6"})," no matter what."]}),"\n",(0,a.jsxs)(t.p,{children:["Regardless of the order in which we iterate over the elements in the set it will always be ",(0,a.jsx)(t.code,{children:"6"})," because addition is a commutative operation. Even if we tried to get a different value we couldn't come up with an order of iterating over the set elements that gave a different result."]}),"\n",(0,a.jsxs)(t.p,{children:["Thus, we can safely work with ",(0,a.jsx)(t.code,{children:"commutative"})," and do anything we want with it because it will always have the same value."]}),"\n",(0,a.jsx)(t.p,{children:"This is a simple example but this property of commutativity can come up in much more complex domains such as concurrent or distributed programming. There, the order in which we receive values from other fibers or nodes is often arbitrary."}),"\n",(0,a.jsx)(t.p,{children:"In that case having a way of combining values that is commutative can be very useful because it means we don't need coordination mechanisms to ensure that we combine results in a certain order."}),"\n",(0,a.jsxs)(t.p,{children:["For an example of this we can look to the ",(0,a.jsx)(t.code,{children:"mergeAllPar"})," operator on ",(0,a.jsx)(t.code,{children:"ZIO"}),"."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:"import zio._\n\nobject ZIO {\n  def mergeAllPar[R, E, A, B](\n    in: Iterable[ZIO[R, E, A]]\n  )(zero: B)(f: (B, A) => B): ZIO[R, E, B] =\n    ???\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["This runs all of the ",(0,a.jsx)(t.code,{children:"ZIO"})," workflows in the ",(0,a.jsx)(t.code,{children:"Iterable"})," in parallel and combines their results with the function ",(0,a.jsx)(t.code,{children:"f"}),", starting from ",(0,a.jsx)(t.code,{children:"zero"}),". Its implementation creates a ",(0,a.jsx)(t.code,{children:"Ref"})," with the ",(0,a.jsx)(t.code,{children:"zero"})," value and then each fiber updates the ",(0,a.jsx)(t.code,{children:"Ref"})," with its result as it completes."]}),"\n",(0,a.jsxs)(t.p,{children:["The order in which the fibers complete is not determinate so the function ",(0,a.jsx)(t.code,{children:"f"})," should be associative and commutative, as the documentation for ",(0,a.jsx)(t.code,{children:"mergeAllPar"})," helpfully informs us."]}),"\n",(0,a.jsxs)(t.p,{children:["We do not want to force functional abstractions on users so in ZIO itself we state that the function must satisfy these properties and leave it at that. But with ZIO Prelude we can define a version of this operator that expresses at the type level that the ",(0,a.jsx)(t.code,{children:"combine"})," operator must be associative and commutative."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:"def mergeAllParCommutative[R, E, A, B: Commutative](\n  in: Iterable[ZIO[R, E, A]]\n)(zero: B)(f: A => B): ZIO[R, E, B] =\n  ZIO.mergeAllPar(in)(zero)((b, a) => b <> f(a))\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Now we run all the ",(0,a.jsx)(t.code,{children:"ZIO"})," workflows in parallel, mapping their results to a type for which a commutative ",(0,a.jsx)(t.code,{children:"combine"})," operator is defined. This will ensure that our way of combining values really is commutative."]}),"\n",(0,a.jsxs)(t.p,{children:["With the ",(0,a.jsx)(t.code,{children:"Commutative"})," abstraction we can describe the properties of our data types precisely, helping us understand what guarantees they provide and what our responsibilities are for working with them. This idea of commutative operators is also a helpful one to keep in mind when we are designing our own data types as we saw in the example above."]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);