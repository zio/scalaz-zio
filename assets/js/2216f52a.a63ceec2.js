"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[66990],{28453:(e,s,a)=>{a.d(s,{R:()=>i,x:()=>t});var c=a(96540);const n={},o=c.createContext(n);function i(e){const s=c.useContext(o);return c.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function t(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),c.createElement(o.Provider,{value:s},e.children)}},39817:(e,s,a)=>{a.r(s),a.d(s,{assets:()=>d,contentTitle:()=>t,default:()=>m,frontMatter:()=>i,metadata:()=>c,toc:()=>r});const c=JSON.parse('{"id":"zio-schema/derivations/codecs/message-pack","title":"MessagePack Codecs","description":"Introduction","source":"@site/docs/zio-schema/derivations/codecs/messsage-pack.md","sourceDirName":"zio-schema/derivations/codecs","slug":"/zio-schema/derivations/codecs/message-pack","permalink":"/zio-schema/derivations/codecs/message-pack","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-schema/derivations/codecs/messsage-pack.md","tags":[],"version":"current","frontMatter":{"id":"message-pack","title":"MessagePack Codecs","sidebar_label":"MessagePack"},"sidebar":"ecosystem-sidebar","previous":{"title":"JSON","permalink":"/zio-schema/derivations/codecs/json"},"next":{"title":"Protobuf","permalink":"/zio-schema/derivations/codecs/protobuf"}}');var n=a(74848),o=a(28453);const i={id:"message-pack",title:"MessagePack Codecs",sidebar_label:"MessagePack"},t=void 0,d={},r=[{value:"Introduction",id:"introduction",level:2},{value:"Installation",id:"installation",level:2},{value:"BinaryCodec",id:"binarycodec",level:2},{value:"Example",id:"example",level:2}];function l(e){const s={code:"code",h2:"h2",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.h2,{id:"introduction",children:"Introduction"}),"\n",(0,n.jsx)(s.p,{children:"MessagePack is a binary serialization format designed for efficient data exchange between different systems and languages. In this section, we will explore how to derive MessagePack codecs from a ZIO Schema. MessagePack codecs allow us to easily serialize and deserialize data in MessagePack format."}),"\n",(0,n.jsx)(s.h2,{id:"installation",children:"Installation"}),"\n",(0,n.jsx)(s.p,{children:"To use MessagePack codecs, you need to add the following dependency to your build.sbt file:"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-scala",children:'libraryDependencies += "dev.zio" %% "zio-schema-msg-pack" % "1.6.1"\n'})}),"\n",(0,n.jsx)(s.h2,{id:"binarycodec",children:"BinaryCodec"}),"\n",(0,n.jsxs)(s.p,{children:["The ",(0,n.jsx)(s.code,{children:"MessagePackCodec"})," object inside the ",(0,n.jsx)(s.code,{children:"zio.schema.codec"})," package provides the ",(0,n.jsx)(s.code,{children:"messagePackCodec"})," operator which allows us to derive MessagePack codecs from a ZIO Schema:"]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-scala",children:"object MessagePackCodec {\n  implicit def messagePackCodec[A](implicit schema: Schema[A]): BinaryCodec[A] = ???\n}\n"})}),"\n",(0,n.jsx)(s.h2,{id:"example",children:"Example"}),"\n",(0,n.jsx)(s.p,{children:"Let's try an example to see how it works:"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-scala",children:'import zio._\nimport zio.schema.codec._\nimport zio.schema.{DeriveSchema, Schema}\n\ncase class Person(name: String, age: Int)\n\nobject Person {\n  implicit val schema: Schema[Person] =\n    DeriveSchema.gen\n  implicit val msgPackCodec: BinaryCodec[Person] =\n    MessagePackCodec.messagePackCodec(schema)\n}\n\nobject Main extends ZIOAppDefault {\n  def run = for {\n    _ <- ZIO.debug("MessagePack Codec Example:")\n    person: Person = Person("John", 42)\n    encoded: Chunk[Byte] = Person.msgPackCodec.encode(person)\n    _ <- ZIO.debug(s"person object encoded to MessagePack\'s binary format: ${toHex(encoded)}")\n    decoded <- ZIO.fromEither(Person.msgPackCodec.decode(encoded))\n    _ <- ZIO.debug(s"MessagePack object decoded to Person class: $decoded")\n  } yield ()\n\n  def toHex(bytes: Chunk[Byte]): String =\n    bytes.map("%02x".format(_)).mkString(" ")\n}\n'})}),"\n",(0,n.jsx)(s.p,{children:"The output of the above program is:"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-scala",children:"MessagePack Codec Example:\nperson object encoded to MessagePack's binary format: 82 a4 6e 61 6d 65 a4 4a 6f 68 6e a3 61 67 65 2a\nMessagePack object decoded to Person class: Person(John,42)\n"})})]})}function m(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}}}]);