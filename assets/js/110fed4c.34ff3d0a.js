"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[87351],{28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>i});var s=t(96540);const c={},o=s.createContext(c);function a(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:a(e.components),s.createElement(o.Provider,{value:n},e.children)}},54588:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"zio-http/reference/socket/socket","title":"Socket","description":"Websocket support can be added to your Http application using the same Http domain, something like this \u2014","source":"@site/docs/zio-http/reference/socket/socket.md","sourceDirName":"zio-http/reference/socket","slug":"/zio-http/reference/socket/","permalink":"/zio-http/reference/socket/","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-http/reference/socket/socket.md","tags":[],"version":"current","frontMatter":{"id":"socket","title":"Socket"},"sidebar":"ecosystem-sidebar","previous":{"title":"HandlerAspect","permalink":"/zio-http/reference/aop/handler_aspect"},"next":{"title":"WebSocketFrame","permalink":"/zio-http/reference/socket/websocketframe"}}');var c=t(74848),o=t(28453);const a={id:"socket",title:"Socket"},i=void 0,r={},l=[{value:"Channel",id:"channel",level:2},{value:"ChannelEvents",id:"channelevents",level:2},{value:"Using <code>Http</code>",id:"using-http",level:2}];function h(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.p,{children:["Websocket support can be added to your Http application using the same ",(0,c.jsx)(n.code,{children:"Http"})," domain, something like this \u2014"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:'import zio.http._\nimport zio._\n\nval socket = Handler.webSocket { channel =>\n  channel.receiveAll {\n    case ChannelEvent.Read(WebSocketFrame.Text("foo")) =>\n      channel.send(ChannelEvent.Read(WebSocketFrame.text("bar")))\n    case _ =>\n      ZIO.unit\n  }\n}\n\nval http = Routes(\n  Method.GET / "subscriptions" -> handler(socket.toResponse)\n)\n'})}),"\n",(0,c.jsxs)(n.p,{children:["The WebSocket API leverages the already powerful ",(0,c.jsx)(n.code,{children:"Http"})," domain to write web socket apps. The difference is that instead\nof collecting ",(0,c.jsx)(n.code,{children:"Request"})," we collect ",(0,c.jsx)(n.code,{children:"Channel"})," or more specifically ",(0,c.jsx)(n.code,{children:"WebSocketChannel"}),". And, instead of\nreturning\na ",(0,c.jsx)(n.code,{children:"Response"})," we return ",(0,c.jsx)(n.code,{children:"Unit"}),", because we use the channel to write content directly."]}),"\n",(0,c.jsx)(n.h2,{id:"channel",children:"Channel"}),"\n",(0,c.jsx)(n.p,{children:"Essentially, whenever there is a connection created between a server and client a channel is created on both sides. The\nchannel is a low level api that allows us to send and receive arbitrary messages."}),"\n",(0,c.jsxs)(n.p,{children:["When we upgrade a Http connection to WebSocket, we create a specialized channel that only allows websocket frames to be\nsent and received. The access to channel is available through the ",(0,c.jsx)(n.code,{children:"Channel"})," api."]}),"\n",(0,c.jsx)(n.h2,{id:"channelevents",children:"ChannelEvents"}),"\n",(0,c.jsxs)(n.p,{children:["A ",(0,c.jsx)(n.code,{children:"ChannelEvent"})," is an immutable, type-safe representation of an event that's happened on a channel, and it looks like\nthis:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:"sealed trait ChannelEvent[A]\n"})}),"\n",(0,c.jsxs)(n.p,{children:["It is the ",(0,c.jsx)(n.strong,{children:"Event"})," that was triggered. The type param ",(0,c.jsx)(n.code,{children:"A"})," on the ChannelEvent represents the kind of message the event contains."]}),"\n",(0,c.jsxs)(n.p,{children:["The type ",(0,c.jsx)(n.code,{children:"WebSocketChannelEvent"})," is a type alias to ",(0,c.jsx)(n.code,{children:"ChannelEvent[WebsocketFrame]"}),". Meaning an event that contains ",(0,c.jsx)(n.code,{children:"WebSocketFrame"})," typed messages."]}),"\n",(0,c.jsxs)(n.h2,{id:"using-http",children:["Using ",(0,c.jsx)(n.code,{children:"Http"})]}),"\n",(0,c.jsxs)(n.p,{children:["We can use ",(0,c.jsx)(n.code,{children:"Http.collect"})," to select the events that we care about for our use case, like in the above example we are\nonly interested in the ",(0,c.jsx)(n.code,{children:"ChannelRead"})," event. There are other life cycle events such as ",(0,c.jsx)(n.code,{children:"ChannelRegistered"}),"\nand ",(0,c.jsx)(n.code,{children:"ChannelUnregistered"})," that one might want to hook onto for some other use cases."]})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(h,{...e})}):h(e)}}}]);