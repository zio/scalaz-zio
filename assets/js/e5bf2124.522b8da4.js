"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[34568],{12236:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"zio-constraintless/index","title":"Introduction to ZIO Constraintless","description":"ZIO Constraintless allows you to build programs as mere descriptions with maximum polymorphism, maximum modularity, zero abstraction leakage, and zero casting.","source":"@site/docs/zio-constraintless/index.md","sourceDirName":"zio-constraintless","slug":"/zio-constraintless/","permalink":"/zio-constraintless/","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-constraintless/index.md","tags":[],"version":"current","frontMatter":{"id":"index","title":"Introduction to ZIO Constraintless","sidebar_label":"ZIO Constraintless"},"sidebar":"ecosystem-sidebar","previous":{"title":"S3 Connector","permalink":"/zio-connect/s3-connector"},"next":{"title":"ZIO Deriving","permalink":"/zio-deriving/"}}');var i=t(74848),o=t(28453);const a={id:"index",title:"Introduction to ZIO Constraintless",sidebar_label:"ZIO Constraintless"},r=void 0,l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Installation",id:"installation",level:2},{value:"Example",id:"example",level:2},{value:"Context",id:"context",level:2},{value:"Why not the Hughes schema?",id:"why-not-the-hughes-schema",level:2}];function p(e){const s={a:"a",code:"code",em:"em",h2:"h2",img:"img",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.p,{children:"ZIO Constraintless allows you to build programs as mere descriptions with maximum polymorphism, maximum modularity, zero abstraction leakage, and zero casting."}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.a,{href:"https://github.com/zio/zio/wiki/Project-Stages",children:(0,i.jsx)(s.img,{src:"https://img.shields.io/badge/Project%20Stage-Development-green.svg",alt:"Development"})})," ",(0,i.jsx)(s.img,{src:"https://github.com/zio/zio-constraintless/workflows/Website/badge.svg",alt:"CI Badge"})," ",(0,i.jsx)(s.a,{href:"https://oss.sonatype.org/content/repositories/releases/dev/zio/zio-constraintless_2.13/",children:(0,i.jsx)(s.img,{src:"https://img.shields.io/nexus/r/https/oss.sonatype.org/dev.zio/zio-constraintless_2.13.svg?label=Sonatype%20Release",alt:"Sonatype Releases"})})," ",(0,i.jsx)(s.a,{href:"https://oss.sonatype.org/content/repositories/snapshots/dev/zio/zio-constraintless_2.13/",children:(0,i.jsx)(s.img,{src:"https://img.shields.io/nexus/s/https/oss.sonatype.org/dev.zio/zio-constraintless_2.13.svg?label=Sonatype%20Snapshot",alt:"Sonatype Snapshots"})})," ",(0,i.jsx)(s.a,{href:"https://javadoc.io/doc/dev.zio/zio-constraintless-docs_2.13",children:(0,i.jsx)(s.img,{src:"https://javadoc.io/badge2/dev.zio/zio-constraintless-docs_2.13/javadoc.svg",alt:"javadoc"})})," ",(0,i.jsx)(s.a,{href:"https://github.com/zio/zio-constraintless",children:(0,i.jsx)(s.img,{src:"https://img.shields.io/github/stars/zio/zio-constraintless?style=social",alt:"ZIO Constraintless"})})]}),"\n",(0,i.jsx)(s.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsxs)(s.p,{children:["It is ",(0,i.jsx)(s.strong,{children:"a Scala take on the following paper in Haskell, on parametrising the program with logical constraints at every node, without compromising modularity"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.a,{href:"http://www.doc.ic.ac.uk/~wlj05/files/Deconstraining.pdf",children:"http://www.doc.ic.ac.uk/~wlj05/files/Deconstraining.pdf"})}),"\n",(0,i.jsx)(s.p,{children:"An excerpt from the paper:"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.em,{children:'"The key principle that underpins our idea is that implementation- specific constraints should be imposed at the point of use of a data type, not at the point of definition, i.e. it embodies the established principle that an interface should be separated from its implementation(s)."'})}),"\n",(0,i.jsx)(s.h2,{id:"installation",children:"Installation"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-sbt",children:'libraryDependencies += "dev.zio" %% "constraintless" % "0.3.3"\n'})}),"\n",(0,i.jsx)(s.h2,{id:"example",children:"Example"}),"\n",(0,i.jsxs)(s.p,{children:["Example: ",(0,i.jsx)(s.a,{href:"https://github.com/zio/zio-constraintless/blob/master/examples/src/main/scala/zio/constraintless/examples/Expr.scala",children:"https://github.com/zio/zio-constraintless/blob/master/examples/src/main/scala/zio/constraintless/examples/Expr.scala"})]}),"\n",(0,i.jsx)(s.h2,{id:"context",children:"Context"}),"\n",(0,i.jsx)(s.p,{children:'The key to many inspectable programs such as an execution planner, a configuration DSL etc is the basic concept of "programs as descriptions", but this idea comes with limitations.'}),"\n",(0,i.jsx)(s.p,{children:"This description (or data) can easily turn out to be a Generalised ADT that can be recursive, such that compiler has to traverse through the unknown types (existential) and for the compiler to do any advanced/useful stuff with it, it needs to know more about these types."}),"\n",(0,i.jsx)(s.p,{children:'The obvious implication of having to handle "unknown" is that, the data should hold on to informations as constraints (that are relevant to implementation) on types at the definition site. A possible solution is to compromise on parametric polymorphism, or fall back to relying unsafe/safe (relative) casting (asInstanceOf).'}),"\n",(0,i.jsx)(s.p,{children:"This naive approach imposes modularity issues, and possible runtime crashes. The reasonsing and solution is given in the above paper, and this project solves the exact problem in scala."}),"\n",(0,i.jsx)(s.h2,{id:"why-not-the-hughes-schema",children:"Why not the Hughes schema?"}),"\n",(0,i.jsx)(s.p,{children:"It doesn't allow you to have a compiler with multiple constraints."}),"\n",(0,i.jsx)(s.p,{children:"A few excerpts from the paper on why it doesn't work:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-scala",children:"class Typeable p a valueP :: a \u2192 p a\n"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-scala",children:"newtype SM a = SM {fromSM :: Int}\n\ninstance IntBool a \u21d2 Typeable SM a where\n  valueP = SM \xb7 toInt\n"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-scala",children:"newtype Pretty a = Pretty {fromPretty :: String}\n\ninstance Show a \u21d2 Typeable Pretty a where valueP = Pretty \xb7 show\n"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-scala",children:"data Exp p a where\nValueE::Typeable p a \u21d2 a \u2192 Exp p a\n\nCondE ::Expp Bool\u2192Exp p a \u2192 Exp p a \u2192 Exp p a \n\nEqE :: Eq a \u21d2 Exp p a \u2192 Exp p a \u2192 Exp p Bool\n"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-scala",children:"pretty :: Exp Pretty a \u2192 String // works\ncompileSM :: Exp SM a \u2192 String // works\n"})}),"\n",(0,i.jsx)(s.p,{children:"However, now suppose that we wish to apply the two functions to the same expression, as in:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-scala",children:"f :: Exp p a \u2192 . . .\nf e = ...(compileSM e)...(pretty e)..\n"})}),"\n",(0,i.jsx)(s.p,{children:"and that's impossible"})]})}function h(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}},28453:(e,s,t)=>{t.d(s,{R:()=>a,x:()=>r});var n=t(96540);const i={},o=n.createContext(i);function a(e){const s=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function r(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),n.createElement(o.Provider,{value:s},e.children)}}}]);