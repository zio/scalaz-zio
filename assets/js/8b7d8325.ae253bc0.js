"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[16800],{52378:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"zio-http/examples/websocket","title":"WebSocket Example","description":"This example shows how to create a WebSocket server using ZIO HTTP and how to write a client to connect to it.","source":"@site/docs/zio-http/examples/websocket.md","sourceDirName":"zio-http/examples","slug":"/zio-http/examples/websocket","permalink":"/zio-http/examples/websocket","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-http/examples/websocket.md","tags":[],"version":"current","frontMatter":{"id":"websocket","title":"WebSocket Example","sidebar_label":"WebSocket Server & Client"},"sidebar":"ecosystem-sidebar","previous":{"title":"HTML Templating","permalink":"/zio-http/examples/html-templating"},"next":{"title":"Streaming","permalink":"/zio-http/examples/streaming"}}');var o=t(74848),a=t(28453);const r={id:"websocket",title:"WebSocket Example",sidebar_label:"WebSocket Server & Client"},c=void 0,i={},l=[{value:"Server",id:"server",level:2},{value:"Client",id:"client",level:2},{value:"WebSocket Echo",id:"websocket-echo",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"This example shows how to create a WebSocket server using ZIO HTTP and how to write a client to connect to it."}),"\n",(0,o.jsx)(n.h2,{id:"server",children:"Server"}),"\n",(0,o.jsxs)(n.p,{children:["First we define a ",(0,o.jsx)(n.code,{children:"WebSocketApp"})," that will handle the WebSocket connection.\nThe ",(0,o.jsx)(n.code,{children:"Handler.webSocket"})," constructor gives access to the ",(0,o.jsx)(n.code,{children:"WebSocketChannel"}),". The channel can be used to receive messages from the client and send messages back.\nWe use the ",(0,o.jsx)(n.code,{children:"receiveAll"})," method, to pattern match on the different channel events that could occur.\nThe most important events are ",(0,o.jsx)(n.code,{children:"Read"})," and ",(0,o.jsx)(n.code,{children:"UserEventTriggered"}),". The ",(0,o.jsx)(n.code,{children:"Read"})," event is triggered when the client sends a message to the server. The ",(0,o.jsx)(n.code,{children:"UserEventTriggered"})," event is triggered when the connection is established.\nWe can identify the successful connection of a client by receiving a ",(0,o.jsx)(n.code,{children:"UserEventTriggered(UserEvent.HandshakeComplete)"})," event. And if the client sends us a text message, we will receive a ",(0,o.jsx)(n.code,{children:"Read(WebSocketFrame.Text(<text>))"})," event."]}),"\n",(0,o.jsx)(n.p,{children:"Our WebSocketApp will handle the following events send by the client:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:'If the client connects to the server, we will send a "Greetings!" message to the client.'}),"\n",(0,o.jsx)(n.li,{children:'If the client sends "foo", we will send a "bar" message back to the client.'}),"\n",(0,o.jsx)(n.li,{children:'If the client sends "bar", we will send a "foo" message back to the client.'}),"\n",(0,o.jsx)(n.li,{children:'If the client sends "end", we will close the connection.'}),"\n",(0,o.jsx)(n.li,{children:"If the client sends any other message, we will send the same message back to the client 10 times."}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["For the client to establish a connection with the server, we offer the ",(0,o.jsx)(n.code,{children:"/subscriptions"})," endpoint."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",metastring:'title="zio-http-example/src/main/scala/example/WebSocketAdvanced.scala" ',children:'import scala.annotation.nowarn\n\nimport zio._\n\nimport zio.http.ChannelEvent.{ExceptionCaught, Read, UserEvent, UserEventTriggered}\n\nimport zio.http.codec.PathCodec.string\n\nobject WebSocketAdvanced extends ZIOAppDefault {\n\n  val socketApp: WebSocketApp[Any] =\n    Handler.webSocket { channel =>\n      channel.receiveAll {\n        case Read(WebSocketFrame.Text("end"))                =>\n          channel.shutdown\n\n        // Send a "bar" if the client sends a "foo"\n        case Read(WebSocketFrame.Text("foo"))                =>\n          channel.send(Read(WebSocketFrame.text("bar")))\n\n        // Send a "foo" if the client sends a "bar"\n        case Read(WebSocketFrame.Text("bar"))                =>\n          channel.send(Read(WebSocketFrame.text("foo")))\n\n        // Echo the same message 10 times if it\'s not "foo" or "bar"\n        case Read(WebSocketFrame.Text(text))                 =>\n          channel\n            .send(Read(WebSocketFrame.text(s"echo $text")))\n            .repeatN(10)\n            .catchSomeCause { case cause =>\n              ZIO.logErrorCause(s"failed sending", cause)\n            }\n\n        // Send a "greeting" message to the client once the connection is established\n        case UserEventTriggered(UserEvent.HandshakeComplete) =>\n          channel.send(Read(WebSocketFrame.text("Greetings!")))\n\n        // Log when the channel is getting closed\n        case Read(WebSocketFrame.Close(status, reason))      =>\n          Console.printLine("Closing channel with status: " + status + " and reason: " + reason)\n\n        // Print the exception if it\'s not a normal close\n        case ExceptionCaught(cause)                          =>\n          Console.printLine(s"Channel error!: ${cause.getMessage}")\n\n        case _ =>\n          ZIO.unit\n      }\n    }\n\n  val routes: Routes[Any, Response] =\n    Routes(\n      Method.GET / "greet" / string("name") -> handler { (name: String, _: Request) =>\n        Response.text(s"Greetings ${name}!")\n      },\n      Method.GET / "subscriptions"          -> handler(socketApp.toResponse),\n    )\n\n'})}),"\n",(0,o.jsx)(n.p,{children:"A few things worth noting:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"Server.default"})," starts a server on port 8080."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"socketApp.toResponse"})," converts the ",(0,o.jsx)(n.code,{children:"WebSocketApp"})," to a ",(0,o.jsx)(n.code,{children:"Response"}),", so we can serve it with ",(0,o.jsx)(n.code,{children:"handler"}),"."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"client",children:"Client"}),"\n",(0,o.jsxs)(n.p,{children:["The client will connect to the server and send a message to the server every time the user enters a message in the console.\nFor this we will use the ",(0,o.jsx)(n.code,{children:"Console.readLine"})," method to read a line from the console. We will then send the message to the server using the ",(0,o.jsx)(n.code,{children:"WebSocketChannel.send"})," method.\nBut since we don't want to reconnect to the server every time the user enters a message, we will use a ",(0,o.jsx)(n.code,{children:"Queue"})," to store the messages. We will then use the ",(0,o.jsx)(n.code,{children:"Queue.take"})," method to take a message from the queue and send it to the server, whenever a new message is available.\nAdding a new message to the queue, as well as sending the messages to the server, should happen in a loop in the background. For this we will use the operators ",(0,o.jsx)(n.code,{children:"forever"})," (looping) and ",(0,o.jsx)(n.code,{children:"forkDaemon"})," (fork to a background fiber)."]}),"\n",(0,o.jsxs)(n.p,{children:["Again we will use the ",(0,o.jsx)(n.code,{children:"Handler.webSocket"})," constructor to define how to handle messages and create a ",(0,o.jsx)(n.code,{children:"WebSocketApp"}),". But this time, instead of serving the ",(0,o.jsx)(n.code,{children:"WebSocketApp"})," we will use the ",(0,o.jsx)(n.code,{children:"connect"})," method to establish a connection to the server.\nAll we need for that, is the URL of the server. In our case it's ",(0,o.jsx)(n.code,{children:'"ws://localhost:8080/subscriptions"'}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",metastring:'title="zio-http-example/src/main/scala/example/WebSocketAdvanced.scala" ',children:'import scala.annotation.nowarn\n\nimport zio._\n\nimport zio.http.ChannelEvent.{ExceptionCaught, Read, UserEvent, UserEventTriggered}\n\n}\n\nobject WebSocketAdvancedClient extends ZIOAppDefault {\n\n  def sendChatMessage(message: String): ZIO[Queue[String], Throwable, Unit] =\n    ZIO.serviceWithZIO[Queue[String]](_.offer(message).unit)\n\n  def processQueue(channel: WebSocketChannel): ZIO[Queue[String], Throwable, Unit] = {\n    for {\n      queue <- ZIO.service[Queue[String]]\n      msg   <- queue.take\n      _     <- channel.send(Read(WebSocketFrame.Text(msg)))\n    } yield ()\n  }.forever.forkDaemon.unit\n\n  private def webSocketHandler: ZIO[Queue[String] with Client with Scope, Throwable, Response] =\n    Handler.webSocket { channel =>\n      for {\n        _ <- processQueue(channel)\n        _ <- channel.receiveAll {\n          case Read(WebSocketFrame.Text(text)) =>\n            Console.printLine(s"Server: $text")\n          case _                               =>\n            ZIO.unit\n        }\n      } yield ()\n    }.connect("ws://localhost:8080/subscriptions")\n\n  @nowarn("msg=dead code")\n  override val run =\n    ZIO\n      .scoped(for {\n        _ <- webSocketHandler\n        _ <- Console.readLine.flatMap(sendChatMessage).forever.forkDaemon\n        _ <- ZIO.never\n      } yield ())\n      .provide(\n        Client.default,\n'})}),"\n",(0,o.jsxs)(n.p,{children:["While we access here ",(0,o.jsx)(n.code,{children:"Queue[String]"})," via the ZIO environment, you should use a service in a real world application, that requires a queue as one of its constructor dependencies.\nSee ",(0,o.jsx)(n.a,{href:"https://zio.dev/reference/service-pattern/",children:"ZIO Services"})," for more information."]}),"\n",(0,o.jsx)(n.h2,{id:"websocket-echo",children:"WebSocket Echo"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",metastring:'title="zio-http-example/src/main/scala/example/WebSocketEcho.scala" ',children:'package example\n\nimport zio._\n\nimport zio.http.ChannelEvent.Read\nimport zio.http._\nimport zio.http.codec.PathCodec.string\n\nobject WebSocketEcho extends ZIOAppDefault {\n  private val socketApp: WebSocketApp[Any] =\n    Handler.webSocket { channel =>\n      channel.receiveAll {\n        case Read(WebSocketFrame.Text("FOO")) =>\n          channel.send(Read(WebSocketFrame.Text("BAR")))\n        case Read(WebSocketFrame.Text("BAR")) =>\n          channel.send(Read(WebSocketFrame.Text("FOO")))\n        case Read(WebSocketFrame.Text(text))  =>\n          channel.send(Read(WebSocketFrame.Text(text))).repeatN(10)\n        case _                                =>\n          ZIO.unit\n      }\n    }\n\n  private val routes: Routes[Any, Response] =\n    Routes(\n      Method.GET / "greet" / string("name") -> handler { (name: String, _: Request) =>\n        Response.text(s"Greetings {$name}!")\n      },\n      Method.GET / "subscriptions"          -> handler(socketApp.toResponse),\n    )\n\n  override val run = Server.serve(routes).provide(Server.default)\n}\n'})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>c});var s=t(96540);const o={},a=s.createContext(o);function r(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);