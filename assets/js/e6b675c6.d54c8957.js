"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[59001],{6022:(e,s,r)=>{r.r(s),r.d(s,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"zio-sql/deep-dive","title":"Deep dive","description":"Inserts in depth","source":"@site/docs/zio-sql/deep-dive.md","sourceDirName":"zio-sql","slug":"/zio-sql/deep-dive","permalink":"/zio-sql/deep-dive","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-sql/deep-dive.md","tags":[],"version":"current","frontMatter":{"id":"deep-dive","title":"Deep dive"},"sidebar":"ecosystem-sidebar","previous":{"title":"ZIO SQL","permalink":"/zio-sql/"},"next":{"title":"ZIO SQS","permalink":"/zio-sqs/"}}');var n=r(74848),i=r(28453);const a={id:"deep-dive",title:"Deep dive"},o=void 0,l={},c=[{value:"Inserts in depth",id:"inserts-in-depth",level:2},{value:"Table description",id:"table-description",level:3},{value:"Insert tuples",id:"insert-tuples",level:3},{value:"Insert custom case class",id:"insert-custom-case-class",level:3},{value:"Show generated SQL query",id:"show-generated-sql-query",level:3},{value:"Execute the query",id:"execute-the-query",level:3},{value:"More examples",id:"more-examples",level:3},{value:"What is missing",id:"what-is-missing",level:3},{value:"Subqueries &amp; Correlated subqueries",id:"subqueries--correlated-subqueries",level:2},{value:"Subquery",id:"subquery",level:3},{value:"Correlated subqueries",id:"correlated-subqueries",level:3},{value:"Correlated subquery in from clause &amp; Derived tables",id:"correlated-subquery-in-from-clause--derived-tables",level:3},{value:"Learning Resources",id:"learning-resources",level:2}];function d(e){const s={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.h2,{id:"inserts-in-depth",children:"Inserts in depth"}),"\n",(0,n.jsx)(s.h3,{id:"table-description",children:"Table description"}),"\n",(0,n.jsxs)(s.p,{children:["As usual, in order to use the DSL, first thing we need to do is to create meta-model of our table. Let\u2019s imagine we have a ",(0,n.jsx)(s.em,{children:"customers"})," table in postgres (in case of a different database just extend the appropriate module)\nTo describe table, create a simple case class which describes table data. Derive implicit ",(0,n.jsx)(s.code,{children:"Schema"})," for that type and just call ",(0,n.jsx)(s.code,{children:"defineTable"})," with the type parameter of that case class.\nTo extract columns from table call ",(0,n.jsx)(s.code,{children:"columns"})," method on your table, which returns a flat tuple of all columns."]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-scala",children:"import zio.sql.postgresql.PostgresJdbcModule\n\ntrait TableModel extends PostgresJdbcModule {\n\n  case class Customer(id: UUID, dob: LocalDate, firstName: String, lastName: String, verified: Boolean, createdTimestampString: String, createdTimestamp: ZonedDateTime)\n\n  implicit val custommerSchema = DeriveSchema.gen[Customer]\n\n  val customers = defineTable[Customer]\n\n  val (customerId, dob, fName, lName, verified, createdString, createdTimestamp) =\n    customers.columns\n} \n"})}),"\n",(0,n.jsxs)(s.p,{children:["Then, to use zio-sql \u2019s inserts, just mix in ",(0,n.jsx)(s.code,{children:"TableModel"})," trait from above, to your repository."]}),"\n",(0,n.jsxs)(s.p,{children:["In case you\u2019re wondering what those extracted columns are (customerId, dob etc), they are of a type called ",(0,n.jsx)(s.em,{children:"Expr"}),".\n",(0,n.jsx)(s.code,{children:"Expr[F, A, B]"})," is fundamental abstraction in zio-sql which basically represents description of any SQL expression of type ",(0,n.jsx)(s.code,{children:"B"}),", having a source of type ",(0,n.jsx)(s.code,{children:"A"})," and a phantom type ",(0,n.jsx)(s.code,{children:"F"}),".\nTo give specific example, type of ",(0,n.jsx)(s.code,{children:"fName"})," is"]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-scala",children:"Expr[Features.Source[String(\u201cfirst_name\u201d)], customers.TableType, String]. \n"})}),"\n",(0,n.jsx)(s.p,{children:"This gives DSL huge power to remember table from which the column comes from, type of the columns and what kind of Expr we are dealing with. Don\u2019t worry, you don\u2019t need to remember any of this, but from now on we will use those Expr instances in our inserts."}),"\n",(0,n.jsxs)(s.p,{children:["In general, DSL is giving us two options how to approach inserts. We can insert either tuple values or used defined case class - which requires zio-schema instance (more on that later).\nAlso your custom data type or tuple need to consist only of the types for which there is a ",(0,n.jsx)(s.code,{children:"TypeTag"})," instance defined. Each sql module has a finite set of such types - those are the types that particular module can work with. In other words, types inside your tuples or case class need to correspond with the types of the extracted Exprs."]}),"\n",(0,n.jsx)(s.h3,{id:"insert-tuples",children:"Insert tuples"}),"\n",(0,n.jsx)(s.p,{children:"Let\u2019s say we want to build the query like the following one:"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-sql",children:"insert into \n  customers(id, date_of_birth, first_name, last_name, verified_customer, created)\nvalues\n  ('60b01fc9-c902-4468-8d49-3c0f989def37', \u20181983-01-05\u2019, 'Ronald', 'Russell', true, '2020-11-21 19:10:25+00')\n"})}),"\n",(0,n.jsx)(s.p,{children:"zio-sql gives us nice typesafe DSL that feels similar to writing SQL:"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-scala",children:'insertInto(customers)\n    (customerId, dob, fName, lName, verified, created)\n  .values((UUID.randomUUID(), LocalDate.ofYearDay(1990, 1), "Ronald", "Russell", true, ZonedDateTime.now()))\n'})}),"\n",(0,n.jsx)(s.p,{children:"Compiler verifies your inserts and your query fails with compile-time error at any of the following situations:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"you mess up the order of values - e.g. you put Boolean where String is expected"}),"\n",(0,n.jsx)(s.li,{children:"you don\u2019t specify all the not null columns of the table"}),"\n",(0,n.jsx)(s.li,{children:"you try to insert to columns from another table"}),"\n"]}),"\n",(0,n.jsxs)(s.p,{children:["Some  details about syntax: ",(0,n.jsx)(s.code,{children:"insertInto"})," method takes two value parameters. One is our table ",(0,n.jsx)(s.code,{children:"customers"})," that we created before in ",(0,n.jsx)(s.em,{children:"Table description"})," section. The other is an ",(0,n.jsx)(s.em,{children:"HList like"})," collection of Expr\u2019s, called ",(0,n.jsx)(s.code,{children:"Selection"}),". You create it by appending Exprs with \u201c++\u201d operator.\n",(0,n.jsx)(s.code,{children:"values"})," method takes a Tuple6 of type (UUID, LocalDate, String, String, Boolean, ZonedDateTime). The required tuple is dependent on combination of Exprs. Just like with normal sql insert, you could swap ",(0,n.jsx)(s.code,{children:"fName"})," with ",(0,n.jsx)(s.code,{children:"dob"})," Expr and corresponding values and your query will work just fine. Compiler will only let you build such queries that won\u2019t explode in runtime (in case you described your table correctly of course ! )"]}),"\n",(0,n.jsxs)(s.p,{children:["If we need to insert multiple values at once, all we need to do is to create any ",(0,n.jsx)(s.code,{children:"Seq"})," of tuples and stick it into the overloaded ",(0,n.jsx)(s.code,{children:"values"})," method."]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-scala",children:'val data =\n        List(\n          (UUID.randomUUID(), LocalDate.ofYearDay(1990, 1), "Ronald1", "Russel1", true,  ZonedDateTime.now()),\n          (UUID.randomUUID(), LocalDate.ofYearDay(1980, 1), "Ronald2", "Russel2", false,  ZonedDateTime.now()),\n          (UUID.randomUUID(), LocalDate.ofYearDay(1970, 1), "Ronald3", "Russel3", true,  ZonedDateTime.now())\n        )\n\nval query = insertInto(customers)(\n        customerId, dob, fName, lName, verified, createdString, createdTimestamp\n      ).values(data)\n'})}),"\n",(0,n.jsxs)(s.p,{children:["In this case, data is of type ",(0,n.jsx)(s.code,{children:"List[(UUID, LocalDate, String, String, Boolean, ZonedDateTime)]"})]}),"\n",(0,n.jsx)(s.h3,{id:"insert-custom-case-class",children:"Insert custom case class"}),"\n",(0,n.jsxs)(s.p,{children:["ZIO SQL lets you insert also your own case classes.\nLet\u2019s define a ",(0,n.jsx)(s.em,{children:"customer"})," case class:"]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-scala",children:"final case class Customer(\n        id: UUID,\n        dateOfBirth: LocalDate,\n        firstName: String,\n        lastName: String,\n        verified: Boolean,\n        createdTimestamp: ZonedDateTime\n      )\n"})}),"\n",(0,n.jsx)(s.p,{children:"In this case, the name of the fields makes no difference. Similarly to writing sql, the order of the fields is important."}),"\n",(0,n.jsx)(s.p,{children:"zio-sql also needs an implicit instance of zio-schema for your data type. You can define it easily:"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-scala",children:"import zio.schema.DeriveSchema\nimplicit val customerSchema = DeriveSchema.gen[Customer]\n"})}),"\n",(0,n.jsx)(s.p,{children:"Then your insert looks almost the same as before:"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-scala",children:'val data: Customer = Customer(UUID.randomUUID(), LocalDate.ofYearDay(1990, 1), "Ronald", "Russel", true, ZonedDateTime.now())\n\nval query = insertInto(customers)(\n        customerId, dob, fName, lName, verified, createdString, createdTimestamp\n      ).values(data)\n'})}),"\n",(0,n.jsxs)(s.p,{children:["Or you can insert multiple rows at once. Just define data as a ",(0,n.jsx)(s.code,{children:"List"})," or any collection of your choice."]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-scala",children:"val data : List[Customer] = ???\n"})}),"\n",(0,n.jsx)(s.h3,{id:"show-generated-sql-query",children:"Show generated SQL query"}),"\n",(0,n.jsxs)(s.p,{children:["In case you want to see the exact query that zio-sql generated, you can use ",(0,n.jsx)(s.code,{children:"renderInsert"})," method inside repo that has PostgresModule (or TableModel from above example) mixed in."]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-scala",children:'val query = insertInto(customers)(\n        customerId, dob, fName, lName, verified, createdString, createdTimestamp\n      ).values((UUID.randomUUID(), LocalDate.ofYearDay(1990, 1), "Ronald", "Russell", true, ZonedDateTime.now()))\n\nval sqlString: String = renderInsert(query)\n'})}),"\n",(0,n.jsx)(s.h3,{id:"execute-the-query",children:"Execute the query"}),"\n",(0,n.jsxs)(s.p,{children:["In order to execute a query, we use ",(0,n.jsx)(s.code,{children:"execute"})," method inside repo that has PostgresModule (or TableModel from the above example) mixed in."]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-scala",children:'val query = insertInto(customers)(\n        customerId, dob, fName, lName, verified, createdString, createdTimestamp\n      ).values((UUID.randomUUID(), LocalDate.ofYearDay(1990, 1), "Ronald", "Russell", true, ZonedDateTime.now()))\n\nval executed : ZIO[Has[SqlDriver], Exception, Int] = execute(query)\n'})}),"\n",(0,n.jsxs)(s.p,{children:["As the type of ",(0,n.jsx)(s.code,{children:"executed"})," indicates, you need to provide an ",(0,n.jsx)(s.code,{children:"SqlDriver"})," in order to run this effect. The result ",(0,n.jsx)(s.em,{children:"Int"})," is the number of rows updated."]}),"\n",(0,n.jsx)(s.h3,{id:"more-examples",children:"More examples"}),"\n",(0,n.jsxs)(s.p,{children:["More examples can be found in zio-sql test suite (",(0,n.jsx)(s.code,{children:"PostgresModuleSpec"}),", ",(0,n.jsx)(s.code,{children:"SqlServerModuleSpec"}),", \u2026) or in zio-sql-example application in resources."]}),"\n",(0,n.jsx)(s.h3,{id:"what-is-missing",children:"What is missing"}),"\n",(0,n.jsx)(s.p,{children:"As of now - Q1 2022 - zio-sql contributors is actively working on:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"returning generated IDs from inserts"}),"\n",(0,n.jsx)(s.li,{children:"introduce nullable columns - for which user won\u2019t need to input values"}),"\n",(0,n.jsx)(s.li,{children:"introduce auto generated columns - for which user cannot input values"}),"\n"]}),"\n",(0,n.jsx)(s.h2,{id:"subqueries--correlated-subqueries",children:"Subqueries & Correlated subqueries"}),"\n",(0,n.jsx)(s.p,{children:"The goal of ZIO SQL is to give users the ability to describe also queries much more complex than just simple selects or joins. In this section we will introduce a few examples of subqueries and correlated subqueries. In case you will find a query which is not possible to write with zio-sql - or the generated sql query looks differently then expected - please contact us on discord and we will try to add your use case to the next release :) Now let\u2019s explore what is possible today."}),"\n",(0,n.jsx)(s.h3,{id:"subquery",children:"Subquery"}),"\n",(0,n.jsx)(s.p,{children:"Subquery is a query which is a part of another query. It\u2019s executed first - before outer query - and then its result is used in outer query."}),"\n",(0,n.jsx)(s.p,{children:"Now let\u2019s say we want to build following query (this is on MSSQL Server) :"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-sql",children:"select order_id, product_id, unit_price \nfrom order_details\nwhere unit_price > (select AVG(price) from product_prices )\n"})}),"\n",(0,n.jsxs)(s.p,{children:["We want to match details about orders, but we are interested only in those orders where price is higher than average price of all the products from ",(0,n.jsx)(s.code,{children:"product_prices"})," table."]}),"\n",(0,n.jsx)(s.p,{children:"This is the meta model that we are working with:"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-scala",children:"case class ProductPrices(productId: UUID, effective: OffsetDateTime, price: BigDecimal)\ncase class OrderDetails(orderId: UUID, productId: UUID, unitPrice: BigDecimal)\n\nimplicit val productPricesSchema = DeriveSchema.gen[ProductPrices]\nimplicit val orderDetailsSchema = DeriveSchema.gen[OrderDetails]\n\nval productPrices = defineTable[ProductPrices]\nval (fkProductId, effective, price) = productPrices.columns    \n\nval orderDetails = defineTable[OrderDetails]\nval (orderDetailsId, productId, unitPrice) = orderDetails.columns\n"})}),"\n",(0,n.jsx)(s.p,{children:"We can create query very easily. In fact, just type it like a regular sql query and let your IDE auto completion guide you!"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-scala",children:"val query = select(orderDetailsId, productId, unitPrice)\n        .from(orderDetails)\n        .where(\n          unitPrice > select(Avg(price)).from(productPrices)\n        )\n"})}),"\n",(0,n.jsx)(s.p,{children:"Then you can either execute the query to selected types or inspect sql query represented as a String.\nYou just need a custom data type (Row in our example) to encapsulate results of a selection."}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-scala",children:"case class Row(orderId: UUID, productId: UUID, unitPrice: BigDecimal)\n\nval result: ZStream[Has[SqlDriver],Exception,Row] = execute(query.to[UUID, UUID, BigDecimal, Row](Row.apply))\n\nval sqlQuery: String = renderRead(query)\n"})}),"\n",(0,n.jsxs)(s.p,{children:["Similarly you can use subqueries inside ",(0,n.jsx)(s.code,{children:"select"})," clause."]}),"\n",(0,n.jsx)(s.h3,{id:"correlated-subqueries",children:"Correlated subqueries"}),"\n",(0,n.jsx)(s.p,{children:"Correlated subqueries are the ones that are executed after the outer query. They can be dependent on the result of the outer query and therefore they are executed for each resulting row of the outer query."}),"\n",(0,n.jsx)(s.p,{children:"Lets say we want to build the following query:"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-sql",children:'select first_name, last_name, \n\t\t( select count(orders.id) from orders where customers.id = orders.customer_id ) as "count" \nfrom customers\n'})}),"\n",(0,n.jsx)(s.p,{children:"This would return the count of orders for each customer."}),"\n",(0,n.jsx)(s.p,{children:"Description of tables:"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-scala",children:"case class Customers(id: UUID, firstName: String, lastName: String)\ncase class Orders(id: UUID, customerId: UUID, orderDate: LocalDate)\n\nimplicit val customerSchema = DeriveSchema.gen[Customers]\nimplicit val orderSchema = DeriveSchema.gen[Orders]\n\nval customers = defineTable[Customers]\nval (customerId, fName, lName) = customers.columns    \n\nval orders = defineTable[Orders]\nval (orderId, fkCustomerId, orderDate) = orders.columns\n"})}),"\n",(0,n.jsx)(s.p,{children:"ZIO SQL query:"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-scala",children:'val subquery =\n        customers.subselect(Count(orderId)).from(orders).where(fkCustomerId === customerId)\n\nval query = select(fName, lName, (subquery as "Count")).from(customers)\n'})}),"\n",(0,n.jsx)(s.p,{children:"All of these examples and more can be found and run in zio-sql tests."}),"\n",(0,n.jsx)(s.h3,{id:"correlated-subquery-in-from-clause--derived-tables",children:"Correlated subquery in from clause & Derived tables"}),"\n",(0,n.jsxs)(s.p,{children:["Just one last, a little more complex example before we wrap up this section, for which we would use the same ",(0,n.jsx)(s.em,{children:"customers"})," and ",(0,n.jsx)(s.em,{children:"orders"})," tables as before."]}),"\n",(0,n.jsxs)(s.p,{children:["Imagine we want to write a query that selects all customers with the date of their last order. If you approach this problem with JOIN, you end up with one row of a customer with the newest order. In fact, this is a good example of correlated subquery inside ",(0,n.jsx)(s.code,{children:"from"})," clause, where subquery needs to access ",(0,n.jsx)(s.code,{children:"customer_id"})," of the outer query. For this type of problems postgres introduced ",(0,n.jsx)(s.strong,{children:"LATERAL"})," keyword and MSSQL Server have ",(0,n.jsx)(s.strong,{children:"CROSS APPLY"})," and ",(0,n.jsx)(s.strong,{children:"OUTER APPLY"}),"."]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-sql",children:"select customers.id, customers.first_name, customers.last_name, derived.order_date\n                from customers,\n                lateral  (\n                     select orders.order_date\n                     from orders\n                     where customers.id = orders.customer_id\n                     order by orders.order_date desc limit 1 ) derived order by derived.order_date desc\n"})}),"\n",(0,n.jsxs)(s.p,{children:["Now it\u2019s starting to be a little more complicated. First we need to create a ",(0,n.jsx)(s.code,{children:"subselect"})," which can access columns from another source table - ",(0,n.jsx)(s.code,{children:"customers"})," in our case. Then we specify this source as a type parameter to ",(0,n.jsx)(s.code,{children:"subselect"}),". In order to build the whole query we also need ",(0,n.jsx)(s.code,{children:"derived.order_date"})," which is coming from ",(0,n.jsx)(s.code,{children:"derived"})," table, so that we can extract that column. We create ",(0,n.jsx)(s.code,{children:"derivedTable"})," by calling ",(0,n.jsx)(s.code,{children:"asTable(tableName: String)"})," method on ",(0,n.jsx)(s.code,{children:"subselect"}),"."]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-scala",children:' val derivedTable  = subselect[customers.TableType](orderDate)\n        .from(orders)\n        .limit(1)\n        .where(customerId === fkCustomerId)\n        .orderBy(Ordering.Desc(orderDate))\n        .asTable("derived")\n\nval orderDateDerived :*: _ = derivedTable\n'})}),"\n",(0,n.jsx)(s.p,{children:"Finally, we have all the ingredients we need to describe our query with zio-sql."}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-scala",children:"import PostgresSpecific.PostgresSpecificTable._\n\nval query =\n        select(customerId, fName, lName, orderDateDerived)\n          .from(customers.lateral(derivedTable))\n          .orderBy(Ordering.Desc(orderDateDerived))\n"})}),"\n",(0,n.jsx)(s.h2,{id:"learning-resources",children:"Learning Resources"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.a,{href:"https://github.com/sviezypan/zio-sql-example",children:"ZIO SQL Example Application"})," by ",(0,n.jsx)(s.a,{href:"https://github.com/sviezypan",children:"Jaro Regec"})]}),"\n"]})]})}function u(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},28453:(e,s,r)=>{r.d(s,{R:()=>a,x:()=>o});var t=r(96540);const n={},i=t.createContext(n);function a(e){const s=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),t.createElement(i.Provider,{value:s},e.children)}}}]);