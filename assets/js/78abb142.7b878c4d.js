"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[96974],{8280:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"reference/concurrency/semaphore","title":"Semaphore","description":"A Semaphore datatype which allows synchronization between fibers with the withPermit operation, which safely acquires and releases a permit.","source":"@site/docs/reference/concurrency/semaphore.md","sourceDirName":"reference/concurrency","slug":"/reference/concurrency/semaphore","permalink":"/reference/concurrency/semaphore","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/concurrency/semaphore.md","tags":[],"version":"current","frontMatter":{"id":"semaphore","title":"Semaphore"},"sidebar":"reference-sidebar","previous":{"title":"Hub","permalink":"/reference/concurrency/hub"},"next":{"title":"Introduction to Software Transactional Memory","permalink":"/reference/stm/"}}');var t=r(74848),a=r(28453);const i={id:"semaphore",title:"Semaphore"},o=void 0,c={},l=[{value:"Operations",id:"operations",level:2}];function h(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.code,{children:"Semaphore"})," datatype which allows synchronization between fibers with the ",(0,t.jsx)(n.code,{children:"withPermit"})," operation, which safely acquires and releases a permit.\n",(0,t.jsx)(n.code,{children:"Semaphore"})," is based on ",(0,t.jsx)(n.code,{children:"Ref[A]"})," datatype."]}),"\n",(0,t.jsx)(n.h2,{id:"operations",children:"Operations"}),"\n",(0,t.jsxs)(n.p,{children:["For example, a synchronization of asynchronous tasks can\nbe done via acquiring and releasing a semaphore with a given number of permits it can spend.\nWhen the acquire operation cannot be performed due to no more available ",(0,t.jsx)(n.code,{children:"permits"})," in the semaphore, such task\nis semantically blocked, until the ",(0,t.jsx)(n.code,{children:"permits"})," value is large enough again:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'import java.util.concurrent.TimeUnit\nimport zio._\nimport zio.Console._\n\nval task = for {\n  _ <- printLine("start")\n  _ <- ZIO.sleep(Duration(2, TimeUnit.SECONDS))\n  _ <- printLine("end")\n} yield ()\n\nval semTask = (sem: Semaphore) => for {\n  _ <- sem.withPermit(task)\n} yield ()\n\nval semTaskSeq = (sem: Semaphore) => (1 to 3).map(_ => semTask(sem))\n\nval program = for {\n\n  sem <- Semaphore.make(permits = 1)\n\n  seq <- ZIO.succeed(semTaskSeq(sem))\n\n  _ <- ZIO.collectAllPar(seq)\n\n} yield ()\n'})}),"\n",(0,t.jsxs)(n.p,{children:["As the binary semaphore is a special case of a counting semaphore,\nwe can acquire and release any number of ",(0,t.jsx)(n.code,{children:"permits"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"val semTaskN = (sem: Semaphore) => for {\n  _ <- sem.withPermits(5)(task)\n} yield ()\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The guarantee of ",(0,t.jsx)(n.code,{children:"withPermit"})," (and its corresponding counting version ",(0,t.jsx)(n.code,{children:"withPermits"}),") is that each acquisition will be followed by the equivalent number of releases, regardless of whether the task succeeds, fails, or is interrupted."]})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>o});var s=r(96540);const t={},a=s.createContext(t);function i(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);