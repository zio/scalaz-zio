"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[33292],{70049:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>o,contentTitle:()=>s,default:()=>d,frontMatter:()=>l,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"reference/error-management/sequential-and-parallel-errors","title":"Sequential and Parallel Errors","description":"A simple and regular ZIO application usually fails with one error, which is the first error encountered by the ZIO runtime:","source":"@site/docs/reference/error-management/sequential-and-parallel-errors.md","sourceDirName":"reference/error-management","slug":"/reference/error-management/sequential-and-parallel-errors","permalink":"/reference/error-management/sequential-and-parallel-errors","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/error-management/sequential-and-parallel-errors.md","tags":[],"version":"current","frontMatter":{"id":"sequential-and-parallel-errors","title":"Sequential and Parallel Errors"},"sidebar":"reference-sidebar","previous":{"title":"Typed Errors Guarantees","permalink":"/reference/error-management/typed-errors-guarantees"},"next":{"title":"1. Catching","permalink":"/reference/error-management/recovering/catching"}}');var i=n(74848),t=n(28453);const l={id:"sequential-and-parallel-errors",title:"Sequential and Parallel Errors"},s=void 0,o={},c=[];function p(e){const r={code:"code",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.p,{children:"A simple and regular ZIO application usually fails with one error, which is the first error encountered by the ZIO runtime:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-scala",children:'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  val fail = ZIO.fail("Oh uh!")\n  val die = ZIO.dieMessage("Boom!")\n  val interruption = ZIO.interrupt\n\n  def run = (fail <*> die) *> interruption\n}\n'})}),"\n",(0,i.jsx)(r.p,{children:'This application will fail with the first error which is "Oh uh!":'}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-scala",children:'timestamp=2022-03-09T09:50:22.067072131Z level=ERROR thread=#zio-fiber-0 message="Exception in thread "zio-fiber-2" java.lang.String: Oh uh!\n\tat <empty>.MainApp.fail(MainApp.scala:4)"\n'})}),"\n",(0,i.jsx)(r.p,{children:"In some cases, we may run into multiple errors. When we perform parallel computations, the application may fail due to multiple errors:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-scala",children:'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run = ZIO.fail("Oh!") <&> ZIO.fail("Uh!")\n}\n'})}),"\n",(0,i.jsxs)(r.p,{children:["If we run this application, we can see two exceptions in two different fibers that caused the failure (",(0,i.jsx)(r.code,{children:"zio-fiber-0"})," and ",(0,i.jsx)(r.code,{children:"zio-fiber-14"}),"):"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-scala",children:'timestamp=2022-03-09T08:05:48.703035927Z level=ERROR thread=#zio-fiber-0 message="Exception in thread "zio-fiber-13" java.lang.String: Oh!\n\tat <empty>.MainApp.run(MainApp.scala:4)\nException in thread "zio-fiber-14" java.lang.String: Uh!\n\tat <empty>.MainApp.run(MainApp.scala:4)"\n'})}),"\n",(0,i.jsxs)(r.p,{children:["ZIO has a combinator called ",(0,i.jsx)(r.code,{children:"ZIO#parallelErrors"})," that exposes all parallel failure errors in the error channel:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-scala",children:'import zio._\n\nval result: ZIO[Any, ::[String], Nothing] =\n  (ZIO.fail("Oh uh!") <&> ZIO.fail("Oh Error!")).parallelErrors\n'})}),"\n",(0,i.jsx)(r.p,{children:"Note that this operator is only for failures, not defects or interruptions."}),"\n",(0,i.jsxs)(r.p,{children:["Also, when we work with resource-safety operators like ",(0,i.jsx)(r.code,{children:"ZIO#ensuring"})," we can have multiple sequential errors. Why? because regardless of the original effect has any errors or not, the finalizer is uninterruptible. So the finalizer will be run. Unless the finalizer should be an unexceptional effect (",(0,i.jsx)(r.code,{children:"URIO"}),"), it may die because of a defect. Therefore, it creates multiple sequential errors:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-scala",children:'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run = ZIO.fail("Oh uh!").ensuring(ZIO.dieMessage("Boom!"))\n}\n'})}),"\n",(0,i.jsxs)(r.p,{children:["When we run this application, we can see that the original failure (",(0,i.jsx)(r.code,{children:"Oh uh!"}),") was suppressed by another defect (",(0,i.jsx)(r.code,{children:"Boom!"}),"):"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-scala",children:'timestamp=2022-03-09T08:30:56.563179230Z level=ERROR thread=#zio-fiber-0 message="Exception in thread "zio-fiber-2" java.lang.String: Oh uh!\n\tat <empty>.MainApp.run(MainApp.scala:4)\n\tSuppressed: java.lang.RuntimeException: Boom!\n\t\tat <empty>.MainApp.run(MainApp.scala:4)"\n'})})]})}function d(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}},28453:(e,r,n)=>{n.d(r,{R:()=>l,x:()=>s});var a=n(96540);const i={},t=a.createContext(i);function l(e){const r=a.useContext(t);return a.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function s(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),a.createElement(t.Provider,{value:r},e.children)}}}]);