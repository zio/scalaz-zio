"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[18088],{34284:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"reference/test/property-testing/built-in-generators","title":"Built-in Generators","description":"In the companion object of the Gen data type, there are tons of generators for various data types.","source":"@site/docs/reference/test/property-testing/built-in-generators.md","sourceDirName":"reference/test/property-testing","slug":"/reference/test/property-testing/built-in-generators","permalink":"/reference/test/property-testing/built-in-generators","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/test/property-testing/built-in-generators.md","tags":[],"version":"current","frontMatter":{"id":"built-in-generators","title":"Built-in Generators"},"sidebar":"reference-sidebar","previous":{"title":"How Generators Work?","permalink":"/reference/test/property-testing/how-generators-work"},"next":{"title":"Shrinking","permalink":"/reference/test/property-testing/shrinking"}}');var t=s(74848),l=s(28453);const i={id:"built-in-generators",title:"Built-in Generators"},a=void 0,c={},o=[{value:"Primitive Types Generators",id:"primitive-types-generators",level:2},{value:"Character Generators",id:"character-generators",level:2},{value:"String Generators",id:"string-generators",level:2},{value:"Generating Fixed Values",id:"generating-fixed-values",level:2},{value:"Generating from Fixed Values",id:"generating-from-fixed-values",level:2},{value:"Collection Generators",id:"collection-generators",level:2},{value:"Bounded Generator",id:"bounded-generator",level:2},{value:"Suspended Generator",id:"suspended-generator",level:2},{value:"Unfold Generator",id:"unfold-generator",level:2},{value:"From a ZIO Effect",id:"from-a-zio-effect",level:2},{value:"From a Random Effect",id:"from-a-random-effect",level:2},{value:"Uniform and Non-uniform Generators",id:"uniform-and-non-uniform-generators",level:2},{value:"Generating Date/Time Types",id:"generating-datetime-types",level:2},{value:"Function Generators",id:"function-generators",level:2},{value:"Generating ZIO Values",id:"generating-zio-values",level:2},{value:"Generating Compound Types",id:"generating-compound-types",level:2},{value:"Sized Generators",id:"sized-generators",level:2}];function d(e){const n={code:"code",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["In the companion object of the ",(0,t.jsx)(n.code,{children:"Gen"})," data type, there are tons of generators for various data types."]}),"\n",(0,t.jsx)(n.h2,{id:"primitive-types-generators",children:"Primitive Types Generators"}),"\n",(0,t.jsxs)(n.p,{children:["ZIO Test provides generators for primitive types such as ",(0,t.jsx)(n.code,{children:"Gen.int"}),", ",(0,t.jsx)(n.code,{children:"Gen.string"}),", ",(0,t.jsx)(n.code,{children:"Gen.boolean"}),", ",(0,t.jsx)(n.code,{children:"Gen.float"}),", ",(0,t.jsx)(n.code,{children:"Gen.double"}),", ",(0,t.jsx)(n.code,{children:"Gen.bigInt"}),", ",(0,t.jsx)(n.code,{children:"Gen.byte"}),", ",(0,t.jsx)(n.code,{children:"Gen.bigdecimal"}),", ",(0,t.jsx)(n.code,{children:"Gen.long"}),", ",(0,t.jsx)(n.code,{children:"Gen.char"}),", and ",(0,t.jsx)(n.code,{children:"Gen.short"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Let's create an ",(0,t.jsx)(n.code,{children:"Int"})," generator:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import zio._\nimport zio.test._\n\nval intGen: Gen[Any, Int] = Gen.int\n"})}),"\n",(0,t.jsx)(n.h2,{id:"character-generators",children:"Character Generators"}),"\n",(0,t.jsxs)(n.p,{children:["In addition to ",(0,t.jsx)(n.code,{children:"Gen.char"}),", ZIO Test offers a variety of specialized character generators:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Gen.alphaChar"})," \u2014 e.g. ",(0,t.jsx)(n.code,{children:"Z, z, A, t, o, e, K, E, y, N"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Gen.alphaNumericChar"})," \u2014 e.g. ",(0,t.jsx)(n.code,{children:"b, O, X, B, 4, M, k, 9, a, p"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Gen.asciiChar"})," \u2014 e.g. ",(0,t.jsx)(n.code,{children:"\x10, >, \x04, \x1e, \x02, 2, k, \x16, \x0f, \x03"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Gen.unicodeChar"})," \u2014 e.g. ",(0,t.jsx)(n.code,{children:"\uf9ba, \ue53f, \uc637, \ufa0d, \ue8d4, \ubbb2, \ufe53, \u766e, \uf62c, \u1723)"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Gen.numericChar"})," \u2014 e.g. ",(0,t.jsx)(n.code,{children:"1, 0, 1, 5, 6, 9, 4, 4, 5, 2"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Gen.printableChar"})," \u2014 e.g. ",(0,t.jsx)(n.code,{children:"H, J, (, Q, n, g, 4, G, 9, l"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Gen.whitespaceChars"})," \u2014 e.g. ",(0,t.jsx)(n.code,{children:"\x1c, \x1f, \u2006, \v, \x1f, \u2003, \u2004,  , \u1680, "})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Gen.hexChar"})," \u2014 e.g. ",(0,t.jsx)(n.code,{children:"3, F, b, 5, 9, e, 2, 8, b, e"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Gen.hexCharLower"})," \u2014 e.g. ",(0,t.jsx)(n.code,{children:"f, c, 4, 4, c, 2, 5, 4, f, 3"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Gen.hexCharUpper"})," \u2014 e.g. ",(0,t.jsx)(n.code,{children:"4, 8, 9, 8, C, 9, F, A, E, C"})]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"string-generators",children:"String Generators"}),"\n",(0,t.jsxs)(n.p,{children:["Besides the primitive string generator, ",(0,t.jsx)(n.code,{children:"Gen.string"}),", ZIO Test also provides the following specialized generators:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Gen.stringBounded"})," \u2014 A generator of strings whose size falls within the specified bounds:"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",metastring:"mdoc:compile-only",children:"Gen.stringBounded(1, 5)(Gen.alphaChar)\n  .runCollectN(10)\n  .debug\n// Sample Output: List(b, YJXzY, Aro, y, WMPbj, Abxt, kJep, LKN, kUtr, xJ)\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Gen.stringN"})," \u2014 A generator of strings of fixed size:"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",metastring:"mdoc:compile-only",children:"Gen.stringN(5)(Gen.alphaChar)\n  .runCollectN(10)\n  .debug\n// Sample Output: List(BuywQ, tXCEy, twZli, ffLwI, BPEbz, OKYTi, xeDJW, iDUVn, cuMCr, keQAA)\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"3",children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Gen.string1"})," \u2014 A generator of strings of at least one character."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Gen.alphaNumericString"})," \u2014 A generator of alphanumeric characters."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Gen.alphaNumericStringBounded"})," \u2014 A generator of alphanumeric strings whose size falls within the specified bounds."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Gen.iso_8859_1"})," \u2014 A generator of strings that can be encoded in the ISO-8859-1 character set."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Gen.asciiString"})," \u2014 A generator of US-ASCII characters."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"generating-fixed-values",children:"Generating Fixed Values"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Gen.const"})," \u2014 A constant generator of the specified value."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",metastring:"mdoc:compile-only",children:"Gen.const(true).runCollectN(5)\n// Output: List(true, true, true, true, true)\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Gen.constSample"})," \u2014 A constant generator of the specified sample:"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",metastring:"mdoc:compile-only",children:" Gen.constSample(Sample.noShrink(false)).runCollectN(5)\n// Output: List(true, true, true, true, true)\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"3",children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Gen.unit"})," \u2014 A constant generator of the unit value."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Gen.throwable"})," \u2014 A generator of throwables."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Note that there is an empty generator called ",(0,t.jsx)(n.code,{children:"Gen.empty"}),", which generates no values and returns nothing. We can think of that as a generator of empty stream, ",(0,t.jsx)(n.code,{children:"Gen(Stream.empty)"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"generating-from-fixed-values",children:"Generating from Fixed Values"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Gen.elements"})," \u2014 Constructs a non-deterministic generator that only generates randomly from the fixed values:"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import java.time._\n\nGen.elements(\n  DayOfWeek.MONDAY,\n  DayOfWeek.TUESDAY,\n  DayOfWeek.WEDNESDAY,\n  DayOfWeek.THURSDAY,\n  DayOfWeek.FRIDAY,\n  DayOfWeek.SATURDAY,\n  DayOfWeek.SUNDAY\n).runCollectN(3).debug\n// Sample Output: List(WEDNESDAY, THURSDAY, SUNDAY)\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Gen.fromIterable"})," \u2014 Constructs a deterministic generator that only generates the specified fixed values:"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'Gen.fromIterable(List("red", "green", "blue"))\n  .runCollectN(10)\n  .debug\n'})}),"\n",(0,t.jsx)(n.h2,{id:"collection-generators",children:"Collection Generators"}),"\n",(0,t.jsxs)(n.p,{children:["ZIO Test has generators for collection data types such as ",(0,t.jsx)(n.em,{children:"sets"}),", ",(0,t.jsx)(n.em,{children:"lists"}),", ",(0,t.jsx)(n.em,{children:"vectors"}),", ",(0,t.jsx)(n.em,{children:"chunks"}),", and ",(0,t.jsx)(n.em,{children:"maps"}),". These data types share similar APIs. The following example illustrates how the generator of sets works:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"// A sized generator of sets\nGen.setOf(Gen.alphaChar)\n// Sample Output: Set(Y, M, c), Set(), Set(g, x, Q), Set(s), Set(f, J, b, R)\n\n// A sized generator of non-empty sets\nGen.setOf1(Gen.alphaChar)  \n// Sample Output: Set(Y), Set(L, S), Set(i), Set(H), Set(r, Z, z)\n\n// A generator of sets whose size falls within the specified bounds.\nGen.setOfBounded(1, 3)(Gen.alphaChar)\n// Sample Output: Set(Q), Set(q, J), Set(V, t, h), Set(c), Set(X, O)\n\n// A generator of sets of the specified size.\nGen.setOfN(2)(Gen.alphaChar)\n// Sample Output: Set(J, u), Set(u, p), Set(i, m), Set(b, N), Set(B, Z)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"bounded-generator",children:"Bounded Generator"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"Gen.bounded"})," constructor is a generator whose size falls within the specified bounds:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"Gen.bounded(2, 5)(Gen.stringN(_)(Gen.alphaChar))\n  .runCollectN(5)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"suspended-generator",children:"Suspended Generator"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"Gen.suspend"})," constructs a generator lazily. This is useful to avoid infinite recursion when creating generators that refer to themselves."]}),"\n",(0,t.jsx)(n.h2,{id:"unfold-generator",children:"Unfold Generator"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"unfoldGen"})," takes the initial state and depending on the previous state, it determines what will be the next generated value:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"def unfoldGen[R, S, A](s: S)(f: S => Gen[R, (S, A)]): Gen[R, List[A]]\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Assume we want to test the built-in scala stack (",(0,t.jsx)(n.code,{children:"scala.collection.mutable.Stack"}),"). One way to do that is to create an acceptable series of push and pop commands, and then check that the stack doesn't throw any exception by executing these commands:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"sealed trait Command\ncase object Pop                    extends Command\nfinal case class Push(value: Char) extends Command\n\nval genPop:  Gen[Any, Command]    = Gen.const(Pop)\ndef genPush: Gen[Any, Command] = Gen.alphaChar.map(Push)\n\nval genCommands: Gen[Any, List[Command]] =\n  Gen.unfoldGen(0) { n =>\n    if (n <= 0)\n      genPush.map(command => (n + 1, command))\n    else\n      Gen.oneOf(\n        genPop.map(command => (n - 1, command)),\n        genPush.map(command => (n + 1, command))\n      )\n  }\n"})}),"\n",(0,t.jsx)(n.p,{children:"We are now ready to test the generated list of commands:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'import zio.test.{ test, _ }\n\ntest("unfoldGen") {\n  check(genCommands) { commands =>\n    val stack = scala.collection.mutable.Stack.empty[Int]\n    commands.foreach {\n      case Pop => stack.pop()\n      case Push(value) => stack.push(value)\n    }\n    assertCompletes\n  }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"from-a-zio-effect",children:"From a ZIO Effect"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"Gen.fromZIO"})}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",metastring:"mdoc:compile-only",children:"val gen: Gen[Any, Int] = Gen.fromZIO(Random.nextInt) \n"})}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"Gen.fromZIOSample"})}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",metastring:"mdoc:compile-only",children:"val gen: Gen[Any, Int] =\n  Gen.fromZIOSample(\n    Random.nextInt.map(Sample.shrinkIntegral(0))\n  )\n"})}),"\n",(0,t.jsx)(n.h2,{id:"from-a-random-effect",children:"From a Random Effect"}),"\n",(0,t.jsxs)(n.ol,{start:"3",children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Gen.fromRandom"})," \u2014 Constructs a generator from a function that uses randomness:"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",metastring:"mdoc:compile-only",children:"val gen: Gen[Any, Int] = Gen.fromRandom(_.nextInt) \n"})}),"\n",(0,t.jsxs)(n.ol,{start:"4",children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Gen.fromRandomSample"})," \u2014 Constructs a generator from a function that uses randomness to produce a sample:"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",metastring:"mdoc:compile-only",children:"val gen: Gen[Any, Int] =\n  Gen.fromRandomSample(\n    _.nextIntBounded(20).map(Sample.shrinkIntegral(0))\n  )\n"})}),"\n",(0,t.jsx)(n.h2,{id:"uniform-and-non-uniform-generators",children:"Uniform and Non-uniform Generators"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Gen.uniform"})," \u2014 A generator of uniformly distributed doubles between [0, 1]."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Gen.weighted"})," \u2014 A generator which chooses one of the given generators according to their weights. For example, the following generator will generate 90% true and 10% false values:"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",metastring:"mdoc:compile-only",children:"val trueFalse = Gen.weighted((Gen.const(true), 9), (Gen.const(false), 1))\ntrueFalse.runCollectN(10).debug\n// Sample Output: List(false, false, false, false, false, false, false, false, true, false)\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"3",children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Gen.exponential"})," \u2014 A generator of exponentially distributed doubles with mean ",(0,t.jsx)(n.code,{children:"1"}),":"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",metastring:"mdoc:compile-only",children:"Gen.exponential.map(x => math.round(x * 100) / 100.0)\n  .runCollectN(10)\n  .debug\n// Sample Output: List(0.22, 3.02, 1.96, 1.13, 0.81, 0.92, 1.7, 1.47, 1.55, 0.46)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"generating-datetime-types",children:"Generating Date/Time Types"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Date/Time Types"}),(0,t.jsx)(n.th,{children:"Generators"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"java.time.DayOfWeek"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Gen.dayOfWeek"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"java.time.Month"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Gen.month"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"java.time.Year"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Gen.year"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"java.time.Instant"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Gen.instant"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"java.time.MonthDay"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Gen.monthDay"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"java.time.YearMonth"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Gen.yearMonth"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"java.time.ZoneId"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Gen.zoneId"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"java.time.ZoneOffset"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Gen.zoneOffset"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"java.time.ZonedDateTime"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Gen.zonedDateTime"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"java.time.OffsetTime"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Gen.offsetTime"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"java.time.OffsetDateTime"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Gen.offsetDateTime"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"java.time.Period"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Gen.period"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"java.time.LocalDate"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Gen.localDate"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"java.time.LocalDateTime"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Gen.localDateTime"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"java.time.LocalTime"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Gen.localTime"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"zio.duration.Duration"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Gen.finiteDuration"})})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"function-generators",children:"Function Generators"}),"\n",(0,t.jsx)(n.p,{children:"To test some properties, we need to generate functions. There are two types of function generators:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Gen.function"})," \u2014 It takes a generator of type ",(0,t.jsx)(n.code,{children:"B"})," and produces a generator of functions from ",(0,t.jsx)(n.code,{children:"A"})," to ",(0,t.jsx)(n.code,{children:"B"}),":"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"def function[R, A, B](gen: Gen[R, B]): Gen[R, A => B]\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Two ",(0,t.jsx)(n.code,{children:"A"})," values will be considered to be equal, and thus will be guaranteed to generate the same ",(0,t.jsx)(n.code,{children:"B"})," value, if they have the same\n",(0,t.jsx)(n.code,{children:"hashCode"}),"."]}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Gen.functionWith"})," \u2014 It takes a generator of type ",(0,t.jsx)(n.code,{children:"B"})," and also a hash function for ",(0,t.jsx)(n.code,{children:"A"})," values, and produces a generator of functions from ",(0,t.jsx)(n.code,{children:"A"})," to ",(0,t.jsx)(n.code,{children:"B"}),":"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"def functionWith[R, A, B](gen: Gen[R, B])(hash: A => Int): Gen[R, A => B]\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Two ",(0,t.jsx)(n.code,{children:"A"})," values will be considered to be equal, and thus will be guaranteed to generate the same ",(0,t.jsx)(n.code,{children:"B"})," value, if they have the same hash. This is useful when ",(0,t.jsx)(n.code,{children:"A"})," does not implement ",(0,t.jsx)(n.code,{children:"hashCode"})," in a way that is consistent with equality."]}),"\n",(0,t.jsxs)(n.p,{children:["Accordingly, ZIO Test provides a variety of function generators for ",(0,t.jsx)(n.code,{children:"Function2"}),", ",(0,t.jsx)(n.code,{children:"Function3"}),", ..., and also the ",(0,t.jsx)(n.code,{children:"PartialFunction"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Gen.function2"})," \u2014  Gen[R, C] => Gen[R, (A, B) => C]"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Gen.functionWith2"})," \u2014 Gen[R, B] => ((A, B) => Int) => Gen[R, (A, B) => C]"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Gen.partialFunction"})," \u2014 Gen[R, B] => Gen[R, PartialFunction[A, B]]"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Gen.partialFunctionWith"})," \u2014 Gen[R, B] => (A => Int) => Gen[R, PartialFunction[A, B]]"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Let's write a test for ",(0,t.jsx)(n.code,{children:"ZIO.foldLeft"})," operator. This operator has the following signature:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"def foldLeft[R, E, S, A](in: => Iterable[A])(zero: => S)(f: (S, A) => ZIO[R, E, S]): ZIO[R, E, S]\n"})}),"\n",(0,t.jsx)(n.p,{children:"We want to test the following property:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"\u2200 (in, zero, f) => ZIO.foldLeft(in)(zero)(f) == ZIO(List.foldLeft(in)(zero)(f))\n"})}),"\n",(0,t.jsxs)(n.p,{children:["To test this property, we have an input of type ",(0,t.jsx)(n.code,{children:"(Int, Int) => Int"}),". So we need a Function2 generator of integers:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"val func2: Gen[Any, (Int, Int) => Int] = Gen.function2(Gen.int)\n"})}),"\n",(0,t.jsx)(n.p,{children:"Now we can test this property:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.test.{test, _}\n\ntest("ZIO.foldLeft should have the same result with List.foldLeft") {\n  check(Gen.listOf(Gen.int), Gen.int, func2) { case (in, zero, f) =>\n    assertZIO(\n      ZIO.foldLeft(in)(zero)((s, a) => ZIO.attempt(f(s, a)))\n    )(Assertion.equalTo(\n      in.foldLeft(zero)((s, a) => f(s, a)))\n    )\n  }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"generating-zio-values",children:"Generating ZIO Values"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Successful effects (",(0,t.jsx)(n.code,{children:"Gen.successes"}),"):"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",metastring:"mdoc:compile-only",children:"val gen: Gen[Any, UIO[Int]] = Gen.successes(Gen.int(-10, 10))\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsxs)(n.li,{children:["Failed effects (",(0,t.jsx)(n.code,{children:"Gen.failures"}),"):"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",metastring:"mdoc:compile-only",children:"val gen: Gen[Any, IO[String, Nothing]] = Gen.failures(Gen.string)\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"3",children:["\n",(0,t.jsxs)(n.li,{children:["Died effects (",(0,t.jsx)(n.code,{children:"Gen.died"}),"):"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",metastring:"mdoc:compile-only",children:"val gen: Gen[Any, UIO[Nothing]] = Gen.died(Gen.throwable)\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"4",children:["\n",(0,t.jsxs)(n.li,{children:["Cause values (",(0,t.jsx)(n.code,{children:"Gen.causes"}),"):"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",metastring:"mdoc:compile-only",children:"val causes: Gen[Any, Cause[String]] = \n  Gen.causes(Gen.string, Gen.throwable)\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"5",children:["\n",(0,t.jsxs)(n.li,{children:["Chained effects (",(0,t.jsx)(n.code,{children:"Gen.chined"}),", ",(0,t.jsx)(n.code,{children:"Gen.chainedN"}),"): A generator of effects that are the result of chaining the specified effect with itself a random number of times."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Let's see some example of chained ZIO effects:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",metastring:"mdoc:compile-only",children:"import zio._\nval effect1 = ZIO(2).flatMap(x => ZIO(x * 2))\nval effect2 = ZIO(1) *> ZIO(2)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["By using ",(0,t.jsx)(n.code,{children:"Gen.chaned"})," or ",(0,t.jsx)(n.code,{children:"Gen.chanedN"})," generator, we can create generators of chained effects:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",metastring:"mdoc:compile-only",children:"val chained : Gen[Any, ZIO[Any, Nothing, Int]] = \n  Gen.chained(Gen.successes(Gen.int))\n  \nval chainedN: Gen[Any, ZIO[Any, Nothing, Int]] = \n  Gen.chainedN(5)(Gen.successes(Gen.int))\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"6",children:["\n",(0,t.jsxs)(n.li,{children:["Concurrent effects (",(0,t.jsx)(n.code,{children:"Gen.concurrent"}),"): A generator of effects that are the result of applying concurrency combinators to the specified effect that are guaranteed not to change its value."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",metastring:"mdoc:compile-only",children:"val random  : Gen[Any, UIO[Int]] = Gen.successes(Gen.int).flatMap(Gen.concurrent)\nval constant: Gen[Any, UIO[Int]]    = Gen.concurrent(ZIO(3))\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"7",children:["\n",(0,t.jsxs)(n.li,{children:["Parallel effects (",(0,t.jsx)(n.code,{children:"Gen.parallel"}),"): A generator of effects that are the result of applying parallelism combinators to the specified effect that are guaranteed not to change its value."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",metastring:"mdoc:compile-only",children:'val random: Gen[Any, UIO[String]] =\n  Gen.successes(Gen.string).flatMap(Gen.parallel)\n  \nval constant: Gen[Any, UIO[String]] =\n  Gen.parallel(ZIO("Hello"))\n'})}),"\n",(0,t.jsx)(n.h2,{id:"generating-compound-types",children:"Generating Compound Types"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"tuples \u2014 We can combine generators using for-comprehension syntax and tuples:"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",metastring:"mdoc:compile-only",children:"val tuples: Gen[Any, (Int, Double)] =\n  for {\n    a <- Gen.int\n    b <- Gen.double\n  } yield (a, b)\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Gen.oneOf"})," \u2014 It takes variable number of generators and select one of them:"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",metastring:"mdoc:compile-only",children:"sealed trait Color\ncase object Red extends Color\ncase object Blue extends Color\ncase object Green extends Color\n\nGen.oneOf(Gen.const(Red), Gen.const(Blue), Gen.const(Green))\n// Sample Output: Green, Green, Red, Green, Red\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"4",children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Gen.option"})," \u2014 A generator of ",(0,t.jsx)(n.em,{children:"optional"})," values:"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",metastring:"mdoc:compile-only",children:"val intOptions: Gen[Any, Option[Int]] = Gen.option(Gen.int)\nval someInts:   Gen[Any, Option[Int]] = Gen.some(Gen.int)\nval nons:       Gen[Any, Option[Nothing]]     = Gen.none\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"3",children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Gen.either"})," \u2014 A generator of ",(0,t.jsx)(n.em,{children:"either"})," values:"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",metastring:"mdoc:compile-only",children:"val char: Gen[Any, Either[Char, Char]] =\n  Gen.either(Gen.numericChar, Gen.alphaChar)\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"4",children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Gen.collectAll"})," \u2014 Composes the specified generators to create a ",(0,t.jsx)(n.em,{children:"cartesian product of elements"})," with the specified function:"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",metastring:"mdoc:compile-only",children:"val gen: ZIO[Any, Nothing, List[List[Int]]] =\n  Gen.collectAll(\n    List(\n      Gen.fromIterable(List(1, 2)),\n      Gen.fromIterable(List(3)),\n      Gen.fromIterable(List(4, 5))\n    )\n  ).runCollect\n// Output:\n// List(\n//  List(1, 3, 4),\n//  List(1, 3, 5),\n//  List(2, 3, 4),\n//  List(2, 3, 5)\n//)\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"5",children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Gen.concatAll"})," \u2014 Combines the specified deterministic generators to return a new deterministic generator that generates all the values generated by the specified generators:"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",metastring:"mdoc:compile-only",children:"val gen: ZIO[Any, Nothing, List[Int]] =\n  Gen.concatAll(\n    List(\n      Gen.fromIterable(List(1, 2)),\n      Gen.fromIterable(List(3)),\n      Gen.fromIterable(List(4, 5))\n    )\n  ).runCollect\n// Output: List(1, 2, 3, 4, 5)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"sized-generators",children:"Sized Generators"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Gen.sized"})," \u2014 A sized generator takes a function from ",(0,t.jsx)(n.code,{children:"Int"})," to ",(0,t.jsx)(n.code,{children:"Gen[R, A]"})," and creates a generator by applying a size to that function:"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",metastring:"mdoc:compile-only",children:"Gen.sized(Gen.int(0, _))\n  .runCollectN(10)\n  .provideCustomLayer(Sized.live(5))\n  .debug\n// Sample Output: List(5, 4, 1, 2, 0, 4, 2, 0, 1, 2)\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Gen.size"})," \u2014 A generator which accesses the ",(0,t.jsx)(n.em,{children:"size"})," from the environment and generates that:"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",metastring:"mdoc:compile-only",children:"Gen.size\n  .runCollectN(5)\n  .provideCustomLayer(Sized.live(100))\n  .debug\n// Output: List(100, 100, 100, 100, 100)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["There are also three sized generators, named ",(0,t.jsx)(n.em,{children:"small"}),", ",(0,t.jsx)(n.em,{children:"medium"})," and ",(0,t.jsx)(n.em,{children:"large"}),", that use an exponential distribution of size values:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Gen.small"})," \u2014 The values generated will be strongly concentrated towards the lower end of the range but a few larger values will still be generated:"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",metastring:"mdoc:compile-only",children:"Gen.small(Gen.const(_))\n  .runCollectN(10)\n  .provideCustomLayer(Sized.live(1000))\n  .debug\n// Output: List(6, 39, 73, 3, 57, 51, 40, 12, 110, 46)\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"4",children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Gen.medium"})," \u2014 The majority of sizes will be towards the lower end of the range but some larger sizes will be generated as well:"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",metastring:"mdoc:compile-only",children:"Gen.medium(Gen.const(_))\n  .runCollectN(10)\n  .provideCustomLayer(Sized.live(1000))\n  .debug\n// Output: List(93, 42, 58, 228, 42, 5, 12, 214, 106, 79)\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"5",children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Gen.large"})," \u2014 Uses a uniform distribution of size values. A large number of larger sizes will be generated:"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",metastring:"mdoc:compile-only",children:"Gen.large(Gen.const(_))\n  .runCollectN(10)\n  .provideCustomLayer(Sized.live(1000))\n  .debug\n// Output: List(797, 218, 596, 278, 301, 779, 165, 486, 695, 788)\n"})})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>a});var r=s(96540);const t={},l=r.createContext(t);function i(e){const n=r.useContext(l);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),r.createElement(l.Provider,{value:n},e.children)}}}]);