"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[78043],{54887:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>s,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"reference/error-management/recovering/retrying","title":"Retrying","description":"When we are building applications we want to be resilient in the face of a transient failure. This is where we need to retry to overcome these failures.","source":"@site/docs/reference/error-management/recovering/retrying.md","sourceDirName":"reference/error-management/recovering","slug":"/reference/error-management/recovering/retrying","permalink":"/reference/error-management/recovering/retrying","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/error-management/recovering/retrying.md","tags":[],"version":"current","frontMatter":{"id":"retrying","title":"Retrying","sidebar_label":"4. Retrying"},"sidebar":"reference-sidebar","previous":{"title":"3. Folding","permalink":"/reference/error-management/recovering/folding"},"next":{"title":"5. Timing out","permalink":"/reference/error-management/recovering/timing-out"}}');var t=n(74848),l=n(28453);const o={id:"retrying",title:"Retrying",sidebar_label:"4. Retrying"},a=void 0,s={},c=[{value:"<code>ZIO#retry</code>",id:"zioretry",level:2},{value:"<code>ZIO#retryN</code>",id:"zioretryn",level:2},{value:"<code>ZIO#retryOrElse</code>",id:"zioretryorelse",level:2},{value:"<code>ZIO#retryOrElseEither</code>",id:"zioretryorelseeither",level:2},{value:"<code>ZIO#retryUntil</code>/<code>ZIO#retryUntilZIO</code>",id:"zioretryuntilzioretryuntilzio",level:2},{value:"<code>ZIO#retryUntilEqual</code>",id:"zioretryuntilequal",level:2},{value:"<code>ZIO#retryWhile</code>/<code>ZIO#retryWhileZIO</code>",id:"zioretrywhilezioretrywhilezio",level:2},{value:"<code>ZIO#retryWhileEquals</code>",id:"zioretrywhileequals",level:2}];function d(e){const r={code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,l.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.p,{children:"When we are building applications we want to be resilient in the face of a transient failure. This is where we need to retry to overcome these failures."}),"\n",(0,t.jsx)(r.p,{children:"There are a number of useful methods on the ZIO data type for retrying failed effects:"}),"\n",(0,t.jsx)(r.h2,{id:"zioretry",children:(0,t.jsx)(r.code,{children:"ZIO#retry"})}),"\n",(0,t.jsxs)(r.p,{children:["The most basic of these is ",(0,t.jsx)(r.code,{children:"ZIO#retry"}),", which takes a ",(0,t.jsx)(r.code,{children:"Schedule"})," and returns a new effect that will retry the first effect if it fails, according to the specified policy:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-scala",children:"trait ZIO[-R, +E, +A] {\n  def retry[R1 <: R, S](policy: => Schedule[R1, E, S]): ZIO[R1, E, A]\n}\n"})}),"\n",(0,t.jsx)(r.p,{children:"In this example, we try to read from a file. If we fail to do that, it will try five more times:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-scala",children:'import zio._\n\nval retriedOpenFile: ZIO[Any, IOException, Array[Byte]] =\n  readFile("primary.data").retry(Schedule.recurs(5))\n'})}),"\n",(0,t.jsx)(r.h2,{id:"zioretryn",children:(0,t.jsx)(r.code,{children:"ZIO#retryN"})}),"\n",(0,t.jsx)(r.p,{children:"In case of failure, a ZIO effect can be retried as many times as specified:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-scala",children:'import zio._\n\nval file = readFile("primary.data").retryN(5)\n'})}),"\n",(0,t.jsx)(r.h2,{id:"zioretryorelse",children:(0,t.jsx)(r.code,{children:"ZIO#retryOrElse"})}),"\n",(0,t.jsxs)(r.p,{children:["The next most powerful function is ",(0,t.jsx)(r.code,{children:"ZIO#retryOrElse"}),", which allows specification of a fallback to use, if the effect does not succeed with the specified policy:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-scala",children:"trait ZIO[-R, +E, +A] {\n  def retryOrElse[R1 <: R, A1 >: A, S, E1](\n    policy: => Schedule[R1, E, S],\n    orElse: (E, S) => ZIO[R1, E1, A1]\n  ): ZIO[R1, E1, A1] =\n}\n"})}),"\n",(0,t.jsxs)(r.p,{children:["The ",(0,t.jsx)(r.code,{children:"orElse"})," is the recovery function that has two inputs:"]}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsx)(r.li,{children:"The last error message"}),"\n",(0,t.jsx)(r.li,{children:"Schedule output"}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:"So based on these two values, we can decide what to do as the fallback operation. Let's try an example:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-scala",children:'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    Random\n      .nextIntBounded(11)\n      .flatMap { n =>\n        if (n < 9)\n          ZIO.fail(s"$n is less than 9!").debug("failed")\n        else\n          ZIO.succeed(n).debug("succeeded")\n      }\n      .retryOrElse(\n        policy = Schedule.recurs(5),\n        orElse = (lastError, scheduleOutput: Long) =>\n          ZIO.debug(s"after $scheduleOutput retries, we couldn\'t succeed!") *>\n            ZIO.debug(s"the last error message we received was: $lastError") *>\n            ZIO.succeed(-1)\n      )\n      .debug("the final result")\n}\n'})}),"\n",(0,t.jsx)(r.h2,{id:"zioretryorelseeither",children:(0,t.jsx)(r.code,{children:"ZIO#retryOrElseEither"})}),"\n",(0,t.jsxs)(r.p,{children:["This operator is almost the same as the ",(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.code,{children:"ZIO#retryOrElse"})})," except it will return either result of the original or the fallback operation:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-scala",children:"import zio._\n\ntrait LocalConfig\ntrait RemoteConfig\n\ndef readLocalConfig: ZIO[Any, Throwable, LocalConfig] = ???\ndef readRemoteConfig: ZIO[Any, Throwable, RemoteConfig] = ???\n\nval result: ZIO[Any, Throwable, Either[RemoteConfig, LocalConfig]] =\n  readLocalConfig.retryOrElseEither(\n    schedule0 = Schedule.fibonacci(1.seconds),\n    orElse = (_, _: Duration) => readRemoteConfig\n  )\n"})}),"\n",(0,t.jsxs)(r.h2,{id:"zioretryuntilzioretryuntilzio",children:[(0,t.jsx)(r.code,{children:"ZIO#retryUntil"}),"/",(0,t.jsx)(r.code,{children:"ZIO#retryUntilZIO"})]}),"\n",(0,t.jsx)(r.p,{children:"We can retry an effect until a condition on the error channel is satisfied:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-scala",children:"trait ZIO[-R, +E, +A] {\n  def retryUntil(f: E => Boolean): ZIO[R, E, A]\n  def retryUntilZIO[R1 <: R](f: E => URIO[R1, Boolean]): ZIO[R1, E, A]\n}\n"})}),"\n",(0,t.jsx)(r.p,{children:"Assume we have defined the following remote service call:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-scala",children:"sealed trait  ServiceError extends Exception\ncase object TemporarilyUnavailable extends ServiceError\ncase object DataCorrupted          extends ServiceError\n\ndef remoteService: ZIO[Any, ServiceError, Unit] = ???\n"})}),"\n",(0,t.jsxs)(r.p,{children:["In the following example, we repeat the failed remote service call until we reach the ",(0,t.jsx)(r.code,{children:"DataCorrupted"})," error:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-scala",children:"remoteService.retryUntil(_ == DataCorrupted)\n"})}),"\n",(0,t.jsxs)(r.p,{children:["To provide an effectful predicate we use the ",(0,t.jsx)(r.code,{children:"ZIO#retryUntilZIO"})," operator."]}),"\n",(0,t.jsx)(r.h2,{id:"zioretryuntilequal",children:(0,t.jsx)(r.code,{children:"ZIO#retryUntilEqual"})}),"\n",(0,t.jsx)(r.p,{children:"Like the previous operator, it tries until its error is equal to the specified error:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-scala",children:"remoteService.retryUntilEquals(DataCorrupted)\n"})}),"\n",(0,t.jsxs)(r.h2,{id:"zioretrywhilezioretrywhilezio",children:[(0,t.jsx)(r.code,{children:"ZIO#retryWhile"}),"/",(0,t.jsx)(r.code,{children:"ZIO#retryWhileZIO"})]}),"\n",(0,t.jsxs)(r.p,{children:["Unlike the ",(0,t.jsx)(r.code,{children:"ZIO#retryUntil"})," it will retry the effect while its error satisfies the specified predicate:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-scala",children:"trait ZIO[-R, +E, +A] {\n  def retryWhile(f: E => Boolean): ZIO[R, E, A]\n  def retryWhileZIO[R1 <: R](f: E => URIO[R1, Boolean]): ZIO[R1, E, A]\n}\n"})}),"\n",(0,t.jsxs)(r.p,{children:["In the following example, we repeat the failed remote service call while we have the ",(0,t.jsx)(r.code,{children:"TemporarilyUnavailable"})," error:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-scala",children:"remoteService.retryWhile(_ == TemporarilyUnavailable)\n"})}),"\n",(0,t.jsxs)(r.p,{children:["To provide an effectful predicate we use the ",(0,t.jsx)(r.code,{children:"ZIO#retryWhileZIO"})," operator."]}),"\n",(0,t.jsx)(r.h2,{id:"zioretrywhileequals",children:(0,t.jsx)(r.code,{children:"ZIO#retryWhileEquals"})}),"\n",(0,t.jsx)(r.p,{children:"Like the previous operator, it tries while its error is equal to the specified error:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-scala",children:"remoteService.retryWhileEquals(TemporarilyUnavailable)\n"})})]})}function h(e={}){const{wrapper:r}={...(0,l.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,r,n)=>{n.d(r,{R:()=>o,x:()=>a});var i=n(96540);const t={},l=i.createContext(t);function o(e){const r=i.useContext(l);return i.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(l.Provider,{value:r},e.children)}}}]);