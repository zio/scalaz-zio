"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[20912],{28453:(e,r,t)=>{t.d(r,{R:()=>a,x:()=>i});var n=t(96540);const o={},s=n.createContext(o);function a(e){const r=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),n.createElement(s.Provider,{value:r},e.children)}},31256:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>c,contentTitle:()=>i,default:()=>l,frontMatter:()=>a,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"reference/error-management/expected-and-unexpected-errors","title":"Expected and Unexpected Errors","description":"Inside an application, there are two distinct categories of errors:","source":"@site/docs/reference/error-management/expected-and-unexpected-errors.md","sourceDirName":"reference/error-management","slug":"/reference/error-management/expected-and-unexpected-errors","permalink":"/reference/error-management/expected-and-unexpected-errors","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/error-management/expected-and-unexpected-errors.md","tags":[],"version":"current","frontMatter":{"id":"expected-and-unexpected-errors","title":"Expected and Unexpected Errors"},"sidebar":"reference-sidebar","previous":{"title":"Imperative vs. Declarative","permalink":"/reference/error-management/imperative-vs-declarative"},"next":{"title":"Exceptional and Unexceptional Effects","permalink":"/reference/error-management/exceptional-and-unexceptional-effects"}}');var o=t(74848),s=t(28453);const a={id:"expected-and-unexpected-errors",title:"Expected and Unexpected Errors"},i=void 0,c={},d=[{value:"Expected Errors",id:"expected-errors",level:2},{value:"Unexpected Errors",id:"unexpected-errors",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Expected Errors",id:"expected-errors-1",level:3},{value:"Unexpected Errors",id:"unexpected-errors-1",level:3},{value:"Conclusion",id:"conclusion",level:2}];function h(e){const r={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(r.p,{children:"Inside an application, there are two distinct categories of errors:"}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Expected errors"})," are those that are expected to occur, and we tend to recover them. They are also known as ",(0,o.jsx)(r.em,{children:"recoverable errors"})," or ",(0,o.jsx)(r.em,{children:"declared errors"}),"."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Unexpected errors"})," are those that are not expected to occur, and they are not recoverable. They are also known as ",(0,o.jsx)(r.em,{children:"non-recoverable errors"})," or ",(0,o.jsx)(r.em,{children:"defects"}),"."]}),"\n"]}),"\n",(0,o.jsx)(r.h2,{id:"expected-errors",children:"Expected Errors"}),"\n",(0,o.jsxs)(r.p,{children:["Expected errors are those errors in which we expected them to happen in normal circumstances, and we can't prevent them. They can be predicted upfront, and we can plan for them. We know when, where, and why they occur. So we know when, where, and how to handle these errors. By handling them we can recover from the failure, this is why we say they are ",(0,o.jsx)(r.em,{children:"recoverable errors"}),". All domain errors, business errors are expected once because we talk about them in workflows and user stories, so we know about them in the context of business flows."]}),"\n",(0,o.jsx)(r.p,{children:"For example, when accessing an external database, that database might be down for some short period of time, so we retry to connect again, or after some number of attempts, we might decide to use an alternative solution, e.g. using an in-memory database."}),"\n",(0,o.jsx)(r.h2,{id:"unexpected-errors",children:"Unexpected Errors"}),"\n",(0,o.jsx)(r.p,{children:"We know there is a category of things that we are not going to expect and plan for. These are the things we don't expect but of course, we know they are going to happen. We don't know what is the exact root of these errors at runtime, so we have no idea how to handle them. They are actually going to bring down our production application, and then we have to figure out what went wrong to fix them."}),"\n",(0,o.jsx)(r.p,{children:"For example, the corrupted database file will cause an unexpected error. We can't handle that in runtime. It may be necessary to shut down the whole application in order to prevent further damage."}),"\n",(0,o.jsxs)(r.p,{children:["Most of the unexpected errors are rooted in programming errors. This means, we have just tested the ",(0,o.jsx)(r.em,{children:"happy path"}),", so in case of ",(0,o.jsx)(r.em,{children:"unhappy path"})," we encounter a defect. When we have defects in our code we have no way of knowing about them otherwise we investigate, test, and fix them."]}),"\n",(0,o.jsx)(r.p,{children:"One of the common programming errors is forgetting to validate unexpected errors that may occur when we expect an input but the input is not valid, while we haven't validated the input. When the user inputs the invalid data, we might encounter the divide by zero exception or might corrupt our service state or a cause similar defect."}),"\n",(0,o.jsx)(r.p,{children:"These kinds of defects are common when we upgrade our service with the new data model for its input, while one of the other services is not upgraded with the new data contract and is calling our service with the deprecated data model. If we haven't a validation phase, they will cause defects!"}),"\n",(0,o.jsxs)(r.p,{children:["Another example of defects is ",(0,o.jsx)(r.em,{children:"memory errors"})," like ",(0,o.jsx)(r.em,{children:"buffer overflows"}),", ",(0,o.jsx)(r.em,{children:"stack overflows"}),", ",(0,o.jsx)(r.em,{children:"out-of-memory"}),", ",(0,o.jsx)(r.em,{children:"invalid access to null pointers"}),", and so forth. Most of the time these unexpected errors are occurs when we haven't written a memory-safe and resource-safe program, or they might occur due to hardware issues or uncontrollable external problems. We as a developer don't know how to cope with these types of errors at runtime. We should investigate to find the exact root cause of these defects."]}),"\n",(0,o.jsxs)(r.p,{children:["As we cannot handle unexpected errors, we should instead log them with their respective stack traces and contextual information. So later we could investigate the problem and try to fix them. The best we can do with unexpected errors is to ",(0,o.jsx)(r.em,{children:"sandbox"})," them to limit the damage that they do to the overall application. For example, an unexpected error in browser extension shouldn't crash the whole browser."]}),"\n",(0,o.jsx)(r.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,o.jsx)(r.p,{children:"So the best practice for each of these errors is as follows:"}),"\n",(0,o.jsx)(r.h3,{id:"expected-errors-1",children:"Expected Errors"}),"\n",(0,o.jsxs)(r.p,{children:["we handle expected errors with the aid of the Scala compiler, by pushing them into the type system. In ZIO there is the error type parameter called ",(0,o.jsx)(r.code,{children:"E"}),", and this error type parameter is for modeling all the expected errors in the application."]}),"\n",(0,o.jsxs)(r.p,{children:["A ZIO value has a type parameter ",(0,o.jsx)(r.code,{children:"E"})," which is the type of ",(0,o.jsx)(r.em,{children:"declared errors"})," it can fail with. ",(0,o.jsx)(r.code,{children:"E"})," only covers the errors which were specified at the outset. The same ZIO value could still throw exceptions in unforeseen ways. These unforeseen situations are called ",(0,o.jsx)(r.em,{children:"defects"})," in a ZIO program, and they lie outside ",(0,o.jsx)(r.code,{children:"E"}),"."]}),"\n",(0,o.jsxs)(r.p,{children:["Bringing abnormal situations from the domain of defects into that of ",(0,o.jsx)(r.code,{children:"E"})," enables the compiler to help us keep a tab on error conditions throughout the application, at compile time. This helps ensure the handling of domain errors in domain-specific ways."]}),"\n",(0,o.jsx)(r.h3,{id:"unexpected-errors-1",children:"Unexpected Errors"}),"\n",(0,o.jsx)(r.p,{children:"We encode unexpected errors by not reflecting them to the type system because there is no way we could do it, and it wouldn't provide any value if we could. At best as we can, we simply sandbox that to some well-defined area of the application."}),"\n",(0,o.jsxs)(r.p,{children:["Note that ",(0,o.jsx)(r.em,{children:"defects"}),", can creep silently to higher levels in our application, and, if they get triggered at all, their handling might eventually be in more general ways."]}),"\n",(0,o.jsx)(r.p,{children:"So for ZIO, expected errors are reflected in the type of the ZIO effect, whereas unexpected errors are not so reflective, and that is the distinction."}),"\n",(0,o.jsx)(r.p,{children:"That is the best practice. It helps us write better code. The code that we can reason about its error properties and potential expected errors. We can look at the ZIO effect and know how it is supposed to fail."}),"\n",(0,o.jsx)(r.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsxs)(r.ol,{children:["\n",(0,o.jsx)(r.li,{children:"Unexpected errors are impossible to recover, and they will eventually shut down the application but expected errors can be recovered by handling them."}),"\n",(0,o.jsxs)(r.li,{children:["We do not type unexpected errors, but we type expected errors either explicitly or using general ",(0,o.jsx)(r.code,{children:"Throwable"})," error type."]}),"\n",(0,o.jsx)(r.li,{children:"Unexpected errors mostly is a sign of programming errors, but expected errors part of domain errors."}),"\n",(0,o.jsxs)(r.li,{children:["Even though we haven't any clue on how to handle defects, we might still need to do some operation, before letting them crash the application. So in such a situation, we can ",(0,o.jsx)(r.a,{href:"/reference/error-management/recovering/catching",children:"catch defects"})," do following operations, and then rethrow them again:"]}),"\n"]}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsx)(r.li,{children:"logging the defect to a log aggregator"}),"\n",(0,o.jsx)(r.li,{children:"sending an email to alert developers"}),"\n",(0,o.jsx)(r.li,{children:'displaying a nice "unexpected error" message to the user'}),"\n",(0,o.jsx)(r.li,{children:"etc."}),"\n"]})]})}function l(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,o.jsx)(r,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}}}]);