"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[58914],{28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>r});var i=n(96540);const o={},a=i.createContext(o);function s(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(a.Provider,{value:t},e.children)}},38003:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"zio-prelude/functional-abstractions/parameterized-types/commutativeboth","title":"CommutativeBoth","description":"CommutativeBoth[F] describes a way of combining two values F[A] and F[B] into a value F[(A, B)] that is commutative.","source":"@site/docs/zio-prelude/functional-abstractions/parameterized-types/commutativeboth.md","sourceDirName":"zio-prelude/functional-abstractions/parameterized-types","slug":"/zio-prelude/functional-abstractions/parameterized-types/commutativeboth","permalink":"/zio-prelude/functional-abstractions/parameterized-types/commutativeboth","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-prelude/functional-abstractions/parameterized-types/commutativeboth.md","tags":[],"version":"current","frontMatter":{"id":"commutativeboth","title":"CommutativeBoth"},"sidebar":"ecosystem-sidebar","previous":{"title":"AssociativeFlatten","permalink":"/zio-prelude/functional-abstractions/parameterized-types/associativeflatten"},"next":{"title":"CommutativeEither","permalink":"/zio-prelude/functional-abstractions/parameterized-types/commutativeeither"}}');var o=n(74848),a=n(28453);const s={id:"commutativeboth",title:"CommutativeBoth"},r=void 0,l={},c=[];function d(e){const t={code:"code",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"CommutativeBoth[F]"})," describes a way of combining two values ",(0,o.jsx)(t.code,{children:"F[A]"})," and ",(0,o.jsx)(t.code,{children:"F[B]"})," into a value ",(0,o.jsx)(t.code,{children:"F[(A, B)]"})," that is commutative."]}),"\n",(0,o.jsx)(t.p,{children:"Its signature is:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:"trait AssociativeBoth[F[_]] {\n  def both[A, B](fa: => F[A], fb: => F[B]): F[(A, B)]\n}\n\ntrait CommutativeBoth[F[_]] extends AssociativeBoth[F]\n"})}),"\n",(0,o.jsxs)(t.p,{children:["If we import ",(0,o.jsx)(t.code,{children:"zio.prelude._"})," we can use the ",(0,o.jsx)(t.code,{children:"zipPar"})," operator or its symbolic alias ",(0,o.jsx)(t.code,{children:"<&>"})," to combine any two values of a parameterized type for which a ",(0,o.jsx)(t.code,{children:"CommutativeBoth"})," instance exists in a commutative way."]}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"both"})," operator must be commutative, so if we combine ",(0,o.jsx)(t.code,{children:"fa"})," and ",(0,o.jsx)(t.code,{children:"fb"})," that must be the same as combining ",(0,o.jsx)(t.code,{children:"fb"})," and ",(0,o.jsx)(t.code,{children:"fa"}),". After rearranging the order of tuples:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:"fa <&> fb === fb <&> fa\n"})}),"\n",(0,o.jsxs)(t.p,{children:["This is the same law as defined for the ",(0,o.jsx)(t.code,{children:"Commutative"})," functional abstraction for concrete types, just lifted into the context of parameterized types."]}),"\n",(0,o.jsxs)(t.p,{children:["As the name of the ",(0,o.jsx)(t.code,{children:"zipPar"})," operator implies, the ",(0,o.jsx)(t.code,{children:"both"})," operator of the ",(0,o.jsx)(t.code,{children:"CommutativeBoth"})," abstraction corresponds to running the first value and running the second value in parallel."]}),"\n",(0,o.jsxs)(t.p,{children:["We can see this because to produce a tuple ",(0,o.jsx)(t.code,{children:"(A, B)"})," we need to run both the left value and the right value and to do it in a way that order doesn't matter we need to run the left value and the right value in parallel. This doesn't necessarily mean we are actually forking separate fibers to run the left and right values but it does mean that we run the left and right values in a way that the result does not depend on the order in which they are run."]}),"\n",(0,o.jsxs)(t.p,{children:["To get a better sense of what it means for a combining operation on parameterized types to be commutative, let's start with looking at why the ",(0,o.jsx)(t.code,{children:"zip"})," operator on ",(0,o.jsx)(t.code,{children:"ZIO"})," is not commutative."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:'import zio._\n\nimport java.io.IOException\n\nval helloZIO: ZIO[Console, IOException, Unit] =\n  Console.printLine("Hello") <*> Console.printLine("ZIO")\n// helloZIO: ZIO[Console, IOException, Unit] = FlatMap(\n//   trace = "repl.MdocSession.MdocApp0.helloZIO(commutativeboth.md:29)",\n//   first = Stateful(\n//     trace = "repl.MdocSession.MdocApp0.helloZIO(commutativeboth.md:29)",\n//     onState = zio.FiberRef$unsafe$$anon$2$$Lambda$16955/0x000000080494b040@14be1c92\n//   ),\n//   successK = zio.ZIO$$Lambda$16957/0x0000000804949840@1349e398\n// )\n\nval zioHello: ZIO[Console, IOException, Unit] =\n  Console.printLine("ZIO") <*> Console.printLine("Hello")\n// zioHello: ZIO[Console, IOException, Unit] = FlatMap(\n//   trace = "repl.MdocSession.MdocApp0.zioHello(commutativeboth.md:33)",\n//   first = Stateful(\n//     trace = "repl.MdocSession.MdocApp0.zioHello(commutativeboth.md:33)",\n//     onState = zio.FiberRef$unsafe$$anon$2$$Lambda$16955/0x000000080494b040@2630a6ab\n//   ),\n//   successK = zio.ZIO$$Lambda$16957/0x0000000804949840@7a39c4d6\n// )\n'})}),"\n",(0,o.jsxs)(t.p,{children:["If the ",(0,o.jsx)(t.code,{children:"zip"})," operator was commutative these two ",(0,o.jsx)(t.code,{children:"ZIO"})," workflows would be the same. But they obviously are not."]}),"\n",(0,o.jsxs)(t.p,{children:["The first will print ",(0,o.jsx)(t.code,{children:"Hello"})," to the console on one line followed by ",(0,o.jsx)(t.code,{children:"ZIO"})," on the next whereas the second will print ",(0,o.jsx)(t.code,{children:"ZIO"})," to the console followed by ",(0,o.jsx)(t.code,{children:"Hello"}),". We can easily observe this by running the program ourselves or using a test implementation of the ",(0,o.jsx)(t.code,{children:"Console"})," service like ",(0,o.jsx)(t.code,{children:"TestConsole"})," from ZIO Test."]}),"\n",(0,o.jsx)(t.p,{children:"We can also see this in the context of failures."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:'val failZIO: ZIO[Console, IOException, Unit] =\n  ZIO.fail(new IOException("Fail")) <*> Console.printLine("ZIO")\n// failZIO: ZIO[Console, IOException, Unit] = FlatMap(\n//   trace = "repl.MdocSession.MdocApp0.failZIO(commutativeboth.md:40)",\n//   first = Stateful(\n//     trace = "repl.MdocSession.MdocApp0.failZIO(commutativeboth.md:40)",\n//     onState = zio.ZIO$$$Lambda$16959/0x0000000804961040@65e6a54e\n//   ),\n//   successK = zio.ZIO$$Lambda$16957/0x0000000804949840@51cdd250\n// )\n\nval zioFail: ZIO[Console, IOException, (Unit, Unit)] =\n  Console.printLine("ZIO") <*> ZIO.fail(new IOException("Fail"))\n// zioFail: ZIO[Console, IOException, (Unit, Unit)] = FlatMap(\n//   trace = "repl.MdocSession.MdocApp0.zioFail(commutativeboth.md:44)",\n//   first = Stateful(\n//     trace = "repl.MdocSession.MdocApp0.zioFail(commutativeboth.md:44)",\n//     onState = zio.FiberRef$unsafe$$anon$2$$Lambda$16955/0x000000080494b040@70229c68\n//   ),\n//   successK = zio.ZIO$$Lambda$16957/0x0000000804949840@4fc28f6e\n// )\n'})}),"\n",(0,o.jsxs)(t.p,{children:["Again if the ",(0,o.jsx)(t.code,{children:"zip"})," operator was commutative these two ",(0,o.jsx)(t.code,{children:"ZIO"})," workflows should be the same but they are not. The first program will fail immediately and never print ",(0,o.jsx)(t.code,{children:"ZIO"})," to the console, whereas the second will print ",(0,o.jsx)(t.code,{children:"ZIO"})," to the console and then fail."]}),"\n",(0,o.jsx)(t.p,{children:"What would a commutative version of this operator be? It would have to run both the left and right values at the same time so they both had the same opportunity to run."}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"zipPar"})," operator on ",(0,o.jsx)(t.code,{children:"ZIO"})," does just this."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:'val helloZIOPar: ZIO[Console, IOException, Unit] =\n  Console.printLine("Hello") <&> Console.printLine("ZIO")\n// helloZIOPar: ZIO[Console, IOException, Unit] = DynamicNoBox(\n//   trace = "repl.MdocSession.MdocApp0.helloZIOPar(commutativeboth.md:51)",\n//   update = 1L,\n//   f = zio.ZIO$$Lambda$17019/0x00000008049e0040@166042c3\n// )\n'})}),"\n",(0,o.jsxs)(t.p,{children:["Now ",(0,o.jsx)(t.code,{children:"Hello"})," and ",(0,o.jsx)(t.code,{children:"World"})," will be printed to the console at the same time. For any given execution one will appear before the other but they each have the same opportunity to appear first and both this and the version with the order reversed describe the same ",(0,o.jsx)(t.code,{children:"ZIO"})," workflow."]}),"\n",(0,o.jsxs)(t.p,{children:["This interpretation of ",(0,o.jsx)(t.code,{children:"zipPar"})," as running the left and right values on separate fibers is the most natural one but not the only one. The left and right values can be run in parallel as long as the result of running one does not depend on the result of running the other and information from both has equal opportunity to be included in the result."]}),"\n",(0,o.jsxs)(t.p,{children:["To see this, let's look at a slightly simplified version of the ",(0,o.jsx)(t.code,{children:"Validation"})," data type from ZIO Prelude and how we can define the ",(0,o.jsx)(t.code,{children:"zipPar"})," operator for it."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:"import zio.NonEmptyChunk\n\nsealed trait Validation[+E, +A] { self =>\n  import Validation._\n\n  def zipPar[E1 >: E, B](that: Validation[E1, B]): Validation[E1, (A, B)] =\n    (self, that) match {\n      case (Success(a), Success(b))    => Success((a, b))\n      case (Success(_), Failure(e1s))  => Failure(e1s)\n      case (Failure(es), Success(_))   => Failure(es)\n      case (Failure(es), Failure(e1s)) => Failure(es ++ e1s)\n    }\n}\n\nobject Validation {\n  case class Success[+A](value: A) extends Validation[Nothing, A]\n  case class Failure[+E](errors: NonEmptyChunk[E]) extends Validation[E, Nothing]\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["We are not forking any fibers here, but notice how in our implementation of ",(0,o.jsx)(t.code,{children:"zipPar"})," we are matching on the left and right sides at the same time and preserving the information from both errors in the case where both fail. As long as we implement equality in a way that does not depend on the order of errors, combining two ",(0,o.jsx)(t.code,{children:"Validation"})," values with ",(0,o.jsx)(t.code,{children:"zipPar"})," will always give the same result regardless of the order in which we combine them."]}),"\n",(0,o.jsx)(t.p,{children:"Another interpretation of what it means to run two values in parallel comes from collections. We can combine values from two collections in parallel by zipping them together pairwise."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:"import zio.prelude._\n\nimplicit val ListCommutativeBoth: CommutativeBoth[List] =\n  new CommutativeBoth[List] {\n    def both[A, B](as: => List[A], bs: => List[B]): List[(A, B)] =\n      as.zip(bs)\n  }\n// ListCommutativeBoth: CommutativeBoth[List] = repl.MdocSession$MdocApp0$$anon$1@47d8d747\n"})}),"\n",(0,o.jsx)(t.p,{children:"Again we are not forking any fibers here but values from the left list and the right list have an equal opportunity to be included in the zipped list."}),"\n",(0,o.jsx)(t.p,{children:"We can see this if we zip together two lists of different lengths."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:"val left: List[Int] =\n  List(1, 2, 3)\n// left: List[Int] = List(1, 2, 3)\n\nval right: List[Int] =\n  List(4, 5, 6, 7, 8)\n// right: List[Int] = List(4, 5, 6, 7, 8)\n\nval leftRight: List[(Int, Int)] =\n  left.zip(right)\n// leftRight: List[(Int, Int)] = List((1, 4), (2, 5), (3, 6))\n\nval rightLeft: List[(Int, Int)] =\n  right.zip(left)\n// rightLeft: List[(Int, Int)] = List((4, 1), (5, 2), (6, 3))\n"})}),"\n",(0,o.jsx)(t.p,{children:"The zipped lists are identical after rearranging the order of tuples."}),"\n",(0,o.jsxs)(t.p,{children:["Some instances of ",(0,o.jsx)(t.code,{children:"CommutativeBoth"})," actually combine these interpretations. For example the ",(0,o.jsx)(t.code,{children:"CommutativeBoth"})," instance for ",(0,o.jsx)(t.code,{children:"ZStream"})," is implemented in terms of the ",(0,o.jsx)(t.code,{children:"zip"})," operator on ",(0,o.jsx)(t.code,{children:"ZStream"}),", which creates a new stream that pulls values from the left and the right streams pairwise, evaluating effects in the left and right streams on separate fibers."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:"import zio.stream._\n\ndef both[R, E, A, B](left: => ZStream[R, E, A], right: ZStream[R, E, B]): ZStream[R, E, (A, B)] =\n  left.zip(right)\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Just like the ",(0,o.jsx)(t.code,{children:"AssociativeBoth"})," abstraction, ",(0,o.jsx)(t.code,{children:"CommutativeBoth"})," is not limited to covariant types. For example we could send inputs to multiple sinks in parallel, having each sink run on a separate fiber."]}),"\n",(0,o.jsxs)(t.p,{children:["When the parameterized type is covariant the ",(0,o.jsx)(t.code,{children:"zipWithPar"})," operator is also defined on it."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:"def zipWithPar[F[+_]: CommutativeBoth : Covariant, A, B, C](\n  fa: => F[A],\n  fb: => F[B]\n)(f: (A, B) => C): F[C] =\n  fa.zipPar(fb).map(f.tupled)\n"})}),"\n",(0,o.jsxs)(t.p,{children:["This is just like the ",(0,o.jsx)(t.code,{children:"zipWith"})," operator defined on data types that have an ",(0,o.jsx)(t.code,{children:"AssociativeBoth"})," instance except it runs the left and right values in parallel instead of running the left value and then the right value. It is very useful when you want to do two things in parallel and then combine the results."]}),"\n",(0,o.jsxs)(t.p,{children:["A version of this is available for contravariant data types called ",(0,o.jsx)(t.code,{children:"bothWithPar"}),"."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:"def bothWithPar[F[-_]: CommutativeBoth : Contravariant, A, B, C](\n  fa: => F[A],\n  fb: => F[B]\n)(f: C => (A, B)): F[C] =\n  fa.zipPar(fb).contramap(f)\n"})}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"bothWithPar"})," operator splits a data type ",(0,o.jsx)(t.code,{children:"C"})," up into two parts ",(0,o.jsx)(t.code,{children:"A"})," and ",(0,o.jsx)(t.code,{children:"B"}),", running the left value with ",(0,o.jsx)(t.code,{children:"A"})," and the right value with ",(0,o.jsx)(t.code,{children:"B"})," in parallel."]}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"CommutativeBoth"})," functional abstraction, like the ",(0,o.jsx)(t.code,{children:"AssociativeBoth"})," abstraction, describes a basic way of combining two data types, this time by running them in parallel instead of running the left one and then the right one. The ",(0,o.jsx)(t.code,{children:"zipPar"})," operator, or more domain specific names for it for certain basic types, is also very practically useful and we saw that it corresponded to common operators on these data types that we were probably already familiar with."]}),"\n",(0,o.jsxs)(t.p,{children:["For this reason, however, the ",(0,o.jsx)(t.code,{children:"CommutativeBoth"})," abstraction may be less useful if you are working with data types from ZIO or the Scala standard library. They generally already implement this functionality directly, for example in the ",(0,o.jsx)(t.code,{children:"zipPar"})," operator on ",(0,o.jsx)(t.code,{children:"ZIO"})," and the ",(0,o.jsx)(t.code,{children:"zip"})," operator on ",(0,o.jsx)(t.code,{children:"ZStream"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["This abstraction is more likely to be useful when you are defining your own data type. If your data type supports a way of combining that is commutative, such as the ones we have discussed here, then defining a ",(0,o.jsx)(t.code,{children:"CommutativeBoth"})," instance will let you express that and work with other operators that are defined on data types with ",(0,o.jsx)(t.code,{children:"CommutativeBoth"})," instances."]}),"\n",(0,o.jsxs)(t.p,{children:["Finally, this abstraction is likely to be valuable for those writing generic code to describe running values in parallel. As with the ",(0,o.jsx)(t.code,{children:"AssociativeBoth"})," abstraction the ability to generalize over covariant, contravariant, and invariant data types is likely to be particularly valuable here."]})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);