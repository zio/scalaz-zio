"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[28928],{17621:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>l,frontMatter:()=>s,metadata:()=>i,toc:()=>r});const i=JSON.parse('{"id":"zio-cli/commands","title":"Commands","description":"A command is a piece of text representing a directive for a CLI application. This allows the user to communicate easily which task must perform the application. A popular CLI app is the Version Control System called Git. Commonly used commands of Git are among the following.","source":"@site/docs/zio-cli/commands.md","sourceDirName":"zio-cli","slug":"/zio-cli/commands","permalink":"/zio-cli/commands","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-cli/commands.md","tags":[],"version":"current","frontMatter":{"id":"commands","title":"Commands"},"sidebar":"ecosystem-sidebar","previous":{"title":"Options","permalink":"/zio-cli/options"},"next":{"title":"Help Documentation","permalink":"/zio-cli/helpdoc"}}');var a=o(74848),t=o(28453);const s={id:"commands",title:"Commands"},d=void 0,c={},r=[{value:"Subcommands",id:"subcommands",level:3},{value:"Basic construction",id:"basic-construction",level:3},{value:"Combining commands and transformations",id:"combining-commands-and-transformations",level:2},{value:"Choosing between commands",id:"choosing-between-commands",level:3},{value:"Adding Help Documentation",id:"adding-help-documentation",level:3},{value:"Adding subcommands",id:"adding-subcommands",level:3},{value:"Changing the type parameter",id:"changing-the-type-parameter",level:3}];function m(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"A command is a piece of text representing a directive for a CLI application. This allows the user to communicate easily which task must perform the application. A popular CLI app is the Version Control System called Git. Commonly used commands of Git are among the following."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"git clone // Creates a copy of a repository\ngit add   // Adds modified or new files that will be committed after using git commit\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"ZIO CLI"})," uses class ",(0,a.jsx)(n.code,{children:"Command[Model]"})," as a description of a CLI command. When using ",(0,a.jsx)(n.code,{children:"CliApp.make"}),", it is needed to specify a ",(0,a.jsx)(n.code,{children:"Command[Model]"})," instance. This parameter is parsed by ",(0,a.jsx)(n.code,{children:"CliApp"})," to produce a collection of possible commands and transform a valid input from a user into an instance of type ",(0,a.jsx)(n.code,{children:"Model"}),". Then you can implement the functionality of the CLI App using pattern matching on instances of ",(0,a.jsx)(n.code,{children:"Model"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"subcommands",children:"Subcommands"}),"\n",(0,a.jsxs)(n.p,{children:["A subcommand is a command that belongs to a larger command. Thus, it is possible for a command to have different subcommands. Subcommands can be used to better organize and design the functionality of a CLI app. Different subcommands can represent different types of task that a CLI can perform and give them a descriptive name. In the Git example above, ",(0,a.jsx)(n.code,{children:"git"})," is the name of the command while ",(0,a.jsx)(n.code,{children:"clone"})," or ",(0,a.jsx)(n.code,{children:"add"})," are subcommands of ",(0,a.jsx)(n.code,{children:"git"}),". As the functionality of ",(0,a.jsx)(n.code,{children:"git clone"})," and ",(0,a.jsx)(n.code,{children:"git add"})," are very different, it is better to use different subcommands. In the same way, it would be possible for a subcommand to have other subcommands."]}),"\n",(0,a.jsx)(n.h3,{id:"basic-construction",children:"Basic construction"}),"\n",(0,a.jsxs)(n.p,{children:["It's possible to create a ",(0,a.jsx)(n.code,{children:"Command"})," using the ",(0,a.jsx)(n.code,{children:"apply"})," method. You must always specify the name of the command that will be used\nin the CLI, but you can also specify options and/or arguments:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"import zio.cli._\n\nobject Command {\n  def apply(name: String) = ???\n  def apply[ArgsType](name: String, args: Args[ArgsType]) = ???\n  def apply[OptionsType](name: String, options: Options[OptionsType]) = ???\n  def apply[OptionsType, ArgsType](name: String, options: Options[OptionsType], args: Args[ArgsType]) = ???\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"combining-commands-and-transformations",children:"Combining commands and transformations"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"ZIO CLI"})," also allows to combine different commands in a functional manner. This can be used for a cleaner design of the commands of a CLI app."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"trait Command[+A] {\n  def |[A1 >: A](that: Command[A1]): Command[A1]\n  def orElse[A1 >: A](that: Command[A1]): Command[A1]\n  def orElseEither[B](that: Command[B]): Command[Either[A, B]]\n  def withHelp(help: HelpDoc): Command[A]\n  def withHelp(help: String): Command[A]\n  def subcommands[B](that: Command[B])\n  def subcommands[B](c1: Command[B], c2: Command[B], cs: Command[B]*)\n  def map[B](f: A => B): Command[B]\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"choosing-between-commands",children:"Choosing between commands"}),"\n",(0,a.jsxs)(n.p,{children:["If we have more than one command, we can create a new ",(0,a.jsx)(n.code,{children:"Command"})," that allows to choose between two commands using methods ",(0,a.jsx)(n.code,{children:"|"}),", ",(0,a.jsx)(n.code,{children:"orElse"})," and ",(0,a.jsx)(n.code,{children:"orElseEither"})," as with ",(0,a.jsx)(n.code,{children:"Options"}),". The difference between these three methods lies in the type parameter of the new ",(0,a.jsx)(n.code,{children:"Command"}),". The user will be able to enter only the command that he wants, triggering the desired functionality."]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Method ",(0,a.jsx)(n.code,{children:"orElse"})]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"|"})," is just an alias for ",(0,a.jsx)(n.code,{children:"orElse"}),". In the Git CLI, it is possible to choose between different commands. This can be realized using ",(0,a.jsx)(n.code,{children:"orElse"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'import zio.cli._\nimport java.nio.file.Path\n\nval gitAdd: Command[Unit] = Command("add")\nval gitClone: Command[Path] = Command("clone", Options.directory("directory"))\n\nval newCommand: Command[Any] = gitAdd orElse gitClone \n'})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Method ",(0,a.jsx)(n.code,{children:"orElseEither"})]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["This method wraps the types in an ",(0,a.jsx)(n.code,{children:"Either"})," class."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'import zio.cli._\nimport java.nio.file.Path\n\nval gitAdd: Command[Unit] = Command("add")\nval gitClone: Command[Path] = Command("clone", Options.directory("directory"))\n\nval newCommand: Command[Either[Unit, Path]] = gitAdd orElseEither gitClone \n'})}),"\n",(0,a.jsx)(n.h3,{id:"adding-help-documentation",children:"Adding Help Documentation"}),"\n",(0,a.jsxs)(n.p,{children:["Method ",(0,a.jsx)(n.code,{children:"withHelp"})," returns a new command with the parameter ",(0,a.jsx)(n.code,{children:"HelpDoc"})," or ",(0,a.jsx)(n.code,{children:"String"})," as the ",(0,a.jsx)(n.code,{children:"helpDoc"})," of the command."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'import zio.cli._\nimport java.nio.file.Path\n\nval helpGit = "This is command git."\nval helpGitAdd = "Stages changes in the working repository."\nval helpGitClone = "Creates a copy of an existing repository."\n\n// Adding HelpDoc to Commands\nval gitCommand: Command[Unit] = Command("git").withHelp(helpGit)\nval gitAdd: Command[Unit] = Command("add").withHelp(helpGitAdd)\nval gitClone: Command[Path] = Command("clone", Options.directory("directory")).withHelp(helpGitClone)\n'})}),"\n",(0,a.jsx)(n.p,{children:"The output that this HelpDoc produces is the following."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"DESCRIPTION\n\n  This is command git.\n\nCOMMANDS\n\n  - add                          Stages changes in the working repository.\n  - clone --directory directory  Creates a copy of an existing repository.\n"})}),"\n",(0,a.jsx)(n.h3,{id:"adding-subcommands",children:"Adding subcommands"}),"\n",(0,a.jsxs)(n.p,{children:["Method ",(0,a.jsx)(n.code,{children:"subcommands"})," returns a new command with a new set of child commands."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"// Adds subcommands add and clone to command git\nval git: Command[Any] = gitCommand.subcommands(gitAdd, gitClone)\n"})}),"\n",(0,a.jsx)(n.h3,{id:"changing-the-type-parameter",children:"Changing the type parameter"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"Command[_]"})," is a generic class. We can apply ",(0,a.jsx)(n.code,{children:"map"})," to construct commands returning any custom type that helps us implement business logic. In this way, we can avoid using types as ",(0,a.jsx)(n.code,{children:"Unit"}),", ",(0,a.jsx)(n.code,{children:"Path"}),", ",(0,a.jsx)(n.code,{children:"Any"})," or ",(0,a.jsx)(n.code,{children:"Either"})," that are not very informative. For example, we can modify the type parameter of ",(0,a.jsx)(n.code,{children:"git"})," to the trait ",(0,a.jsx)(n.code,{children:"Git"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"sealed trait Git\ncase class Add() extends Git\ncase class Clone(directory: Path) extends Git\n\nval customCommand: Command[Git] =\n  git.map {\n    case () => Add()\n    case directory: Path => Clone(directory)\n  }\n"})}),"\n",(0,a.jsxs)(n.p,{children:["This makes possible to implement the business logic of our CLI app using directly a custom type. This can be of great use if we have employed various (",(0,a.jsx)(n.code,{children:"orElseEither"}),"). We are going to implement another subcommand of Git using ",(0,a.jsx)(n.code,{children:"orElseEither"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'// new Git subcommand\nval gitBranch = Command("branch", Args.text("branch-name"))\n\n// new Git subclass\ncase class Branch(branchName: String) extends Git\n\nval eitherCommand: Command[Either[Either[Unit, Path], String]] = gitAdd orElseEither gitClone orElseEither gitBranch\nval customEitherCommand: Command[Git] =\n  eitherCommand.map {\n    case Left(Left(_)) => Add()\n    case Left(Right(directory)) => Clone(directory)\n    case Right(branchName) => Branch(branchName)\n  }\n'})}),"\n",(0,a.jsxs)(n.p,{children:["In this example, we have transformed a rather cumbersome ",(0,a.jsx)(n.code,{children:"Command[Either[Either[Unit, Path], String]]"})," into a ",(0,a.jsx)(n.code,{children:"Command[Git]"}),"."]})]})}function l(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(m,{...e})}):m(e)}},28453:(e,n,o)=>{o.d(n,{R:()=>s,x:()=>d});var i=o(96540);const a={},t=i.createContext(a);function s(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);