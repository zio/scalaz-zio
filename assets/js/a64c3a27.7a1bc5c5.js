"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[59128],{37276:(e,i,r)=>{r.r(i),r.d(i,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"reference/fiber/fiberref","title":"FiberRef","description":"FiberRef[A] models a mutable reference to a value of type A. The two basic operations are set, which sets the reference to a new value, and get, which retrieves the current value of the reference.","source":"@site/versioned_docs/version-1.0.18/reference/fiber/fiberref.md","sourceDirName":"reference/fiber","slug":"/reference/fiber/fiberref","permalink":"/1.0.18/reference/fiber/fiberref","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/versioned_docs/version-1.0.18/reference/fiber/fiberref.md","tags":[],"version":"1.0.18","frontMatter":{"id":"fiberref","title":"FiberRef"},"sidebar":"overview_sidebar","previous":{"title":"Fiber","permalink":"/1.0.18/reference/fiber/"},"next":{"title":"Fiber.Id","permalink":"/1.0.18/reference/fiber/fiberid"}}');var s=r(74848),t=r(28453);const a={id:"fiberref",title:"FiberRef"},c=void 0,o={},l=[{value:"Operations",id:"operations",level:2},{value:"Propagation",id:"propagation",level:2},{value:"Copy-on-Fork",id:"copy-on-fork",level:3},{value:"join Semantic",id:"join-semantic",level:3},{value:"Custom Merge",id:"custom-merge",level:3},{value:"await semantic",id:"await-semantic",level:3},{value:"inheritRefs",id:"inheritrefs",level:3},{value:"Memory Safety",id:"memory-safety",level:2}];function d(e){const i={code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.code,{children:"FiberRef[A]"})," models a mutable reference to a value of type ",(0,s.jsx)(i.code,{children:"A"}),". The two basic operations are ",(0,s.jsx)(i.code,{children:"set"}),", which sets the reference to a new value, and ",(0,s.jsx)(i.code,{children:"get"}),", which retrieves the current value of the reference."]}),"\n",(0,s.jsxs)(i.p,{children:["We can think of ",(0,s.jsx)(i.code,{children:"FiberRef"})," as Java's ",(0,s.jsx)(i.code,{children:"ThreadLocal"})," on steroids. So, just like we have ",(0,s.jsx)(i.code,{children:"ThreadLocal"})," in Java we have ",(0,s.jsx)(i.code,{children:"FiberRef"})," in ZIO. So as different threads have different ",(0,s.jsx)(i.code,{children:"ThreadLocal"}),"s, we can say different fibers have different ",(0,s.jsx)(i.code,{children:"FiberRef"}),"s. They don't intersect or overlap in any way. ",(0,s.jsx)(i.code,{children:"FiberRef"})," is the fiber version of ",(0,s.jsx)(i.code,{children:"ThreadLocal"})," with significant improvements in its semantics. A ",(0,s.jsx)(i.code,{children:"ThreadLocal"})," only has a mutable state in which each thread accesses its own copy, but threads don't propagate their state to their children's."]}),"\n",(0,s.jsxs)(i.p,{children:["As opposed to ",(0,s.jsx)(i.code,{children:"Ref[A]"}),", the value of a ",(0,s.jsx)(i.code,{children:"FiberRef[A]"})," is bound to an executing fiber. Different fibers who hold the same ",(0,s.jsx)(i.code,{children:"FiberRef[A]"})," can independently set and retrieve values of the reference, without collisions."]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-scala",children:"import zio._\n\nfor {\n  fiberRef <- FiberRef.make[Int](0)\n  _        <- fiberRef.set(10)\n  v        <- fiberRef.get\n} yield v == 10\n"})}),"\n",(0,s.jsx)(i.h2,{id:"operations",children:"Operations"}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.code,{children:"FiberRef[A]"})," has an API almost identical to ",(0,s.jsx)(i.code,{children:"Ref[A]"}),". It includes well-known methods such as:"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"FiberRef#get"}),". Returns the current value of the reference."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"FiberRef#set"}),". Sets the current value of the reference."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"FiberRef#update"})," / ",(0,s.jsx)(i.code,{children:"FiberRef#updateSome"})," updates the value with the specified function."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"FiberRef#modify"}),"/ ",(0,s.jsx)(i.code,{children:"FiberRef#modifySome"})," modifies the value with the specified function, computing a return value for the operation."]}),"\n"]}),"\n",(0,s.jsxs)(i.p,{children:["You can also use ",(0,s.jsx)(i.code,{children:"locally"})," to scope ",(0,s.jsx)(i.code,{children:"FiberRef"})," value only for a given effect:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-scala",children:'for {\n  correlationId <- FiberRef.make[String]("")\n  v1            <- correlationId.locally("my-correlation-id")(correlationId.get)\n  v2            <- correlationId.get\n} yield v1 == "my-correlation-id" && v2 == ""\n'})}),"\n",(0,s.jsx)(i.h2,{id:"propagation",children:"Propagation"}),"\n",(0,s.jsxs)(i.p,{children:["Let's go back to the ",(0,s.jsx)(i.code,{children:"FiberRef"}),"s analog called ",(0,s.jsx)(i.code,{children:"ThreadLocal"})," and see how it works. If we have thread ",(0,s.jsx)(i.code,{children:"A"})," with its ",(0,s.jsx)(i.code,{children:"ThreadLocal"})," and thread ",(0,s.jsx)(i.code,{children:"A"})," creates a new thread, let's call it thread ",(0,s.jsx)(i.code,{children:"B"}),". When thread ",(0,s.jsx)(i.code,{children:"A"})," sends thread ",(0,s.jsx)(i.code,{children:"B"})," the same ",(0,s.jsx)(i.code,{children:"ThreadLocal"})," then what value does thread ",(0,s.jsx)(i.code,{children:"B"})," see inside the ",(0,s.jsx)(i.code,{children:"ThreadLocal"}),"? Well, it sees the default value of the ",(0,s.jsx)(i.code,{children:"ThreadLocal"}),". It does not see ",(0,s.jsx)(i.code,{children:"A"}),"s value of the ",(0,s.jsx)(i.code,{children:"ThreadLocal"}),". So in other words, ",(0,s.jsx)(i.code,{children:"ThreadLocal"}),"s do not propagate their values across the sort of graph of threads so when one thread creates another, the ",(0,s.jsx)(i.code,{children:"ThreadLocal"})," value is not propagated from parent to child."]}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.code,{children:"FiberRefs"})," improve on that model quite dramatically. Basically, whenever a child's fiber is created from its parent, the ",(0,s.jsx)(i.code,{children:"FiberRef"})," value of parent fiber propagated to its child fiber."]}),"\n",(0,s.jsx)(i.h3,{id:"copy-on-fork",children:"Copy-on-Fork"}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.code,{children:"FiberRef[A]"})," has ",(0,s.jsx)(i.em,{children:"copy-on-fork"})," semantics for ",(0,s.jsx)(i.code,{children:"ZIO#fork"}),". This essentially means that a child ",(0,s.jsx)(i.code,{children:"Fiber"})," starts with ",(0,s.jsx)(i.code,{children:"FiberRef"})," values of its parent. When the child set a new value of ",(0,s.jsx)(i.code,{children:"FiberRef"}),", the change is visible only to the child itself. The parent fiber still has its own value."]}),"\n",(0,s.jsxs)(i.p,{children:["So if we create a ",(0,s.jsx)(i.code,{children:"FiberRef"})," and, we set its value to ",(0,s.jsx)(i.code,{children:"5"}),", and we pass this ",(0,s.jsx)(i.code,{children:"FiberRef"})," to a child fiber, it sees the value ",(0,s.jsx)(i.code,{children:"5"}),". If the child fiber modifies the value ",(0,s.jsx)(i.code,{children:"5"})," to ",(0,s.jsx)(i.code,{children:"6"}),", the parent fiber can't see that change. So the child fiber gets its own copy of the ",(0,s.jsx)(i.code,{children:"FiberRef"}),", and it can modify it locally. Those changes will not affect the parent fiber:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-scala",children:"for {\n  fiberRef <- FiberRef.make(5)\n  promise <- Promise.make[Nothing, Int]\n  _ <- fiberRef\n    .updateAndGet(_ => 6)\n    .flatMap(promise.succeed).fork\n  childValue <- promise.await\n  parentValue <- fiberRef.get\n} yield assert(parentValue == 5 && childValue == 6)\n"})}),"\n",(0,s.jsx)(i.h3,{id:"join-semantic",children:"join Semantic"}),"\n",(0,s.jsxs)(i.p,{children:["If we ",(0,s.jsx)(i.code,{children:"join"})," a fiber then its ",(0,s.jsx)(i.code,{children:"FiberRef"})," is merged back into the parent fiber:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-scala",children:"for {\n  fiberRef <- FiberRef.make(5)\n  child <- fiberRef.set(6).fork\n  _ <- child.join\n  parentValue <- fiberRef.get\n} yield assert(parentValue == 6)\n"})}),"\n",(0,s.jsxs)(i.p,{children:["So if we ",(0,s.jsx)(i.code,{children:"fork"})," a fiber and that child fiber modifies a bunch of ",(0,s.jsx)(i.code,{children:"FiberRef"}),"s and then later we join it, we get those modifications merged back into the parent fiber. So that's the semantic model of ZIO on ",(0,s.jsx)(i.code,{children:"join"}),"."]}),"\n",(0,s.jsxs)(i.p,{children:["Each fiber has its ",(0,s.jsx)(i.code,{children:"FiberRef"})," and modifying it locally. So when they do their job and ",(0,s.jsx)(i.code,{children:"join"})," their parent, how do they get merged?  By default, the last child fiber will win, the last fiber which is going to ",(0,s.jsx)(i.code,{children:"join"})," will override the parent's ",(0,s.jsx)(i.code,{children:"FiberRef"})," value."]}),"\n",(0,s.jsxs)(i.p,{children:["As we can see, ",(0,s.jsx)(i.code,{children:"child1"})," is the last fiber, so its value which is ",(0,s.jsx)(i.code,{children:"6"}),", gets merged back into its parent:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-scala",children:"for {\n  fiberRef <- FiberRef.make(5)\n  child1 <- fiberRef.set(6).fork\n  child2 <- fiberRef.set(7).fork\n  _ <- child2.join\n  _ <- child1.join\n  parentValue <- fiberRef.get\n} yield assert(parentValue == 6)\n"})}),"\n",(0,s.jsx)(i.h3,{id:"custom-merge",children:"Custom Merge"}),"\n",(0,s.jsxs)(i.p,{children:["Furthermore we can customize how, if at all, the value will be update when a fiber is forked and how values will be combined when a fiber is merged. To do this you specify the desired behavior during ",(0,s.jsx)(i.code,{children:"FiberRef#make"}),":"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-scala",children:"for {\n  fiberRef <- FiberRef.make(initial = 0, join = math.max)\n  child    <- fiberRef.update(_ + 1).fork\n  _        <- fiberRef.update(_ + 2)\n  _        <- child.join\n  value    <- fiberRef.get\n} yield assert(value == 2)\n"})}),"\n",(0,s.jsx)(i.h3,{id:"await-semantic",children:"await semantic"}),"\n",(0,s.jsxs)(i.p,{children:["Important to note that ",(0,s.jsx)(i.code,{children:"await"}),", has no such properties, so ",(0,s.jsx)(i.code,{children:"await"})," waits for the child fiber to finish and gives us its value as an ",(0,s.jsx)(i.code,{children:"Exit"}),":"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-scala",children:"for {\n  fiberRef <- FiberRef.make(5)\n  child <- fiberRef.set(6).fork\n  _ <- child.await\n  parentValue <- fiberRef.get\n} yield assert(parentValue == 5)\n"})}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.code,{children:"Join"})," has higher-level semantics that ",(0,s.jsx)(i.code,{children:"await"})," because it will fail if the child fiber failed, and it will also merge back its value to its parent."]}),"\n",(0,s.jsx)(i.h3,{id:"inheritrefs",children:"inheritRefs"}),"\n",(0,s.jsxs)(i.p,{children:["We can inherit the values from all ",(0,s.jsx)(i.code,{children:"FiberRef"}),"s from an existing ",(0,s.jsx)(i.code,{children:"Fiber"})," using the ",(0,s.jsx)(i.code,{children:"Fiber#inheritRefs"})," method:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-scala",children:"for {\n  fiberRef <- FiberRef.make[Int](0)\n  latch    <- Promise.make[Nothing, Unit]\n  fiber    <- (fiberRef.set(10) *> latch.succeed(())).fork\n  _        <- latch.await\n  _        <- fiber.inheritRefs\n  v        <- fiberRef.get\n} yield v == 10\n"})}),"\n",(0,s.jsxs)(i.p,{children:["Note that ",(0,s.jsx)(i.code,{children:"inheritRefs"})," is automatically called on ",(0,s.jsx)(i.code,{children:"join"}),". This effectively means that both of the following effects behave identically:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-scala",children:"val withJoin =\n  for {\n    fiberRef <- FiberRef.make[Int](0)\n    fiber    <- fiberRef.set(10).fork\n    _        <- fiber.join\n    v        <- fiberRef.get\n  } yield assert(v == 10)\n"})}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-scala",children:"val withoutJoin =\n  for {\n    fiberRef <- FiberRef.make[Int](0)\n    fiber    <- fiberRef.set(10).fork\n    _        <- fiber.inheritRefs\n    v        <- fiberRef.get\n  } yield assert(v == 10)\n"})}),"\n",(0,s.jsx)(i.h2,{id:"memory-safety",children:"Memory Safety"}),"\n",(0,s.jsxs)(i.p,{children:["The value of a ",(0,s.jsx)(i.code,{children:"FiberRef"})," is automatically garbage collected once the ",(0,s.jsx)(i.code,{children:"Fiber"})," owning it is finished. A ",(0,s.jsx)(i.code,{children:"FiberRef"})," that is no longer reachable (has no reference to it in user-code) will cause all fiber-specific values of the reference to be garbage collected, even if they were once used in a ",(0,s.jsx)(i.code,{children:"Fiber"})," that is currently executing."]})]})}function h(e={}){const{wrapper:i}={...(0,t.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,i,r)=>{r.d(i,{R:()=>a,x:()=>c});var n=r(96540);const s={},t=n.createContext(s);function a(e){const i=n.useContext(t);return n.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function c(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),n.createElement(t.Provider,{value:i},e.children)}}}]);