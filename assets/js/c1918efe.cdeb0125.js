"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[19331],{39561:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>d,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"ecosystem/community/caliban","title":"Caliban","description":"Caliban is a purely functional library for creating GraphQL servers and clients in Scala.","source":"@site/docs/ecosystem/community/caliban.md","sourceDirName":"ecosystem/community","slug":"/ecosystem/community/caliban","permalink":"/ecosystem/community/caliban","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/ecosystem/community/caliban.md","tags":[],"version":"current","frontMatter":{"id":"caliban","title":"Caliban"},"sidebar":"ecosystem-sidebar","previous":{"title":"ZIO Ecosystem Community Libraries","permalink":"/ecosystem/community/"},"next":{"title":"Distage","permalink":"/ecosystem/community/distage"}}');var r=a(74848),t=a(28453);const l={id:"caliban",title:"Caliban"},s=void 0,o={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Installation",id:"installation",level:2},{value:"Example",id:"example",level:2},{value:"Resources",id:"resources",level:2}];function p(e){const n={a:"a",code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://ghostdogpr.github.io/caliban/",children:"Caliban"})," is a purely functional library for creating GraphQL servers and clients in Scala."]}),"\n",(0,r.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,r.jsx)(n.p,{children:"Key features of Caliban"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Purely Functional"})," \u2014 All interfaces are pure and types are referentially transparent."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type Safety"})," \u2014 Schemas are type safe and derived at compile time."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Minimal Boilerplate"})," \u2014 No need to manually define a schema for every type in your API."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Excellent Interoperability"})," \u2014 Out-of-the-box support for major HTTP server libraries, effect types, JSON libraries, and more."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,r.jsxs)(n.p,{children:["In order to use this library, we need to add the following line in our ",(0,r.jsx)(n.code,{children:"build.sbt"})," file:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'libraryDependencies += "com.github.ghostdogpr" %% "caliban"       % "2.8.1"\nlibraryDependencies += "com.github.ghostdogpr" %% "caliban-quick" % "2.8.1" // Optional: HTTP routes via ZIO HTTP\n'})}),"\n",(0,r.jsx)(n.p,{children:"Caliban also have lots of optional modules to interoperate with other various libraries:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'libraryDependencies += "com.github.ghostdogpr" %% "caliban-http4s"     % "2.8.1" // routes for http4s\nlibraryDependencies += "com.github.ghostdogpr" %% "caliban-akka-http"  % "2.8.1" // routes for akka-http\nlibraryDependencies += "com.github.ghostdogpr" %% "caliban-play"       % "2.8.1" // routes for play\nlibraryDependencies += "com.github.ghostdogpr" %% "caliban-finch"      % "2.8.1" // routes for finch\nlibraryDependencies += "com.github.ghostdogpr" %% "caliban-cats"       % "2.8.1" // interop with cats effect\nlibraryDependencies += "com.github.ghostdogpr" %% "caliban-monix"      % "2.8.1" // interop with monix\nlibraryDependencies += "com.github.ghostdogpr" %% "caliban-tapir"      % "2.8.1" // interop with tapir\nlibraryDependencies += "com.github.ghostdogpr" %% "caliban-federation" % "2.8.1" // interop with apollo federation\n'})}),"\n",(0,r.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,r.jsx)(n.p,{children:"First, to define Caliban API, we should define data models using case classes and ADTs. Then the Caliban can derive the whole GraphQL schema from these data models:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import caliban._\nimport caliban.quick._\nimport caliban.schema.{Schema, ArgBuilder}\nimport caliban.schema.Annotations.GQLDescription\n\nsealed trait Role\n\nobject Role {\n  case object SoftwareDeveloper       extends Role\n  case object SiteReliabilityEngineer extends Role\n  case object DevOps                  extends Role\n}\n\ncase class Employee(\n    name: String,\n    role: Role\n)\n\ncase class EmployeesArgs(role: Role)\ncase class EmployeeArgs(name: String)\n\ncase class Queries(\n    @GQLDescription("Return all employees with specific role")\n    employees: EmployeesArgs => List[Employee],\n    @GQLDescription("Find an employee by its name")\n    employee: EmployeeArgs => Option[Employee]\n)\n\nobject CalibanExample extends zio.ZIOAppDefault {\n  import ArgBuilder.auto._\n  import Schema.auto._\n\n  val employees = List(\n    Employee("Alex", Role.DevOps),\n    Employee("Maria", Role.SoftwareDeveloper),\n    Employee("James", Role.SiteReliabilityEngineer),\n    Employee("Peter", Role.SoftwareDeveloper),\n    Employee("Julia", Role.SiteReliabilityEngineer),\n    Employee("Roberta", Role.DevOps)\n  )\n\n  override def run =\n    graphQL(\n      RootResolver(\n        Queries(\n          args => employees.filter(e => args.role == e.role),\n          args => employees.find(e => e.name == args.name)\n        )\n      )\n    ).runServer(\n      port = 8088,\n      apiPath = "/api/graphql",\n      graphiqlPath = Some("/api/graphiql"),\n    )\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Now let's query all software developers using GraphQL query language:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:"query{\n  employees(role: SoftwareDeveloper){\n    name\n    role\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Here is the ",(0,r.jsx)(n.em,{children:"curl"})," request of this query:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"curl 'http://localhost:8088/api/graphql' --data-binary '{\"query\":\"query{\\n employees(role: SoftwareDeveloper){\\n name\\n role\\n}\\n}\"}'\n"})}),"\n",(0,r.jsx)(n.p,{children:"And the response:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "data" : {\n    "employees" : [\n      {\n        "name" : "Maria",\n        "role" : "SoftwareDeveloper"\n      },\n      {\n        "name" : "Peter",\n        "role" : "SoftwareDeveloper"\n      }\n    ]\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"resources",children:"Resources"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://www.youtube.com/watch?v=mzqsXklbmfM&t=2849s",children:"Zymposium - Caliban"})," by Adam Fraser, Kit Langton and Pierre Ricadat \u2014 We will be building full-stack applications with the special guest international man of mystery Pierre Ricadat. Pierre will be walking us through Caliban, a GraphQL library in Scala that just had its 1.0 release. We'll be seeing how easy it can be to upgrade an existing application to use GraphQL with the power of Caliban!"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}},28453:(e,n,a)=>{a.d(n,{R:()=>l,x:()=>s});var i=a(96540);const r={},t=i.createContext(r);function l(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);