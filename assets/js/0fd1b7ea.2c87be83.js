"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[59639],{97762:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"overview/basic-operations","title":"Basic Operations","description":"Like the String data type, as well as the collection data types in Scala (such as List, Map, and Set), ZIO effects are immutable, and cannot be changed.","source":"@site/docs/overview/basic-operations.md","sourceDirName":"overview","slug":"/overview/basic-operations","permalink":"/overview/basic-operations","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/overview/basic-operations.md","tags":[],"version":"current","frontMatter":{"id":"basic-operations","title":"Basic Operations"},"sidebar":"overview_sidebar","previous":{"title":"Creating Effects","permalink":"/overview/creating-effects"},"next":{"title":"Handling Errors","permalink":"/overview/handling-errors"}}');var s=i(74848),o=i(28453);const a={id:"basic-operations",title:"Basic Operations"},r=void 0,c={},l=[{value:"Mapping",id:"mapping",level:2},{value:"Chaining",id:"chaining",level:2},{value:"For Comprehensions",id:"for-comprehensions",level:2},{value:"Zipping",id:"zipping",level:2},{value:"Next Steps",id:"next-steps",level:2}];function h(e){const n={a:"a",code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Like the ",(0,s.jsx)(n.code,{children:"String"})," data type, as well as the collection data types in Scala (such as ",(0,s.jsx)(n.code,{children:"List"}),", ",(0,s.jsx)(n.code,{children:"Map"}),", and ",(0,s.jsx)(n.code,{children:"Set"}),"), ZIO effects are ",(0,s.jsx)(n.em,{children:"immutable"}),", and cannot be changed."]}),"\n",(0,s.jsxs)(n.p,{children:["In order to transform or combine ZIO effects, you can use the methods on the ZIO data type, which return ",(0,s.jsx)(n.em,{children:"new effects"}),", with the specified transformations or combinations applied to them."]}),"\n",(0,s.jsx)(n.p,{children:"There are two categories of methods on the ZIO data type:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Transformations"}),". Transformation functions alter an effect in some well-defined way, allowing you to customize runtime behavior. For example, calling ",(0,s.jsx)(n.code,{children:"effect.timeout(60.seconds)"})," on an effect returns a new effect, which, when executed, will apply a timeout to the original effect."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Combinations"}),". Combination functions combine two or more effects together in a single effect. For example, calling ",(0,s.jsx)(n.code,{children:"effect1.orElse(effect2)"})," combines two effects in such a fashion that the returned effect, when executed, will first execute the left hand side, and if that fails, it will then execute the right hand side. This lets you specify a fallback effect in case a primary effect fails."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"mapping",children:"Mapping"}),"\n",(0,s.jsxs)(n.p,{children:["If you have an effect that succeeds with some value, you can use ",(0,s.jsx)(n.code,{children:"ZIO#map"})," to obtain a new effect, which will transform the value using the function you provide."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nval succeeded: ZIO[Any, Nothing, Int] = ZIO.succeed(21).map(_ * 2)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In a similar fashion, you can transform an effect that has one error to an effect with a different error using the ",(0,s.jsx)(n.code,{children:"ZIO#mapError"})," method, which requires you supply a function to do the conversion:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'val failed: ZIO[Any, Exception, Unit] = \n  ZIO.fail("No no!").mapError(msg => new Exception(msg))\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Note that mapping the error or success value of an effect does not change ",(0,s.jsx)(n.em,{children:"whether or not"})," the effect fails or succeeds. This is similar to how mapping over Scala's ",(0,s.jsx)(n.code,{children:"Either"})," data type does not change whether the ",(0,s.jsx)(n.code,{children:"Either"})," is ",(0,s.jsx)(n.code,{children:"Left"})," or ",(0,s.jsx)(n.code,{children:"Right"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"chaining",children:"Chaining"}),"\n",(0,s.jsxs)(n.p,{children:["You can execute two effects sequentially with the ",(0,s.jsx)(n.code,{children:"flatMap"})," method. The ",(0,s.jsx)(n.code,{children:"flatMap"})," method requires that you pass a callback, which will receive the success value of the first effect, and must return a second effect, which depends on this value:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'val sequenced: ZIO[Any, IOException, Unit] =\n  Console.readLine.flatMap(input => Console.printLine(s"You entered: $input"))\n'})}),"\n",(0,s.jsxs)(n.p,{children:["If the first effect fails, the callback passed to ",(0,s.jsx)(n.code,{children:"flatMap"})," will never be invoked, and the effect returned by ",(0,s.jsx)(n.code,{children:"flatMap"})," will also fail."]}),"\n",(0,s.jsxs)(n.p,{children:["In ",(0,s.jsx)(n.em,{children:"any"})," chain of effects created with ",(0,s.jsx)(n.code,{children:"flatMap"}),", the first failure will short-circuit the whole chain, just like throwing an exception will prematurely exit a sequence of statements."]}),"\n",(0,s.jsx)(n.h2,{id:"for-comprehensions",children:"For Comprehensions"}),"\n",(0,s.jsxs)(n.p,{children:["Because the ZIO data type supports both ",(0,s.jsx)(n.code,{children:"flatMap"})," and ",(0,s.jsx)(n.code,{children:"map"}),", you can use Scala's ",(0,s.jsx)(n.em,{children:"for comprehensions"})," to build imperative effects:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'val program: ZIO[Any, IOException, Unit] =\n  for {\n    _    <- Console.printLine("Hello! What is your name?")\n    name <- Console.readLine\n    _    <- Console.printLine(s"Hello, ${name}, welcome to ZIO!")\n  } yield ()\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"For comprehensions"})," provide a procedural syntax for creating chains of effects, and are the fastest way for most programmers to get up to speed using ZIO."]}),"\n",(0,s.jsx)(n.h2,{id:"zipping",children:"Zipping"}),"\n",(0,s.jsxs)(n.p,{children:["You can combine two effects into a single effect with the ",(0,s.jsx)(n.code,{children:"ZIO#zip"})," method."]}),"\n",(0,s.jsx)(n.p,{children:"The method returns an effect that will execute the left effect first, followed by the right effect, and which will place both success values into a tuple:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'val zipped: ZIO[Any, Nothing, (String, Int)] = \n  ZIO.succeed("4").zip(ZIO.succeed(2))\n'})}),"\n",(0,s.jsxs)(n.p,{children:["In any ",(0,s.jsx)(n.code,{children:"zip"})," operation, if either the left or right-hand side fails, the composed effect will fail, because ",(0,s.jsx)(n.em,{children:"both"})," values are required to construct the tuple. If the left side fails, the right side will not be executed at all."]}),"\n",(0,s.jsxs)(n.p,{children:["Sometimes, when the success value of an effect is not useful (for example, if it is ",(0,s.jsx)(n.code,{children:"Unit"}),"), it can be more convenient to use the ",(0,s.jsx)(n.code,{children:"ZIO#zipLeft"})," or ",(0,s.jsx)(n.code,{children:"ZIO#zipRight"})," functions, which first perform a ",(0,s.jsx)(n.code,{children:"zip"})," and then map over the tuple to discard one side or the other:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'val zipRight1: ZIO[Any, IOException, String] =\n  Console.printLine("What is your name?").zipRight(Console.readLine)\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"zipRight"})," and ",(0,s.jsx)(n.code,{children:"zipLeft"})," functions have symbolic aliases, known as ",(0,s.jsx)(n.code,{children:"*>"})," and ",(0,s.jsx)(n.code,{children:"<*"}),", respectively. Some developers find these operators easier to read:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'val zipRight2: ZIO[Any, IOException, String] =\n  Console.printLine("What is your name?") *>\n    Console.readLine\n'})}),"\n",(0,s.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsxs)(n.p,{children:["If you are comfortable with the basic operations on ZIO effects, the next step is to learn about ",(0,s.jsx)(n.a,{href:"/overview/handling-errors",children:"error handling"}),"."]})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>r});var t=i(96540);const s={},o=t.createContext(s);function a(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);