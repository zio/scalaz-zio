"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[25966],{35399:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"reference/test/aspects/index","title":"Introduction to Test Aspects","description":"A TestAspect is an aspect that can be weaved into specs. We can think of an aspect as a polymorphic function, capable of transforming one test into another, possibly enlarging the environment or error type. We use them to change existing tests or even entire suites or specs that we have already created.","source":"@site/docs/reference/test/aspects/index.md","sourceDirName":"reference/test/aspects","slug":"/reference/test/aspects/","permalink":"/reference/test/aspects/","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/test/aspects/index.md","tags":[],"version":"current","frontMatter":{"id":"index","title":"Introduction to Test Aspects","sidebar_label":"Test Aspects"},"sidebar":"reference-sidebar","previous":{"title":"Sized","permalink":"/reference/test/services/sized"},"next":{"title":"Before, After, and Around","permalink":"/reference/test/aspects/before-after-around"}}');var r=s(74848),a=s(28453);const i={id:"index",title:"Introduction to Test Aspects",sidebar_label:"Test Aspects"},o=void 0,c={},l=[{value:"Examples",id:"examples",level:2}];function p(e){const t={code:"code",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:["A ",(0,r.jsx)(t.code,{children:"TestAspect"})," is an aspect that can be weaved into specs. We can think of an aspect as a polymorphic function, capable of transforming one test into another, possibly enlarging the environment or error type. We use them to change existing tests or even entire suites or specs that we have already created."]}),"\n",(0,r.jsxs)(t.p,{children:["We can think of a test aspect as a Spec transformer. It takes one spec, transforms it, and produces another spec (",(0,r.jsx)(t.code,{children:"Spec => Spec"}),"). Test aspects are applied to a test or suite using the ",(0,r.jsx)(t.code,{children:"@@"})," operator:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-scala",children:'import zio.test.{test, _}\n\ntest("a single test") {\n  ???\n} @@ testAspect\n\nsuite("suite of multiple tests") {\n  ???\n} @@ testAspect\n'})}),"\n",(0,r.jsx)(t.p,{children:"Test aspects encapsulate cross-cutting concerns and increase the modularity of our tests. So we can focus on the primary concerns of our tests and at the end of the day, we can apply required aspects to our tests."}),"\n",(0,r.jsx)(t.p,{children:"The great thing about test aspects is that they are very composable. So we can chain them one after another. We can even have test aspects that modify other test aspects."}),"\n",(0,r.jsx)(t.p,{children:"Let's say we have the following test:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-scala",children:'import zio.test._\n\ntest("test") {\n  assertTrue(true)\n}\n'})}),"\n",(0,r.jsx)(t.p,{children:"We can pass this test to whatever test aspect we want. For example, to run this test only on the JVM and repeat it five times, we can write the test as below:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-scala",children:'import zio._\nimport zio.test.{test, _}\nimport zio.test.TestAspect._\n\nrepeat(Schedule.recurs(5))(\n  jvmOnly(\n    test("test") {\n      assertTrue(true)\n    }\n  )\n)\n'})}),"\n",(0,r.jsxs)(t.p,{children:["To compose the aspects, we have a very nice ",(0,r.jsx)(t.code,{children:"@@"})," syntax, which helps us to write tests concisely. So the previous example can be written as follows:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-scala",children:'import zio._\nimport zio.test.{test, _}\nimport zio.test.TestAspect._\n\ntest("test") {\n  assertTrue(true)\n} @@ jvmOnly @@ repeat(Schedule.recurs(5))\n'})}),"\n",(0,r.jsxs)(t.p,{children:["When composing test aspects, ",(0,r.jsx)(t.strong,{children:"the order of test aspects is important"}),". So if we change the order, their behavior may change. For example, the following test will repeat the test 2 times:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-scala",children:'import zio._\nimport zio.test.{test, _}\nimport zio.test.TestAspect._\n\nsuite("suite")(\n  test("A") {\n    ZIO.debug("executing test")\n      .map(_ => assertTrue(true))\n  },\n) @@ nonFlaky @@ repeats(2)\n'})}),"\n",(0,r.jsx)(t.p,{children:"The output:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"executing test\nexecuting test\nexecuting test\n+ suite - repeated: 2\n  + A - repeated: 2\nRan 1 test in 343 ms: 1 succeeded, 0 ignored, 0 failed\n"})}),"\n",(0,r.jsx)(t.p,{children:"But the following test aspect repeats the test 100 times:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-scala",children:'import zio._\nimport zio.test.{test, _}\nimport zio.test.TestAspect._\n\nsuite("suite")(\n  test("A") {\n    ZIO.debug("executing test")\n      .map(_ => assertTrue(true))\n  },\n) @@ repeats(2) @@ nonFlaky\n'})}),"\n",(0,r.jsx)(t.p,{children:"The output:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"executing test\nexecuting test\nexecuting test\nexecuting test\nexecuting test\n...\nexecuting test\n+ suite - repeated: 100\n  + A - repeated: 100\nRan 1 test in 478 ms: 1 succeeded, 0 ignored, 0 failed\n"})}),"\n",(0,r.jsx)(t.h2,{id:"examples",children:"Examples"}),"\n",(0,r.jsx)(t.p,{children:"So let's say we have a challenge that we need to run a test, and we want to make sure there is no flaky on the JVM, and then we want to make sure it doesn't take more than 60 seconds:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-scala",children:'import zio._\nimport zio.test.{test, _}\nimport zio.test.TestAspect._\n\ntest("a test with two aspects composed together") {\n  ???\n} @@ jvm(nonFlaky) @@ timeout(60.seconds)\n'})}),"\n",(0,r.jsx)(t.p,{children:"This is another example of a test suite showing the use of aspects to modify test behavior:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-scala",children:'import zio.test._\nimport zio.{test => _, _}\nimport zio.test.TestAspect._\n\nobject MySpec extends ZIOSpecDefault {\n  def spec = suite("A Suite")(\n    test("A passing test") {\n      assertTrue(true)\n    },\n    test("A passing test run for JVM only") {\n      assertTrue(true)\n    } @@ jvmOnly, // @@ jvmOnly only runs tests on the JVM\n    test("A passing test run for JS only") {\n      assertTrue(true)\n    } @@ jsOnly, // @@ jsOnly only runs tests on Scala.js\n    test("A passing test with a timeout") {\n      assertTrue(true)\n    } @@ timeout(10.nanos), // @@ timeout will fail a test that doesn\'t pass within the specified time\n    test("A failing test... that passes") {\n      assertTrue(true)\n    } @@ failing, //@@ failing turns a failing test into a passing test\n    test("A ignored test") {\n      assertTrue(false)\n    } @@ ignore, //@@ ignore marks test as ignored\n    test("A test using a live service instead of the test service") {\n      for {\n        _ <- TestClock.timeZone\n      } yield assertCompletes\n    } @@ withLiveClock, //@@ withLiveClock uses the live Clock service from the ZIO runtime in the test\n    test("A flaky test that only works on the JVM and sometimes fails; let\'s compose some aspects!") {\n      assertTrue(false)\n    } @@ jvmOnly           // only run on the JVM\n      @@ eventually        // @@ eventually retries a test indefinitely until it succeeds\n      @@ timeout(20.nanos) // it\'s a good idea to compose `eventually` with `timeout`, or the test may never end\n  ) @@ timeout(60.seconds) // apply a timeout to the whole suite\n}\n'})})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}},28453:(e,t,s)=>{s.d(t,{R:()=>i,x:()=>o});var n=s(96540);const r={},a=n.createContext(r);function i(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);