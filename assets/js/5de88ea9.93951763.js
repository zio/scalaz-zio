"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[80688],{74949:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"reference/error-management/recovering/catching","title":"Catching","description":"Catching Failures","source":"@site/docs/reference/error-management/recovering/catching.md","sourceDirName":"reference/error-management/recovering","slug":"/reference/error-management/recovering/catching","permalink":"/reference/error-management/recovering/catching","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/error-management/recovering/catching.md","tags":[],"version":"current","frontMatter":{"id":"catching","title":"Catching","sidebar_label":"1. Catching"},"sidebar":"reference-sidebar","previous":{"title":"Sequential and Parallel Errors","permalink":"/reference/error-management/sequential-and-parallel-errors"},"next":{"title":"2. Fallback","permalink":"/reference/error-management/recovering/fallback"}}');var c=a(74848),r=a(28453);const i={id:"catching",title:"Catching",sidebar_label:"1. Catching"},l=void 0,s={},o=[{value:"Catching Failures",id:"catching-failures",level:2},{value:"Catching Defects",id:"catching-defects",level:2},{value:"Catching Causes",id:"catching-causes",level:2},{value:"Catching Traces",id:"catching-traces",level:2},{value:"Catching Non-Fatal",id:"catching-non-fatal",level:2}];function h(e){const n={a:"a",code:"code",em:"em",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(n.h2,{id:"catching-failures",children:"Catching Failures"}),"\n",(0,c.jsxs)(n.p,{children:["If we want to catch and recover from all ",(0,c.jsx)(n.em,{children:"typed error"})," and effectfully attempt recovery, we can use the ",(0,c.jsx)(n.code,{children:"ZIO#catchAll"})," operator:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:"trait ZIO[-R, +E, +A] {\n  def catchAll[R1 <: R, E2, A1 >: A](h: E => ZIO[R1, E2, A1]): ZIO[R1, E2, A1]\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"We can recover from all errors while reading a file and then fallback to another operation:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nval z: ZIO[Any, IOException, Array[Byte]] =\n  readFile("primary.json").catchAll(_ =>\n    readFile("backup.json"))\n'})}),"\n",(0,c.jsxs)(n.p,{children:["In the callback passed to ",(0,c.jsx)(n.code,{children:"ZIO#catchAll"}),", we may return an effect with a different error type (or perhaps ",(0,c.jsx)(n.code,{children:"Nothing"}),"), which will be reflected in the type of effect returned by ",(0,c.jsx)(n.code,{children:"ZIO#catchAll"}),"."]}),"\n",(0,c.jsxs)(n.p,{children:["When using ",(0,c.jsx)(n.code,{children:"ZIO#catchAll"})," operator, the match cases should be exhaustive. Remember our ",(0,c.jsx)(n.code,{children:"validate"})," function again:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nsealed trait AgeValidationException extends Exception\ncase class NegativeAgeException(age: Int) extends AgeValidationException\ncase class IllegalAgeException(age: Int)  extends AgeValidationException\n\ndef validate(age: Int): ZIO[Any, AgeValidationException, Int] =\n  if (age < 0)\n    ZIO.fail(NegativeAgeException(age))\n  else if (age < 18)\n    ZIO.fail(IllegalAgeException(age))\n  else ZIO.succeed(age)\n"})}),"\n",(0,c.jsxs)(n.p,{children:["In the following example, we covered all the cases for the ",(0,c.jsx)(n.code,{children:"catchAll"})," operator:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nval result: ZIO[Any, Nothing, Int] =\n  validate(20)\n  .catchAll {\n    case NegativeAgeException(age) =>\n      ZIO.debug(s"negative age: $age").as(-1)\n    case IllegalAgeException(age) =>\n      ZIO.debug(s"illegal age: $age").as(-1)\n  }\n'})}),"\n",(0,c.jsxs)(n.p,{children:["If we forget to catch all cases and the match fails, the original ",(0,c.jsx)(n.strong,{children:"failure"})," will be lost and replaced by a ",(0,c.jsx)(n.code,{children:"MatchError"})," ",(0,c.jsx)(n.strong,{children:"defect"}),":"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:'object MainApp extends ZIOAppDefault {\n  val result: ZIO[Any, Nothing, Int] =\n    validate(15)\n      .catchAll {\n        case NegativeAgeException(age) =>\n          ZIO.debug(s"negative age: $age").as(-1)\n//        case IllegalAgeException(age) =>\n//          ZIO.debug(s"illegal age: $age").as(-1)\n      }\n\n  def run = result\n}\n'})}),"\n",(0,c.jsxs)(n.p,{children:["Another important note about ",(0,c.jsx)(n.code,{children:"ZIO#catchAll"})," is that this operator only can recover from ",(0,c.jsx)(n.em,{children:"failures"}),". So it can't recover from defects or fiber interruptions."]}),"\n",(0,c.jsxs)(n.p,{children:["Let's try what happens if we ",(0,c.jsx)(n.code,{children:"catchAll"})," on a dying effect:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  val die: ZIO[Any, String, Nothing] =\n    ZIO.dieMessage("Boom!") *> ZIO.fail("Oh uh!")\n\n  def run = die.catchAll(_ => ZIO.unit)\n}\n\n// Output:\n// timestamp=2022-03-03T11:04:41.209169849Z level=ERROR thread=#zio-fiber-0 message="Exception in thread "zio-fiber-2" java.lang.RuntimeException: Boom!\n// \tat <empty>.MainApp.die(MainApp.scala:6)\n//\tat <empty>.MainApp.run(MainApp.scala:8)"\n'})}),"\n",(0,c.jsx)(n.p,{children:"Also, if we have a fiber interruption, we can't catch that using this operator:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  val interruptedEffect: ZIO[Any, String, Nothing] =\n    ZIO.interrupt *> ZIO.fail("Oh uh!")\n\n  def run = interruptedEffect.catchAll(_ => ZIO.unit)\n}\n\n// Output:\n// timestamp=2022-03-03T11:10:15.573588420Z level=ERROR thread=#zio-fiber-0 message="Exception in thread "zio-fiber-2" java.lang.InterruptedException: Interrupted by thread "zio-fiber-"\n//\tat <empty>.MainApp.die(MainApp.scala:6)\n//\tat <empty>.MainApp.run(MainApp.scala:8)"\n'})}),"\n",(0,c.jsxs)(n.p,{children:["If we want to catch and recover from only some types of exceptions and effectfully attempt recovery, we can use the ",(0,c.jsx)(n.code,{children:"ZIO#catchSome"})," method:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:"trait ZIO[-R, +E, +A] {\n  def catchSome[R1 <: R, E1 >: E, A1 >: A](pf: PartialFunction[E, ZIO[R1, E1, A1]]): ZIO[R1, E1, A1]\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["In the following example, we are only catching failure of type ",(0,c.jsx)(n.code,{children:"FileNotFoundException"}),":"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nval data: ZIO[Any, IOException, Array[Byte]] =\n  readFile("primary.data").catchSome {\n    case _ : FileNotFoundException =>\n      readFile("backup.data")\n  }\n'})}),"\n",(0,c.jsx)(n.h2,{id:"catching-defects",children:"Catching Defects"}),"\n",(0,c.jsxs)(n.p,{children:["Like catching failures, ZIO has two operators to catch ",(0,c.jsx)(n.em,{children:"defects"}),":"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:"trait ZIO[-R, +E, +A] {\n  def catchAllDefect[R1 <: R, E1 >: E, A1 >: A](h: Throwable => ZIO[R1, E1, A1]): ZIO[R1, E1, A1]\n\n  def catchSomeDefect[R1 <: R, E1 >: E, A1 >: A](pf: PartialFunction[Throwable, ZIO[R1, E1, A1]]): ZIO[R1, E1, A1]\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["Let's try the ",(0,c.jsx)(n.code,{children:"ZIO#catchAllDefect"})," operator:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nZIO.dieMessage("Boom!")\n  .catchAllDefect {\n    case e: RuntimeException if e.getMessage == "Boom!" =>\n      ZIO.debug("Boom! defect caught.")\n    case _: NumberFormatException =>\n      ZIO.debug("NumberFormatException defect caught.")\n    case _ =>\n      ZIO.debug("Unknown defect caught.")\n  }\n'})}),"\n",(0,c.jsx)(n.p,{children:"We should note that using these operators, we can only recover from a dying effect, and it cannot recover from a failure or fiber interruption."}),"\n",(0,c.jsx)(n.p,{children:"A defect is an error that cannot be anticipated in advance, and there is no way to respond to it. Our rule of thumb is to not recover defects since we don't know about them. We let them crash the application. Although, in some cases, we might need to reload a part of the application instead of killing the entire application."}),"\n",(0,c.jsx)(n.p,{children:"Assume we have written an application that can load plugins at runtime. During the runtime of the plugins, if a defect occurs, we don't want to crash the entire application; rather, we log all defects and then reload the plugin."}),"\n",(0,c.jsx)(n.h2,{id:"catching-causes",children:"Catching Causes"}),"\n",(0,c.jsxs)(n.p,{children:["So far, we have only studied how to catch ",(0,c.jsx)(n.em,{children:"failures"})," and ",(0,c.jsx)(n.em,{children:"defects"}),". But what about ",(0,c.jsx)(n.em,{children:"fiber interruptions"})," or how about the specific combination of these errors?"]}),"\n",(0,c.jsx)(n.p,{children:"There are two ZIO operators useful for catching causes:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:"trait ZIO[-R, +E, +A] {\n  def catchAllCause[R1 <: R, E2, A1 >: A](h: Cause[E] => ZIO[R1, E2, A1]): ZIO[R1, E2, A1]\n\n  def catchSomeCause[R1 <: R, E1 >: E, A1 >: A](pf: PartialFunction[Cause[E], ZIO[R1, E1, A1]]): ZIO[R1, E1, A1]\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["With the help of the ",(0,c.jsx)(n.code,{children:"ZIO#catchAllCause"})," operator we can catch all errors of an effect and recover from them:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nval exceptionalEffect = ZIO.attempt(???)\n\nexceptionalEffect.catchAllCause {\n  case Cause.Empty =>\n    ZIO.debug("no error caught")\n  case Cause.Fail(value, _) =>\n    ZIO.debug(s"a failure caught: $value")\n  case Cause.Die(value, _) =>\n    ZIO.debug(s"a defect caught: $value")\n  case Cause.Interrupt(fiberId, _) =>\n    ZIO.debug(s"a fiber interruption caught with the fiber id: $fiberId")\n  case Cause.Stackless(cause: Cause.Die, _) =>\n    ZIO.debug(s"a stackless defect caught: ${cause.value}")\n  case Cause.Stackless(cause: Cause[_], _) =>\n    ZIO.debug(s"an unknown stackless defect caught: ${cause.squashWith(identity)}")\n  case Cause.Then(left, right) =>\n    ZIO.debug(s"two consequence causes caught")\n  case Cause.Both(left, right) =>\n    ZIO.debug(s"two parallel causes caught")\n}\n'})}),"\n",(0,c.jsxs)(n.p,{children:["Additionally, there is a partial version of this operator called ",(0,c.jsx)(n.code,{children:"ZIO#catchSomeCause"}),", which can be used when we don't want to catch all causes, but some of them."]}),"\n",(0,c.jsx)(n.h2,{id:"catching-traces",children:"Catching Traces"}),"\n",(0,c.jsxs)(n.p,{children:["The two ",(0,c.jsx)(n.code,{children:"ZIO#catchAllTrace"})," and ",(0,c.jsx)(n.code,{children:"ZIO#catchSomeTrace"})," operators are useful to catch the typed error as well as stack traces of exceptional effects:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:"trait ZIO[-R, +E, +A] {\n  def catchAllTrace[R1 <: R, E2, A1 >: A](\n    h: ((E, Trace)) => ZIO[R1, E2, A1]\n  ): ZIO[R1, E2, A1]\n\n  def catchSomeTrace[R1 <: R, E1 >: E, A1 >: A](\n    pf: PartialFunction[(E, Trace), ZIO[R1, E1, A1]]\n  ): ZIO[R1, E1, A1]\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"In the below example, let's try to catch a failure on the line number 4:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nZIO\n  .fail("Oh uh!")\n  .catchAllTrace {\n    case ("Oh uh!", trace)\n      if trace.toJava\n        .map(_.getLineNumber)\n        .headOption\n        .contains(4) =>\n      ZIO.debug("caught a failure on the line number 4")\n    case _ =>\n      ZIO.debug("caught other failures")\n  }\n'})}),"\n",(0,c.jsx)(n.h2,{id:"catching-non-fatal",children:"Catching Non-Fatal"}),"\n",(0,c.jsxs)(n.p,{children:["We can use the ",(0,c.jsx)(n.code,{children:"ZIO#catchNonFatalOrDie"})," to recover from all non-fatal errors:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:"trait ZIO[-R, +E, +A] {\n  def catchNonFatalOrDie[R1 <: R, E2, A1 >: A](\n    h: E => ZIO[R1, E2, A1]\n  )(implicit ev1: CanFail[E], ev2: E <:< Throwable): ZIO[R1, E2, A1]\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["In case of occurring any ",(0,c.jsx)(n.a,{href:"#catching-traces",children:"fatal error"}),", it will die."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:'openFile("data.json").catchNonFatalOrDie(_ => openFile("backup.json"))\n'})})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(h,{...e})}):h(e)}},28453:(e,n,a)=>{a.d(n,{R:()=>i,x:()=>l});var t=a(96540);const c={},r=t.createContext(c);function i(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:i(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);