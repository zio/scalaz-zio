"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[17127],{28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var r=t(96540);const i={},s=r.createContext(i);function a(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:n},e.children)}},48381:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>f,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"reference/error-management/operations/filtering-the-success-channel","title":"Filtering the Success Channel","description":"ZIO has a variety of operators that can filter values on the success channel based on a given predicate, and if the predicate fails, we can use different strategies:","source":"@site/docs/reference/error-management/operations/filtering-the-success-channel.md","sourceDirName":"reference/error-management/operations","slug":"/reference/error-management/operations/filtering-the-success-channel","permalink":"/reference/error-management/operations/filtering-the-success-channel","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/error-management/operations/filtering-the-success-channel.md","tags":[],"version":"current","frontMatter":{"id":"filtering-the-success-channel","title":"Filtering the Success Channel"},"sidebar":"reference-sidebar","previous":{"title":"Chaining Effects Based on Errors","permalink":"/reference/error-management/operations/chaining-effects-based-on-errors"},"next":{"title":"Tapping Errors","permalink":"/reference/error-management/operations/tapping-errors"}}');var i=t(74848),s=t(28453);const a={id:"filtering-the-success-channel",title:"Filtering the Success Channel"},o=void 0,c={},l=[];function d(e){const n={code:"code",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"ZIO has a variety of operators that can filter values on the success channel based on a given predicate, and if the predicate fails, we can use different strategies:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Failing the original effect (",(0,i.jsx)(n.code,{children:"ZIO#filterOrFail"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:["Dying the original effect (",(0,i.jsx)(n.code,{children:"ZIO#filterOrDie"})," and ",(0,i.jsx)(n.code,{children:"ZIO#filterOrDieMessage"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:["Running an alternative ZIO effect (",(0,i.jsx)(n.code,{children:"ZIO#filterOrElse"})," and ",(0,i.jsx)(n.code,{children:"ZIO#filterOrElseWith"}),")"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'import zio._\n\ndef getNumber: ZIO[Any, Nothing, Int] =\n  (Console.print("Please enter a non-negative number: ") *>\n    Console.readLine.mapAttempt(_.toInt))\n    .retryUntil(!_.isInstanceOf[NumberFormatException]).orDie\n\nval r1: ZIO[Any, String, Int] =\n  Random.nextInt.filterOrFail(_ >= 0)("random number is negative")\n\nval r2: ZIO[Any, Nothing, Int] =\n  Random.nextInt.filterOrDie(_ >= 0)(\n    new IllegalArgumentException("random number is negative")\n  )\n\nval r3: ZIO[Any, Nothing, Int] =\n  Random.nextInt.filterOrDieMessage(_ >= 0)("random number is negative")\n\nval r4: ZIO[Any, Nothing, Int] =\n  Random.nextInt.filterOrElse(_ >= 0)(getNumber)\n\nval r5: ZIO[Any, Nothing, Int] =\n  Random.nextInt.filterOrElseWith(_ >= 0)(x => ZIO.succeed(-x))\n'})})]})}function f(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);