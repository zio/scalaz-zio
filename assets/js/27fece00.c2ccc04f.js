"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[29585],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>s});var i=t(96540);const r={},a=i.createContext(r);function o(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(a.Provider,{value:n},e.children)}},93450:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"reference/service-pattern/defining-polymorphic-services-in-zio","title":"Defining Polymorphic Services in ZIO","description":"As we discussed here, the ZEnvironment, which is the underlying data type used by ZLayer, is backed by a type-level mapping from types of services to implementations of those services. This functionality is backed by izumi.reflect.Tag, which captures a type as a value.","source":"@site/docs/reference/service-pattern/defining-polymorphic-services-in-zio.md","sourceDirName":"reference/service-pattern","slug":"/reference/service-pattern/defining-polymorphic-services-in-zio","permalink":"/reference/service-pattern/defining-polymorphic-services-in-zio","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/service-pattern/defining-polymorphic-services-in-zio.md","tags":[],"version":"current","frontMatter":{"id":"defining-polymorphic-services-in-zio","title":"Defining Polymorphic Services in ZIO","sidebar_label":"Polymorphic Services"},"sidebar":"reference-sidebar","previous":{"title":"Service Pattern","permalink":"/reference/service-pattern/"},"next":{"title":"Three Laws of ZIO Environment","permalink":"/reference/service-pattern/the-three-laws-of-zio-environment"}}');var r=t(74848),a=t(28453);const o={id:"defining-polymorphic-services-in-zio",title:"Defining Polymorphic Services in ZIO",sidebar_label:"Polymorphic Services"},s=void 0,c={},l=[];function d(e){const n={a:"a",code:"code",em:"em",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["As we discussed ",(0,r.jsx)(n.a,{href:"/reference/contextual/zenvironment",children:"here"}),", the ",(0,r.jsx)(n.code,{children:"ZEnvironment"}),", which is the underlying data type used by ",(0,r.jsx)(n.code,{children:"ZLayer"}),", is backed by a type-level mapping from types of services to implementations of those services. This functionality is backed by ",(0,r.jsx)(n.code,{children:"izumi.reflect.Tag"}),", which captures a type as a value."]}),"\n",(0,r.jsxs)(n.p,{children:["We just need to know what is the type of service when we put it in the ",(0,r.jsx)(n.code,{children:"ZEnvironment"})," because ",(0,r.jsx)(n.code,{children:"ZEnvironment"})," is essentially a map from ",(0,r.jsx)(n.em,{children:"service types (interfaces)"})," to ",(0,r.jsx)(n.em,{children:"implementation of those interfaces"}),". To implement the map, the ",(0,r.jsx)(n.code,{children:"ZEnvironment"})," needs a type tag for the new service, and also needs a way to remove the old service from the type level map. So we should have service type information at the runtime."]}),"\n",(0,r.jsxs)(n.p,{children:["We can think of ",(0,r.jsx)(n.code,{children:"Tag[A]"})," as like a ",(0,r.jsx)(n.code,{children:"TypeTag[A]"})," or ",(0,r.jsx)(n.code,{children:"ClassTag[A]"})," from the Scala standard library but available on a cross-version and cross-platform basis. Basically, it carries information about a certain type into runtime that was available at compile time. Methods that construct ",(0,r.jsx)(n.code,{children:"ZEnvironment"})," values generally require a tag for the value being included in the \u201cbundle of services\u201d."]}),"\n",(0,r.jsxs)(n.p,{children:["As a user, we should not normally interact with ",(0,r.jsx)(n.code,{children:"Tag"})," except where we define polymorphic services. In general, a ",(0,r.jsx)(n.code,{children:"Tag"})," should always be available whenever we have a concrete type. The only time we should have to use it is when we have a ",(0,r.jsx)(n.em,{children:"polymorphic service"}),". If we are using polymorphic code, we need to provide implicit evidence that a tag exists for that type (",(0,r.jsx)(n.code,{children:"implicit tag: Tag[A]"}),") or as a context-bound for that type parameter: (",(0,r.jsx)(n.code,{children:"A: Tag"}),")."]}),"\n",(0,r.jsx)(n.p,{children:"Let's try to write a polymorphic service. Assume we have the following service interface:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"trait KeyValueStore[K, V, E, F[_, _]] {\n  def get(key: K): F[E, V]\n\n  def set(key: K, value: V): F[E, V]\n\n  def remove(key: K): F[E, Unit]\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In the next step, we are going to write its accessors (note: ",(0,r.jsx)(n.a,{href:"/reference/service-pattern/accessor-methods",children:"accessor methods"})," are deprecated). We might end up with the following snippet code:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nobject KeyValueStore {\n  def get[K, V, E](key: K): ZIO[KeyValueStore[K, V, E, IO], E, V] =\n    ZIO.serviceWithZIO[KeyValueStore[K, V, E, IO]](_.get(key))\n\n  def set[K, V, E](key: K, value: V): ZIO[KeyValueStore[K, V, E, IO], E, V] =\n    ZIO.serviceWithZIO[KeyValueStore[K, V, E, IO]](_.set(key, value))\n\n  def remove[K, V, E](key: K): ZIO[KeyValueStore[K, V, E, IO], E, Unit] =\n    ZIO.serviceWithZIO(_.remove(key))\n}\n\n// error: could not find implicit value for izumi.reflect.Tag[K]. Did you forget to put on a Tag, TagK or TagKK context bound on one of the parameters in K? e.g. def x[T: Tag, F[_]: TagK] = ...\n// \n// \n// <trace>: \n//   deriving Tag for K, dealiased: K:\n//   could not find implicit value for Tag[K]: K is a type parameter without an implicit Tag!\n//     ZIO.serviceWithZIO[KeyValueStore[K, V, E, IO]](_.get(key))\n//                                                   ^\n// error: could not find implicit value for izumi.reflect.Tag[K]. Did you forget to put on a Tag, TagK or TagKK context bound on one of the parameters in K? e.g. def x[T: Tag, F[_]: TagK] = ...\n// \n// \n// <trace>: \n//   deriving Tag for K, dealiased: K:\n//   could not find implicit value for Tag[K]: K is a type parameter without an implicit Tag!\n//     ZIO.serviceWithZIO[KeyValueStore[K, V, E, IO]](_.set(key, value))\n//                                                   ^\n// error: could not find implicit value for izumi.reflect.Tag[K]. Did you forget to put on a Tag, TagK or TagKK context bound on one of the parameters in K? e.g. def x[T: Tag, F[_]: TagK] = ...\n// \n// \n// <trace>: \n//   deriving Tag for K, dealiased: K:\n//   could not find implicit value for Tag[K]: K is a type parameter without an implicit Tag!\n//     ZIO.serviceWithZIO(_.remove(key))\n//                       ^\n"})}),"\n",(0,r.jsx)(n.p,{children:"The compiler generates the following errors:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"could not find implicit value for izumi.reflect.Tag[K]. Did you forget to put on a Tag, TagK or TagKK context bound on one of the parameters in K? e.g. def x[T: Tag, F[_]: TagK] = ...\n\n\n<trace>: \n  deriving Tag for K, dealiased: K:\n  could not find implicit value for Tag[K]: K is a type parameter without an implicit Tag!\n    ZIO.serviceWithZIO[KeyValueStore[K, V, E, IO]](_.get(key))\n"})}),"\n",(0,r.jsxs)(n.p,{children:["As the compiler says, we should put ",(0,r.jsx)(n.code,{children:"Tag"})," as a context-bound for ",(0,r.jsx)(n.code,{children:"K"}),", ",(0,r.jsx)(n.code,{children:"V"}),", and ",(0,r.jsx)(n.code,{children:"E"})," type parameters:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nobject KeyValueStore {\n  def get[K: Tag, V: Tag, E: Tag](key: K): ZIO[KeyValueStore[K, V, E, IO], E, V] =\n    ZIO.serviceWithZIO[KeyValueStore[K, V, E, IO]](_.get(key))\n\n  def set[K: Tag, V: Tag, E: Tag](key: K, value: V): ZIO[KeyValueStore[K, V, E, IO], E, V] =\n    ZIO.serviceWithZIO[KeyValueStore[K, V, E, IO]](_.set(key, value))\n\n  def remove[K: Tag, V: Tag, E: Tag](key: K): ZIO[KeyValueStore[K, V, E, IO], E, Unit] =\n    ZIO.serviceWithZIO(_.remove(key))\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Now, we can continue and implement the in-memory version of this key-value store:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'case class InmemoryKeyValueStore(map: Ref[Map[String, Int]])\n  extends KeyValueStore[String, Int, String, IO] {\n\n  override def get(key: String): IO[String, Int] =\n    map.get.map(_.get(key)).someOrFail(s"$key not found")\n\n  override def set(key: String, value: Int): IO[String, Int] =\n    map.update(_.updated(key, value)).map(_ => value)\n\n  override def remove(key: String): IO[String, Unit] =\n    map.update(_.removed(key))\n}\n\nobject InmemoryKeyValueStore {\n  def layer: ULayer[KeyValueStore[String, Int, String, IO]] =\n    ZLayer {\n      Ref.make(Map[String, Int]()).map(InmemoryKeyValueStore.apply)\n    }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"The last step is to use the service in a ZIO application:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  val myApp: ZIO[KeyValueStore[String, Int, String, IO], String, Unit] =\n    for {\n      _ <- KeyValueStore.set[String, Int, String]("key1", 3).debug\n      _ <- KeyValueStore.get[String, Int, String]("key1").debug\n      _ <- KeyValueStore.remove[String, Int, String]("key1")\n      _ <- KeyValueStore.get[String, Int, String]("key1").either.debug\n    } yield ()\n\n  def run = myApp.provide(InmemoryKeyValueStore.layer)\n  \n}\n\n// Output:\n// 3\n// 3\n// not found\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Note that in the above example, one might want to write accessors more polymorphic. So in this case we should add ",(0,r.jsx)(n.code,{children:"TagKK"})," as a context-bound of the ",(0,r.jsx)(n.code,{children:"F"})," type parameter:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"object KeyValueStore {\n  def get[K: Tag, V: Tag, E: Tag, F[_, _] : TagKK](key: K): ZIO[KeyValueStore[K, V, E, F], Nothing, F[E, V]] =\n    ZIO.serviceWith[KeyValueStore[K, V, E, F]](_.get(key))\n\n  def set[K: Tag, V: Tag, E: Tag, F[_, _] : TagKK](key: K, value: V): ZIO[KeyValueStore[K, V, E, F], Nothing, F[E, V]] =\n    ZIO.serviceWith[KeyValueStore[K, V, E, F]](_.set(key, value))\n\n  def remove[K: Tag, V: Tag, E: Tag, F[_, _] : TagKK](key: K): ZIO[KeyValueStore[K, V, E, F], E, Unit] =\n    ZIO.serviceWith(_.remove(key))\n}\n"})})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);