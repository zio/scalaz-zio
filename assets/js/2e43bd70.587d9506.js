"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[97316],{28453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>s});var a=t(96540);const o={},i=a.createContext(o);function c(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:c(e.components),a.createElement(i.Provider,{value:n},e.children)}},93613:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>s,default:()=>h,frontMatter:()=>c,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"zio-prelude/functional-abstractions/parameterized-types/foreach","title":"ForEach","description":"ForEach[F] describes a parameterized type F[A] that contains zero or more values of type A.","source":"@site/docs/zio-prelude/functional-abstractions/parameterized-types/foreach.md","sourceDirName":"zio-prelude/functional-abstractions/parameterized-types","slug":"/zio-prelude/functional-abstractions/parameterized-types/foreach","permalink":"/zio-prelude/functional-abstractions/parameterized-types/foreach","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-prelude/functional-abstractions/parameterized-types/foreach.md","tags":[],"version":"current","frontMatter":{"id":"foreach","title":"ForEach"},"sidebar":"ecosystem-sidebar","previous":{"title":"Covariant","permalink":"/zio-prelude/functional-abstractions/parameterized-types/covariant"},"next":{"title":"IdentityBoth","permalink":"/zio-prelude/functional-abstractions/parameterized-types/identityboth"}}');var o=t(74848),i=t(28453);const c={id:"foreach",title:"ForEach"},s=void 0,r={},d=[];function l(e){const n={code:"code",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"ForEach[F]"})," describes a parameterized type ",(0,o.jsx)(n.code,{children:"F[A]"})," that contains zero or more values of type ",(0,o.jsx)(n.code,{children:"A"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"Its signature is:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"trait Covariant[F[+_]] {\n  def map[A, B](f: A => B): F[A] => F[B]\n}\n\ntrait ForEach[F[+_]] extends Covariant[F] {\n  def forEach[G[+_]: IdentityBoth: Covariant, A, B](fa: F[A])(f: A => G[B]): G[F[B]]\n  final def map[A, B](f: A => B): F[A] => F[B] =\n    ???\n}\n\ntrait IdentityBoth[F[_]] {\n  def any: F[Any]\n  def both[A, B](fa: => F[A], b: => F[B]): F[(A, B)]\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"ForEach"})," functional abstraction builds on the ",(0,o.jsx)(n.code,{children:"Covariant"})," abstraction to describe a type that contains zero or more ",(0,o.jsx)(n.code,{children:"A"})," values rather than merely potentially producing ",(0,o.jsx)(n.code,{children:"A"})," values at some point in the future."]}),"\n",(0,o.jsxs)(n.p,{children:["For example ",(0,o.jsx)(n.code,{children:"Chunk"})," has a ",(0,o.jsx)(n.code,{children:"ForEach"})," instance because it contains zero or more ",(0,o.jsx)(n.code,{children:"A"})," values. In contrast ",(0,o.jsx)(n.code,{children:"ZIO"})," has a ",(0,o.jsx)(n.code,{children:"Covariant"})," instance but not a ",(0,o.jsx)(n.code,{children:"ForEach"})," instance because it is only a description of a workflow that may produce an ",(0,o.jsx)(n.code,{children:"A"})," value and does not output any actual ",(0,o.jsx)(n.code,{children:"A"})," value until it is run."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"ForEach"})," generalizes over collection types like ",(0,o.jsx)(n.code,{children:"List"}),", ",(0,o.jsx)(n.code,{children:"Map"}),", and ",(0,o.jsx)(n.code,{children:"Chunk"}),". It also describes data types like ",(0,o.jsx)(n.code,{children:"Option"})," and ",(0,o.jsx)(n.code,{children:"Either"})," that contain zero or one value, which can be thought of as a special case of containing zero or more values."]}),"\n",(0,o.jsxs)(n.p,{children:["The defining operator of the ",(0,o.jsx)(n.code,{children:"ForEach"})," abstraction is ",(0,o.jsx)(n.code,{children:"forEach"}),". It lets us take a collection of type ",(0,o.jsx)(n.code,{children:"F[A]"})," and run a function ",(0,o.jsx)(n.code,{children:"A => G[B]"})," for each element in the collection, returning a new collection ",(0,o.jsx)(n.code,{children:"F[B]"})," in the context of ",(0,o.jsx)(n.code,{children:"G"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["This is somewhat abstract so let's look at the ",(0,o.jsx)(n.code,{children:"foreach"})," operator on ",(0,o.jsx)(n.code,{children:"ZIO"}),", which is a variant of this, to get a sense of what it means."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"trait ZIO[-R, +E, +A]\n\nobject ZIO {\n  def foreach[R, E, A, B](as: List[A])(f: A => ZIO[R, E, B]): ZIO[R, E, List[B]] =\n    ???\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Here we have specialized the collection type ",(0,o.jsx)(n.code,{children:"F"})," from ",(0,o.jsx)(n.code,{children:"ForEach"})," to ",(0,o.jsx)(n.code,{children:"List"})," and the effect type ",(0,o.jsx)(n.code,{children:"G"})," from ",(0,o.jsx)(n.code,{children:"ForEach"})," to ",(0,o.jsx)(n.code,{children:"ZIO"}),". The interpretation of this is now much more clear."]}),"\n",(0,o.jsxs)(n.p,{children:["For each element in the list we construct a new ",(0,o.jsx)(n.code,{children:"ZIO[R, E, B]"})," by applying ",(0,o.jsx)(n.code,{children:"f"})," to the element. Then we combine all of those ",(0,o.jsx)(n.code,{children:"ZIO"})," effects into a single effect that will run each of the individual effects and collect their results in a ",(0,o.jsx)(n.code,{children:"List"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["This pattern of doing something for each element in the collection and then collecting the results back into the original collection is common to all implementations of ",(0,o.jsx)(n.code,{children:"ForEach"}),". We can get a better sense for it by looking at a simple implementation of the ",(0,o.jsx)(n.code,{children:"foreach"})," operator on ",(0,o.jsx)(n.code,{children:"ZIO"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"trait ZIO[-R, +E, +A] { self =>\n  def zipWith[R1 <: R, E1 >: E, B, C](that: ZIO[R1, E1, B])(f: (A, B) => C): ZIO[R, E, C] =\n    ???\n}\n\nobject ZIO {\n  def foreach[R, E, A, B](as: List[A])(f: A => ZIO[R, E, B]): ZIO[R, E, List[B]] =\n    as.foldRight[ZIO[R, E, List[B]]](ZIO.succeed(List.empty)) { (a, zio) =>\n      f(a).zipWith(zio)(_ :: _)\n    }\n  def succeed[A](a: => A): ZIO[Any, Nothing, A] =\n    ???\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In the implementation of ",(0,o.jsx)(n.code,{children:"foreach"})," the ",(0,o.jsx)(n.code,{children:"foldRight"})," operator on ",(0,o.jsx)(n.code,{children:"List"})," tears down the original list into each of its elements, using the function ",(0,o.jsx)(n.code,{children:"f"})," to produce a new ",(0,o.jsx)(n.code,{children:"ZIO"})," value for each element. Then we use the ",(0,o.jsx)(n.code,{children:"zipWith"})," operator on ",(0,o.jsx)(n.code,{children:"ZIO"})," to combine the resulting ",(0,o.jsx)(n.code,{children:"ZIO"})," values into a single ",(0,o.jsx)(n.code,{children:"ZIO"})," value, putting the values back together into a ",(0,o.jsx)(n.code,{children:"List"})," with the ",(0,o.jsx)(n.code,{children:"::"})," constructor."]}),"\n",(0,o.jsxs)(n.p,{children:["The fact that the implementation of such a complex operator can be so simple should have us thinking about how we can make this work for collection types other than ",(0,o.jsx)(n.code,{children:"List"})," and types other than ",(0,o.jsx)(n.code,{children:"ZIO"}),". The ",(0,o.jsx)(n.code,{children:"ForEach"})," functional abstraction does just that."]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"ForEach"})," abstraction is parameterized on the collection type ",(0,o.jsx)(n.code,{children:"F"}),", so in the implementation of ",(0,o.jsx)(n.code,{children:"ForEach"})," for a collection we will know how to tear down that collection and build it back up. For example, in the implementation of ",(0,o.jsx)(n.code,{children:"ForEach"})," for ",(0,o.jsx)(n.code,{children:"List"})," we will know that we can tear down a ",(0,o.jsx)(n.code,{children:"List"})," using ",(0,o.jsx)(n.code,{children:"foldRight"})," and build it back up using ",(0,o.jsx)(n.code,{children:"List.empty"})," and ",(0,o.jsx)(n.code,{children:"::"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["The other piece of information we need is how to put a value into the type ",(0,o.jsx)(n.code,{children:"G"}),", described by the ",(0,o.jsx)(n.code,{children:"succeed"})," operator, and how to combine two ",(0,o.jsx)(n.code,{children:"G"})," values into a single ",(0,o.jsx)(n.code,{children:"G"})," value, described by the ",(0,o.jsx)(n.code,{children:"zipWith"})," operator. Fortunately, that is exactly the functionality that the combination of the ",(0,o.jsx)(n.code,{children:"Covariant"})," and ",(0,o.jsx)(n.code,{children:"IdentityBoth"})," abstractions provide."]}),"\n",(0,o.jsxs)(n.p,{children:["Recall that the ",(0,o.jsx)(n.code,{children:"Covariant"})," functional abstraction defines a ",(0,o.jsx)(n.code,{children:"map"})," operator that allows us to transform a ",(0,o.jsx)(n.code,{children:"F[A]"})," into an ",(0,o.jsx)(n.code,{children:"F[B]"})," with a function ",(0,o.jsx)(n.code,{children:"A => B"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"trait Covariant[F[+_]] {\n  def map[A, B](f: A => B): F[A] => F[B]\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"IdentityBoth"})," abstraction defines a ",(0,o.jsx)(n.code,{children:"both"})," operator that allows us to combine an ",(0,o.jsx)(n.code,{children:"F[A]"})," and an ",(0,o.jsx)(n.code,{children:"F[B]"})," into an ",(0,o.jsx)(n.code,{children:"F[(A, B)]"})," as well as an ",(0,o.jsx)(n.code,{children:"any"})," value of type ",(0,o.jsx)(n.code,{children:"F[Any]"})," that is an identity element for that operator."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"trait AssociativeBoth[F[_]] {\n  def both[A, B](fa: => F[A], b: => F[B]): F[(A, B)]\n}\n\ntrait IdentityBoth[F[_]] extends AssociativeBoth[F] {\n  def any: F[Any]\n\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["If instances of these two abstractions exist for a data type we can define the ",(0,o.jsx)(n.code,{children:"zipWith"})," and ",(0,o.jsx)(n.code,{children:"succeed"})," operators that we used in our implementation of ",(0,o.jsx)(n.code,{children:"foreach"})," for ",(0,o.jsx)(n.code,{children:"ZIO"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"def succeed[F[+_], A](a: => A)(implicit covariant: Covariant[F], both: IdentityBoth[F]): F[A] =\n  covariant.map[Any, A](_ => a)(both.any)\n\ndef zipWith[F[+_], A, B, C](\n  fa: F[A],\n  fb: F[B]\n)(f: (A, B) => C)(implicit covariant: Covariant[F], both: AssociativeBoth[F]): F[C] =\n  covariant.map(f.tupled)(both.both(fa, fb))\n"})}),"\n",(0,o.jsxs)(n.p,{children:["We are now in a position to complete our generalization of the ",(0,o.jsx)(n.code,{children:"foreach"})," operator on ",(0,o.jsx)(n.code,{children:"ZIO"}),". Here is what the implementation of the ",(0,o.jsx)(n.code,{children:"ForEach"})," instance for ",(0,o.jsx)(n.code,{children:"List"})," would look like."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"trait ForEach[F[+_]]{\n  def forEach[G[+_]: IdentityBoth: Covariant, A, B](fa: F[A])(f: A => G[B]): G[F[B]]\n}\n\nimplicit val ListForEach: ForEach[List] =\n  new ForEach[List] {\n    def forEach[G[+_]: IdentityBoth: Covariant, A, B](fa: List[A])(f: A => G[B]): G[List[B]] =\n      fa.foldRight(succeed[G, List[B]](List.empty)) { (a, gbs) =>\n        zipWith(f(a), gbs)(_ :: _)\n      }\n  }\n// ListForEach: ForEach[List] = repl.MdocSession$MdocApp$$anon$1@3e2aa7c2\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Notice how similar our implementation of the ",(0,o.jsx)(n.code,{children:"ForEach"})," abstraction looks to our initial implementation of the ",(0,o.jsx)(n.code,{children:"foreach"})," operator on ",(0,o.jsx)(n.code,{children:"ZIO"}),". Other than using operators defined on ",(0,o.jsx)(n.code,{children:"Covariant"})," and ",(0,o.jsx)(n.code,{children:"IdentityBoth"})," instead of operators on ",(0,o.jsx)(n.code,{children:"ZIO"})," they are identical."]}),"\n",(0,o.jsxs)(n.p,{children:["We have already come a long way with our implementation of ",(0,o.jsx)(n.code,{children:"ForEach"}),". We have a much better understanding now of what the ",(0,o.jsx)(n.code,{children:"forEach"})," operator does and how its signature reflects the minimum possible set of constraints necessary to implement it."]}),"\n",(0,o.jsxs)(n.p,{children:["We can now implement instances of ",(0,o.jsx)(n.code,{children:"ForEach"})," for all collection types, like ",(0,o.jsx)(n.code,{children:"List"}),", ",(0,o.jsx)(n.code,{children:"Chunk"}),", and ",(0,o.jsx)(n.code,{children:"Map"}),", as well as types that are like collections, such as ",(0,o.jsx)(n.code,{children:"Option"})," and ",(0,o.jsx)(n.code,{children:"Either"}),". In each case we can perform an effect like a ",(0,o.jsx)(n.code,{children:"ZIO"})," for each element in the collection, returning a new ",(0,o.jsx)(n.code,{children:"ZIO"})," that collects the results back into the original collection type."]}),"\n",(0,o.jsxs)(n.p,{children:["This is already quite powerful, but the other aspect of the ",(0,o.jsx)(n.code,{children:"ForEach"})," abstraction that is important is our ability to use other parameterized types for the ",(0,o.jsx)(n.code,{children:"G"})," in the signature of ",(0,o.jsx)(n.code,{children:"ForEach"}),". We have focused so far on ",(0,o.jsx)(n.code,{children:"ZIO"})," because it is the prototypical functional effect and provides a very clear intuition of what it means to do something for each element of a collection, but we can use many other data types as well."]}),"\n",(0,o.jsxs)(n.p,{children:["For example, we can use the ",(0,o.jsx)(n.code,{children:"forEach"})," operator with a function that returns a ",(0,o.jsx)(n.code,{children:"Validation"})," value from ZIO Prelude."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"Validation"})," is a data type that can either succeed with a value or fail with one or more errors. Using ",(0,o.jsx)(n.code,{children:"forEach"})," with ",(0,o.jsx)(n.code,{children:"Validation"})," corresponds to validating all the values in a collection, returning either a new collection of fully validated data or an accumulation of all validation errors that occurred."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import zio.prelude._\n\ncase class Person(name: String, age: Int)\n\ndef validateName(name: String): Validation[String, String] =\n  Validation.fromPredicateWith("Name was empty")(name)(_.nonEmpty)\n\ndef validateAge(age: Int): Validation[String, Int] =\n  Validation.fromPredicateWith(s"Age $age was less than zero")(age)(_ >= 0)\n\ndef validatePerson(name: String, age: Int): Validation[String, Person] =\n  Validation.validateWith(validateName(name), validateAge(age))(Person)\n\nval validData: List[(String, Int)] =\n  List(("John", 35), ("Jane", 25))\n// validData: List[(String, Int)] = List(("John", 35), ("Jane", 25))\n\nval invalidData: List[(String, Int)] =\n  List(("", 35), ("John", -1))\n// invalidData: List[(String, Int)] = List(("", 35), ("John", -1))\n\nval success: Validation[String, List[Person]] =\n  validData.forEach { case (name, age) => validatePerson(name, age) }\n// success: Validation[String, List[Person]] = Success(\n//   log = IndexedSeq(),\n//   value = List(Person(name = "John", age = 35), Person(name = "Jane", age = 25))\n// )\n\nval failure: Validation[String, List[Person]] =\n  invalidData.forEach { case (name, age) => validatePerson(name, age) }\n// failure: Validation[String, List[Person]] = Failure(\n//   log = IndexedSeq(),\n//   errors = NonEmptyChunk(Name was empty, Age -1 was less than zero)\n// )\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Using ",(0,o.jsx)(n.code,{children:"forEach"})," with the valid data will return a validation success containing the fully validated list of ",(0,o.jsx)(n.code,{children:'Person("John", 35)'})," and ",(0,o.jsx)(n.code,{children:'Person("Jane", 25")'}),". In contrast, using ",(0,o.jsx)(n.code,{children:"forEach"})," with the invalid data will return a validation failure with the failures ",(0,o.jsx)(n.code,{children:'"Name was empty"'})," and ",(0,o.jsx)(n.code,{children:'"Age -1 was less than zero"'}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["We can return other data types from the function we provide to ",(0,o.jsx)(n.code,{children:"ForEach"})," to obtain other functionality. For example, if we use ",(0,o.jsx)(n.code,{children:"Option"})," or ",(0,o.jsx)(n.code,{children:"Either"})," we will get either a collection of all the successful results or the first failure to occur, rather than the accumulation of all failures as with ",(0,o.jsx)(n.code,{children:"Validation"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["There are also a couple of specialized data types we can use in the return type of ",(0,o.jsx)(n.code,{children:"f"})," that turn out to be particularly important for implementing other operators."]}),"\n",(0,o.jsxs)(n.p,{children:["One of these you may have noticed from the very beginning of this section was the ",(0,o.jsx)(n.code,{children:"Id"})," type."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"Id"})," is the parameterized type ",(0,o.jsx)(n.code,{children:"F[A]"})," where ",(0,o.jsx)(n.code,{children:"F"})," doesn't have any structure itself and just contains exactly one ",(0,o.jsx)(n.code,{children:"A"})," value. This seems quite trivial but it is useful to adapt a function ",(0,o.jsx)(n.code,{children:"A => B"})," to the type ",(0,o.jsx)(n.code,{children:"A => G[B]"})," that ",(0,o.jsx)(n.code,{children:"ForEach"})," is expecting."]}),"\n",(0,o.jsxs)(n.p,{children:["This allows us to implement the ",(0,o.jsx)(n.code,{children:"map"})," operator in terms of ",(0,o.jsx)(n.code,{children:"forEach"})," and proves that the ",(0,o.jsx)(n.code,{children:"ForEach"})," abstraction is an extension of the ",(0,o.jsx)(n.code,{children:"Covariant"})," abstraction."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"def map[F[+_]: ForEach, A, B](fa: F[A])(f: A => B): F[B] =\n  Id.unwrap(fa.forEach(a => Id.wrap(f(a))))\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Another data type that is important for implementing other operators is ",(0,o.jsx)(n.code,{children:"State"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"State"})," data type from ZIO Prelude describes a state transition function ",(0,o.jsx)(n.code,{children:"S => (A, S)"})," that takes an initial state and returns a value and an updated state. Using ",(0,o.jsx)(n.code,{children:"ForEach"})," with ",(0,o.jsx)(n.code,{children:"State"})," corresponds to composing all of those state transition functions into a single state transition function."]}),"\n",(0,o.jsxs)(n.p,{children:["ZIO Prelude provides a specialized operator for using ",(0,o.jsx)(n.code,{children:"forEach"})," with ",(0,o.jsx)(n.code,{children:"State"})," called ",(0,o.jsx)(n.code,{children:"mapAccum"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"def mapAccum[F[+_]: ForEach, S, A, B](fa: F[A])(s: S)(f: (S, A) => (S, B)): (S, F[B]) =\n  ???\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This lets us specify an initial state ",(0,o.jsx)(n.code,{children:"S"})," and then in our function ",(0,o.jsx)(n.code,{children:"f"})," instead of just providing a function ",(0,o.jsx)(n.code,{children:"A => B"})," like in ",(0,o.jsx)(n.code,{children:"map"})," we can update the state as well. The implementation of ",(0,o.jsx)(n.code,{children:"mapAccum"})," takes care of putting each of these functions in the ",(0,o.jsx)(n.code,{children:"State"})," data type for us and then runs the final computation for us with the initial state to produce both the final state and the final value."]}),"\n",(0,o.jsxs)(n.p,{children:["This is very useful for implementing other operators because it lets us get information out of the collection type ",(0,o.jsx)(n.code,{children:"S"}),", so now we can implement collection operators that don't just transform the collection but reduce it to a summary value."]}),"\n",(0,o.jsxs)(n.p,{children:["To see this, let's implement the ",(0,o.jsx)(n.code,{children:"foldLeft"})," operator from the Scala collection library in terms of ",(0,o.jsx)(n.code,{children:"mapAccum"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"def foldLeft[F[+_]: ForEach, A, S](fa: F[A])(s: S)(f: (S, A) => S): S =\n  mapAccum(fa)(s)((s, a) => (f(s, a), ()))._1\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"foldLeft"})," operator simply accumulates the fold state and discards the collection."]}),"\n",(0,o.jsxs)(n.p,{children:["This is very powerful because it means that we can implement almost every collection operator in terms of ",(0,o.jsx)(n.code,{children:"ForEach"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["This includes any collection operator that reduces a collection to some other value, like ",(0,o.jsx)(n.code,{children:"count"}),", ",(0,o.jsx)(n.code,{children:"exists"}),", ",(0,o.jsx)(n.code,{children:"find"}),", ",(0,o.jsx)(n.code,{children:"foldLeft"}),", ",(0,o.jsx)(n.code,{children:"foldRight"}),", ",(0,o.jsx)(n.code,{children:"forall"}),", ",(0,o.jsx)(n.code,{children:"groupBy"}),", ",(0,o.jsx)(n.code,{children:"isEmpty"}),", ",(0,o.jsx)(n.code,{children:"product"}),", ",(0,o.jsx)(n.code,{children:"size"}),", ",(0,o.jsx)(n.code,{children:"sum"}),", and ",(0,o.jsx)(n.code,{children:"toList"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:['It also includes any operator that modifies the values of a collection while maintaining the "shape" of the collection such as ',(0,o.jsx)(n.code,{children:"zipWithIndex"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["The only collection operators we can't implement in terms of ",(0,o.jsx)(n.code,{children:"ForEach"})," are those that change the shape of the collection like appending a new element to the collection. We don't know enough about the structure of the data type to know what that would mean or even if it would be well defined."]}),"\n",(0,o.jsxs)(n.p,{children:["For example, the data type might be a tree that does not have a well defined notion of adding an element without specifying where it should be added. Or it might be a data type like ",(0,o.jsx)(n.code,{children:"Option"})," or ",(0,o.jsx)(n.code,{children:"Either"})," that doesn't support appending at all."]}),"\n",(0,o.jsxs)(n.p,{children:["In addition to the standard Scala collection operators, ",(0,o.jsx)(n.code,{children:"ForEach"})," allows us to define additional operators that take advantage of the functional abstractions and data structure in ZIO Prelude."]}),"\n",(0,o.jsxs)(n.p,{children:["One variant of ",(0,o.jsx)(n.code,{children:"forEach"})," that you may be familiar with is ",(0,o.jsx)(n.code,{children:"flip"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"def flip[F[+_]: ForEach, G[+_]: IdentityBoth : Covariant, S, A, B](fga: F[G[A]]): G[F[A]] =\n  fga.forEach(identity)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This is the generalized version of the ",(0,o.jsx)(n.code,{children:"collectAll"})," operator on ",(0,o.jsx)(n.code,{children:"ZIO"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio._\n\ndef collectAll[R, E, A](as: List[ZIO[R, E, A]]): ZIO[R, E, List[A]] =\n  ZIO.foreach(as)(identity)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This operator already takes a list of ",(0,o.jsx)(n.code,{children:"ZIO"})," values so all it has to do is combine them into a single ",(0,o.jsx)(n.code,{children:"ZIO"})," value and put the results back together into a list."]}),"\n",(0,o.jsxs)(n.p,{children:["Another particularly useful operator is ",(0,o.jsx)(n.code,{children:"foldMap"}),", which lets us reduce a collection to a summary value by mapping each value to a value for which an ",(0,o.jsx)(n.code,{children:"Identity"})," instance is defined and combining those values with the ",(0,o.jsx)(n.code,{children:"combine"})," operator."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"def foldMap[F[+_]: ForEach, A, B: Identity](as: F[A])(f: A => B): B =\n  foldLeft(as)(Identity[B].identity)((b, a) => b <> f(a))\n"})}),"\n",(0,o.jsx)(n.p,{children:"This is a very nice operator that lets us express a variety of ways of reducing a collection to a summary value in a very concise way."}),"\n",(0,o.jsxs)(n.p,{children:["For example we could implement ",(0,o.jsx)(n.code,{children:"sum"})," in terms of ",(0,o.jsx)(n.code,{children:"foldMap"})," like this:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio.prelude.newtypes._\n\ndef sum[F[+_]: ForEach, A](as: F[A])(implicit identity: Identity[Sum[A]]): A =\n  foldMap(as)(a => Sum[A](a))\n"})}),"\n",(0,o.jsx)(n.p,{children:"Here is how we could implement a fold that computes the sum and product of the values of a collection in a single pass:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"def sumProd[F[+_]: ForEach, A](as: F[A])(implicit sum: Identity[Sum[A]], product: Identity[Prod[A]]): (A, A) =\n  foldMap(as)(a => (Sum[A](a), Prod[A](a)))\n"})}),"\n",(0,o.jsxs)(n.p,{children:["As you can see by using ",(0,o.jsx)(n.code,{children:"foldMap"})," with the functional abstractions in ZIO Prelude for describing ways of combining concrete types we can implement folds like this in an extremely high level and compositional way."]}),"\n",(0,o.jsxs)(n.p,{children:["One common variant of a fold that can be particularly useful is ",(0,o.jsx)(n.code,{children:"concatenate"}),", which allows us to combine all the elements of a collection into one using an ",(0,o.jsx)(n.code,{children:"Identity"})," instance already defined for the element type. For example, here is how we could use it to combine a list of strings:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'val strings = List("Hello", ", ", "World", "!")\n\nstrings.concatenate\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Note that as with other extension methods in ZIO Prelude we need to do ",(0,o.jsx)(n.code,{children:"import zio.prelude._"})," to bring these extension methods into scope."]}),"\n",(0,o.jsxs)(n.p,{children:["In summary, ",(0,o.jsx)(n.code,{children:"ForEach"})," is one of the most useful abstractions in ZIO Prelude in terms of providing a very large number of practically useful operators for implementing a single method. So if you are implementing your own parameterized type that contains zero or more values of the type it is parameterized on then defining a ",(0,o.jsx)(n.code,{children:"ForEach"}),' instance is a great "quick win" to immediately add a lot of functionality to your data type.']})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}}}]);