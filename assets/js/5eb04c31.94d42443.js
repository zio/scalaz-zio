"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[9288],{28453:(e,s,n)=>{n.d(s,{R:()=>r,x:()=>a});var t=n(96540);const o={},i=t.createContext(o);function r(e){const s=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(i.Provider,{value:s},e.children)}},84053:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"reference/test/assertions/index","title":"Introduction to ZIO Test Assertions","description":"Assertions are used to make sure that the assumptions on computations are exactly what we expect them to be. They are executable checks for a property that must be true in our code. Also, they can be seen as a specification of a program and facilitate understanding of programs.","source":"@site/docs/reference/test/assertions/index.md","sourceDirName":"reference/test/assertions","slug":"/reference/test/assertions/","permalink":"/reference/test/assertions/","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/test/assertions/index.md","tags":[],"version":"current","frontMatter":{"id":"index","title":"Introduction to ZIO Test Assertions"},"sidebar":"reference-sidebar","previous":{"title":"JUnit Integration","permalink":"/reference/test/junit-integration"},"next":{"title":"Classic Assertions","permalink":"/reference/test/assertions/classic-assertions"}}');var o=n(74848),i=n(28453);const r={id:"index",title:"Introduction to ZIO Test Assertions"},a=void 0,c={},l=[{value:"Built-in Assertions",id:"built-in-assertions",level:2},{value:"Logical Operations",id:"logical-operations",level:2},{value:"Composable Nested Assertions",id:"composable-nested-assertions",level:2},{value:"Testing using Assertions",id:"testing-using-assertions",level:2}];function d(e){const s={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(s.p,{children:["Assertions are used to make sure that the assumptions on computations are exactly what we expect them to be. They are ",(0,o.jsx)(s.em,{children:"executable checks"})," for a property that must be true in our code. Also, they can be seen as a ",(0,o.jsx)(s.em,{children:"specification of a program"})," and facilitate understanding of programs."]}),"\n",(0,o.jsxs)(s.p,{children:["An ",(0,o.jsx)(s.code,{children:"Assertion[A]"})," is a statement that can be used to assert the predicate of type ",(0,o.jsx)(s.code,{children:"A => Boolean"}),". It is a piece of code that checks whether a value of type ",(0,o.jsx)(s.code,{children:"A"})," satisfies some condition. If the condition is satisfied, the assertion passes; otherwise, it fails. We can think of the ",(0,o.jsx)(s.code,{children:"Assertion[A]"})," as a function from ",(0,o.jsx)(s.code,{children:"A"})," to ",(0,o.jsx)(s.code,{children:"Boolean"}),":"]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-scala",children:"case class Assertion[-A](arrow: TestArrow[A, Boolean]) {\n  def test(value: A): Boolean = ???\n  def run(value: => A): TestResult = ???\n}\n"})}),"\n",(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.code,{children:"Assertion"})," has a companion object with lots of predefined assertions that can be used to test values of different types. For example, the ",(0,o.jsx)(s.code,{children:"Assertion.equalTo"})," takes a value of type ",(0,o.jsx)(s.code,{children:"A"})," and returns an assertion that checks whether the value is equal to the given value:"]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-scala",children:"import zio.test._\nimport zio.test.Assertion\n\ndef sut = 40 + 2\nval assertion: Assertion[Int] = Assertion.equalTo[Int, Int](42)\nassertion.test(sut) // true\n"})}),"\n",(0,o.jsxs)(s.admonition,{type:"note",children:[(0,o.jsxs)(s.p,{children:["Behind the scenes, the ",(0,o.jsx)(s.code,{children:"Assertion"})," type uses a ",(0,o.jsx)(s.code,{children:"TestArrow"})," type to represent the function from ",(0,o.jsx)(s.code,{children:"A"})," to ",(0,o.jsx)(s.code,{children:"Boolean"}),". For example, instead of using a predefined ",(0,o.jsx)(s.code,{children:"equalTo"})," assertion, we can create our assertion directly from a ",(0,o.jsx)(s.code,{children:"TestArrow"}),":"]}),(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-scala",children:"import zio.test._\n\ndef sut = 40 + 2\nval assertion: Assertion[Int] = Assertion(TestArrow.fromFunction(_ == 42))\nassertion.test(sut) // true\n"})}),(0,o.jsxs)(s.p,{children:["Please note that the ",(0,o.jsx)(s.code,{children:"TestArrow"})," is the fundamental building block of assertions specially the complex ones. Usually, as the end user, we do not require interacting with ",(0,o.jsx)(s.code,{children:"TestArrow"})," directly. But it is good to know that it is there and how it works. We will see more about ",(0,o.jsx)(s.code,{children:"TestArrow"})," in the next sections."]})]}),"\n",(0,o.jsx)(s.h2,{id:"built-in-assertions",children:"Built-in Assertions"}),"\n",(0,o.jsxs)(s.p,{children:["The companion object of ",(0,o.jsx)(s.code,{children:"Assertion"})," provides a comprehensive set of predefined assertions that can be used to test values of different types. We have a separate page for introducing the ",(0,o.jsx)(s.a,{href:"/reference/test/assertions/built-in-assertions",children:"built-in assertions"})," in ZIO Test."]}),"\n",(0,o.jsx)(s.h2,{id:"logical-operations",children:"Logical Operations"}),"\n",(0,o.jsx)(s.p,{children:"As a proposition, assertions compose using logical conjunction and disjunction and can be negated:"}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-scala",children:"import zio.test._\n\nval greaterThanZero: Assertion[Int] = Assertion.isPositive\nval lessThanFive   : Assertion[Int] = Assertion.isLessThan(5)\nval equalTo10      : Assertion[Int] = Assertion.equalTo(10)\n\nval assertion: Assertion[Int] = greaterThanZero && lessThanFive || !equalTo10\n"})}),"\n",(0,o.jsx)(s.p,{children:"After composing them, we can run it on any expression:"}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-scala",children:"import zio._\n\nval result: TestResult = assertion.run(10)\n"})}),"\n",(0,o.jsx)(s.h2,{id:"composable-nested-assertions",children:"Composable Nested Assertions"}),"\n",(0,o.jsxs)(s.p,{children:["Besides the logical operators, we can also combine assertions like the following to have assertions on more complex types like ",(0,o.jsx)(s.code,{children:"Option[Int]"}),":"]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-scala",children:'val assertion: Assertion[Option[Int]] = Assertion.isSome(Assertion.equalTo(5))\n\ntest("optional value is some(5)") {\n  assert(Some(1 + 4))(assertion)\n}\n'})}),"\n",(0,o.jsxs)(s.p,{children:["This nested assertion will pass only if the given value is ",(0,o.jsx)(s.code,{children:"Some(5)"}),"."]}),"\n",(0,o.jsxs)(s.p,{children:["We can also combine assertions on more complex types like ",(0,o.jsx)(s.code,{children:"Either[Int, Option[Int]]"}),":"]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-scala",children:'import zio.test._\nimport zio.test.Assertion.{isRight, isSome, equalTo, hasField}\n\ntest("either value is right(Some(5))") {\n  assert(Right(Some(1 + 4)))(isRight(isSome(equalTo(5))))\n}\n'})}),"\n",(0,o.jsxs)(s.p,{children:["Here we're checking deeply nested values inside an ",(0,o.jsx)(s.code,{children:"Either"})," and ",(0,o.jsx)(s.code,{children:"Option"}),". Because ",(0,o.jsx)(s.code,{children:"Assertion"}),"s compose this is not a problem. All layers are being peeled off tested for the condition until the final value is reached."]}),"\n",(0,o.jsxs)(s.p,{children:["Here the expression ",(0,o.jsx)(s.code,{children:"Right(Some(1 + 4))"})," is of type ",(0,o.jsx)(s.code,{children:"Either[Any, Option[Int]]"})," and our assertion ",(0,o.jsx)(s.code,{children:"isRight(isSome(equalTo(5)))"})," is of type ",(0,o.jsx)(s.code,{children:"Assertion[Either[Any, Option[Int]]]"})]}),"\n",(0,o.jsxs)(s.admonition,{type:"note",children:[(0,o.jsxs)(s.p,{children:["Under the hood, the above assertion uses the ",(0,o.jsx)(s.code,{children:">>>"})," operator of ",(0,o.jsx)(s.code,{children:"TestArrow"})," to make the composition of two assertions sequentially:"]}),(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-scala",children:"import zio.test._\nimport zio.test.Assertion\n\ndef isRight[A]: TestArrow[Either[Any, A], A] =\n  TestArrow.fromFunction(_.toOption.get)\n\ndef isSome[A]: TestArrow[Option[A], A] =\n  TestArrow.fromFunction(_.get)\n\ndef equalTo[A, B](expected: B): TestArrow[B, Boolean] =\n  TestArrow.fromFunction((actual: B) => actual == expected)\n\nval assertion: Assertion[Either[Any, Option[Int]]] = {\n  val arrow: TestArrow[Either[Any, Option[Int]], Boolean] =\n    isRight >>>        // Either[Any, Option[Int]] => Option[Int]\n      isSome[Int] >>>  // Option[Int] => Int\n      equalTo(5)       // Int => Boolean\n  Assertion(arrow)\n}\n"})}),(0,o.jsxs)(s.p,{children:["By composing an arrow of ",(0,o.jsx)(s.code,{children:"TestArrow[Either[Any, Option[Int]], Option[Int]]"})," and ",(0,o.jsx)(s.code,{children:"TestArrow[Option[Int], Boolean]"})," and ",(0,o.jsx)(s.code,{children:"TestArrow[Int, Boolean]"})," we can create an arrow of ",(0,o.jsx)(s.code,{children:"TestArrow[Either[Any, Option[Int]], Boolean]"}),". Using this technique, we can compose more arrows to create more and more complex assertions."]}),(0,o.jsxs)(s.p,{children:["We can see that ",(0,o.jsx)(s.code,{children:"TestArrow"})," has the same analogy as ",(0,o.jsx)(s.a,{href:"/reference/contextual/zlayer",children:(0,o.jsx)(s.code,{children:"ZLayer"})}),'. We are dealing with generalization of functions and composition of functions in a pure and declarative fashion, which is called "arrow" in functional programming. In other words, with ',(0,o.jsx)(s.code,{children:"TestArrow"}),", we have reified the concept of a function and its composition, which allows us to manipulate functions as first-class values."]}),(0,o.jsx)(s.p,{children:'One of the benefits of reification of assertions into "arrows" is that we can write macros to generate assertions from pure Scala code. This is how the smart assertions work in ZIO Test.'})]}),"\n",(0,o.jsx)(s.h2,{id:"testing-using-assertions",children:"Testing using Assertions"}),"\n",(0,o.jsx)(s.p,{children:"We have two types of methods for writing test assertions:"}),"\n",(0,o.jsxs)(s.ol,{children:["\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:(0,o.jsx)(s.a,{href:"/reference/test/assertions/classic-assertions",children:"Classic Assertions"})}),"\u2014 This one is the classic way of asserting ordinary values (",(0,o.jsx)(s.code,{children:"assert"}),") and ZIO effects (",(0,o.jsx)(s.code,{children:"assertZIO"}),") without using macros."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:(0,o.jsx)(s.a,{href:"/reference/test/assertions/smart-assertions",children:"Smart Assertions"})}),"\u2014 This is a unified syntax for asserting both ordinary values and ZIO effects using the ",(0,o.jsx)(s.code,{children:"assertTrue"})," macro."]}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,o.jsx)(s,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);