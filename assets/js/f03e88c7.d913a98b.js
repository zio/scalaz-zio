"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[52331],{28453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>l});var r=i(96540);const s={},a=r.createContext(s);function t(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),r.createElement(a.Provider,{value:n},e.children)}},90338:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"overview/handling-resources","title":"Handling Resources","description":"Ensuring that your applications never leak resources is one of the keys to maximizing application throughput, minimizing latency, and maximizing per-node uptime.","source":"@site/docs/overview/handling-resources.md","sourceDirName":"overview","slug":"/overview/handling-resources","permalink":"/overview/handling-resources","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/overview/handling-resources.md","tags":[],"version":"current","frontMatter":{"id":"handling-resources","title":"Handling Resources"},"sidebar":"overview_sidebar","previous":{"title":"Handling Errors","permalink":"/overview/handling-errors"},"next":{"title":"Basic Concurrency","permalink":"/overview/basic-concurrency"}}');var s=i(74848),a=i(28453);const t={id:"handling-resources",title:"Handling Resources"},l=void 0,o={},c=[{value:"Finalizing",id:"finalizing",level:2},{value:"Acquire Release",id:"acquire-release",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Ensuring that your applications never leak resources is one of the keys to maximizing application throughput, minimizing latency, and maximizing per-node uptime."}),"\n",(0,s.jsx)(n.p,{children:"Yet, achieving resource safety in the presence of asynchronous operations, concurrency, and ZIO's interruption model (which will automatically cancel running effects anytime their results will no longer be used) is challenging."}),"\n",(0,s.jsx)(n.p,{children:"In this section, you will learn a few of the tools that ZIO provides to create safe applications that never leak resources, even in the case of failure, interruption, or defects in your application."}),"\n",(0,s.jsx)(n.h2,{id:"finalizing",children:"Finalizing"}),"\n",(0,s.jsxs)(n.p,{children:["In many languages, the ",(0,s.jsx)(n.code,{children:"try"})," / ",(0,s.jsx)(n.code,{children:"finally"})," construct provides a language-level way to guarantee that when the ",(0,s.jsx)(n.code,{children:"try"})," code exits, either normally or abnormally, the ",(0,s.jsx)(n.em,{children:"finalizer"})," code in the ",(0,s.jsx)(n.code,{children:"finally"})," block will be executed."]}),"\n",(0,s.jsxs)(n.p,{children:["ZIO provides a version of this with the ",(0,s.jsx)(n.code,{children:"ZIO#ensuring"})," method, whose guarantees hold across concurrent and async effects. ZIO goes one step further in automatically and losslessly aggregating errors from finalizers."]}),"\n",(0,s.jsxs)(n.p,{children:["As with ",(0,s.jsx)(n.code,{children:"try"})," / ",(0,s.jsx)(n.code,{children:"finally"}),", the ",(0,s.jsx)(n.code,{children:"ensuring"})," method guarantees if the effect it is called on begins executing and terminates (either normally or abnormally), then the finalizer will begin execution."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'val finalizer: UIO[Unit] = \n  ZIO.succeed(println("Finalizing!"))\n// finalizer: UIO[Unit] = Sync(\n//   trace = "repl.MdocSession.MdocApp.finalizer(handling-resources.md:15)",\n//   eval = <function0>\n// )\n\nval finalized: IO[String, Unit] = \n  ZIO.fail("Failed!").ensuring(finalizer)\n// finalized: IO[String, Unit] = DynamicNoBox(\n//   trace = "repl.MdocSession.MdocApp.finalized(handling-resources.md:19)",\n//   update = 1L,\n//   f = zio.ZIO$$$Lambda$18783/0x00007f30c2dc0210@2e7a1fbf\n// )\n'})}),"\n",(0,s.jsx)(n.p,{children:"In ZIO, finalizers are not allowed to fail in any recoverable way, which means that you must handle all of the errors that your code can produce."}),"\n",(0,s.jsxs)(n.p,{children:["Like ",(0,s.jsx)(n.code,{children:"try"})," / ",(0,s.jsx)(n.code,{children:"finally"}),", finalizers can be nested, and the failure of any inner finalizer will not affect outer finalizers. Nested finalizers will be executed in reverse order and sequentially, with later finalizers executed only after earlier finalizers."]}),"\n",(0,s.jsx)(n.h2,{id:"acquire-release",children:"Acquire Release"}),"\n",(0,s.jsxs)(n.p,{children:["A common use for ",(0,s.jsx)(n.code,{children:"try"})," is safely acquiring and releasing resources, such as new socket connections or opened files:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"val handle = openFile(name)\n\ntry {\n  processFile(handle)\n} finally closeFile(handle)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["ZIO encapsulates this common pattern with ",(0,s.jsx)(n.code,{children:"ZIO.acquireReleaseWith"}),", which allows you to specify an ",(0,s.jsx)(n.em,{children:"acquire"})," effect, which acquires a resource; a ",(0,s.jsx)(n.em,{children:"release function"}),", which returns an effect to release the resource; and a ",(0,s.jsx)(n.em,{children:"use function"}),", which returns an effect that ",(0,s.jsx)(n.em,{children:"uses"})," the resource."]}),"\n",(0,s.jsx)(n.p,{children:"So long as the acquire effect succeeds, the release effect is guaranteed to be executed by the runtime system, even in the presence of errors or interruption."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'val groupedFileData: IO[IOException, Unit] = \n  ZIO.acquireReleaseWith(openFile("data.json"))(closeFile(_)) { file =>\n    for {\n      data    <- decodeData(file)\n      grouped <- groupData(data)\n    } yield grouped\n  }\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Like ",(0,s.jsx)(n.code,{children:"ensuring"}),", ",(0,s.jsx)(n.code,{children:"acquireReleaseWith"})," has compositional semantics, so if one ",(0,s.jsx)(n.code,{children:"acquireReleaseWith"})," is nested inside another ",(0,s.jsx)(n.code,{children:"acquireReleaseWith"}),", and the outer resource is acquired, then the outer release will always be called, even if, for example, the inner release fails."]}),"\n",(0,s.jsxs)(n.p,{children:["For resources which implement the AutoClosable interface, the convenience method ",(0,s.jsx)(n.code,{children:"fromAutoClosable"})," can be used, which can be seen as the ZIO equivalent of try-with-resource."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'val bytesInFile: IO[Throwable, Int] =\n  ZIO.scoped {\n    for {\n      stream <- ZIO.fromAutoCloseable(openFileInputStream("data.json"))\n      data   <- ZIO.attemptBlockingIO(stream.readAllBytes())\n    } yield data.length\n  }\n'})}),"\n",(0,s.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsxs)(n.p,{children:["If you are comfortable with basic resource handling, the next step is to learn about ",(0,s.jsx)(n.a,{href:"/overview/basic-concurrency",children:"basic concurrency"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);