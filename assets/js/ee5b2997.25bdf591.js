"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[94103],{23717:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>t,toc:()=>p});const t=JSON.parse('{"id":"reference/error-management/operations/map-operations","title":"Map Operations","description":"Other than ZIO#map and ZIO#flatMap, ZIO has several other operators to manage errors while mapping:","source":"@site/docs/reference/error-management/operations/map-operations.md","sourceDirName":"reference/error-management/operations","slug":"/reference/error-management/operations/map-operations","permalink":"/reference/error-management/operations/map-operations","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/error-management/operations/map-operations.md","tags":[],"version":"current","frontMatter":{"id":"map-operations","title":"Map Operations"},"sidebar":"reference-sidebar","previous":{"title":"Error Accumulation","permalink":"/reference/error-management/error-accumulation"},"next":{"title":"Chaining Effects Based on Errors","permalink":"/reference/error-management/operations/chaining-effects-based-on-errors"}}');var r=a(74848),o=a(28453);const i={id:"map-operations",title:"Map Operations"},s=void 0,c={},p=[{value:"<code>ZIO#mapError</code>/<code>ZIO#mapErrorCause</code>",id:"ziomaperrorziomaperrorcause",level:2},{value:"<code>ZIO#mapAttempt</code>",id:"ziomapattempt",level:2},{value:"<code>ZIO#mapBoth</code>",id:"ziomapboth",level:2}];function l(e){const n={blockquote:"blockquote",code:"code",em:"em",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["Other than ",(0,r.jsx)(n.code,{children:"ZIO#map"})," and ",(0,r.jsx)(n.code,{children:"ZIO#flatMap"}),", ZIO has several other operators to manage errors while mapping:"]}),"\n",(0,r.jsxs)(n.h2,{id:"ziomaperrorziomaperrorcause",children:[(0,r.jsx)(n.code,{children:"ZIO#mapError"}),"/",(0,r.jsx)(n.code,{children:"ZIO#mapErrorCause"})]}),"\n",(0,r.jsxs)(n.p,{children:["Let's begin with ",(0,r.jsx)(n.code,{children:"ZIO#mapError"})," and ",(0,r.jsx)(n.code,{children:"ZIO#mapErrorCause"}),". These operators help us to access the error channel as a raw error value or as a type of ",(0,r.jsx)(n.code,{children:"Cause"})," and map their values:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"trait ZIO[-R, +E, +A] {\n  def mapError[E2](f: E => E2): ZIO[R, E2, A]\n  def mapErrorCause[E2](h: Cause[E] => Cause[E2]): ZIO[R, E2, A]\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Here are two simple examples for these operators:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio._\n\ndef parseInt(input: String): ZIO[Any, NumberFormatException, Int] = ???\n\n// mapping the error of the original effect to its message\nval r1: ZIO[Any, String, Int] =\n  parseInt("five")                // ZIO[Any, NumberFormatException, Int]\n    .mapError(e => e.getMessage)  // ZIO[Any, String, Int]\n\n// mapping the cause of the original effect to be untraced\nval r2 = parseInt("five")         // ZIO[Any, NumberFormatException, Int]\n  .mapErrorCause(_.untraced)      // ZIO[Any, NumberFormatException, Int]\n'})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"Note:"})})}),"\n",(0,r.jsxs)(n.p,{children:["Note that mapping over an effect's success or error channel does not change the success or failure of the effect, in the same way that mapping over an ",(0,r.jsx)(n.code,{children:"Either"})," does not change whether the ",(0,r.jsx)(n.code,{children:"Either"})," is ",(0,r.jsx)(n.code,{children:"Left"})," or ",(0,r.jsx)(n.code,{children:"Right"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"ziomapattempt",children:(0,r.jsx)(n.code,{children:"ZIO#mapAttempt"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"ZIO#mapAttempt"})," returns an effect whose success is mapped by the specified side-effecting ",(0,r.jsx)(n.code,{children:"f"})," function, translating any thrown exceptions into typed failed effects. So it converts an unchecked exception to a checked one by returning the ",(0,r.jsx)(n.code,{children:"RIO"})," effect."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"  trait ZIO[-R, +E, +A] {\n    def map[B](f: A => B): ZIO[R, E, B]\n    def mapAttempt[B](f: A => B): ZIO[R, Throwable, B]\n  }\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Using operations that can throw exceptions inside of ",(0,r.jsx)(n.code,{children:"ZIO#map"})," such as ",(0,r.jsx)(n.code,{children:"effect.map(_.unsafeOpThatThrows)"})," will result in a defect (an unexceptional effect that will die). In the following example, when we use the ",(0,r.jsx)(n.code,{children:"ZIO#map"})," operation. So, if the ",(0,r.jsx)(n.code,{children:"String#toInt"})," operation throws ",(0,r.jsx)(n.code,{children:"NumberFormatException"})," it will be converted to a defect:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nval result: ZIO[Any, Nothing, Int] =\n  Console.readLine.orDie.map(_.toInt)\n"})}),"\n",(0,r.jsx)(n.p,{children:"As a result, when the map operation is unsafe, it may lead to buggy programs that may crash, as shown below:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  val myApp: ZIO[Any, Nothing, Unit] =\n    Console.print("Please enter a number: ").orDie *>\n      Console.readLine.orDie\n        .map(_.toInt)\n        .map(_ % 2 == 0)\n        .flatMap {\n          case true =>\n            Console.printLine("You have entered an even number.").orDie\n          case false =>\n            Console.printLine("You have entered an odd number.").orDie\n        }\n\n  def run = myApp\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:['Converting literal "five" String to Int by calling ',(0,r.jsx)(n.code,{children:"toInt"})," is a side effecting operation because it will throw ",(0,r.jsx)(n.code,{children:"NumberFormatException"}),' exception. So in the previous example, if we enter a non-integer number, e.g. "five", it will die because of a ',(0,r.jsx)(n.code,{children:"NumberFormatException"})," defect:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'Please enter a number: five\ntimestamp=2022-03-17T14:01:33.323639073Z level=ERROR thread=#zio-fiber-0 message="Exception in thread "zio-fiber-2" java.lang.NumberFormatException: For input string: "five"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Integer.parseInt(Integer.java:660)\n\tat java.base/java.lang.Integer.parseInt(Integer.java:778)\n\tat scala.collection.StringOps$.toInt$extension(StringOps.scala:910)\n\tat MainApp$.$anonfun$myApp$3(MainApp.scala:7)\n\tat MainApp$.$anonfun$myApp$3$adapted(MainApp.scala:7)\n\tat zio.ZIO.$anonfun$map$1(ZIO.scala:1168)\n\tat zio.ZIO$FlatMap.apply(ZIO.scala:6182)\n\tat zio.ZIO$FlatMap.apply(ZIO.scala:6171)\n\tat zio.internal.FiberContext.runUntil(FiberContext.scala:885)\n\tat zio.internal.FiberContext.run(FiberContext.scala:115)\n\tat java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)\n\tat java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)\n\tat java.base/java.lang.Thread.run(Thread.java:831)\n\tat zio.internal.FiberContext.runUntil(FiberContext.scala:538)\n\tat <empty>.MainApp.myApp(MainApp.scala:8)\n\tat <empty>.MainApp.myApp(MainApp.scala:9)"\n'})}),"\n",(0,r.jsxs)(n.p,{children:["We can see that the error channel of ",(0,r.jsx)(n.code,{children:"myApp"})," is typed as ",(0,r.jsx)(n.code,{children:"Nothing"}),", so it's not an exceptional error. If we want typed effects, this behavior is not intended. So instead of ",(0,r.jsx)(n.code,{children:"ZIO#map"})," we can use the ",(0,r.jsx)(n.code,{children:"mapAttempt"})," combinator which is a safe map operator that translates all thrown exceptions into typed exceptional effect."]}),"\n",(0,r.jsxs)(n.p,{children:["To prevent converting exceptions to defects, we can use ",(0,r.jsx)(n.code,{children:"ZIO#mapAttempt"})," which converts any exceptions to exceptional effects:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nval result: ZIO[Any, Throwable, Int] =\n  Console.readLine.orDie.mapAttempt(_.toInt)\n"})}),"\n",(0,r.jsx)(n.p,{children:"Having typed errors helps us to catch errors explicitly and handle them in the right way:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  val myApp: ZIO[Any, Nothing, Unit] =\n    Console.print("Please enter a number: ").orDie *>\n      Console.readLine.orDie\n        .mapAttempt(_.toInt)\n        .map(_ % 2 == 0)\n        .flatMap {\n          case true =>\n            Console.printLine("You have entered an even number.").orDie\n          case false =>\n            Console.printLine("You have entered an odd number.").orDie\n        }.catchAll(_ => myApp)\n\n  def run = myApp\n}\n\n// Please enter a number: five\n// Please enter a number: 4\n// You have entered an even number.\n'})}),"\n",(0,r.jsx)(n.h2,{id:"ziomapboth",children:(0,r.jsx)(n.code,{children:"ZIO#mapBoth"})}),"\n",(0,r.jsx)(n.p,{children:"It takes two map functions, one for the error channel and the other for the success channel, and maps both sides of a ZIO effect:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"trait ZIO[-R, +E, +A] {\n  def mapBoth[E2, B](f: E => E2, g: A => B): ZIO[R, E2, B]\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Here is a simple example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nval result: ZIO[Any, String, Int] =\n  Console.readLine.orDie.mapAttempt(_.toInt).mapBoth(\n    _ => "non-integer input",\n    n => Math.abs(n)\n  )\n'})})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},28453:(e,n,a)=>{a.d(n,{R:()=>i,x:()=>s});var t=a(96540);const r={},o=t.createContext(r);function i(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);