"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[55144],{6810:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>s,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"reference/di/zlayer-constructor-as-a-value","title":"ZLayer: Constructor as a Value","description":"Before jumping into the next section, which will explain dependency injection in ZIO, let\'s take a look at the philosophy behind the ZLayer data type.","source":"@site/docs/reference/di/zlayer-constructor-as-a-value.md","sourceDirName":"reference/di","slug":"/reference/di/zlayer-constructor-as-a-value","permalink":"/reference/di/zlayer-constructor-as-a-value","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/di/zlayer-constructor-as-a-value.md","tags":[],"version":"current","frontMatter":{"id":"zlayer-constructor-as-a-value","title":"ZLayer: Constructor as a Value","sidebar_label":"Constructor as a Value"},"sidebar":"reference-sidebar","previous":{"title":"Motivation","permalink":"/reference/di/motivation"},"next":{"title":"Getting Started","permalink":"/reference/di/dependency-injection-in-zio"}}');var o=r(74848),t=r(28453);const s={id:"zlayer-constructor-as-a-value",title:"ZLayer: Constructor as a Value",sidebar_label:"Constructor as a Value"},i=void 0,c={},l=[{value:"Composable Constructors",id:"composable-constructors",level:2},{value:"Effectful Constructors",id:"effectful-constructors",level:2},{value:"Resourceful Constructors",id:"resourceful-constructors",level:2},{value:"Asynchronous Constructors",id:"asynchronous-constructors",level:2},{value:"Parallel Constructors",id:"parallel-constructors",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:["Before jumping into the next section, which will explain dependency injection in ZIO, let's take a look at the philosophy behind the ",(0,o.jsx)(n.code,{children:"ZLayer"})," data type."]}),"\n",(0,o.jsxs)(n.p,{children:["In the ",(0,o.jsx)(n.a,{href:"/reference/di/motivation",children:"motivation"})," section, we find out that the ordinary Scala constructors are not powerful enough to help us to build the dependency graph easily. So ",(0,o.jsx)(n.code,{children:"ZLayer"})," was created to overcome scala constructors' limitations."]}),"\n",(0,o.jsxs)(n.p,{children:["We can think of ",(0,o.jsx)(n.code,{children:"ZLayer"})," as an alternative to constructors but with the following powerful features:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Composable with a nice ergonomic API"}),"\n",(0,o.jsx)(n.li,{children:"Asynchronous so it doesn't block the thread"}),"\n",(0,o.jsx)(n.li,{children:"Effectful and resourceful"}),"\n",(0,o.jsx)(n.li,{children:"Support for concurrency and parallelism"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Let's see the following example written using scala constructors:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"class Editor(formatter: Formatter, compiler: Compiler) {\n  // ...\n}\n\nclass Compiler() {\n  // ...\n}\n\nclass Formatter() {\n  // ...\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"We can say that each constructor is a function that takes some arguments as dependencies and returns a new instance of the class:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"() => Formatter"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"() => Compiler"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"(Formatter, Compiler) => Editor"})}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"ZLayer"})," reifies the conceptual idea of scala constructor and turned it into typed value which is equipped with lots of compositional operators and also supporting asynchronous operations."]}),"\n",(0,o.jsxs)(n.p,{children:["So in other words, ",(0,o.jsx)(n.code,{children:"ZLayer"})," is a type-safe data type that describes the asynchronous, effectful and resourceful process of building the dependency graph. We can say that a ",(0,o.jsx)(n.code,{children:"ZLayer[Input, E, Output]"})," is a recipe that takes some services as input and returns some services as output."]}),"\n",(0,o.jsxs)(n.p,{children:["For example, a ",(0,o.jsx)(n.code,{children:"ZLayer"})," of type ",(0,o.jsx)(n.code,{children:"ZLayer[Any, Nothing, Formatter]"})," is a constructor that doesn't take any services from the input and returns ",(0,o.jsx)(n.code,{children:"Formatter"})," as output. Also, a ",(0,o.jsx)(n.code,{children:"ZLayer"})," of type ",(0,o.jsx)(n.code,{children:"ZLayer[Formatter with Compiler, Nothing, Editor]"})," is a constructor that takes ",(0,o.jsx)(n.code,{children:"Formatter"})," and ",(0,o.jsx)(n.code,{children:"Compiler"})," services from the input and returns ",(0,o.jsx)(n.code,{children:"Editor"})," as output:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nobject Formatter {\n  val layer: ZLayer[Any, Nothing, Formatter] =\n    ZLayer.succeed(new Formatter())\n}\n\nobject Compiler {\n  val layer: ZLayer[Any, Nothing, Compiler] =\n    ZLayer.succeed(new Compiler())\n}\n\nobject Editor {\n  val layer: ZLayer[Formatter with Compiler, Nothing, Editor] =\n    ZLayer {\n      for {\n        formatter <- ZIO.service[Formatter]\n        compiler  <- ZIO.service[Compiler]\n      } yield new Editor(formatter, compiler) \n    }\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"composable-constructors",children:"Composable Constructors"}),"\n",(0,o.jsx)(n.p,{children:"With scala constructors we compose services like the below to create the dependency graph:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"val formatter = new Formatter()\nval compiler = new Compiler()\nval editor = new Editor(formatter, compiler)\n"})}),"\n",(0,o.jsx)(n.p,{children:"While Scala constructors are a type of Scala function. Composable functions in Scala are not as ergonomic as ZLayer for constructing dependency graphs."}),"\n",(0,o.jsxs)(n.p,{children:["With ZLayer we can compose them using operators like ",(0,o.jsx)(n.code,{children:"++"})," and ",(0,o.jsx)(n.code,{children:">>>"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"val editor: ZLayer[Formatter with Compiler, Nothing, Editor] = \n  (Formatter.layer ++ Compiler.layer) >>> Editor.layer\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Also, we can compose ",(0,o.jsx)(n.code,{children:"Formatter"})," and ",(0,o.jsx)(n.code,{children:"Editor"})," layers to create a new layer that takes the ",(0,o.jsx)(n.code,{children:"Compiler"})," service and returns the",(0,o.jsx)(n.code,{children:" Editor"})," service:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"val editor: ZLayer[Compiler, Nothing, Editor] =\n  Formatter.layer >>> Editor.layer\n"})}),"\n",(0,o.jsx)(n.h2,{id:"effectful-constructors",children:"Effectful Constructors"}),"\n",(0,o.jsx)(n.p,{children:"If we have a dependency that requires an effectful computation to be initialized, we can't model easily such an operation using ordinary Scala constructors."}),"\n",(0,o.jsxs)(n.p,{children:["In the following example, without the help of ",(0,o.jsx)(n.code,{children:"ZIO#flatMap"})," or ",(0,o.jsx)(n.code,{children:"ZLayer"}),", we can't easily create an instance of the ",(0,o.jsx)(n.code,{children:"Editor"})," class:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio._\n\ncase class Counter(ref: Ref[Int]) {\n  def inc: UIO[Unit] = ref.update(_ + 1)\n  def dec: UIO[Unit] = ref.update(_ - 1)\n  def get: UIO[Int]  = ref.get\n}\n\nobject Counter {\n  // Effectful constructor\n  def make: UIO[Counter] = Ref.make(0).map(new Counter(_))\n}\n\nclass Editor(formatter: Formatter, compiler: Compiler, counter: Counter) {\n  // ...\n}\n\nobject Formatter {\n  def make = new Formatter() \n}\n\nobject Compiler {\n  def make = new Compiler()\n}\n\nval editor    =   \n  new Editor(\n    Formatter.make,\n    Compiler.make,\n    Counter.make // Compiler Error: Type mismatch: expected: Counter, found: UIO[Counter]\n  )\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Let's see how we can use ",(0,o.jsx)(n.code,{children:"ZIO#flatMap"})," to create ",(0,o.jsx)(n.code,{children:"Editor"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"val editor: ZIO[Any, Nothing, Editor] =\n  Counter.make.map { counter =>\n    new Editor(\n      Formatter.make,\n      Compiler.make,\n      counter\n    )\n  }\n"})}),"\n",(0,o.jsxs)(n.p,{children:["While with ",(0,o.jsx)(n.code,{children:"ZLayer"}),", we can easily have an effectful constructor. We can create ",(0,o.jsx)(n.code,{children:"ZLayer"})," from any ",(0,o.jsx)(n.code,{children:"ZIO"})," effect by using ",(0,o.jsx)(n.code,{children:"ZLayer.fromZIO"}),"/",(0,o.jsx)(n.code,{children:"ZLayer.apply"})," constructor:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"case class Counter(ref: Ref[Int]) {\n  def inc: UIO[Unit] = ref.update(_ + 1)\n  def dec: UIO[Unit] = ref.update(_ - 1)\n  def get: UIO[Int]  = ref.get\n}\n\nobject Counter {\n  val layer: ZLayer[Any, Nothing, Counter] = \n    ZLayer {\n      Ref.make(0).map(new Counter(_))\n    }\n}\n\nclass Formatter {\n  def format(code: String): UIO[String] = ???\n}\n\nobject Formatter {\n  val layer: ZLayer[Any, Nothing, Formatter] =\n    ZLayer.succeed(new Formatter())\n}\n\nclass Compiler {\n  def compile(code: String): UIO[String] = ???\n}\n\nobject Compiler {\n  val layer: ZLayer[Any, Nothing, Compiler] = \n    ZLayer.succeed(new Compiler())\n}\n\nclass Editor(formatter: Formatter, compiler: Compiler, counter: Counter) {\n  def formatAndCompile(code: String): UIO[String] = ???\n}\n\nobject Editor {\n  val layer: ZLayer[Formatter with Compiler with Counter, Nothing, Editor] =\n    ZLayer {\n      for {\n        formatter <- ZIO.service[Formatter]\n        compiler  <- ZIO.service[Compiler]\n        counter   <- ZIO.service[Counter]\n      } yield new Editor(formatter, compiler, counter) \n    }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Let's try another example. Assume we have a ",(0,o.jsx)(n.code,{children:"ZIO"})," effect that reads the application config from a file, we can create a layer from that:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio._\n\ncase class AppConfig(poolSize: Int)\n  \nobject AppConfig {\n  private def loadConfig : Task[AppConfig] = \n    ZIO.attempt(???) // loading config from a file\n    \n  val layer: TaskLayer[AppConfig] = \n    ZLayer(loadConfig)  // or ZLayer.fromZIO(loadConfig)\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"resourceful-constructors",children:"Resourceful Constructors"}),"\n",(0,o.jsx)(n.p,{children:"Some components of our applications need to be scoped, meaning they undergo a resource acquisition phase before usage, and a resource release phase after usage (e.g. when the application shuts down). As we stated before, the construction of ZIO layers can be effectful and resourceful, this means they can be acquired and safely released when the services are done being utilized."}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"ZLayer"})," relies on the powerful ",(0,o.jsx)(n.code,{children:"Scope"})," data type and this makes this process extremely simple. We can lift any scoped ",(0,o.jsx)(n.code,{children:"ZIO"})," to ",(0,o.jsx)(n.code,{children:"ZLayer"})," by providing a scoped resource to the ",(0,o.jsx)(n.code,{children:"ZLayer.scoped"})," constructor:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import zio._\n\ncase class A(a: Int)\nobject A {\n  val layer: ZLayer[Any, Nothing, A] =\n    ZLayer.scoped {\n      ZIO.acquireRelease(acquire = ZIO.debug("Initializing A") *> ZIO.succeed(A(5)))(\n        release = _ => ZIO.debug("Releasing A")\n      )\n    }\n}\n\nobject ZIOApp extends ZIOAppDefault {\n  val myApp: ZIO[A, Nothing, Int] =\n    for {\n      a <- ZIO.serviceWith[A](_.a)\n    } yield a * a\n\n  def run =\n    myApp\n      .debug("result")\n      .provide(A.layer)\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"The output:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Initializing A\nresult: 25\nReleasing A\n"})}),"\n",(0,o.jsxs)(n.p,{children:["We can see that the ",(0,o.jsx)(n.code,{children:"A"})," service is initialized and carefull released when the application is shut down."]}),"\n",(0,o.jsx)(n.p,{children:"Here is another example that uses auto closeable resources:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport scala.io.BufferedSource\n\nval fileLayer: ZLayer[Any, Throwable, BufferedSource] =\n  ZLayer.scoped {\n    ZIO.fromAutoCloseable(\n      ZIO.attemptBlocking(scala.io.Source.fromFile("file.txt"))\n    )\n  }\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Finally, let's see a real-world example of creating a layer from scoped resources. Assume we have the following ",(0,o.jsx)(n.code,{children:"UserRepository"})," service:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio._\nimport scala.io.Source._\nimport java.io.{FileInputStream, FileOutputStream, Closeable}\n\ntrait DBConfig\ntrait Transactor\ntrait User\n\ndef dbConfig: Task[DBConfig] = ZIO.attempt(???)\ndef initializeDb(config: DBConfig): Task[Unit] = ZIO.attempt(???)\ndef makeTransactor(config: DBConfig): ZIO[Scope, Throwable, Transactor] = ZIO.attempt(???)\n\ntrait UserRepository {\n  def save(user: User): Task[Unit]\n}\n\ncase class UserRepositoryLive(xa: Transactor) extends UserRepository {\n  override def save(user: User): Task[Unit] = ZIO.attempt(???)\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Assume we have written a scoped ",(0,o.jsx)(n.code,{children:"UserRepository"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"def scoped: ZIO[Scope, Throwable, UserRepository] = \n  for {\n    cfg <- dbConfig\n    _   <- initializeDb(cfg)\n    xa  <- makeTransactor(cfg)\n  } yield new UserRepositoryLive(xa)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["We can convert that to ",(0,o.jsx)(n.code,{children:"ZLayer"})," with ",(0,o.jsx)(n.code,{children:"ZLayer.scoped"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"object UserRepositoyLive {\n  val layer : ZLayer[Any, Throwable, UserRepository] =\n    ZLayer.scoped(scoped)\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"asynchronous-constructors",children:"Asynchronous Constructors"}),"\n",(0,o.jsx)(n.p,{children:"We should avoid using blocking operations inside Scala constructors:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"class ProducerInput\n\nclass KafkaProducer(input: ProducerInput) {\n  def send(message: String): Unit = ???\n}\n\nobject KafkaProducer {\n  def apply() = {\n    // Blocking operation, we should avoid it inside constructors\n    val input = doSomeBlockingOperation()\n    new KafkaProducer(input)\n  }\n\n  private def doSomeBlockingOperation(): ProducerInput = ???\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["While with ",(0,o.jsx)(n.code,{children:"ZLayer"}),", we can easily use blocking operations:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nclass ProducerInput\n\nclass KafkaProducer(input: ProducerInput) {\n    def send(message: String): Task[Unit] = ???\n}\n\nobject KafkaProducer {\n  val layer =\n    ZLayer {\n      for {\n        input <- ZIO.attemptBlocking(doSomeBlockingOperation())\n      } yield (new KafkaProducer(input))\n    }\n\n  private def doSomeBlockingOperation(): ProducerInput = ???\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"parallel-constructors",children:"Parallel Constructors"}),"\n",(0,o.jsxs)(n.p,{children:["With ",(0,o.jsx)(n.code,{children:"Zlayer"})," all layers in the dependency graph are executed in parallel:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import zio._\n\ncase class A(a: Int)\nobject A {\n  val layer: ZLayer[Any, Nothing, A] =\n    ZLayer.fromZIO {\n      for {\n        _ <- ZIO.debug("Initializing A")\n        _ <- ZIO.sleep(3.seconds)\n        _ <- ZIO.debug("Initialized A")\n      } yield A(1)\n    }\n}\n\ncase class B(b: Int)\nobject B {\n  val layer: ZLayer[Any, Nothing, B] =\n    ZLayer.fromZIO {\n      for {\n        _ <- ZIO.debug("Initializing B")\n        _ <- ZIO.sleep(2.seconds)\n        _ <- ZIO.debug("Initialized B")\n      } yield B(2)\n    }\n}\n\nobject ZIOApp extends ZIOAppDefault {\n  val myApp: ZIO[A with B, Nothing, Int] =\n    for {\n      a <- ZIO.serviceWith[A](_.a)\n      b <- ZIO.serviceWith[B](_.b)\n    } yield a + b\n\n  def run =\n    myApp\n      .debug("result")\n      .provide(A.layer, B.layer)\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"The output:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Initializing A\nInitializing B\nInitialized B\nInitialized A\nresult: 3\n"})})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>i});var a=r(96540);const o={},t=a.createContext(o);function s(e){const n=a.useContext(t);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),a.createElement(t.Provider,{value:n},e.children)}}}]);