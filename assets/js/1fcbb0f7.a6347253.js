"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[4142],{81827:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>c,metadata:()=>i,toc:()=>r});const i=JSON.parse('{"id":"zio-prelude/functional-data-types/equivalence","title":"Equivalence","description":"An Equivalence[A, B] describes an equivalence relationship between two types A and B.","source":"@site/docs/zio-prelude/functional-data-types/equivalence.md","sourceDirName":"zio-prelude/functional-data-types","slug":"/zio-prelude/functional-data-types/equivalence","permalink":"/zio-prelude/functional-data-types/equivalence","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-prelude/functional-data-types/equivalence.md","tags":[],"version":"current","frontMatter":{"id":"equivalence","title":"Equivalence"},"sidebar":"ecosystem-sidebar","previous":{"title":"Functional Data Types","permalink":"/zio-prelude/functional-data-types/"},"next":{"title":"NonEmptyList","permalink":"/zio-prelude/functional-data-types/nonemptylist"}}');var s=t(74848),a=t(28453);const c={id:"equivalence",title:"Equivalence"},l=void 0,o={},r=[];function d(e){const n={code:"code",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["An ",(0,s.jsx)(n.code,{children:"Equivalence[A, B]"})," describes an equivalence relationship between two types ",(0,s.jsx)(n.code,{children:"A"})," and ",(0,s.jsx)(n.code,{children:"B"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["An equivalence relationship is defined in terms of two functions ",(0,s.jsx)(n.code,{children:"to"})," and ",(0,s.jsx)(n.code,{children:"from"})," that convert a value of type ",(0,s.jsx)(n.code,{children:"A"})," to a value of type ",(0,s.jsx)(n.code,{children:"B"})," and vice versa."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"case class Equivalence[A, B](to: A => B, from: B => A)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["To be a valid ",(0,s.jsx)(n.code,{children:"Equivalence"})," the functions ",(0,s.jsx)(n.code,{children:"to"})," and ",(0,s.jsx)(n.code,{children:"from"})," must satisfy an identity law, which says that for any value of type ",(0,s.jsx)(n.code,{children:"A"}),", if we transform it to a ",(0,s.jsx)(n.code,{children:"B"})," using ",(0,s.jsx)(n.code,{children:"to"})," and then back using ",(0,s.jsx)(n.code,{children:"from"})," we get the same value. The same property must also apply for the reverse."]}),"\n",(0,s.jsxs)(n.p,{children:["Simple examples of an equivalence relationship would be between an ",(0,s.jsx)(n.code,{children:"List[A]"})," and a ",(0,s.jsx)(n.code,{children:"Chunk[A]"}),". We can transform any ",(0,s.jsx)(n.code,{children:"List"})," into a ",(0,s.jsx)(n.code,{children:"Chunk"})," using the ",(0,s.jsx)(n.code,{children:"Chunk.fromIterable"})," operator, and we can transform any ",(0,s.jsx)(n.code,{children:"Chunk"})," into a ",(0,s.jsx)(n.code,{children:"List"})," using the ",(0,s.jsx)(n.code,{children:"toList"})," operator:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"import zio.Chunk\nimport zio.prelude.Equivalence\n\ndef listChunkEquivalence[A]: Equivalence[List[A], Chunk[A]] =\n  Equivalence(Chunk.fromIterable, _.toList)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This essentially represents the fact that ",(0,s.jsx)(n.code,{children:"List"})," and ",(0,s.jsx)(n.code,{children:"Chunk"})," contain the same information. They represent it in different ways internally and have different performance characteristics but both of them model zero or more values of some type ",(0,s.jsx)(n.code,{children:"A"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["We can see from the example above that the order of describing ",(0,s.jsx)(n.code,{children:"List"})," and ",(0,s.jsx)(n.code,{children:"Chunk"})," in the equivalence relationship was somewhat arbitrary. We could just as well have described this as an equivalence between ",(0,s.jsx)(n.code,{children:"Chunk[A]"})," and ",(0,s.jsx)(n.code,{children:"List[A]"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Equivalence"})," data type lets us express that through the ",(0,s.jsx)(n.code,{children:"flip"})," operator."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"def chunkListEquivalence[A]: Equivalence[Chunk[A], List[A]] =\n  listChunkEquivalence.flip\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In addition to being able to reverse equivalence relationships we can also compose them. If ",(0,s.jsx)(n.code,{children:"A"})," is equivalent to ",(0,s.jsx)(n.code,{children:"B"})," and ",(0,s.jsx)(n.code,{children:"B"})," is equivalent to ",(0,s.jsx)(n.code,{children:"C"})," then ",(0,s.jsx)(n.code,{children:"A"})," is equivalent to ",(0,s.jsx)(n.code,{children:"C"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["We can express this using the ",(0,s.jsx)(n.code,{children:"andThen"})," operator on ",(0,s.jsx)(n.code,{children:"Equivalence"})," or its symbolic alias ",(0,s.jsx)(n.code,{children:">>>"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["To demonstrate this let's define another equivalence relationship ",(0,s.jsx)(n.code,{children:"Vector[A]"})," and ",(0,s.jsx)(n.code,{children:"List[A]"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"def vectorListEquivalence[A]: Equivalence[Vector[A], List[A]] =\n  Equivalence(_.toList, _.toVector)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Given these two equivalence relationships we can then define an equivalence relationship between a ",(0,s.jsx)(n.code,{children:"Vector[A]"})," and a ",(0,s.jsx)(n.code,{children:"Chunk[A]"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"def vectorChunkEquivalence[A]: Equivalence[Vector[A], Chunk[A]] =\n  vectorListEquivalence.andThen(listChunkEquivalence)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This is not a particularly interesting example because we could have easily converted directly from ",(0,s.jsx)(n.code,{children:"Vector"})," to ",(0,s.jsx)(n.code,{children:"Chunk"})," in a more performant way without going through ",(0,s.jsx)(n.code,{children:"List"}),". But we can imagine that if ",(0,s.jsx)(n.code,{children:"A"}),", ",(0,s.jsx)(n.code,{children:"B"}),", and ",(0,s.jsx)(n.code,{children:"C"})," were equivalent but different representations of some more complex data type, being able to build up these conversions incrementally could be quite useful."]}),"\n",(0,s.jsxs)(n.p,{children:["Beyond this there are not a lot of operators on the ",(0,s.jsx)(n.code,{children:"Equivalence"})," data type itself. The main power of this data type is the ability to express the fact that two types are equivalent and capture this as a data type that we can test and reuse."]}),"\n",(0,s.jsxs)(n.p,{children:["In particular, if we have what we believe to be an equivalence relationship between two types ",(0,s.jsx)(n.code,{children:"A"})," and ",(0,s.jsx)(n.code,{children:"B"})," ZIO Prelude makes it easy for us to test this."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import zio.prelude.laws._\nimport zio.test._\nimport zio.test.laws._\n\nobject EquivalenceSpec extends ZIOSpecDefault {\n\n  def spec = suite("EquivalenceSpec") {\n    test("chunkListEquivalence") {\n      implicit val equivalence = listChunkEquivalence[Int]\n      val listGen = Gen.listOf(Gen.int)\n      val chunkGen = Gen.chunkOf(Gen.int)\n      checkAllLaws(EquivalenceLaws)(listGen, chunkGen)\n    }\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["ZIO Test will generate a large number of ",(0,s.jsx)(n.code,{children:"A"})," and ",(0,s.jsx)(n.code,{children:"B"})," values and check that the identity law holds. This can be helpful to catch corner cases where we think two things are equivalent, but they are really not."]}),"\n",(0,s.jsx)(n.p,{children:"With these equivalence relationships in hand we can then convert between different representations of our data in a straightforward and principled way. This is helpful when we need to implement higher level logic that needs to rely on this equivalence relationship existing between certain data types."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>l});var i=t(96540);const s={},a=i.createContext(s);function c(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);