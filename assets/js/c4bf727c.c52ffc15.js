"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[93019],{93572:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"zio-telemetry/opencensus","title":"OpenCensus","description":"OpenCensus is a stats collection and distributed tracing framework. Well known implementations are Jaeger","source":"@site/docs/zio-telemetry/opencensus.md","sourceDirName":"zio-telemetry","slug":"/zio-telemetry/opencensus","permalink":"/zio-telemetry/opencensus","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-telemetry/opencensus.md","tags":[],"version":"current","frontMatter":{"id":"opencensus","title":"OpenCensus"},"sidebar":"ecosystem-sidebar","previous":{"title":"OpenTracing Example","permalink":"/zio-telemetry/opentracing-example"},"next":{"title":"OpenTelemetry","permalink":"/zio-telemetry/opentelemetry"}}');var a=n(74848),i=n(28453);const s={id:"opencensus",title:"OpenCensus"},o=void 0,c={},l=[{value:"Installation",id:"installation",level:2},{value:"Usage",id:"usage",level:2}];function p(e){const t={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.p,{children:["OpenCensus is a stats collection and distributed tracing framework. Well known implementations are ",(0,a.jsx)(t.a,{href:"https://www.jaegertracing.io",children:"Jaeger"}),"\nand ",(0,a.jsx)(t.a,{href:"https://www.zipkin.io",children:"Zipkin"}),"."]}),"\n",(0,a.jsx)(t.h2,{id:"installation",children:"Installation"}),"\n",(0,a.jsx)(t.p,{children:"First, add the following dependency to your build.sbt:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:'"dev.zio" %% "zio-opencensus" % "<version>"\n'})}),"\n",(0,a.jsx)(t.h2,{id:"usage",children:"Usage"}),"\n",(0,a.jsxs)(t.p,{children:["To use ZIO Telemetry, you will need a ",(0,a.jsx)(t.code,{children:"Tracing"})," service in your environment. You also need to provide a ",(0,a.jsx)(t.code,{children:"tracer"})," implementation:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:'import zio.telemetry.opencensus.Tracing\nimport zio.telemetry.opencensus.implicits._\nimport zio._\nimport io.opencensus.trace.Status\n\nval tracerLayer = ZLayer.succeed(io.opencensus.trace.Tracing.getTracer)\n\nval errorMapper = ErrorMapper[Throwable] { case _ => Status.UNKNOWN }\n\nval app =\n  ZIO.serviceWithZIO[Tracing] { tracing =>\n    import tracing.aspects._\n\n    (for {\n      _       <- tracing.putAttributes(Map("foo" -> "bar"))\n      message <- Console.readline\n    } yield message) @@ root("/app")\n  }.provide(Tracing.live, tracerLayer)\n'})}),"\n",(0,a.jsxs)(t.p,{children:["After importing ",(0,a.jsx)(t.code,{children:"import tracing.aspects._"}),", additional ",(0,a.jsx)(t.code,{children:"ZIOAspect"})," combinators\non ",(0,a.jsx)(t.code,{children:"ZIO"}),"s are available to support starting child spans and adding attributes."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:'ZIO.serviceWithZIO[Tracing] { tracing =>\n  import tracing.aspects._\n  \n  // start a new root span and set some attributes\n  val zio1 = ZIO.unit @@ root("root span", attributes = ("foo", "bar))\n  // start a child of the current span\n  val zio2 = ZIO.unit @@ span("child span", attributes = Map.empty)\n}\n'})}),"\n",(0,a.jsx)(t.p,{children:"To propagate contexts across process boundaries, extraction and injection can be\nused. The current span context is injected into a carrier, which is passed\nthrough some side channel to the next process. There it is injected back and a\nchild span of it is started."}),"\n",(0,a.jsx)(t.p,{children:"Due to the use of the (mutable) OpenCensus carrier APIs, injection and extraction\nare not referentially transparent."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:'ZIO.serviceWithZIO[Tracing] { tracing =>\n  import tracing.aspects._\n  \n  val textFormat                           = Tracing.getPropagationComponent().getB3Format()\n  val carrier: mutable.Map[String, String] = mutable.Map().empty\n\n  val getter: TextFormat.Getter[mutable.Map[String, String]] = new TextFormat.Getter[mutable.Map[String, String]] {\n    override def keys(carrier: mutable.Map[String, String]): lang.Iterable[String] =\n      carrier.keys.asJava\n\n    override def get(carrier: mutable.Map[String, String], key: String): String =\n      carrier.get(key).orNull\n  }\n\n  val setter: TextFormat.Setter[mutable.Map[String, String]] = new TextFormat.Setter[mutable.Map[String, String]] {\n    override def put(carrier: mutable.Map[String, String], key: String, value: String): Unit =\n      carrier.update(key, value)\n  }\n  \n  val zio1 = tracing.inject(textFormat, carrier, setter) @@ \n    root("root span", attributes = Map.empty)\n  \n  val zio2 = ZIO.unit @@ \n    span("child span", attributes = Map(("foo", "bar"))) @@ \n    fromRootSpan(textFormat, carrier, getter, "foo", attributes = Map.empty)\n}\n'})})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>o});var r=n(96540);const a={},i=r.createContext(a);function s(e){const t=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);