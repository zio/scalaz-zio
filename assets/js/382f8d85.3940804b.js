"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[55019],{4475:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"caliban-deriving/index","title":"Introduction to Caliban Deriving","description":"Full-featured, robust deriving for Caliban.","source":"@site/docs/caliban-deriving/index.md","sourceDirName":"caliban-deriving","slug":"/caliban-deriving/","permalink":"/caliban-deriving/","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/caliban-deriving/index.md","tags":[],"version":"current","frontMatter":{"id":"index","title":"Introduction to Caliban Deriving","sidebar_label":"Caliban Deriving"},"sidebar":"ecosystem-sidebar","previous":{"title":"ZIO Ecosystem Official Libraries","permalink":"/ecosystem/officials/"},"next":{"title":"ZIO 2.x Interop Cats 2.x","permalink":"/zio2-interop-cats2/"}}');var t=n(74848),a=n(28453);const r={id:"index",title:"Introduction to Caliban Deriving",sidebar_label:"Caliban Deriving"},c=void 0,l={},d=[{value:"Getting started",id:"getting-started",level:2},{value:"Features",id:"features",level:2},{value:"Common features",id:"common-features",level:3},{value:"Case classes",id:"case-classes",level:3},{value:"Sealed traits",id:"sealed-traits",level:3},{value:"Traits",id:"traits",level:3},{value:"Using with effects",id:"using-with-effects",level:2},{value:"Mutations and subscriptions",id:"mutations-and-subscriptions",level:3}];function o(e){const i={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.p,{children:"Full-featured, robust deriving for Caliban."}),"\n",(0,t.jsxs)(i.p,{children:["The Caliban Deriving library provides an advanced derive macro for the ",(0,t.jsx)(i.a,{href:"https://github.com/ghostdogpr/caliban",children:"Caliban library"})," that seamlessly integrates with the built-in schema derivation system and allows the library users to not only derive the schema for the user defined case classes and enums but also for calculated fields and functions with parameters."]}),"\n",(0,t.jsx)(i.h2,{id:"getting-started",children:"Getting started"}),"\n",(0,t.jsxs)(i.p,{children:["Start by adding ",(0,t.jsx)(i.code,{children:"caliban-deriving"})," as a dependency to your project:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-scala",children:'libraryDependencies += "dev.zio" %% "caliban-deriving" % "0.0.1"\n'})}),"\n",(0,t.jsx)(i.p,{children:"Once the library is added, Caliban's default auto-derived schemas can be replaced one by one for each type by explicitly deriving its\nschema using the Caliban Deriving method:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-scala",children:"case class Example(value: Int)\nobject Example {\n    implicit lazy val exampleSchema: Schema[Any, Example] =\n      deriveSchemaInstance[Any, Example]\n}\n"})}),"\n",(0,t.jsxs)(i.p,{children:["Please read ",(0,t.jsx)(i.a,{href:"https://ghostdogpr.github.io/caliban/docs/schema.html#schemas",children:"Caliban's official documentation about schemas"})," to learn more about what a schema is and what features the core library provides."]}),"\n",(0,t.jsxs)(i.p,{children:["It is important that it is possible to use a ",(0,t.jsx)(i.em,{children:"mix"})," of Caliban's built-in schemas, auto-derived schemas and the ones provided by ",(0,t.jsx)(i.code,{children:"deriveSchemaInstance"}),". Both derive methods are looking for implicit instances of ",(0,t.jsx)(i.code,{children:"Schema"}),"."]}),"\n",(0,t.jsx)(i.h2,{id:"features",children:"Features"}),"\n",(0,t.jsxs)(i.p,{children:["Caliban Deriving's ",(0,t.jsx)(i.code,{children:"deriveSchemaInstance"})," function can be applied on the following Scala data types:"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.em,{children:"case classes"})}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.em,{children:"sealed traits"}),"  or Scala 3 ",(0,t.jsx)(i.em,{children:"enums"})]}),"\n",(0,t.jsxs)(i.li,{children:["any ",(0,t.jsx)(i.em,{children:"trait"})]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"common-features",children:"Common features"}),"\n",(0,t.jsx)(i.p,{children:"The following rules apply equally for case classes, sealed traits and traits."}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["public ",(0,t.jsx)(i.code,{children:"val"})," fields and parameterless ",(0,t.jsx)(i.code,{children:"def"})," methods are generated as GraphQL ",(0,t.jsx)(i.em,{children:"fields"}),". Their ",(0,t.jsx)(i.code,{children:"Schema"})," is found by an implicit search for the given type. This way it supports exactly the same cases as Caliban's built-in derive method, including fields of type ",(0,t.jsx)(i.code,{children:"ZIO"}),", ",(0,t.jsx)(i.code,{children:"ZQuery"})," and ",(0,t.jsx)(i.code,{children:"Future"}),"."]}),"\n",(0,t.jsxs)(i.li,{children:["public methods with one or more parameters are generated as GraphQL ",(0,t.jsx)(i.em,{children:"functions"}),". The ",(0,t.jsx)(i.code,{children:"Schema"})," of the function arguments is found by an implicit search for their type."]}),"\n",(0,t.jsx)(i.li,{children:"protected and private fields/methods are excluded"}),"\n",(0,t.jsxs)(i.li,{children:["public members annotated by ",(0,t.jsx)(i.code,{children:"@GQLExclude"})," are also excluded"]}),"\n",(0,t.jsxs)(i.li,{children:["the following core ",(0,t.jsx)(i.a,{href:"https://ghostdogpr.github.io/caliban/docs/schema.html#annotations",children:"Caliban annotations"})," are supported: ",(0,t.jsx)(i.code,{children:"@GQLName"}),", ",(0,t.jsx)(i.code,{children:"@GQLDescription"}),", ",(0,t.jsx)(i.code,{children:"@GQLDeprecated"})," and ",(0,t.jsx)(i.code,{children:"@GQLDirective"})]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"case-classes",children:"Case classes"}),"\n",(0,t.jsxs)(i.p,{children:["From ",(0,t.jsx)(i.em,{children:"case classes"})," a GraphQL ",(0,t.jsx)(i.code,{children:"type"})," is generated. If it is used as an input (as a parameter for a function in another type), then an GraphQL ",(0,t.jsx)(i.code,{children:"input"})," is generated which only contains the constructor parameters of the case class, not the other members."]}),"\n",(0,t.jsx)(i.h3,{id:"sealed-traits",children:"Sealed traits"}),"\n",(0,t.jsxs)(i.p,{children:["For ",(0,t.jsx)(i.em,{children:"sum types"})," (sealed trait with a set of case class / case objects implementations) if the base trait contains any methods, it will become a GraphQL ",(0,t.jsx)(i.code,{children:"interface"})," and each constuctor a ",(0,t.jsx)(i.code,{children:"type"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["If the base trait has no members, but the constructors have parameters, it becomes a GraphQL ",(0,t.jsx)(i.code,{children:"union"}),". Members of constructors are still handled the same way as mentioned above."]}),"\n",(0,t.jsxs)(i.p,{children:["If all the constructors are case objects then it becomes a GraphQL ",(0,t.jsx)(i.code,{children:"enum"}),"."]}),"\n",(0,t.jsx)(i.h3,{id:"traits",children:"Traits"}),"\n",(0,t.jsxs)(i.p,{children:["If the derivation is invoked on a simple trait (not ",(0,t.jsx)(i.code,{children:"sealed"}),") then it works as if it were a concrete parameterless ",(0,t.jsx)(i.em,{children:"case class"}),". This means a GraphQL ",(0,t.jsx)(i.code,{children:"type"})," is generated and a schema derived for an arbitrary trait can be used to serve any implementation of it."]}),"\n",(0,t.jsx)(i.h2,{id:"using-with-effects",children:"Using with effects"}),"\n",(0,t.jsxs)(i.p,{children:["When there are members of type ",(0,t.jsx)(i.code,{children:"ZIO"})," or ",(0,t.jsx)(i.code,{children:"ZQuery"}),", they can have an environment parameter (",(0,t.jsx)(i.code,{children:"-R"}),") that is not ",(0,t.jsx)(i.code,{children:"Any"}),". Effects and queries without environment just work."]}),"\n",(0,t.jsx)(i.p,{children:"When working with effects requiring an environment the following rules apply:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["You have to have the ",(0,t.jsx)(i.code,{children:"GenericSchema[R]"})," trait in scope as described ",(0,t.jsx)(i.a,{href:"https://ghostdogpr.github.io/caliban/docs/schema.html#effects",children:"in the official documentation"}),". This should be done by inheriting this trait in an object and putting all the additional derived implicits there."]}),"\n",(0,t.jsxs)(i.li,{children:["The implicit resolution in this case will only be correct if you put all the implicit instances derived with Caliban Deriving's ",(0,t.jsx)(i.code,{children:"deriveSchemaInstance"})," ",(0,t.jsx)(i.strong,{children:"directly into the object"})," extending ",(0,t.jsx)(i.code,{children:"GenericSchema"}),"."]}),"\n",(0,t.jsxs)(i.li,{children:["Although the macro can calculate the union of all the required environments used in a type, it is not automatically using it for the result ",(0,t.jsx)(i.code,{children:"Schema"}),". The reason is that you may want to derive schema for multiple data types, each using only a subset of the total environment passed to the ",(0,t.jsx)(i.code,{children:"GenericSchema"}),". In this case the full environment cannot be calculated inside the derivation. For this reason, you ",(0,t.jsx)(i.strong,{children:"must"})," provide the full required environment, the same that is passed to the ",(0,t.jsx)(i.code,{children:"GenericSchema"})," in scope, to the ",(0,t.jsx)(i.code,{children:"deriveSchemaInstance"})," method in its first type parameter."]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"mutations-and-subscriptions",children:"Mutations and subscriptions"}),"\n",(0,t.jsx)(i.p,{children:"Not supported yet."})]})}function h(e={}){const{wrapper:i}={...(0,a.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}},28453:(e,i,n)=>{n.d(i,{R:()=>r,x:()=>c});var s=n(96540);const t={},a=s.createContext(t);function r(e){const i=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function c(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(a.Provider,{value:i},e.children)}}}]);