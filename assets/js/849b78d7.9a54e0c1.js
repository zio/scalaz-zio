"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[46760],{38481:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"reference/di/dependency-injection-in-zio","title":"Getting Started With Dependency Injection in ZIO","description":"In this page, we will focus on essential parts of dependency injection in ZIO. So in some examples we are not going to cover all the best practices for writing ZIO services.","source":"@site/docs/reference/di/dependency-injection-in-zio.md","sourceDirName":"reference/di","slug":"/reference/di/dependency-injection-in-zio","permalink":"/reference/di/dependency-injection-in-zio","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/di/dependency-injection-in-zio.md","tags":[],"version":"current","frontMatter":{"id":"dependency-injection-in-zio","title":"Getting Started With Dependency Injection in ZIO","sidebar_label":"Getting Started"},"sidebar":"reference-sidebar","previous":{"title":"Constructor as a Value","permalink":"/reference/di/zlayer-constructor-as-a-value"},"next":{"title":"Building Dependency Graph","permalink":"/reference/di/building-dependency-graph"}}');var s=i(74848),c=i(28453);const r={id:"dependency-injection-in-zio",title:"Getting Started With Dependency Injection in ZIO",sidebar_label:"Getting Started"},o=void 0,a={},l=[{value:"Essential Steps of Dependency Injection in ZIO",id:"essential-steps-of-dependency-injection-in-zio",level:2},{value:"Step 1: Accessing Services From The ZIO Environment",id:"step-1-accessing-services-from-the-zio-environment",level:3},{value:"Step 2: Writing Application Logic Using Services",id:"step-2-writing-application-logic-using-services",level:3},{value:"Step 3: Building The Dependency Graph (Optional)",id:"step-3-building-the-dependency-graph-optional",level:3},{value:"Step 4: Providing Dependencies to the ZIO Environment",id:"step-4-providing-dependencies-to-the-zio-environment",level:3},{value:"Dependency Injection and Service Pattern",id:"dependency-injection-and-service-pattern",level:2},{value:"Dependency Injection When Writing Services",id:"dependency-injection-when-writing-services",level:3},{value:"Dependency Injection When Writing Services Using Interfaces",id:"dependency-injection-when-writing-services-using-interfaces",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",...(0,c.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.admonition,{type:"caution",children:[(0,s.jsx)(n.p,{children:"In this page, we will focus on essential parts of dependency injection in ZIO. So in some examples we are not going to cover all the best practices for writing ZIO services."}),(0,s.jsxs)(n.p,{children:["In real world applications, we encourage to use ",(0,s.jsx)(n.a,{href:"/reference/service-pattern/",children:"service pattern"})," to write ZIO services."]})]}),"\n",(0,s.jsx)(n.h2,{id:"essential-steps-of-dependency-injection-in-zio",children:"Essential Steps of Dependency Injection in ZIO"}),"\n",(0,s.jsx)(n.p,{children:"We can achieve dependency injection through these three simple steps:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Accessing services from the ZIO environment through the ",(0,s.jsx)(n.code,{children:"ZIO.serviceXYZ"})," operations."]}),"\n",(0,s.jsx)(n.li,{children:"Writing application logic using services and composing them together."}),"\n",(0,s.jsx)(n.li,{children:"Building the dependency graph using manual or automatic layer construction (optional)."}),"\n",(0,s.jsxs)(n.li,{children:["Providing dependencies to the ZIO environment through the ",(0,s.jsx)(n.code,{children:"ZIO.provideXYZ"})," operations."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"step-1-accessing-services-from-the-zio-environment",children:"Step 1: Accessing Services From The ZIO Environment"}),"\n",(0,s.jsxs)(n.p,{children:["To write application logic, we need to access services from the ZIO environment. We can do this by using the ",(0,s.jsx)(n.code,{children:"ZIO.serviceXYZ"})," operation."]}),"\n",(0,s.jsx)(n.p,{children:"For example, assume we have the following services:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nfinal class A {\n  def foo: UIO[String] = ZIO.succeed("Hello!")\n}\n\nfinal class B {\n  def bar: UIO[Int] = ZIO.succeed(42)\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["When we call ",(0,s.jsx)(n.code,{children:"ZIO.service[A]"}),", we are asking the ZIO environment for the ",(0,s.jsx)(n.code,{children:"A"})," service. So then we can access all the functionality of the ",(0,s.jsx)(n.code,{children:"A"})," service:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"val effect: ZIO[A, Nothing, String] =\n  for {\n    a <- ZIO.service[A] \n    r <- a.foo\n  } yield r\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The signature of the above effect, says that in order to produce a value of type ",(0,s.jsx)(n.code,{children:"String"}),", I need the ",(0,s.jsx)(n.code,{children:"A"})," service from the ZIO environment."]}),"\n",(0,s.jsxs)(n.p,{children:["We can also use ",(0,s.jsx)(n.code,{children:"ZIO.serviceWith"}),"/",(0,s.jsx)(n.code,{children:"ZIO.srviceWithZIO"})," to directly access one of the service functionalities:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"object A {\n  def foo: ZIO[A, Nothing, String] = ZIO.serviceWithZIO[A](_.foo) \n}\n\nobject B {\n  def bar: ZIO[B, Nothing, Int] = ZIO.serviceWithZIO[B](_.bar)\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"step-2-writing-application-logic-using-services",children:"Step 2: Writing Application Logic Using Services"}),"\n",(0,s.jsxs)(n.p,{children:["ZIO is a composable data type on its environment type parameter. So when we have an effect that requires the ",(0,s.jsx)(n.code,{children:"A"})," service, and also we have another effect that requires the ",(0,s.jsx)(n.code,{children:"B"})," service; when we compose these two services together, the resulting effect requires both ",(0,s.jsx)(n.code,{children:"A"})," and ",(0,s.jsx)(n.code,{children:"B"})," services:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"// Sequential Composition Example\nval myApp: ZIO[A with B, Nothing, (String, Int)] =\n  for {\n    a <- A.foo\n    b <- B.bar\n  } yield (a, b)\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"// Parallel Composition Example\nval myApp: ZIO[A with B, Nothing, (String, Int)] = A.foo <&> B.bar\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Now the ",(0,s.jsx)(n.code,{children:"myApp"})," effect requires ",(0,s.jsx)(n.code,{children:"A"})," and ",(0,s.jsx)(n.code,{children:"B"})," services to fulfill its functionality. We can see that we are writing application logic, we are not concerned about how services will be created! We are focused on using services to write the application logic."]}),"\n",(0,s.jsxs)(n.p,{children:["In the next step, we are going to build a dependency graph that holds two ",(0,s.jsx)(n.code,{children:"A"})," and ",(0,s.jsx)(n.code,{children:"B"})," services."]}),"\n",(0,s.jsx)(n.h3,{id:"step-3-building-the-dependency-graph-optional",children:"Step 3: Building The Dependency Graph (Optional)"}),"\n",(0,s.jsxs)(n.p,{children:["To be able to run our application, we need to build the dependency graph that it needs. This can be done using the ",(0,s.jsx)(n.code,{children:"ZLayer"})," data type. It allows us to build up the whole application's dependency graph by composing layers manually or automatically."]}),"\n",(0,s.jsx)(n.p,{children:"Assume each of these services has its own layer like the below:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"object A {\n  def foo: ZIO[A, Nothing, String] = \n    ZIO.serviceWithZIO[A](_.foo) \n  \n  val layer: ZLayer[Any, Nothing, A] = \n    ZLayer.succeed(new A) \n}\n\nobject B {\n  def bar: ZIO[B, Nothing, Int] = \n    ZIO.serviceWithZIO[B](_.bar)\n  \n  val layer: ZLayer[Any, Nothing, B] = \n    ZLayer.succeed(new B)\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In the previous example, the ",(0,s.jsx)(n.code,{children:"myApp"})," application requires the ",(0,s.jsx)(n.code,{children:"A"})," and ",(0,s.jsx)(n.code,{children:"B"})," services. We can build that manually by composing two ",(0,s.jsx)(n.code,{children:"A"})," and ",(0,s.jsx)(n.code,{children:"B"})," layers horizontally:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"val appLayer: ZLayer[Any, Nothing, A with B] = \n  A.layer ++ B.layer\n"})}),"\n",(0,s.jsx)(n.p,{children:"Or we can use automatic layer construction:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"val appLayer: ZLayer[Any, Nothing, A with B] =\n  ZLayer.make[A with B](A.layer, B.layer)\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"Automatic layer construction is useful when the dependency graph is large and complex. So in simple cases, it doesn't demonstrate the power of automatic layer construction."})}),"\n",(0,s.jsx)(n.h3,{id:"step-4-providing-dependencies-to-the-zio-environment",children:"Step 4: Providing Dependencies to the ZIO Environment"}),"\n",(0,s.jsxs)(n.p,{children:["To run our application, we need to provide (inject) all dependencies to the ZIO environment. This can be done by using one of the ",(0,s.jsx)(n.code,{children:"ZIO.provideXYZ"})," operations. This allows us to propagate dependencies from button to top:"]}),"\n",(0,s.jsxs)(n.p,{children:["Let's provide our application with the ",(0,s.jsx)(n.code,{children:"appLayer"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"val result: ZIO[Any, Nothing, (String, Int)] = myApp.provideLayer(appLayer)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Here the ",(0,s.jsx)(n.code,{children:"ZLayer"})," data types act as a dependency/environment eliminator. By providing required dependencies to our ZIO application, ",(0,s.jsx)(n.code,{children:"ZLayer"})," eliminates all dependencies from the environment of our application."]}),"\n",(0,s.jsx)(n.p,{children:"That's it! Now we can run our application:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run = result\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Usually, when we use automatic layer construction, we skip the second step and instead provide all dependencies directly to the ",(0,s.jsx)(n.code,{children:"ZIO.provide"})," operation. It takes care of building the dependency graph and providing the dependency graph to our ZIO application:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run = myApp.provide(A.layer, B.layer)\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"dependency-injection-and-service-pattern",children:"Dependency Injection and Service Pattern"}),"\n",(0,s.jsx)(n.h3,{id:"dependency-injection-when-writing-services",children:"Dependency Injection When Writing Services"}),"\n",(0,s.jsx)(n.p,{children:"When writing services, we might want to use other services. In such cases, we would like dependent services injected into our service. This is where we need to use dependency injection in order to write services."}),"\n",(0,s.jsx)(n.p,{children:"In ZIO, when we write services, we use class constructors to pass dependencies to the service. This is similar to the object-oriented style."}),"\n",(0,s.jsxs)(n.p,{children:["For example, assume we have written the following ",(0,s.jsx)(n.code,{children:"A"})," and ",(0,s.jsx)(n.code,{children:"B"})," services:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nfinal class A {\n  def foo: ZIO[Any, Nothing, String] = ZIO.succeed("Hello!")\n}\n\nobject A {\n  def foo: ZIO[A, Nothing, String] = ZIO.serviceWithZIO[A](_.foo)\n\n  val layer: ZLayer[Any, Nothing, A] = ZLayer.succeed(new A)\n}\n\nfinal class B {\n  def bar: ZIO[Any, Nothing, Int] = ZIO.succeed(42)\n}\n\nobject B {\n  def bar: ZIO[B, Nothing, Int] = ZIO.serviceWithZIO[B](_.bar)\n\n  val layer: ZLayer[Any, Nothing, B] = ZLayer.succeed(new B)\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["In order to write a service that depends on ",(0,s.jsx)(n.code,{children:"A"})," and ",(0,s.jsx)(n.code,{children:"B"})," services, we use the class constructor to pass dependencies to our service:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"final case class C(a: A, b: B) {\n  def baz: ZIO[Any, Nothing, Unit] =\n    for {\n      _ <- a.foo\n      _ <- b.bar\n    } yield ()\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["To write a layer for our ",(0,s.jsx)(n.code,{children:"C"})," service, we can use ",(0,s.jsx)(n.code,{children:"ZIO.service"})," to access dependent services effectfully and pass them to the service's constructor:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"object C {\n  def baz: ZIO[C, Nothing, Unit] = ZIO.serviceWithZIO[C](_.baz)\n\n  val layer: ZLayer[A with B, Nothing, C] =\n    ZLayer {\n      for {\n        a <- ZIO.service[A]\n        b <- ZIO.service[B]\n      } yield C(a, b)\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Now, assume we have the following application logic:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"val myApp: ZIO[A with B with C, Nothing, Unit] =\n  for {\n    _ <- A.foo\n    _ <- C.baz\n  } yield ()\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In order to run the application, we should provide the ",(0,s.jsx)(n.code,{children:"A"}),", ",(0,s.jsx)(n.code,{children:"B"})," and ",(0,s.jsx)(n.code,{children:"C"})," services:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run = myApp.provide(A.layer, B.layer, C.layer)\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"dependency-injection-when-writing-services-using-interfaces",children:"Dependency Injection When Writing Services Using Interfaces"}),"\n",(0,s.jsx)(n.p,{children:"Although dependency injection is not about coding to the interface, it is a good pattern to have testable and configurable programs."}),"\n",(0,s.jsxs)(n.p,{children:["When we code to the interface, our application logic will not dependent on any concrete implementation. So we can replace implementations, without changing the application. This is what ",(0,s.jsx)(n.a,{href:"/reference/service-pattern/",children:"Service Pattern"})," encourages us when writing services."]}),"\n",(0,s.jsxs)(n.p,{children:["Let's try an example. Assume we want to implement service ",(0,s.jsx)(n.code,{children:"C"})," which is implemented in terms of ",(0,s.jsx)(n.code,{children:"A"})," and ",(0,s.jsx)(n.code,{children:"B"})," services. We want to keep our code modular and testable."]}),"\n",(0,s.jsx)(n.p,{children:"The first step is to define interfaces for each service. This gives us the contract for how our services work together and lets us figure out our architecture and divide and conquer:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"import zio._\n\ntrait A {\n  def foo: ZIO[Any, Nothing, Int]\n}\n\ntrait B {\n  def bar: ZIO[Any, Nothing, String]\n}\n\ntrait C {\n  def baz: ZIO[Any, Nothing, Unit]\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"The next step is to create implementations of our services taking their dependencies as constructor parameters. It's just constructor-based dependency injection:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'final case class ALive() extends A {\n  def foo = ZIO.succeed(42)\n}\n\nfinal case class BLive() extends B {\n  def bar: ZIO[Any, Nothing, String] = ZIO.succeed("Hello!")\n}\n\nfinal case class CLive(a: A, b: B) extends C {\n  def baz: ZIO[Any, Nothing, Unit] =\n    for {\n      _ <- a.foo\n      _ <- b.bar\n    } yield ()\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Now, we need to create layers for each of our implementations. This lets ZIO automatically wire them together. It also lets us take care of any setup or teardown. We use ",(0,s.jsx)(n.code,{children:"ZIO.service"})," to grab things from the environment:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",metastring:"modc:silent",children:"import zio._\n\nobject ALive {\n  val layer: ZLayer[Any, Nothing, ALive] = ZLayer.succeed(ALive())\n}\n\nobject BLive {\n  val layer: ZLayer[Any, Nothing, BLive] = ZLayer.succeed(BLive())\n}\n\nobject CLive {\n  val layer: ZLayer[B with A, Nothing, CLive] =\n    ZLayer {\n      for {\n        a <- ZIO.service[A]\n        b <- ZIO.service[B]\n      } yield CLive(a, b)\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Finally, it is time to write our application logic in terms of our services.  We use ",(0,s.jsx)(n.code,{children:"ZIO.service"})," once more in our main application to actually access the service that contains our main application logic and call it:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nval myApp: ZIO[A with C, Nothing, Unit] =\n  for {\n    a <- ZIO.service[A]\n    _ <- a.foo\n    c <- ZIO.service[C]\n    _ <- c.baz\n  } yield ()\n"})}),"\n",(0,s.jsx)(n.p,{children:"To make our services more ergonomic, it is better to write an accessor method for each capability of our services. We put them in the companion object of the service interfaces:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"object A {\n  def foo: ZIO[A, Nothing, Int] = ZIO.serviceWithZIO[A](_.foo)\n}\n\nobject B {\n  def bar = ZIO.serviceWithZIO[B](_.bar)\n}\n\nobject C {\n  def baz: ZIO[C, Nothing, Unit] = ZIO.serviceWithZIO[C](_.baz)\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Let's rewrite the previous application logic with accessor methods:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nval myApp: ZIO[A with C, Nothing, Unit] =\n  for {\n    _ <- A.foo\n    _ <- C.baz\n  } yield ()\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Now, in order to run our application, we wire all of our services together with ",(0,s.jsx)(n.code,{children:"ZIO#provide"})," and inject them to our application:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run = myApp.provide(\n    ALive.layer,\n    BLive.layer,\n    CLive.layer\n  )\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["For any purpose, if we decided to use another implementation for the ",(0,s.jsx)(n.code,{children:"A"})," service, we can replace it easily without changing our application logic:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nfinal case class ACustom() extends A {\n  def foo = ZIO.succeed(84)\n}\n\nobject ACustom {\n  val layer: ZLayer[Any, Nothing, A] = ZLayer.succeed(ACustom())\n}\n\nobject MainApp extends ZIOAppDefault {\n  def run = myApp.provide(\n    ACustom.layer,\n    BLive.layer,\n    CLive.layer\n  )\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"Following is a summary of some essential points when using dependency injection in ZIO:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"For each service, we should write a layer that contains the recipe for creating the service."}),"\n",(0,s.jsxs)(n.li,{children:["We use class constructors to pass dependencies to our services. So inside the service, it is not idiomatic to use ",(0,s.jsx)(n.code,{children:"ZIO.service"})," to access dependent services."]}),"\n",(0,s.jsxs)(n.li,{children:["When writing a layer for a service that is dependent on other services, we use ",(0,s.jsx)(n.code,{children:"ZIO.service"})," to access required services from the environment and then pass them to the service's constructor."]}),"\n",(0,s.jsx)(n.li,{children:"We use layers to compose and wire them together to create the dependency graph."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>o});var t=i(96540);const s={},c=t.createContext(s);function r(e){const n=t.useContext(c);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(c.Provider,{value:n},e.children)}}}]);