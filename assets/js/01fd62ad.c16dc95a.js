"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[79743],{18930:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"zio-prelude/functional-abstractions/parameterized-types/associativeboth","title":"AssociativeBoth","description":"AssociativeBoth[F] describes a way of combining two values F[A] and F[B] into a value F[(A, B)] that is associative.","source":"@site/docs/zio-prelude/functional-abstractions/parameterized-types/associativeboth.md","sourceDirName":"zio-prelude/functional-abstractions/parameterized-types","slug":"/zio-prelude/functional-abstractions/parameterized-types/associativeboth","permalink":"/zio-prelude/functional-abstractions/parameterized-types/associativeboth","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-prelude/functional-abstractions/parameterized-types/associativeboth.md","tags":[],"version":"current","frontMatter":{"id":"associativeboth","title":"AssociativeBoth"},"sidebar":"ecosystem-sidebar","previous":{"title":"Introduction","permalink":"/zio-prelude/functional-abstractions/parameterized-types/"},"next":{"title":"AssociativeEither","permalink":"/zio-prelude/functional-abstractions/parameterized-types/associativeeither"}}');var i=t(74848),s=t(28453);const o={id:"associativeboth",title:"AssociativeBoth"},r=void 0,c={},d=[];function l(e){const n={code:"code",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"AssociativeBoth[F]"})," describes a way of combining two values ",(0,i.jsx)(n.code,{children:"F[A]"})," and ",(0,i.jsx)(n.code,{children:"F[B]"})," into a value ",(0,i.jsx)(n.code,{children:"F[(A, B)]"})," that is associative."]}),"\n",(0,i.jsx)(n.p,{children:"Its signature is:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"trait AssociativeBoth[F[_]] {\n  def both[A, B](fa: => F[A], fb: => F[B]): F[(A, B)]\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If we import ",(0,i.jsx)(n.code,{children:"zio.prelude._"})," we can use the ",(0,i.jsx)(n.code,{children:"zip"})," operator or its symbolic alias ",(0,i.jsx)(n.code,{children:"<*>"})," to combine any two values of a parameterized type ",(0,i.jsx)(n.code,{children:"F"})," that have an ",(0,i.jsx)(n.code,{children:"AssociativeBoth"})," instance defined for them."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"both"})," operator must be associative, so if we combine ",(0,i.jsx)(n.code,{children:"fa"})," and ",(0,i.jsx)(n.code,{children:"fb"})," with ",(0,i.jsx)(n.code,{children:"both"})," and then combine the result with ",(0,i.jsx)(n.code,{children:"fc"})," we must get the same value as if we combine ",(0,i.jsx)(n.code,{children:"fb"})," and ",(0,i.jsx)(n.code,{children:"fc"})," and then combine ",(0,i.jsx)(n.code,{children:"fa"})," with the result. That is, after reassociating nested tuples:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"(fa <*> fb) <*> fc === fa <*> (fb <*> fc)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Notice that this is the same as the associative law for concrete types described by the ",(0,i.jsx)(n.code,{children:"Associative"})," abstraction, just lifted into the context of parameterized types."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"both"})," operator corresponds to running the left value and then running the right value."]}),"\n",(0,i.jsxs)(n.p,{children:["We can see this because to produce a tuple ",(0,i.jsx)(n.code,{children:"(A, B)"})," we need to run both the left value and the right value and to do it in a way that is associative we need to do it in a consistent order. Technically running the right value and then running the left value would also be associative but since we can always flip the order of the arguments it is helpful to adopt the convention that the first value goes on the left and the second value goes on the right."]}),"\n",(0,i.jsxs)(n.p,{children:["For example, in the context of ",(0,i.jsx)(n.code,{children:"ZIO"})," the ",(0,i.jsx)(n.code,{children:"zip"})," operator returns a new ",(0,i.jsx)(n.code,{children:"ZIO"})," workflow that describes running the workflow on the left, then running the workflow on the right, and then returning a tuple of their results."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nimport java.io.IOException\n\nval helloZIO: ZIO[Console, IOException, Unit] =\n  Console.printLine("Hello") <*> Console.printLine("ZIO")\n// helloZIO: ZIO[Console, IOException, Unit] = FlatMap(\n//   trace = "repl.MdocSession.MdocApp0.helloZIO(associativeboth.md:26)",\n//   first = Stateful(\n//     trace = "repl.MdocSession.MdocApp0.helloZIO(associativeboth.md:26)",\n//     onState = zio.FiberRef$unsafe$$anon$2$$Lambda$17011/0x00000008046a1840@bcb8c1d\n//   ),\n//   successK = zio.ZIO$$Lambda$17013/0x00000008046a3040@41d38b64\n// )\n'})}),"\n",(0,i.jsxs)(n.p,{children:["This will print ",(0,i.jsx)(n.code,{children:"Hello"})," to the console on the first line and then ",(0,i.jsx)(n.code,{children:"ZIO"})," on the second line."]}),"\n",(0,i.jsx)(n.p,{children:"If the first workflow fails then the second workflow will never be run."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'val failZIO: ZIO[Console, IOException, Unit] =\n  ZIO.fail(new IOException("Fail")) <*> Console.printLine("ZIO")\n// failZIO: ZIO[Console, IOException, Unit] = FlatMap(\n//   trace = "repl.MdocSession.MdocApp0.failZIO(associativeboth.md:33)",\n//   first = FlatMap(\n//     trace = "repl.MdocSession.MdocApp0.failZIO(associativeboth.md:33)",\n//     first = GenerateStackTrace(\n//       trace = "repl.MdocSession.MdocApp0.failZIO(associativeboth.md:33)"\n//     ),\n//     successK = zio.ZIO$$$Lambda$17015/0x00000008046a4840@6dd4a4cc\n//   ),\n//   successK = zio.ZIO$$Lambda$17013/0x00000008046a3040@60a1880c\n// )\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Now ",(0,i.jsx)(n.code,{children:"ZIO"})," will never be printed to the console."]}),"\n",(0,i.jsx)(n.p,{children:"What it means to run the left value and run the right value will vary between data types."}),"\n",(0,i.jsxs)(n.p,{children:["For example, for ",(0,i.jsx)(n.code,{children:"Either"})," and ",(0,i.jsx)(n.code,{children:"Option"})," it corresponds to running the left value and then running the right value if the left value is a success."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"def both[E, A, B](fa: => Either[E, A], fb: => Either[E, B]): Either[E, (A, B)] =\n  fa match {\n    case Left(e)  => Left(e)\n    case Right(a) => fb match {\n      case Left(e)  => Left(e)\n      case Right(b) => Right((a, b))\n    }\n  }\n\ndef both[E, A, B](fa: => Option[A], fb: => Option[B]): Option[(A, B)] =\n  fa match {\n    case None    => None\n    case Some(a) =>\n      fb match {\n        case None    => None\n        case Some(b) => Some((a, b))\n      }\n  }\n"})}),"\n",(0,i.jsx)(n.p,{children:"For collection types it corresponds to the Cartesian product of the left and right values."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"def both[A, B](fa: => List[A], fb: => List[B]): List[(A, B)] =\n  for {\n    a <- fa\n    b <- fb\n  } yield (a, b)\n"})}),"\n",(0,i.jsx)(n.p,{children:"If we think of a collection as representing a set of possible states then we can see this as the set of all possible states from taking each element in the left collection and then combining it with each element in the right collection."}),"\n",(0,i.jsx)(n.p,{children:"For a parser it corresponds to running the left parser and then running the right parser with the updated state if the first parser succeeds."}),"\n",(0,i.jsxs)(n.p,{children:["So far we have been using covariant types that produced values in our example, but there is no reason we have to limit ourselves to that. The ",(0,i.jsx)(n.code,{children:"AssociativeBoth"})," functional abstraction can describe associative ways of combining contravariant and invariant parameterized types as well."]}),"\n",(0,i.jsx)(n.p,{children:"This is a significant advantage over other functional programming libraries, which conflate abstractions for describing ways of combining paramaterized types with abstractions for describing the variance of parameterized types. This requires defining many additional interfaces to try to accomplish the same thing and obscures the fundamental symmetry of the underlying structure here."}),"\n",(0,i.jsxs)(n.p,{children:["To see this, let's start with a ",(0,i.jsx)(n.code,{children:"Predicate"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"trait Predicate[-A] {\n  def run(a: A): Boolean\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.code,{children:"Predicate"})," is naturally contravariant in the ",(0,i.jsx)(n.code,{children:"A"})," type parameter because ",(0,i.jsx)(n.code,{children:"A"})," appears as an input to ",(0,i.jsx)(n.code,{children:"run"})," but never as an output. We can prove that to ourselves by implementing a ",(0,i.jsx)(n.code,{children:"contramap"})," operator for ",(0,i.jsx)(n.code,{children:"Predicate"})," like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"trait Predicate[-A] { self =>\n  def run(a: A): Boolean\n  def contramap[B](f: B => A): Predicate[B] =\n    new Predicate[B] {\n      def run(b: B): Boolean =\n        self.run(f(b))\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["We would like to be able to combine predicates so that if we have predicates about types ",(0,i.jsx)(n.code,{children:"A"})," and ",(0,i.jsx)(n.code,{children:"B"})," we can combine them into a predicate about the tuple ",(0,i.jsx)(n.code,{children:"(A, B)"}),". Especially in combination with the ",(0,i.jsx)(n.code,{children:"contramap"})," operator, which we could use to transform a predicate about a tuple to a predicate about a class class, we could then define predicates about user defined data types in terms of predicates about primitive types."]}),"\n",(0,i.jsxs)(n.p,{children:["We can do that with ",(0,i.jsx)(n.code,{children:"AssociativeBoth"})," like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"import zio.prelude._\n\nobject Predicate {\n  implicit val PredicateAssociativeBoth: AssociativeBoth[Predicate] =\n    new AssociativeBoth[Predicate] {\n      def both[A, B](left: => Predicate[A], right: => Predicate[B]): Predicate[(A, B)] =\n        new Predicate[(A, B)] {\n          def run(tuple: (A, B)): Boolean =\n            left.run(tuple._1) && right.run(tuple._2)\n        }\n    }\n\n  implicit val PredicateContravariant: Contravariant[Predicate] =\n    new Contravariant[Predicate] {\n      def contramap[A, B](f: B => A): Predicate[A] => Predicate[B] =\n        _.contramap(f)\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Here what the ",(0,i.jsx)(n.code,{children:"both"})," operator means is to run the left predicate and then if it passes to run the right predicate."]}),"\n",(0,i.jsx)(n.p,{children:"When the parameterized type is covariant there are some additional useful operators we can define for it."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"def zipWith[F[+_]: AssociativeBoth : Covariant, A, B, C](\n  fa: => F[A],\n  fb: => F[B]\n)(f: (A, B) => C): F[C] =\n  fa.zip(fb).map(f.tupled)\n\ndef zipLeft[F[+_]: AssociativeBoth : Covariant, A, B, C](\n  fa: => F[A],\n  fb: => F[B]\n): F[A] =\n  zipWith(fa, fb)((a, _) => a)\n  \ndef zipRight[F[+_]: AssociativeBoth : Covariant, A, B, C](\n  fa: => F[A],\n  fb: => F[B]\n): F[B] =\n  zipWith(fa, fb)((_, b) => b)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"zipWith"})," operator uses ",(0,i.jsx)(n.code,{children:"zip"})," to combine two parameterized types and then ",(0,i.jsx)(n.code,{children:"map"})," to combine the outputs with a function. For example, we can generate two random numbers with ",(0,i.jsx)(n.code,{children:"ZIO"})," and then combine their results by adding them."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"zipLeft"})," and ",(0,i.jsx)(n.code,{children:"zipRight"})," operators and their symbolic aliases ",(0,i.jsx)(n.code,{children:"<*"})," and ",(0,i.jsx)(n.code,{children:"*>"})," are specialized variants of this that throw away the left or right results. These are useful when we want to include a value of a parameterized type in the larger data type we are building but don't care about its result."]}),"\n",(0,i.jsxs)(n.p,{children:["For example, we could avoid creating unnecessary nested tuples when we combine ",(0,i.jsx)(n.code,{children:"ZIO"})," workflows like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'val helloFromAssociativeBoth: ZIO[Console, IOException, Unit] =\n  Console.printLine("Hello") *>\n    Console.printLine("From") *>\n    Console.printLine("AssociativeBoth")\n// helloFromAssociativeBoth: ZIO[Console, IOException, Unit] = FlatMap(\n//   trace = "repl.MdocSession.MdocApp0.<local MdocApp0>.helloFromAssociativeBoth(associativeboth.md:145)",\n//   first = FlatMap(\n//     trace = "repl.MdocSession.MdocApp0.<local MdocApp0>.helloFromAssociativeBoth(associativeboth.md:144)",\n//     first = Stateful(\n//       trace = "repl.MdocSession.MdocApp0.<local MdocApp0>.helloFromAssociativeBoth(associativeboth.md:144)",\n//       onState = zio.FiberRef$unsafe$$anon$2$$Lambda$17011/0x00000008046a1840@1e22810c\n//     ),\n//     successK = zio.ZIO$$Lambda$17016/0x00000008046a6040@59b3dd5b\n//   ),\n//   successK = zio.ZIO$$Lambda$17016/0x00000008046a6040@7a4ea39\n// )\n'})}),"\n",(0,i.jsxs)(n.p,{children:["There is also a variant of ",(0,i.jsx)(n.code,{children:"zipWith"})," for contravariant types called ",(0,i.jsx)(n.code,{children:"bothWith"})," that combines ",(0,i.jsx)(n.code,{children:"zip"})," and ",(0,i.jsx)(n.code,{children:"contramap"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"def bothWith[F[-_]: AssociativeBoth : Contravariant, A, B, C](\n  fa: => F[A],\n  fb: => F[B]\n)(f: C => (A, B)): F[C] =\n  fa.zip(fb).contramap(f)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Notice again the symmetry here between the ",(0,i.jsx)(n.code,{children:"zipWith"})," and ",(0,i.jsx)(n.code,{children:"bothWith"})," operators."]}),"\n",(0,i.jsxs)(n.p,{children:["With this we can combine contravariant data types such as ",(0,i.jsx)(n.code,{children:"Predicate"})," the same way we can with covariant data types."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'case class Email(lines: List[String], sender: String)\n\nval noSuspiciousWords: Predicate[List[String]] =\n  new Predicate[List[String]] {\n    def run(words: List[String]): Boolean =\n      !words.exists(_.contains("get rich"))\n  }\n// noSuspiciousWords: Predicate[List[String]] = repl.MdocSession$MdocApp0$$anon$5@10164dac\n\nval noSuspiciousSender: Predicate[String] =\n  new Predicate[String] {\n    def run(sender: String): Boolean =\n      !sender.contains("unclaimedfunds")\n  }\n// noSuspiciousSender: Predicate[String] = repl.MdocSession$MdocApp0$$anon$6@2baa7f75\n\nval spamFilter: Predicate[Email] =\n  noSuspiciousWords.bothWith(noSuspiciousSender) { \n    case Email(lines, sender) => (lines, sender)\n  }\n// spamFilter: Predicate[Email] = repl.MdocSession$MdocApp0$Predicate$1$$anon$1@63b03aae\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The composed predicate will extract the lines and the sender, sending the lines to the ",(0,i.jsx)(n.code,{children:"nonSuspiciousWords"})," predicate and then if it passes sending the sender to the ",(0,i.jsx)(n.code,{children:"nonSuspiciousSender"})," predicate."]}),"\n",(0,i.jsxs)(n.p,{children:["We can use the ",(0,i.jsx)(n.code,{children:"bothWith"})," operator with other contravariant types as well. For example, we could combine two sinks to produce a new sink that sends all inputs first to one sink and then to the other."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"AssociativeBoth"})," functional abstraction describes a very basic pattern of running one value and then running another value. In addition, the operators that can be defined in terms of it such as ",(0,i.jsx)(n.code,{children:"zip"})," and ",(0,i.jsx)(n.code,{children:"zipWith"})," are very common and practically useful."]}),"\n",(0,i.jsxs)(n.p,{children:["If you are working with data types from ZIO or the Scala standard library the value you get from the ",(0,i.jsx)(n.code,{children:"AssociativeBoth"})," abstraction itself may be limited because most of these data types already define these operators directly since they are so useful."]}),"\n",(0,i.jsxs)(n.p,{children:["However, there are some cases where these operators are missing such as the ",(0,i.jsx)(n.code,{children:"zip"})," operator on ",(0,i.jsx)(n.code,{children:"Either"}),". In these cases if you bring in ZIO Prelude you will get these missing operators automatically, which can help clean up your code."]}),"\n",(0,i.jsxs)(n.p,{children:["If you are defining your own parameterized data type then asking if you can define an ",(0,i.jsx)(n.code,{children:"AssociativeBoth"})," instance for it can be a very helpful exercise."]}),"\n",(0,i.jsxs)(n.p,{children:["Associative ways of combining are fundamental to building up more complex structures from simpler ones, so if your data type does not support an associative combining operation it can be worth asking why that is and if there is a way it could be refactored to support such an operation. If it does, defining an ",(0,i.jsx)(n.code,{children:"AssociativeBoth"})," instance will get you a lot of useful operators, especially in combination with the ",(0,i.jsx)(n.code,{children:"Covariant"})," or ",(0,i.jsx)(n.code,{children:"Contravariant"})," and ",(0,i.jsx)(n.code,{children:"ForEach"})," abstractions from ZIO Prelude."]}),"\n",(0,i.jsxs)(n.p,{children:["Finally, if you are doing generic programming with the abstractions in ZIO Prelude then ",(0,i.jsx)(n.code,{children:"AssociativeBoth"})," will again be an important operator to describe running one value and then another in a generic way. The orthagonal way that abstractions are described in ZIO Prelude can be particularly valuable here to help you avoid confusing unrelated concepts and describe your shared structure in as general a way as possbile."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var a=t(96540);const i={},s=a.createContext(i);function o(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);