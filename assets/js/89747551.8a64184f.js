"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[50993],{28453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>a});var t=i(96540);const o={},s=t.createContext(o);function r(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(s.Provider,{value:n},e.children)}},38554:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"reference/contextual/zio-environment-use-cases","title":"ZIO Environment Use-cases","description":"ZIO Environment allows us to describe workflows which carry some context that is used in the course of executing the workflow. This context can be dived into two categories:","source":"@site/docs/reference/contextual/zio-environment-use-cases.md","sourceDirName":"reference/contextual","slug":"/reference/contextual/zio-environment-use-cases","permalink":"/reference/contextual/zio-environment-use-cases","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/contextual/zio-environment-use-cases.md","tags":[],"version":"current","frontMatter":{"id":"zio-environment-use-cases","title":"ZIO Environment Use-cases"},"sidebar":"reference-sidebar","previous":{"title":"ZEnvironment","permalink":"/reference/contextual/zenvironment"},"next":{"title":"ZLayer","permalink":"/reference/contextual/zlayer"}}');var o=i(74848),s=i(28453);const r={id:"zio-environment-use-cases",title:"ZIO Environment Use-cases"},a=void 0,c={},l=[{value:"Local Capabilities",id:"local-capabilities",level:2},{value:"1. Local Contexts",id:"1-local-contexts",level:3},{value:"2. Type-level Reasoning",id:"2-type-level-reasoning",level:3},{value:"Business Logic",id:"business-logic",level:2},{value:"Everything as a Service",id:"everything-as-a-service",level:3},{value:"Using ZIO Environment",id:"using-zio-environment",level:3}];function h(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"ZIO Environment allows us to describe workflows which carry some context that is used in the course of executing the workflow. This context can be dived into two categories:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Local Capabilities, e.g. scopes and transactions"}),"\n",(0,o.jsx)(n.li,{children:"Business Logic, e.g. services and repositories"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Let's discuss each of these in turn."}),"\n",(0,o.jsx)(n.h2,{id:"local-capabilities",children:"Local Capabilities"}),"\n",(0,o.jsx)(n.p,{children:"The most idiomatic use of the ZIO environment is for:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:'Describing as values workflows that use capabilities that are "local" to a particular context'}),"\n",(0,o.jsx)(n.li,{children:"Where tracking the use of this context at the type level is helpful for reasoning about programs"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["Let's look at ",(0,o.jsx)(n.a,{href:"/reference/resource/scope",children:(0,o.jsx)(n.code,{children:"Scope"})}),", which I would say is the most idiomatic usage of the environment in ZIO itself, to see what each of these mean:"]}),"\n",(0,o.jsx)(n.h3,{id:"1-local-contexts",children:"1. Local Contexts"}),"\n",(0,o.jsxs)(n.p,{children:['The first criteria is that a capability be "local" to a particular context and not shared throughout the entire application. For example, in the case of ',(0,o.jsx)(n.code,{children:"Scope"})," we typically don't just have one scope for our entire application but many smaller scopes, such as the scope for using a particular file. Usages of local context also have an operator that allows locally eliminating this capability, such as the ",(0,o.jsx)(n.code,{children:"ZIO.scoped"})," operator which transforms a ",(0,o.jsx)(n.code,{children:"ZIO[R with Scope, E, A]"})," to a ",(0,o.jsx)(n.code,{children:"ZIO[R, E, A]"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["Other potential examples of this would be the ",(0,o.jsx)(n.a,{href:"/reference/state-management/zstate",children:(0,o.jsx)(n.code,{children:"ZState"})})," data type in ZIO, which describes some local use of state and is eliminated by the ",(0,o.jsx)(n.code,{children:"ZIO.stateful"})," operator, a ",(0,o.jsx)(n.code,{children:"Transaction"})," representing the usage of a database transaction, or the context of a particular HTTP request (",(0,o.jsx)(n.code,{children:"RequestContext"}),")."]}),"\n",(0,o.jsxs)(n.p,{children:["Notice that using the environment type allows workflows that require these capabilities to be first class values that ",(0,o.jsx)(n.strong,{children:"compose naturally"})," and can have their own operators for working with them, which would not be possible if we defined them as methods that required us to explicitly pass around these capabilities."]}),"\n",(0,o.jsx)(n.h3,{id:"2-type-level-reasoning",children:"2. Type-level Reasoning"}),"\n",(0,o.jsxs)(n.p,{children:["The second criteria is that tracking the usage of this context be helpful for reasoning about programs. We can also use a ",(0,o.jsx)(n.a,{href:"/reference/state-management/fiberref",children:(0,o.jsx)(n.code,{children:"FiberRef"})})," value to maintain some local context. However, when we do so, our usage of that context is not reflected at the type level."]}),"\n",(0,o.jsx)(n.p,{children:"For example, when we log something it will use a variety of contextual information including the current log level, the current log span, and the current log annotations but none of this is reflected at the type level:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"object ZIO {\n  def log(message: => String)(implicit trace: Trace): ZIO[Any, Nothing, Unit]\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"Not reflecting this usage of contextual information at the type level can be both an advantage and a disadvantage:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"The advantage is that it can create a simpler API because we do not clutter up the environment with additional dependencies."}),"\n",(0,o.jsx)(n.li,{children:"The disadvantage is that we can't track at the type level whether we are using contextual information or whether we have provided it."}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"In the case of logging this is clearly the right trade-off. Logging is a low level concern that we don't want to require us to update our type signatures, and there is essentially no harm in running a ZIO workflow that does logging without providing this log context since we can just log at some default log level without any log spans or annotations."}),"\n",(0,o.jsxs)(n.p,{children:["In contrast, in the case of ",(0,o.jsx)(n.code,{children:"Scope"})," there is tremendous value in reflecting the use of ",(0,o.jsx)(n.code,{children:"Scope"})," at the type level so we know whether a workflow is resourceful and can have operators that reflect at the type level that we have provided a ",(0,o.jsx)(n.code,{children:"Scope"})," to part of our application. Similarly if we have a ",(0,o.jsx)(n.strong,{children:"database transaction"}),' reflecting at the type level that some workflow needs to be done as part of a transaction and when we are "executing" a transaction is extremely valuable.']}),"\n",(0,o.jsx)(n.h2,{id:"business-logic",children:"Business Logic"}),"\n",(0,o.jsxs)(n.p,{children:["The other potential use of the ZIO environment is describing the dependencies of our business logic itself. Normally, we implement higher level services in terms of lower level services using ",(0,o.jsx)(n.a,{href:"/reference/di/",children:"constructor based dependency injection with ZLayer"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio._\n\ntrait HighLevelService {\n  def doSomething: ZIO[Any, Nothing, Unit]\n}\n\nobject HighLevelService {\n  val live: ZLayer[LowLevelService, Nothing, HighLevelService] =\n    ZLayer.fromFunction(HighLevelServiceLive(_))\n\n  final case class HighLevelServiceLive(lowLevelService: LowLevelService) extends HighLevelService {\n    def doSomething: ZIO[Any, Nothing, Unit] =\n      ??? // implemented in terms of `LowLevelService`\n  }\n}\n\ntrait LowLevelService {\n  def doSomethingElse: ZIO[Any, Nothing, Unit]\n}\n\nobject LowLevelService {\n  val live: ZLayer[Any, Nothing, LowLevelService] = ???\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This allows us to avoid using ",(0,o.jsx)(n.code,{children:"LowLevelService"}),' in the environment and to not "leak" implementation details, since the dependency on ',(0,o.jsx)(n.code,{children:"LowLevelService"})," is an implementation detail of ",(0,o.jsx)(n.code,{children:"HighLevelService"})," that might not even exist if ",(0,o.jsx)(n.code,{children:"HighLevelService"})," is refactored."]}),"\n",(0,o.jsxs)(n.p,{children:["However, the question arises then of how we should work with ",(0,o.jsx)(n.code,{children:"HighLevelService"}),' in the core of our business logic or the center of the "onion" in the ',(0,o.jsx)(n.a,{href:"/reference/architecture/architectural-patterns#onion-architecture",children:"onion architecture"}),"?"]}),"\n",(0,o.jsx)(n.p,{children:"There are two approaches to this."}),"\n",(0,o.jsx)(n.h3,{id:"everything-as-a-service",children:"Everything as a Service"}),"\n",(0,o.jsx)(n.p,{children:"The first approach is just that everything is a service:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"sealed trait ApplicationService {\n  def run: ZIO[Any, Nothing, Unit]\n}\n\nobject ApplicationService {\n  val live: ZLayer[Any, Nothing, LowLevelService] = ???\n  \n  final case class ApplicationServiceLive(highLevelService: HighLevelService) extends ApplicationService {\n    val run: ZIO[Any, Nothing, Unit] = ??? // business logic implemented in terms of high level services\n  }\n}\n\nobject Main extends ZIOAppDefault {\n  val run =\n    ZIO\n      .serviceWithZIO[ApplicationService](_.run)\n      .provide(\n        ApplicationService.live,\n        HighLevelService.live,\n        LowLevelService.live\n      )\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This style avoids any usage of the ZIO environment that is not a local capability except for possibly a single time within ",(0,o.jsx)(n.code,{children:"ZIOAppDefault"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"using-zio-environment",children:"Using ZIO Environment"}),"\n",(0,o.jsxs)(n.p,{children:["There can be a feeling that defining this final ",(0,o.jsx)(n.code,{children:"ApplicationLevelService"})," is unnecessary, and we would like to be able to write our business logic in terms of high level services directly without making it another service:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nobject Main extends ZIOAppDefault {\n\n  val myProgramLogic: ZIO[HighLevelService, Nothing, Unit] =\n    for {\n      _ <- ZIO.serviceWithZIO[HighLevelService](_.doSomething)\n      - <- otherLogicHere\n    } yield ()\n\n  val run =\n    myProgramLogic.provide(\n      HighLevelSevice.live,\n      LowLevelService.live\n    )\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:['There has been some movement towards the "everything is a service" approach since it avoids the need to implement ',(0,o.jsx)(n.a,{href:"/reference/service-pattern/accessor-methods",children:"service accessors"})," but it can be a matter of team style which of these approaches to use. Either way our program is the same except for whether in our business logic we call methods on services directly or use the environment for that."]}),"\n",(0,o.jsxs)(n.p,{children:["To learn more about this approach please see ",(0,o.jsx)(n.a,{href:"/reference/di/dependency-injection-in-zio#dependency-injection-and-service-pattern",children:"how we can use dependency injection with the service pattern"}),"."]})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}}}]);