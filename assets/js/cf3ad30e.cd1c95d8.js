"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[32302],{77270:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"reference/error-management/types/fatals","title":"Fatal Errors","description":"In ZIO on the JVM platform, the VirtualMachineError and all its subtypes are the only errors considered fatal by the ZIO runtime. So if during the running application, the JVM throws any of these errors like StackOverflowError, the ZIO runtime considers it as a catastrophic fatal error. So it will interrupt the whole application immediately without safe resource interruption. None of the ZIO#catchAll and ZIO#catchAllDefects can catch these fatal errors. At most, if we set the Runtime.setReportFatal, the application will log the stack trace before interrupting the entire application.","source":"@site/docs/reference/error-management/types/fatals.md","sourceDirName":"reference/error-management/types","slug":"/reference/error-management/types/fatals","permalink":"/reference/error-management/types/fatals","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/error-management/types/fatals.md","tags":[],"version":"current","frontMatter":{"id":"fatals","title":"Fatal Errors"},"sidebar":"reference-sidebar","previous":{"title":"Defects","permalink":"/reference/error-management/types/defects"},"next":{"title":"Imperative vs. Declarative","permalink":"/reference/error-management/imperative-vs-declarative"}}');var a=r(74848),o=r(28453);const i={id:"fatals",title:"Fatal Errors"},s=void 0,l={},c=[];function p(e){const t={code:"code",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.p,{children:["In ZIO on the JVM platform, the ",(0,a.jsx)(t.code,{children:"VirtualMachineError"})," and all its subtypes are the only errors considered fatal by the ZIO runtime. So if during the running application, the JVM throws any of these errors like ",(0,a.jsx)(t.code,{children:"StackOverflowError"}),", the ZIO runtime considers it as a catastrophic fatal error. So it will interrupt the whole application immediately without safe resource interruption. None of the ",(0,a.jsx)(t.code,{children:"ZIO#catchAll"})," and ",(0,a.jsx)(t.code,{children:"ZIO#catchAllDefects"})," can catch these fatal errors. At most, if we set the ",(0,a.jsx)(t.code,{children:"Runtime.setReportFatal"}),", the application will log the stack trace before interrupting the entire application."]}),"\n",(0,a.jsx)(t.p,{children:"Here is an example of manually creating a fatal error. Although we are ignoring all expected and unexpected errors, the fatal error interrupts the whole application:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    ZIO\n      .attempt(\n        throw new StackOverflowError(\n          "The call stack pointer exceeds the stack bound."\n        )\n      )\n      .catchAll(_ => ZIO.unit)       // ignoring all expected errors\n      .catchAllDefect(_ => ZIO.unit) // ignoring all unexpected errors\n}\n'})}),"\n",(0,a.jsx)(t.p,{children:"The output will be something like this:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:"java.lang.StackOverflowError: The call stack pointer exceeds the stack bound.\nat zio.examples.MainApp$.$anonfun$run$1(MainApp.scala:10)\nat zio.ZIO$.liftedTree1$1(ZIO.scala:2603)\nat zio.ZIO$.$anonfun$attempt$1(ZIO.scala:2603)\nat zio.ZIO$.$anonfun$isFatalWith$1(ZIO.scala:3571)\nat zio.internal.FiberContext.runUntil(FiberContext.scala:410)\nat zio.internal.FiberContext.run(FiberContext.scala:111)\nat zio.Runtime.unsafeRunWithRefs(Runtime.scala:400)\n  ...\n**** WARNING ****\nCatastrophic error encountered. Application not safely interrupted. Resources may be leaked. Check the logs for more details and consider overriding `Runtime.reportFatal` to capture context.\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Note that we can change the default way to report fatal errors using ",(0,a.jsx)(t.code,{children:"Runtime#reportFatal"})," or the ",(0,a.jsx)(t.code,{children:"Runtime.setReportFatal"})," layer."]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}},28453:(e,t,r)=>{r.d(t,{R:()=>i,x:()=>s});var n=r(96540);const a={},o=n.createContext(a);function i(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);