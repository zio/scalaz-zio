"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[97495],{2948:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"reference/error-management/best-practices/logging-errors","title":"Don\'t Reflexively Log Errors","description":"In modern async concurrent applications with a lot of subsystems, if we do not type errors, we are not able to see what section of our code fails with what error. Therefore, this can be very tempting to log errors when they happen. So when we lose type-safety in the whole application it makes us be more sensitive and program defensively. Therefore, whenever we are calling an API we tend to catch its errors, log them as below:","source":"@site/docs/reference/error-management/best-practices/logging-errors.md","sourceDirName":"reference/error-management/best-practices","slug":"/reference/error-management/best-practices/logging-errors","permalink":"/reference/error-management/best-practices/logging-errors","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/error-management/best-practices/logging-errors.md","tags":[],"version":"current","frontMatter":{"id":"logging-errors","title":"Don\'t Reflexively Log Errors"},"sidebar":"reference-sidebar","previous":{"title":"Don\'t Type Unexpected Errors","permalink":"/reference/error-management/best-practices/unexpected-errors"},"next":{"title":"Examples","permalink":"/reference/error-management/examples"}}');var o=t(74848),a=t(28453);const s={id:"logging-errors",title:"Don't Reflexively Log Errors"},i=void 0,l={},c=[];function d(e){const r={code:"code",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(r.p,{children:"In modern async concurrent applications with a lot of subsystems, if we do not type errors, we are not able to see what section of our code fails with what error. Therefore, this can be very tempting to log errors when they happen. So when we lose type-safety in the whole application it makes us be more sensitive and program defensively. Therefore, whenever we are calling an API we tend to catch its errors, log them as below:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-scala",children:'import zio._\n\nsealed trait UploadError extends Exception\ncase class FileExist(name: String)          extends UploadError\ncase class FileNotExist(name: String)       extends UploadError\ncase class StorageLimitExceeded(limit: Int) extends UploadError\n\n/**\n * This API fail with `FileExist` failure when the provided file name exist.\n */\ndef upload(name: String): Task[Unit] = {\n    if (...)\n      ZIO.fail(FileExist(name))\n    else if (...)\n      ZIO.fail(StorageLimitExceeded(limit)) // This error is undocumented unintentionally\n    else\n      ZIO.attempt(...)\n}\n\nupload("contacts.csv").catchAll {\n  case FileExist(name) => delete("contacts.csv") *> upload("contacts.csv")\n  case _ =>\n    for {\n      _ <- ZIO.log(error.toString) // logging the error\n      _ <- ZIO.fail(error) // failing again (just like rethrowing exceptions in OOP)\n    } yield ()\n}\n'})}),"\n",(0,o.jsxs)(r.p,{children:["In the above code when we see the ",(0,o.jsx)(r.code,{children:"upload"}),"'s return type we can't find out what types of error it may fail with. So as a programmer we need to read the API documentation, and see in what cases it may fail. Due to the fact that the documents may be outdated, and they may not provide all error cases, we tend to add another case to cover all the other errors. Expert developers may prefer to read the implementation to find out all expected errors, but it is a tedious task to do."]}),"\n",(0,o.jsx)(r.p,{children:"We don't want to lose any errors. So if we do not use typed errors, it makes us defensive to log every error, regardless of whether they will occur or not."}),"\n",(0,o.jsx)(r.p,{children:"When we are programming with typed errors, that allows us to never lose any errors. Even if we don't handle all, the error channel of our effect type demonstrate the type of remaining errors:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-scala",children:'val myApp: ZIO[Any, UploadError, Unit] =\n  upload("contacts.csv")\n    .catchSome {\n      case FileExist(name) => delete(name) *> upload(name)\n    }\n'})}),"\n",(0,o.jsx)(r.p,{children:"It is still going to be sent an unhandled error type as a result. Therefore, there is no way to lose any errors, and they propagate automatically through all the different subsystems in our application, which means we don't have to be fearful anymore. It will be handled by higher-level code, or if it doesn't it will be passed off to something that can."}),"\n",(0,o.jsxs)(r.p,{children:["If we handle all errors using ",(0,o.jsx)(r.code,{children:"ZIO#catchAll"})," the type of error channel become ",(0,o.jsx)(r.code,{children:"Nothing"})," which means there is no expected error remaining to handle:"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-scala",children:'val myApp: ZIO[Any, Nothing, Unit] =\n  upload("contacts.csv")\n    .catchAll {\n      case FileExist(name) =>\n        ZIO.unit // handling FileExist error case\n      case StorageLimitExceeded(limit) =>\n        ZIO.unit // handling StorageLimitExceeded error case\n    }\n'})}),"\n",(0,o.jsx)(r.p,{children:"When we type errors, we know that they can't be lost. So typed errors give us the ability to log less."})]})}function h(e={}){const{wrapper:r}={...(0,a.R)(),...e.components};return r?(0,o.jsx)(r,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,r,t)=>{t.d(r,{R:()=>s,x:()=>i});var n=t(96540);const o={},a=n.createContext(o);function s(e){const r=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),n.createElement(a.Provider,{value:r},e.children)}}}]);