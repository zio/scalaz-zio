"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[70018],{28453:(e,t,a)=>{a.d(t,{R:()=>n,x:()=>r});var i=a(96540);const o={},s=i.createContext(o);function n(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:n(e.components),i.createElement(s.Provider,{value:t},e.children)}},84576:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>l,frontMatter:()=>n,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"zio-schema/operations/schema-serialization","title":"Serialization of the Schema Itself","description":"In distributed systems, we often need to move computations to data instead of moving data to computations. The data is big and the network is slow, so moving it is expensive and sometimes impossible due to the volume of data. So in distributed systems, we would like to move our functions to the data and apply the data to the functions and gather the results back.","source":"@site/docs/zio-schema/operations/serialization-of-the-schema-itself.md","sourceDirName":"zio-schema/operations","slug":"/zio-schema/operations/schema-serialization","permalink":"/zio-schema/operations/schema-serialization","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-schema/operations/serialization-of-the-schema-itself.md","tags":[],"version":"current","frontMatter":{"id":"schema-serialization","title":"Serialization of the Schema Itself","sidebar_label":"Schema Serialization"},"sidebar":"ecosystem-sidebar","previous":{"title":"Schema Migration","permalink":"/zio-schema/operations/schema-migration"},"next":{"title":"Dynamic Data Representation","permalink":"/zio-schema/operations/dynamic-data-representation"}}');var o=a(74848),s=a(28453);const n={id:"schema-serialization",title:"Serialization of the Schema Itself",sidebar_label:"Schema Serialization"},r=void 0,c={},h=[];function d(e){const t={code:"code",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"In distributed systems, we often need to move computations to data instead of moving data to computations. The data is big and the network is slow, so moving it is expensive and sometimes impossible due to the volume of data. So in distributed systems, we would like to move our functions to the data and apply the data to the functions and gather the results back."}),"\n",(0,o.jsxs)(t.p,{children:["So we need a way to serialize our computations and send them through the network. In ZIO Schema, each schema itself has a schema, so we can treat the structure as pure data! we can serialize our schemas by calling the ",(0,o.jsx)(t.code,{children:"serializable"})," method:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:"sealed trait Schema[A] {\n  def serializable: Schema[Schema[A]]\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["By calling this method, we can get the schema of a schema. So we can serialize it and send it across the wire, and it can be deserialized on the other side. After deserializing it, we have a schema that is isomorphic to the original schema. So all the operations that we can perform on the original type ",(0,o.jsx)(t.code,{children:"A"}),", we can perform on any value that is isomorphic to ",(0,o.jsx)(t.code,{children:"A"})," on the other side."]})]})}function l(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);