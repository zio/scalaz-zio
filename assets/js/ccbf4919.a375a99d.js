"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[52162],{28453:(e,r,n)=>{n.d(r,{R:()=>s,x:()=>i});var t=n(96540);const a={},o=t.createContext(a);function s(e){const r=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(o.Provider,{value:r},e.children)}},63841:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"overview/handling-errors","title":"Handling Errors","description":"ZIO effects may fail due to foreseen or unforeseen problems. In order to help you build robust applications, ZIO tracks foreseen errors at compile-time, letting you know which effects can fail, and how they can fail. For non-recoverable problems, ZIO gives you full insight into the cause of failures (even if unexpected or catastrophic), preserving all information and automatically logging unhandled errors.","source":"@site/docs/overview/handling-errors.md","sourceDirName":"overview","slug":"/overview/handling-errors","permalink":"/overview/handling-errors","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/overview/handling-errors.md","tags":[],"version":"current","frontMatter":{"id":"handling-errors","title":"Handling Errors"},"sidebar":"overview_sidebar","previous":{"title":"Basic Operations","permalink":"/overview/basic-operations"},"next":{"title":"Handling Resources","permalink":"/overview/handling-resources"}}');var a=n(74848),o=n(28453);const s={id:"handling-errors",title:"Handling Errors"},i=void 0,l={},c=[{value:"Either",id:"either",level:2},{value:"Catching All Errors",id:"catching-all-errors",level:2},{value:"Catching Some Errors",id:"catching-some-errors",level:2},{value:"Fallback",id:"fallback",level:2},{value:"Folding",id:"folding",level:2},{value:"Retrying",id:"retrying",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const r={a:"a",code:"code",em:"em",h2:"h2",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(r.p,{children:"ZIO effects may fail due to foreseen or unforeseen problems. In order to help you build robust applications, ZIO tracks foreseen errors at compile-time, letting you know which effects can fail, and how they can fail. For non-recoverable problems, ZIO gives you full insight into the cause of failures (even if unexpected or catastrophic), preserving all information and automatically logging unhandled errors."}),"\n",(0,a.jsx)(r.p,{children:"In this section, you will learn about some of the tools ZIO gives you to build applications with robust error management."}),"\n",(0,a.jsx)(r.h2,{id:"either",children:"Either"}),"\n",(0,a.jsxs)(r.p,{children:["With the ",(0,a.jsx)(r.code,{children:"ZIO#either"})," method, you can transform an effect that fails into an infallible effect that places both failure and success into Scala's ",(0,a.jsx)(r.code,{children:"Either"})," type. This brings the error from the error channel to the success channel, which is useful because many ZIO operators work on the success channel, not the error channel."]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-scala",children:'val zeither: ZIO[Any, Nothing, Either[String, Nothing]] = \n  ZIO.fail("Uh oh!").either\n'})}),"\n",(0,a.jsx)(r.h2,{id:"catching-all-errors",children:"Catching All Errors"}),"\n",(0,a.jsxs)(r.p,{children:["If you want to catch and recover from all types of recoverable errors and effectfully attempt recovery, then you can use the ",(0,a.jsx)(r.code,{children:"catchAll"})," method, which lets you specify an error handler that returns the effect to execute in the event of an error:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-scala",children:'val z: ZIO[Any, IOException, Array[Byte]] = \n  openFile("primary.json").catchAll { error => \n    for {\n      _    <- ZIO.logErrorCause("Could not open primary file", Cause.fail(error))\n      file <- openFile("backup.json")\n    } yield file \n  }\n'})}),"\n",(0,a.jsxs)(r.p,{children:["In the error handler passed to ",(0,a.jsx)(r.code,{children:"catchAll"}),", you may return an effect with a ",(0,a.jsx)(r.em,{children:"different"})," error type (perhaps ",(0,a.jsx)(r.code,{children:"Nothing"}),", if the error handler cannot fail), which is then reflected in the type of effect returned by ",(0,a.jsx)(r.code,{children:"catchAll"}),"."]}),"\n",(0,a.jsx)(r.h2,{id:"catching-some-errors",children:"Catching Some Errors"}),"\n",(0,a.jsxs)(r.p,{children:["If you want to catch and recover from only some types of recoverable errors and effectfully attempt recovery, then you can use the ",(0,a.jsx)(r.code,{children:"catchSome"})," method:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-scala",children:'val data: ZIO[Any, IOException, Array[Byte]] = \n  openFile("primary.data").catchSome {\n    case _ : FileNotFoundException => \n      openFile("backup.data")\n  }\n'})}),"\n",(0,a.jsxs)(r.p,{children:["Unlike ",(0,a.jsx)(r.code,{children:"catchAll"}),", ",(0,a.jsx)(r.code,{children:"catchSome"})," cannot reduce or eliminate the error type, although it can widen the error type to a broader class of errors."]}),"\n",(0,a.jsx)(r.h2,{id:"fallback",children:"Fallback"}),"\n",(0,a.jsxs)(r.p,{children:["You can try one effect or if it fails, try another effect with the ",(0,a.jsx)(r.code,{children:"orElse"})," combinator:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-scala",children:'val primaryOrBackupData: ZIO[Any, IOException, Array[Byte]] = \n  openFile("primary.data").orElse(openFile("backup.data"))\n'})}),"\n",(0,a.jsx)(r.h2,{id:"folding",children:"Folding"}),"\n",(0,a.jsxs)(r.p,{children:["In the Scala standard library, the data types ",(0,a.jsx)(r.code,{children:"Option"})," and ",(0,a.jsx)(r.code,{children:"Either"})," have a ",(0,a.jsx)(r.code,{children:"fold"})," method, which lets you handle both failure and success cases at the same time."]}),"\n",(0,a.jsxs)(r.p,{children:["In a similar fashion, ",(0,a.jsx)(r.code,{children:"ZIO"})," effects also have several methods that allow you to handle both failure and success at the same time."]}),"\n",(0,a.jsxs)(r.p,{children:["The first fold method, ",(0,a.jsx)(r.code,{children:"fold"}),", lets you separately convert both failure and success into some common type:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-scala",children:'lazy val DefaultData: Array[Byte] = Array(0, 0)\n\nval primaryOrDefaultData: ZIO[Any, Nothing, Array[Byte]] = \n  openFile("primary.data").fold(\n    _    => DefaultData, // Failure case\n    data => data)        // Success case\n'})}),"\n",(0,a.jsxs)(r.p,{children:["The second fold method, ",(0,a.jsx)(r.code,{children:"foldZIO"}),", lets you separately handle both failure and success by specifying effects that will be executed in each respective case:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-scala",children:'val primaryOrSecondaryData: ZIO[Any, IOException, Array[Byte]] = \n  openFile("primary.data").foldZIO(\n    _    => openFile("secondary.data"), // Error handler\n    data => ZIO.succeed(data))          // Success handler\n'})}),"\n",(0,a.jsxs)(r.p,{children:["The ",(0,a.jsx)(r.code,{children:"foldZIO"})," method is almost the most powerful error recovery method in ZIO, with only ",(0,a.jsx)(r.code,{children:"foldCauseZIO"})," being more powerful. Most other operators, such as ",(0,a.jsx)(r.code,{children:"either"})," or ",(0,a.jsx)(r.code,{children:"orElse"}),", are implemented in terms of these powerful methods."]}),"\n",(0,a.jsxs)(r.p,{children:["In the following additional example, ",(0,a.jsx)(r.code,{children:"foldZIO"})," is used to handle both the failure and the success of the ",(0,a.jsx)(r.code,{children:"readUrls"})," method:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-scala",children:'val urls: ZIO[Any, Nothing, Content] =\n  readUrls("urls.json").foldZIO(\n    error   => ZIO.succeed(Content.NoContent(error)), \n    success => fetchContent(success)\n  )\n'})}),"\n",(0,a.jsx)(r.h2,{id:"retrying",children:"Retrying"}),"\n",(0,a.jsx)(r.p,{children:"In order to deal with transient errors, which are the norm when interacting with external cloud systems, ZIO provides very powerful retry mechanisms."}),"\n",(0,a.jsxs)(r.p,{children:["One of these mechanisms is the ",(0,a.jsx)(r.code,{children:"ZIO#retry"})," method, which takes a ",(0,a.jsx)(r.code,{children:"Schedule"}),", and returns a new effect that will retry the original effect if it fails, according to the specified schedule:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-scala",children:'val retriedOpenFile: ZIO[Any, IOException, Array[Byte]] = \n  openFile("primary.data")\n      .retry(Schedule.recurs(5))\n'})}),"\n",(0,a.jsxs)(r.p,{children:["The next most powerful function is ",(0,a.jsx)(r.code,{children:"ZIO#retryOrElse"}),", which allows specification of a fallback to use if the effect does not succeed with the specified policy:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-scala",children:'val retryOpenFile: ZIO[Any, IOException, DefaultData) = \n  openFile("primary.data")\n      .retryOrElse(Schedule.recurs(5), (_, _) => ZIO.succeed(DefaultData))\n'})}),"\n",(0,a.jsxs)(r.p,{children:["For more information on how to build schedules, see the documentation on ",(0,a.jsx)(r.a,{href:"/reference/schedule/",children:"Schedule"}),"."]}),"\n",(0,a.jsx)(r.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,a.jsxs)(r.p,{children:["If you are comfortable with basic error handling, including applying simple retry logic to effects, the next step is to learn about safe ",(0,a.jsx)(r.a,{href:"/overview/handling-resources",children:"resource handling"}),"."]})]})}function h(e={}){const{wrapper:r}={...(0,o.R)(),...e.components};return r?(0,a.jsx)(r,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);