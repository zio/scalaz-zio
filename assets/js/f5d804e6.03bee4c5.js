"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[50221],{23217:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>a,contentTitle:()=>n,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>p});const i=JSON.parse('{"id":"zio-optics/effectual-optics","title":"Effectual Optics","description":"In addition to \\"pure\\" optics like the ones discussed so far ZIO Optics supports optics where getting and setting involve ZIO or STM effects. This allows using optics to work with ZIO data structures such as TMap.","source":"@site/docs/zio-optics/effectual-optics.md","sourceDirName":"zio-optics","slug":"/zio-optics/effectual-optics","permalink":"/zio-optics/effectual-optics","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-optics/effectual-optics.md","tags":[],"version":"current","frontMatter":{"id":"effectual-optics","title":"Effectual Optics"},"sidebar":"ecosystem-sidebar","previous":{"title":"Using Optics","permalink":"/zio-optics/using-optics"},"next":{"title":"ZIO Parser","permalink":"/zio-parser/"}}');var o=s(74848),c=s(28453);const r={id:"effectual-optics",title:"Effectual Optics"},n=void 0,a={},p=[];function l(e){const t={code:"code",p:"p",pre:"pre",...(0,c.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:['In addition to "pure" optics like the ones discussed so far ZIO Optics supports optics where getting and setting involve ',(0,o.jsx)(t.code,{children:"ZIO"})," or ",(0,o.jsx)(t.code,{children:"STM"})," effects. This allows using optics to work with ZIO data structures such as ",(0,o.jsx)(t.code,{children:"TMap"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["These optics work exactly the same way as pure optics except that instead of the getter and setter returning an ",(0,o.jsx)(t.code,{children:"Either"})," they return a ",(0,o.jsx)(t.code,{children:"ZIO"})," or an ",(0,o.jsx)(t.code,{children:"STM"})," value."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:"import zio._\n\ntrait Optic[-GetWhole, -SetWholeBefore, -SetPiece, +GetError, +SetError, +GetPiece, +SetWholeAfter] {\n  def getOptic(whole: GetWhole): IO[GetError, GetPiece]\n  def setOptic(piece: SetPiece)(whole: SetWholeBefore): IO[SetError, SetWholeAfter]\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["To work with these optics, import ",(0,o.jsx)(t.code,{children:"zio.optics.opticsm._"})," for optics where the result type is a ",(0,o.jsx)(t.code,{children:"ZIO"})," value or ",(0,o.jsx)(t.code,{children:"zio.optics.toptics._"})," for optics where the result type is an ",(0,o.jsx)(t.code,{children:"STM"})," value. This will automatically bring the appropriate version of the ",(0,o.jsx)(t.code,{children:"Optic"})," data type as well as its constructors and syntax into scope."]}),"\n",(0,o.jsxs)(t.p,{children:["For example, here is how we could define an optic to work with a nested value inside a ",(0,o.jsx)(t.code,{children:"TMap"}),":"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:'import zio.stm._\nimport zio.optics.toptics._\n\nval optic: Optional[TMap[String, Either[String, Int]], Int] =\n  TOptics.key("key") >>> Optic.right\n'})}),"\n",(0,o.jsxs)(t.p,{children:["Note that optics specific to STM data structures are defined in the ",(0,o.jsx)(t.code,{children:"TOptics"})," object. Otherwise everything works the same way."]}),"\n",(0,o.jsxs)(t.p,{children:["Just like with ",(0,o.jsx)(t.code,{children:"Ref"}),", ZIO Optics provides special support for working with STM data types such as ",(0,o.jsx)(t.code,{children:"TMap"}),", so we can update our ",(0,o.jsx)(t.code,{children:"TMap"}),' using "dot" syntax like this:']}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala:mdoc",children:'tMap.key("key").right.at(0).update(_ + 1)\n'})})]})}function d(e={}){const{wrapper:t}={...(0,c.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},28453:(e,t,s)=>{s.d(t,{R:()=>r,x:()=>n});var i=s(96540);const o={},c=i.createContext(o);function r(e){const t=i.useContext(c);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function n(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(c.Provider,{value:t},e.children)}}}]);