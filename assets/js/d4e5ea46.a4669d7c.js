"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[17733],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>s});var r=t(96540);const a={},i=r.createContext(a);function o(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),r.createElement(i.Provider,{value:n},e.children)}},97356:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>l,frontMatter:()=>o,metadata:()=>r,toc:()=>p});const r=JSON.parse('{"id":"reference/error-management/examples","title":"Examples","description":"Let\'s write an application that takes numerator and denominator from the user and then print the result back to the user:","source":"@site/docs/reference/error-management/examples.md","sourceDirName":"reference/error-management","slug":"/reference/error-management/examples","permalink":"/reference/error-management/examples","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/error-management/examples.md","tags":[],"version":"current","frontMatter":{"id":"examples","title":"Examples"},"sidebar":"reference-sidebar","previous":{"title":"Don\'t Reflexively Log Errors","permalink":"/reference/error-management/best-practices/logging-errors"},"next":{"title":"Interruption Model","permalink":"/reference/interruption/"}}');var a=t(74848),i=t(28453);const o={id:"examples",title:"Examples"},s=void 0,c={},p=[];function d(e){const n={code:"code",em:"em",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"Let's write an application that takes numerator and denominator from the user and then print the result back to the user:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport java.io.IOException\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    for {\n      a <- readNumber("Enter the first number  (a): ")\n      b <- readNumber("Enter the second number (b): ")\n      r <- divide(a, b)\n      _ <- Console.printLine(s"a / b: $r")\n    } yield ()\n\n  def readNumber(msg: String): ZIO[Any, IOException, Int] =\n    Console.print(msg) *> Console.readLine.map(_.toInt)\n\n  def divide(a: Int, b: Int): ZIO[Any, Nothing, Int] =\n    if (b == 0)\n      ZIO.die(new ArithmeticException("divide by zero")) // unexpected error\n    else\n      ZIO.succeed(a / b)\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"Now let's try to enter the zero for the second number and see what happens:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'Please enter the first number  (a): 5\nPlease enter the second number (b): 0\ntimestamp=2022-02-14T09:39:53.981143209Z level=ERROR thread=#zio-fiber-0 message="Exception in thread "zio-fiber-2" java.lang.ArithmeticException: divide by zero\nat MainApp$.$anonfun$divide$1(MainApp.scala:16)\nat zio.ZIO$.$anonfun$die$1(ZIO.scala:3384)\nat zio.internal.FiberContext.runUntil(FiberContext.scala:255)\nat zio.internal.FiberContext.run(FiberContext.scala:115)\nat java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)\nat java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)\nat java.base/java.lang.Thread.run(Thread.java:831)\nat <empty>.MainApp.divide(MainApp.scala:16)"\n'})}),"\n",(0,a.jsxs)(n.p,{children:["As we see, because we entered the zero for the denominator, the ",(0,a.jsx)(n.code,{children:"ArithmeticException"})," defect, makes the application crash."]}),"\n",(0,a.jsxs)(n.p,{children:["Defects are any ",(0,a.jsx)(n.em,{children:"unexpected errors"})," that we are not going to handle. They will propagate through our application stack until they crash the whole."]}),"\n",(0,a.jsxs)(n.p,{children:["Defects have many roots, most of them are from a programming error. Errors will happen when we haven't written the application with best practices. For example, one of these practices is that we should validate the inputs before providing them to the ",(0,a.jsx)(n.code,{children:"divide"})," function. So if the user entered the zero as the denominator, we can retry and ask the user to return another number:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport java.io.IOException\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    for {\n      a <- readNumber("Enter the first number  (a): ")\n      b <- readNumber("Enter the second number (b): ").repeatUntil(_ != 0)\n      r <- divide(a, b)\n      _ <- Console.printLine(s"a / b: $r")\n    } yield ()\n\n  def readNumber(msg: String): ZIO[Any, IOException, Int] =\n    Console.print(msg) *> Console.readLine.map(_.toInt)\n\n  def divide(a: Int, b: Int): ZIO[Any, Nothing, Int] = ZIO.succeed(a / b)\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Another note about defects is that they are invisible, and they are not typed. We cannot expect what defects will happen by observing the typed error channel. In the above example, when we run the application and enter noninteger input, another defect, which is called ",(0,a.jsx)(n.code,{children:"NumberFormatException"})," will crash the application:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'Enter the first number  (a): five\ntimestamp=2022-02-18T06:36:25.984665171Z level=ERROR thread=#zio-fiber-0 message="Exception in thread "zio-fiber-2" java.lang.NumberFormatException: For input string: "five"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Integer.parseInt(Integer.java:660)\n\tat java.base/java.lang.Integer.parseInt(Integer.java:778)\n\tat scala.collection.StringOps$.toInt$extension(StringOps.scala:910)\n\tat MainApp$.$anonfun$readNumber$3(MainApp.scala:16)\n\tat MainApp$.$anonfun$readNumber$3$adapted(MainApp.scala:16)\n  ...\n\tat <empty>.MainApp.run(MainApp.scala:9)"\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The cause of this defect is also a programming error, which means we haven't validated input when parsing it. So let's try to validate the input, and make sure that it is a number. We know that if the entered input does not contain a parsable ",(0,a.jsx)(n.code,{children:"Int"})," the ",(0,a.jsx)(n.code,{children:"String#toInt"})," throws the ",(0,a.jsx)(n.code,{children:"NumberFormatException"})," exception. As we want this exception to be typed, we import the ",(0,a.jsx)(n.code,{children:"String#toInt"})," function using the ",(0,a.jsx)(n.code,{children:"ZIO.attempt"})," constructor. Using this constructor the function signature would be as follows:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"import zio._\n\ndef parseInput(input: String): ZIO[Any, Throwable, Int] =\n  ZIO.attempt(input.toInt)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Since the ",(0,a.jsx)(n.code,{children:"NumberFormatException"})," is an expected error, and we want to handle it. So we type the error channel as ",(0,a.jsx)(n.code,{children:"NumberFormatException"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["To be more specific, we would like to narrow down the error channel to the ",(0,a.jsx)(n.code,{children:"NumberFormatException"}),", so we can use the ",(0,a.jsx)(n.code,{children:"refineToOrDie"})," operator:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"import zio._\n\ndef parseInput(input: String): ZIO[Any, NumberFormatException, Int] =\n  ZIO.attempt(input.toInt)                 // ZIO[Any, Throwable, Int]\n    .refineToOrDie[NumberFormatException]  // ZIO[Any, NumberFormatException, Int]\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The same result can be achieved by succeeding the ",(0,a.jsx)(n.code,{children:"String#toInt"})," and then widening the error channel using the ",(0,a.jsx)(n.code,{children:"ZIO#unrefineTo"})," operator:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"import zio._\n\ndef parseInput(input: String): ZIO[Any, NumberFormatException, Int] =\n  ZIO.succeed(input.toInt)                 // ZIO[Any, Nothing, Int]\n    .unrefineTo[NumberFormatException]     // ZIO[Any, NumberFormatException, Int]\n"})}),"\n",(0,a.jsx)(n.p,{children:"Now, let's refactor the example with recent changes:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport java.io.IOException\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    for {\n      a <- readNumber("Enter the first number  (a): ")\n      b <- readNumber("Enter the second number (b): ").repeatUntil(_ != 0)\n      r <- divide(a, b)\n      _ <- Console.printLine(s"a / b: $r")\n    } yield ()\n\n  def parseInput(input: String): ZIO[Any, NumberFormatException, Int] =\n    ZIO.attempt(input.toInt).refineToOrDie[NumberFormatException]\n\n  def readNumber(msg: String): ZIO[Any, IOException, Int] =\n    (Console.print(msg) *> Console.readLine.flatMap(parseInput))\n      .retryUntil(!_.isInstanceOf[NumberFormatException])\n      .refineToOrDie[IOException]\n\n  def divide(a: Int, b: Int): ZIO[Any, Nothing, Int] = ZIO.succeed(a / b)\n}\n'})})]})}function l(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);