"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[89972],{74684:(e,n,d)=>{d.r(n),d.d(n,{assets:()=>t,contentTitle:()=>r,default:()=>a,frontMatter:()=>s,metadata:()=>c,toc:()=>l});const c=JSON.parse('{"id":"zio-flow/remote","title":"Remote","description":"Overview","source":"@site/docs/zio-flow/remote.md","sourceDirName":"zio-flow","slug":"/zio-flow/remote","permalink":"/zio-flow/remote","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-flow/remote.md","tags":[],"version":"current","frontMatter":{"id":"remote","title":"Remote"},"sidebar":"ecosystem-sidebar","previous":{"title":"Defining flows","permalink":"/zio-flow/zflow"},"next":{"title":"Activities","permalink":"/zio-flow/activities"}}');var i=d(74848),o=d(28453);const s={id:"remote",title:"Remote"},r="Remotes",t={},l=[{value:"Overview",id:"overview",level:2},{value:"Remote Values",id:"remote-values",level:3},{value:"Working With Remote Values",id:"working-with-remote-values",level:3},{value:"Working With Schemas",id:"working-with-schemas",level:3},{value:"Constructing remotes",id:"constructing-remotes",level:2},{value:"Accessing custom types with optics",id:"accessing-custom-types-with-optics",level:2},{value:"Case classes",id:"case-classes",level:3},{value:"Sealed traits",id:"sealed-traits",level:3},{value:"Accessing configuration",id:"accessing-configuration",level:2},{value:"Writing remote functions",id:"writing-remote-functions",level:2},{value:"Bind",id:"bind",level:3},{value:"Conditional expressions",id:"conditional-expressions",level:3},{value:"Recursion",id:"recursion",level:3},{value:"Debugging",id:"debugging",level:3},{value:"Metrics",id:"metrics",level:3},{value:"List of supported remote types",id:"list-of-supported-remote-types",level:2},{value:"Remote[Boolean]",id:"remoteboolean",level:3},{value:"Remote[Char],",id:"remotechar",level:3},{value:"Remote[ChronoUnit]",id:"remotechronounit",level:3},{value:"Remote[Chunk[A]]",id:"remotechunka",level:3},{value:"Remote[Duration]",id:"remoteduration",level:3},{value:"Remote[Either[L, R]]",id:"remoteeitherl-r",level:3},{value:"Remote[Instant]",id:"remoteinstant",level:3},{value:"Remote[List[A]]",id:"remotelista",level:3},{value:"Remote[Map[K, V]]",id:"remotemapk-v",level:3},{value:"Remote[OffsetDateTime]",id:"remoteoffsetdatetime",level:3},{value:"Remote[Option[A]]",id:"remoteoptiona",level:3},{value:"Remote[Regex]",id:"remoteregex",level:3},{value:"Remote[Set[A]]",id:"remoteseta",level:3},{value:"Remote[String]",id:"remotestring",level:3},{value:"Remote numeric types",id:"remote-numeric-types",level:3},{value:"Remote integral types",id:"remote-integral-types",level:3},{value:"Remote fractional types",id:"remote-fractional-types",level:3},{value:"Remote tuples",id:"remote-tuples",level:3},{value:"Remote[_]",id:"remote_",level:3},{value:"math object",id:"math-object",level:3}];function h(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"remotes",children:"Remotes"})}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.h3,{id:"remote-values",children:"Remote Values"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Remote"})," data type forms the backbone of ZIO Flow and allows us to safely describe values that may be part of\ncomputations on multiple remote nodes."]}),"\n",(0,i.jsxs)(n.p,{children:["In ordinary Scala we are used to working with values defined by the Scala library such as ",(0,i.jsx)(n.code,{children:"Int"})," and ",(0,i.jsx)(n.code,{children:"String"})," as well as\nuser defined data types such as a ",(0,i.jsx)(n.code,{children:"User"})," and interfaces such as a ",(0,i.jsx)(n.code,{children:"UserService"}),". The problem with using these data types\nin a distributed in a setting where we need to perform distributed or resilient workflows is that these data types may\nnot actually be safely serializable and cause our programs to fail at runtime."]}),"\n",(0,i.jsx)(n.p,{children:"Even if we are extremely diligent about trying to avoid this, it can be easy to avoid accidentally closing over other\nvariables, resulting in data that is either not serializable or takes up much more space than we intended. This is an\ninfamous problem with frameworks like Spark despite their best efforts to avoid it."}),"\n",(0,i.jsxs)(n.p,{children:["ZIO Flow handles this issue in a principled way with its ",(0,i.jsx)(n.code,{children:"Remote"})," data type, which is a ",(0,i.jsx)(n.em,{children:"description"})," of a value that\nmay potentially exist on a remote node. This way you can easily look at any value and tell just from its type whether it\nis a ",(0,i.jsx)(n.code,{children:"Remote"})," value that is safe to use in resilient, distributed computations or an ordinary value that is fine to use\non a single node but does not provide these guarantees."]}),"\n",(0,i.jsxs)(n.p,{children:["Generally ZIO Flow will require that the values we work with be ",(0,i.jsx)(n.code,{children:"Remote"})," values so that it can safely replicate them\nacross multiple nodes or reload them from durable storage in the event of a failure."]}),"\n",(0,i.jsxs)(n.p,{children:["For example, compare the signature of the ",(0,i.jsx)(n.code,{children:"map"})," operator on ",(0,i.jsx)(n.code,{children:"ZIO"})," and ",(0,i.jsx)(n.code,{children:"ZFlow"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"import zio.flow._\n\ntrait ZIO[-R, +E, +A] {\n  def map[B](f: A => B): ZIO[R, E, B]\n}\n\ntrait ZFlow[-R, +E, +A] {\n  def map[B](f: Remote[A] => Remote[B]): ZFlow[R, E, B]\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"There are a couple of things that should jump out at you from this."}),"\n",(0,i.jsxs)(n.p,{children:["First, the method signatures are nearly identical! You will find this frequently with ZIO Flow, where most of the\noperators you are familiar with from ",(0,i.jsx)(n.code,{children:"ZIO"})," like ",(0,i.jsx)(n.code,{children:"map"})," also exist on ",(0,i.jsx)(n.code,{children:"ZFlow"})," so if you know ZIO you are already ready to\ngo."]}),"\n",(0,i.jsxs)(n.p,{children:["Second, you will notice that the one thing that differs between these type signatures is that whereas ",(0,i.jsx)(n.code,{children:"ZIO#map"})," accepts\na function ",(0,i.jsx)(n.code,{children:"A => B"}),", ",(0,i.jsx)(n.code,{children:"ZFlow#map"})," accepts a function ",(0,i.jsx)(n.code,{children:"Remote[A] => Remote[B]"}),". This makes sense because ",(0,i.jsx)(n.code,{children:"ZIO"})," describes a\nworkflow on a single machine whereas ",(0,i.jsx)(n.code,{children:"ZFlow"})," describes a resilient, distributed, computation, so the values we are\nworking with must be of the form ",(0,i.jsx)(n.code,{children:"Remote[A]"})," rather than ",(0,i.jsx)(n.code,{children:"A"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"working-with-remote-values",children:"Working With Remote Values"}),"\n",(0,i.jsxs)(n.p,{children:["At this point you might be worried that despite these benefits, working with remote values could involve additional\nboilerplate. We know how to add two ",(0,i.jsx)(n.code,{children:"Int"})," values, but how do we add two ",(0,i.jsx)(n.code,{children:"Remote[Int]"})," values?"]}),"\n",(0,i.jsxs)(n.p,{children:["Fortunately, ZIO Flow goes to great lengths to make working with ",(0,i.jsx)(n.code,{children:"Remote"}),' values as ergonomic as possible, so we can\nalmost "forget" that we are working with something other than ordinary values at all.']}),"\n",(0,i.jsxs)(n.p,{children:["The main way ZIO Flow does this is by providing operators on remote values that mirror the operators on ordinary values.\nFor example, we can add two ",(0,i.jsx)(n.code,{children:"Remote[Int]"})," values by simply adding the two values together:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"import zio.flow._\n\nval left: Remote[Int] = Remote(1)\n// left: Remote[Int] = Literal(\n//   value = Primitive(value = 1, standardType = int)\n// )\nval right: Remote[Int] = Remote(1)\n// right: Remote[Int] = Literal(\n//   value = Primitive(value = 1, standardType = int)\n// )\n\nval sum: Remote[Int] = left + right\n// sum: Remote[Int] = Binary(\n//   left = Literal(value = Primitive(value = 1, standardType = int)),\n//   right = Literal(value = Primitive(value = 1, standardType = int)),\n//   operator = Numeric(\n//     operator = Add,\n//     numeric = zio.flow.remote.numeric.Numeric$NumericInt$@6533bc8e\n//   )\n// )\n"})}),"\n",(0,i.jsxs)(n.p,{children:["We see here that we can use the ",(0,i.jsx)(n.code,{children:"apply"})," constructor on ",(0,i.jsx)(n.code,{children:"Remote"})," to lift any existing value into a remote value as long\nas there is a ",(0,i.jsx)(n.code,{children:"Schema"})," for it. We'll talk more about schemas below but you can think of a ",(0,i.jsx)(n.code,{children:"Schema"}),' as describing the "\nstructure" of some Scala type as a value, allowing us to safely serialize it and deserialize it, among other things.']}),"\n",(0,i.jsx)(n.p,{children:"In fact ZIO Flow will convert ordinary values into remote values for us automatically when needed. So we could also do\nthis:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"val flow: ZFlow[Any, Nothing, Int] =\n  ZFlow.succeed(1)\n// flow: ZFlow[Any, Nothing, Int] = Return(\n//   value = Literal(value = Primitive(value = 1, standardType = int))\n// )\n\nval incrementedFlow: ZFlow[Any, Nothing, Int] =\n  flow.map(_ + 1)\n// incrementedFlow: ZFlow[Any, Nothing, Int] = Fold(\n//   value = Return(\n//     value = Literal(value = Primitive(value = 1, standardType = int))\n//   ),\n//   errorCase = None,\n//   successCase = Some(\n//     value = UnboundRemoteFunction(\n//       input = Unbound(identifier = 6f5a4d8a-fa7b-43df-8106-9effcc41b3ee),\n//       result = Flow(\n//         flow = Return(\n//           value = Binary(\n//             left = Unbound(identifier = 6f5a4d8a-fa7b-43df-8106-9effcc41b3ee),\n//             right = Literal(value = Primitive(value = 1, standardType = int)),\n//             operator = Numeric(\n//               operator = Add,\n//               numeric = zio.flow.remote.numeric.Numeric$NumericInt$@6533bc8e\n//             )\n//           )\n//         )\n//       )\n//     )\n//   )\n// )\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Notice that here the function we provided to ",(0,i.jsx)(n.code,{children:"ZFlow#map"})," looked identical to the one we would provide to ",(0,i.jsx)(n.code,{children:"ZIO#map"})," in\na ",(0,i.jsx)(n.code,{children:"ZIO"}),' application. This is exactly the interface we want and lets use "forget" in most cases that we are working with\nthe world of ',(0,i.jsx)(n.code,{children:"Remote"})," values instead of the world of normal values."]}),"\n",(0,i.jsxs)(n.p,{children:["This also reflects the idea that the ",(0,i.jsx)(n.code,{children:"Remote"}),' world is a "mirror" of the world of ordinary values and absent underlying\nimplementation limitations (e.g. arbitrary Scala functions are not serializable) the interface for working with ',(0,i.jsx)(n.code,{children:"Remote"}),"\nvalues should look and feel as similar to the interface for working with ordinary values as possible."]}),"\n",(0,i.jsxs)(n.p,{children:["This also means that if you know how to do something in ordinary Scala you also already know how to do it with ",(0,i.jsx)(n.code,{children:"Remote"}),"\nvalues."]}),"\n",(0,i.jsxs)(n.p,{children:["We are definitely working on ensuring that the experience of working with ",(0,i.jsx)(n.code,{children:"Remote"})," values is as good as working with\nordinary values. So if you see an area where this is not the case please reach out to us on Discord or open an issue so\nthat we can improve it!"]}),"\n",(0,i.jsx)(n.h3,{id:"working-with-schemas",children:"Working With Schemas"}),"\n",(0,i.jsxs)(n.p,{children:["As discussed above, a ",(0,i.jsx)(n.code,{children:"Schema"}),' describes the "structure" of some Scala type as a value. This lets us know how to\nserialize and deserialize the value, as well as providing other useful functional like migrations between two versions\nof a data type.']}),"\n",(0,i.jsxs)(n.p,{children:["Schemas are provided by ",(0,i.jsx)(n.code,{children:"ZIO Schema"}),", a library that is exclusively focused on defining these schemas, providing schemas\nfor various data types, and enabling useful functionality with them. When we are working with data types defined by the\nScala or Java standard libraries schemas should already automatically be available as long as the data type can be\nsafely serialized and deserialized."]}),"\n",(0,i.jsxs)(n.p,{children:['ZIO Flow uses those schemas internally and as long as they exist things "just work". So you may have noticed that we\ndidn\'t have to do anything with schemas when we did ',(0,i.jsx)(n.code,{children:"Remote(1)"})," because a schema for ",(0,i.jsx)(n.code,{children:"Int"})," values already exists."]}),"\n",(0,i.jsx)(n.p,{children:"The one time you will typically have to work with schemas directly is in defining schemas for your own custom data\ntypes. Fortunately this is very easy!"}),"\n",(0,i.jsxs)(n.p,{children:["In idiomatic Scala and in ZIO Flow we always define our data types as either a ",(0,i.jsx)(n.code,{children:"case class"})," to represent data that has\none thing ",(0,i.jsx)(n.em,{children:"and"})," has another thing (e.g. a credit card has a name and a number) or a ",(0,i.jsx)(n.code,{children:"sealed trait"})," to represent data\nthat is one ",(0,i.jsx)(n.em,{children:"or"})," is another thing (e.g. a payment method is either credit card or check)."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"sealed trait PaymentMethod\n\ncase class CreditCard(name: String, number: String) extends PaymentMethod\ncase class Check(name: String, routing: String) extends PaymentMethod\n"})}),"\n",(0,i.jsx)(n.p,{children:"Notice how even in this simple example we have combined these two techniques to model a more complex domain with both of\nthese types."}),"\n",(0,i.jsxs)(n.p,{children:["As long as we model our data this way, we can automatically generate schemas for our data types using\nthe ",(0,i.jsx)(n.code,{children:"DeriveSchema.gen"})," operator. For example, let's see how we could generate a schema for our ",(0,i.jsx)(n.code,{children:"PaymentMethod"})," data\ntype:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"import zio.schema._\n\nobject PaymentMethod {\n  implicit val schema = DeriveSchema.gen[PaymentMethod]\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["We should be sure to define our schemas in the companion objects of the data types they describe the structure of, like\nwe did by putting the ",(0,i.jsx)(n.code,{children:"schema"})," for ",(0,i.jsx)(n.code,{children:"PaymentMethod"})," in the ",(0,i.jsx)(n.code,{children:"PaymentMethod"})," companion object here. We should also declare\nit as an ",(0,i.jsx)(n.code,{children:"implicit val"})," so that the compiler can automatically find the schema when needed."]}),"\n",(0,i.jsx)(n.p,{children:"Other than that the hardest thing is remembering to import ZIO Schema!"}),"\n",(0,i.jsxs)(n.p,{children:["With the schema defined this way, we can construct remote versions of ",(0,i.jsx)(n.code,{children:"PaymentMethod"})," values just like we did for ",(0,i.jsx)(n.code,{children:"Int"}),"\nvalues:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'val remotePaymentMethod: Remote[PaymentMethod] =\n  Remote(CreditCard("John Doe", "123456789"))\n'})}),"\n",(0,i.jsx)(n.p,{children:"With this, you know everything you need to work with remote values as part of writing your resilient, distributed\napplication!"}),"\n",(0,i.jsx)(n.h2,{id:"constructing-remotes",children:"Constructing remotes"}),"\n",(0,i.jsxs)(n.p,{children:["Let's see the specific ways to construct a ",(0,i.jsx)(n.code,{children:"Remote"})," value in ZIO Flow."]}),"\n",(0,i.jsxs)(n.p,{children:["The simplest way is to use the ",(0,i.jsx)(n.code,{children:"Remote"})," constructor to capture any Scala value that has a ",(0,i.jsx)(n.code,{children:"Schema"})," available:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'Remote(0)\nRemote("hello world")\nRemote(CreditCard("John Doe", "123456789"): PaymentMethod)\nRemote(List(1, 2, 3))\n'})}),"\n",(0,i.jsxs)(n.p,{children:["What if we already have one or more ",(0,i.jsx)(n.code,{children:"Remote"})," values and want to wrap them in a standard type like ",(0,i.jsx)(n.code,{children:"Option"}),", ",(0,i.jsx)(n.code,{children:"Either"}),"\nor ",(0,i.jsx)(n.code,{children:"List"}),"? There are\nconstructors on the ",(0,i.jsx)(n.code,{children:"Remote"})," object for that:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'Remote.none[String]\nRemote.some(Remote("hello world"))\nRemote.nil[Int]\nRemote.list(Remote(1), Remote(2), Remote(3))\nRemote.left[String, Int](Remote("failed"))\nRemote.right[String, Int](Remote(11))\nRemote.emptyMap[String, Int]\nRemote.map(Remote(("x", 1)), Remote(("y", 2)))\nRemote.emptySet[Int]\nRemote.set(Remote(1), Remote(2), Remote(3))\nRemote.emptyChunk[Double]\nRemote.chunk(Remote(1.2), Remote(3.4), Remote(5.6))\nRemote.tuple3(Remote(1), Remote("hello"), Remote(0.1))\n'})}),"\n",(0,i.jsxs)(n.p,{children:["In many cases you don't have to explicitly create a ",(0,i.jsx)(n.code,{children:"Remote"})," at all! In case the compiler knows a value has to have the\ntype ",(0,i.jsx)(n.code,{children:"Remote[A]"}),", any value of type ",(0,i.jsx)(n.code,{children:"A"})," will be automatically converted:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"val x: Remote[Int] = 1\n"})}),"\n",(0,i.jsx)(n.h2,{id:"accessing-custom-types-with-optics",children:"Accessing custom types with optics"}),"\n",(0,i.jsxs)(n.p,{children:["As we saw above, custom types such as case classes and sealed traits are supported if they have an associated ",(0,i.jsx)(n.em,{children:"schema"}),".\nThis can be enough if all we need is to pass a custom value to our flow, let's say to send it to an external service.\nBut what if we need to extract information from a custom type, or we need to construct it from other remote values?"]}),"\n",(0,i.jsxs)(n.p,{children:["This problem is solved by ZIO Flow's optics support which is built on top of ",(0,i.jsx)(n.em,{children:"ZIO Schema accessors"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"case-classes",children:"Case classes"}),"\n",(0,i.jsx)(n.p,{children:"For a custom case class, first we need to define accessors for all its fields:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"final case class Person(name: String, age: Int)\n\nobject Person {\n  implicit val schema = DeriveSchema.gen[Person]\n  val (name, age) = Remote.makeAccessors[Person]\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Note that when working with ",(0,i.jsx)(n.em,{children:"accessors"}),", it is important that we don't specify an explicit type for the schema. This for\nexample would not work:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"// Wrong example!!!\nobject Person {\n  implicit val schema: Schema[Person] = DeriveSchema.gen\n  val (name, age) = Remote.makeAccessors[Person]\n}\n// Wrong example!!!\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The reason is that ",(0,i.jsx)(n.code,{children:"DeriveSchema"})," generates a more specific type than ",(0,i.jsx)(n.code,{children:"Schema[Person]"})," and ",(0,i.jsx)(n.code,{children:"makeAccessors"})," needs this\ninformation to work properly."]}),"\n",(0,i.jsx)(n.p,{children:"Then we can use these accessors to get the fields of a remote value of our custom type:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'val person1 = Remote(Person("John", 30))\nval extractedName: Remote[String] = Person.name.get(person1)\nval extractedAge: Remote[Int] = Person.age.get(person1)\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"set"})," method on the accessors can be used to manipulate the fields of a remote value:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'val sourceName: Remote[String] = "John"\nval sourceAge: Remote[Int] = 30\nval person2 = Person.name.set(Person.age.set(Remote(Person("", 0)))(sourceAge))(sourceName)\n'})}),"\n",(0,i.jsx)(n.h3,{id:"sealed-traits",children:"Sealed traits"}),"\n",(0,i.jsxs)(n.p,{children:["Similarly for sealed traits we can define accessors for all its subtypes. Using the earlier defined ",(0,i.jsx)(n.code,{children:"PaymentMethod"}),"\ntype:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"val (creditCard, check) = Remote.makeAccessors[PaymentMethod]\n"})}),"\n",(0,i.jsxs)(n.p,{children:["then we can use these accessors to check if a remote value of ",(0,i.jsx)(n.code,{children:"PaymentMethod"})," is a ",(0,i.jsx)(n.code,{children:"CreditCard"})," or a ",(0,i.jsx)(n.code,{children:"Check"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'val paymentMethod: Remote[PaymentMethod] = Remote[PaymentMethod](CreditCard("John Doe", "123456789"))\nval maybeCreditCard: Remote[Option[CreditCard]] = creditCard.get(paymentMethod)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"accessing-configuration",children:"Accessing configuration"}),"\n",(0,i.jsx)(n.p,{children:"ZIO Flow provides a way to access configuration values from within a flow. This can be used for example to pass access\ntokens and other sensitive information to the flows."}),"\n",(0,i.jsxs)(n.p,{children:["To access a configured value, we can use the special ",(0,i.jsx)(n.code,{children:"Remote.config"})," constructor:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'Remote.config[String](ConfigKey("example_api_token"))\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.a,{href:"execution",children:"execution section"})," explains how these configuration values can be injected to the executed flows."]}),"\n",(0,i.jsx)(n.h2,{id:"writing-remote-functions",children:"Writing remote functions"}),"\n",(0,i.jsxs)(n.p,{children:["Just like in a regular Scala program, functions are also values, so we can define ",(0,i.jsx)(n.em,{children:"remote functions"}),". This is often used\nin ZIO Flow's built-in operators. One example is the ",(0,i.jsx)(n.code,{children:"map"})," operation that can transform the result of a flow:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"ZFlow.succeed(1).map(_ + 1)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Here the ",(0,i.jsx)(n.code,{children:"_ + 1"})," is a remote function! Its type is ",(0,i.jsx)(n.code,{children:"Remote[Int] => Remote[Int]"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"In this section we will see some helpers available for defining such remote functions."}),"\n",(0,i.jsx)(n.h3,{id:"bind",children:"Bind"}),"\n",(0,i.jsxs)(n.p,{children:["In a regular Scala function we could use ",(0,i.jsx)(n.em,{children:"local variables"})," to store intermediate results to avoid calculating them\nmultiple times:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"val scalaFun1: (Int => Int) =\n  (input: Int) => {\n    val a: Int = input * 2\n    a + a\n  }\n"})}),"\n",(0,i.jsx)(n.p,{children:"What if we do the same in a remote function?"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"val remoteFun1: (Remote[Int] => Remote[Int]) =\n  (input: Remote[Int]) => {\n    val a: Remote[Int] = input * 2\n    a + a\n  }\n"})}),"\n",(0,i.jsxs)(n.p,{children:["this will compile but remember that ",(0,i.jsx)(n.code,{children:"Remote[Int]"})," is just a ",(0,i.jsx)(n.em,{children:"serializable description"})," of a value. Storing ",(0,i.jsx)(n.code,{children:"input * 2"}),"\nin ",(0,i.jsx)(n.code,{children:"a"})," does not actually perform the multiplication! So this style can improve readability of our code, but when the\nexecutor calculates the actual value of this remote function, it will have to calculate ",(0,i.jsx)(n.code,{children:"input * 2"})," twice."]}),"\n",(0,i.jsxs)(n.p,{children:["The solution is to use the ",(0,i.jsx)(n.code,{children:"bind"})," method on ",(0,i.jsx)(n.code,{children:"Remote"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"val remoteFun2: (Remote[Int] => Remote[Int]) =\n  (input: Remote[Int]) => \n    Remote.bind(input * 2) { a =>\n      a + a\n    }\n"})}),"\n",(0,i.jsx)(n.h3,{id:"conditional-expressions",children:"Conditional expressions"}),"\n",(0,i.jsxs)(n.p,{children:["If we have a remote boolean value and want to choose between two possible remote values based on it, we cannot use\nScala's ",(0,i.jsx)(n.code,{children:"if"})," expression as the ",(0,i.jsx)(n.code,{children:"Remote[Boolean]"})," is just a description of a computation, it does not have a value yet.\nInstead we can use the ",(0,i.jsx)(n.code,{children:"ifThenElse"})," method on ",(0,i.jsx)(n.code,{children:"Remote"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'Remote.config[Boolean](ConfigKey("feature1"))\n  .ifThenElse(\n    ifTrue = Remote(1), \n    ifFalse = Remote(2)\n  )\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Similarily we cannot do pattern matching on values, but we can use the ",(0,i.jsx)(n.code,{children:"match"})," helper function on ",(0,i.jsx)(n.code,{children:"Remote"})," to achieve\nsomething similar:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'import java.time.temporal.ChronoUnit\n\ndef convert(nanos: Remote[Long], unit: Remote[ChronoUnit]): Remote[Long] =\n  unit.`match`(\n    ChronoUnit.NANOS   -> nanos,\n    ChronoUnit.SECONDS -> nanos / 1000L,\n    ChronoUnit.MILLIS  -> nanos / 1000000L\n  )(Remote.fail("Unsupported unit"))\n'})}),"\n",(0,i.jsx)(n.h3,{id:"recursion",children:"Recursion"}),"\n",(0,i.jsxs)(n.p,{children:["As explained in connection with the ",(0,i.jsx)(n.a,{href:"zflow",children:"ZFlow"})," type, recursive functions need special support in ZIO Flow to ensure\nthey are serializable."]}),"\n",(0,i.jsxs)(n.p,{children:["Let's see an example! The following definition of ",(0,i.jsx)(n.code,{children:"List#grouped"})," splits a remote list of elements into sublists of the\ngiven length:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"def grouped[A](source: Remote[List[A]], size: Remote[Int]): Remote[List[List[A]]] =\n  Remote.recurse[List[A], List[List[A]]](source) { (input, rec) =>\n    input.isEmpty.ifThenElse(\n      Remote.nil,\n      Remote.bind(input.splitAt(size)) { splitPair =>\n        splitPair._1 :: rec(splitPair._2)\n      }\n    )\n  }\n"})}),"\n",(0,i.jsx)(n.h3,{id:"debugging",children:"Debugging"}),"\n",(0,i.jsxs)(n.p,{children:["Any remote value can be annotated with the ",(0,i.jsx)(n.code,{children:'.debug("message")'})," syntax to print the value to the executor's log when it\ngets evaluated. This can be used to debug complex remote functions during the development of a ZIO flow program."]}),"\n",(0,i.jsxs)(n.p,{children:["For example we may annotate parts of the above defined ",(0,i.jsx)(n.code,{children:"grouped"})," function:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'def groupedDebug[A](source: Remote[List[A]], size: Remote[Int]): Remote[List[List[A]]] =\n  Remote.recurse[List[A], List[List[A]]](source.debug("source")) { (input, rec) =>\n    input.debug("recursive function input").isEmpty.ifThenElse(\n      Remote.nil,\n      Remote.bind(input.splitAt(size)) { splitPair =>\n        splitPair.debug("splitPair")._1 :: rec(splitPair._2)\n      }\n    )\n  }\n'})}),"\n",(0,i.jsx)(n.h3,{id:"metrics",children:"Metrics"}),"\n",(0,i.jsxs)(n.p,{children:["Similarly to ",(0,i.jsx)(n.code,{children:".debug"}),", the ",(0,i.jsx)(n.code,{children:'.track("name")'})," modifier can be used to measure the execution time and number of invocations\nof a remote value. Remotes annotated like that will be reported to the metrics backend by a counter\nnamed ",(0,i.jsx)(n.code,{children:"zioflow_remote_evals"})," and a histogram named ",(0,i.jsx)(n.code,{children:"zioflow_remote_eval_time_ms"})," with the given name as a tag."]}),"\n",(0,i.jsx)(n.h2,{id:"list-of-supported-remote-types",children:"List of supported remote types"}),"\n",(0,i.jsxs)(n.p,{children:["The Scala (and Java) standard library defines many useful operations on common data types like numbers, strings,\ncollection types, date and time related types etc. Once we wrap these types in ",(0,i.jsx)(n.code,{children:"Remote"})," we loose the possibility to call\nthese standard library methods, as we switched into a ",(0,i.jsx)(n.em,{children:"serializable descrition"})," of a computation from defining the\nactual compiled code."]}),"\n",(0,i.jsx)(n.p,{children:"ZIO Flow redefines many of these standard library functions for the remote types. As an example, consider the following\nScala code:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'val scalaExample = List(4, 2, 3, 6).sorted.map(n => s"Number: $n").mkString("<", ", ", ">")\n// scalaExample: String = "<Number: 2, Number: 3, Number: 4, Number: 6>"\n'})}),"\n",(0,i.jsx)(n.p,{children:"The equivalent ZIO Flow code would look like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'val remoteExample = \n  Remote(List(4, 2, 3, 6)).sorted.map(n => rs"Number: ${n.toString}").mkString("<", ", ", ">")\n'})}),"\n",(0,i.jsxs)(n.p,{children:["We start by wrapping the input list in ",(0,i.jsx)(n.code,{children:"Remote"}),". Everything else looks completely the same, except the ",(0,i.jsx)(n.em,{children:"string\ninterpolator"})," which has a remote equivalent using the prefix ",(0,i.jsx)(n.code,{children:"rs"}),". The remote string interpolator does not automatically\nconvert values to strings - so we need to explicitly call ",(0,i.jsx)(n.code,{children:"n.toString"})," to convert the number to a string. Other than\nthat all the standard library methods required for this example are also available on remote values."]}),"\n",(0,i.jsxs)(n.p,{children:["The remote ",(0,i.jsx)(n.code,{children:"toString"})," method is defined on all ",(0,i.jsx)(n.code,{children:"Remote[A]"})," values and it creates a ",(0,i.jsx)(n.code,{children:"Remote[String]"})," as expected."]}),"\n",(0,i.jsx)(n.p,{children:"In the following tables we list the standard library methods that are available for the remote types without further\nexplanation - please use their original documentation for usage details."}),"\n",(0,i.jsx)(n.h3,{id:"remoteboolean",children:"Remote[Boolean]"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"&&"}),", ",(0,i.jsx)(n.code,{children:"&"})," ",(0,i.jsx)(n.code,{children:"|"}),", ",(0,i.jsx)(n.code,{children:"||"}),", ",(0,i.jsx)(n.code,{children:"^"}),", ",(0,i.jsx)(n.code,{children:"!"})]}),"\n",(0,i.jsx)(n.h3,{id:"remotechar",children:"Remote[Char],"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"asDigit"}),",",(0,i.jsx)(n.code,{children:"getDirectionality"}),",",(0,i.jsx)(n.code,{children:"getNumericValue"}),", ",(0,i.jsx)(n.code,{children:"getType"}),", ",(0,i.jsx)(n.code,{children:"isControl"}),", ",(0,i.jsx)(n.code,{children:"isDigit"}),", ",(0,i.jsx)(n.code,{children:"isHighSurrogate"}),", ",(0,i.jsx)(n.code,{children:"isIdentifierIgnorable"}),", ",(0,i.jsx)(n.code,{children:"isLetter"}),", ",(0,i.jsx)(n.code,{children:"isLetterOrDigit"}),", ",(0,i.jsx)(n.code,{children:"isLowSurrogate"}),", ",(0,i.jsx)(n.code,{children:"isLower"}),", ",(0,i.jsx)(n.code,{children:"isMirrored"}),", ",(0,i.jsx)(n.code,{children:"isSpaceChar"}),", ",(0,i.jsx)(n.code,{children:"isSurrogate"}),", ",(0,i.jsx)(n.code,{children:"isTitleCase"}),", ",(0,i.jsx)(n.code,{children:"isUnicodeIdentifierPart"}),", ",(0,i.jsx)(n.code,{children:"isUnicodeIdentifierStart"}),", ",(0,i.jsx)(n.code,{children:"isUpper"}),", ",(0,i.jsx)(n.code,{children:"isWhitespace"}),",\n",(0,i.jsx)(n.code,{children:"reverseBytes"}),", ",(0,i.jsx)(n.code,{children:"toTitleCase"}),", ",(0,i.jsx)(n.code,{children:"toUpper"})]}),"\n",(0,i.jsx)(n.h3,{id:"remotechronounit",children:"Remote[ChronoUnit]"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"getDuration"})}),"\n",(0,i.jsx)(n.h3,{id:"remotechunka",children:"Remote[Chunk[A]]"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"++"}),", ",(0,i.jsx)(n.code,{children:"++:"}),", ",(0,i.jsx)(n.code,{children:"+:"}),", ",(0,i.jsx)(n.code,{children:":++"}),", ",(0,i.jsx)(n.code,{children:"appended"}),", ",(0,i.jsx)(n.code,{children:"appendedAll"}),", ",(0,i.jsx)(n.code,{children:"apply"}),", ",(0,i.jsx)(n.code,{children:"concat"}),", ",(0,i.jsx)(n.code,{children:"contains"}),", ",(0,i.jsx)(n.code,{children:"containsSlice"}),", ",(0,i.jsx)(n.code,{children:"corresponds"}),", ",(0,i.jsx)(n.code,{children:"count"}),", ",(0,i.jsx)(n.code,{children:"diff"}),", ",(0,i.jsx)(n.code,{children:"distinct"}),", ",(0,i.jsx)(n.code,{children:"distinctBy"}),", ",(0,i.jsx)(n.code,{children:"drop"}),", ",(0,i.jsx)(n.code,{children:"dropRight"}),", ",(0,i.jsx)(n.code,{children:"dropWhile"}),", ",(0,i.jsx)(n.code,{children:"endsWith"}),", ",(0,i.jsx)(n.code,{children:"empty"}),", ",(0,i.jsx)(n.code,{children:"exists"}),", ",(0,i.jsx)(n.code,{children:"filter"}),", ",(0,i.jsx)(n.code,{children:"filterNot"}),", ",(0,i.jsx)(n.code,{children:"find"}),", ",(0,i.jsx)(n.code,{children:"findLast"}),", ",(0,i.jsx)(n.code,{children:"flatMap"}),", ",(0,i.jsx)(n.code,{children:"flatten"}),", ",(0,i.jsx)(n.code,{children:"fold"}),", ",(0,i.jsx)(n.code,{children:"foldLeft"}),", ",(0,i.jsx)(n.code,{children:"foldRight"}),", ",(0,i.jsx)(n.code,{children:"forall"}),", ",(0,i.jsx)(n.code,{children:"groupBy"}),", ",(0,i.jsx)(n.code,{children:"groupMap"}),", ",(0,i.jsx)(n.code,{children:"groupMapReduce"}),", ",(0,i.jsx)(n.code,{children:"grouped"}),", ",(0,i.jsx)(n.code,{children:"head"}),", ",(0,i.jsx)(n.code,{children:"headOption"}),", ",(0,i.jsx)(n.code,{children:"indexOf"}),", ",(0,i.jsx)(n.code,{children:"indexOfSlice"}),", ",(0,i.jsx)(n.code,{children:"indexWhere"}),", ",(0,i.jsx)(n.code,{children:"init"}),", ",(0,i.jsx)(n.code,{children:"inits"}),", ",(0,i.jsx)(n.code,{children:"intersect"}),", ",(0,i.jsx)(n.code,{children:"isDefinedAt"}),", ",(0,i.jsx)(n.code,{children:"isEmpty"}),", ",(0,i.jsx)(n.code,{children:"last"}),", ",(0,i.jsx)(n.code,{children:"lastIndexOf"}),", ",(0,i.jsx)(n.code,{children:"lastIndexOfSlice"}),", ",(0,i.jsx)(n.code,{children:"lastIndexWhere"}),", ",(0,i.jsx)(n.code,{children:"lastOption"}),", ",(0,i.jsx)(n.code,{children:"length"}),", ",(0,i.jsx)(n.code,{children:"map"}),", ",(0,i.jsx)(n.code,{children:"max"}),", ",(0,i.jsx)(n.code,{children:"maxBy"}),", ",(0,i.jsx)(n.code,{children:"maxByOption"}),", ",(0,i.jsx)(n.code,{children:"maxOption"}),", ",(0,i.jsx)(n.code,{children:"min"}),", ",(0,i.jsx)(n.code,{children:"minBy"}),", ",(0,i.jsx)(n.code,{children:"minByOption"}),", ",(0,i.jsx)(n.code,{children:"minOption"}),", ",(0,i.jsx)(n.code,{children:"mkString"}),", ",(0,i.jsx)(n.code,{children:"nonEmpty"}),", ",(0,i.jsx)(n.code,{children:"padTo"}),", ",(0,i.jsx)(n.code,{children:"partition"}),", ",(0,i.jsx)(n.code,{children:"partitionMap"}),", ",(0,i.jsx)(n.code,{children:"patch"}),", ",(0,i.jsx)(n.code,{children:"permutations"}),", ",(0,i.jsx)(n.code,{children:"prepended"}),", ",(0,i.jsx)(n.code,{children:"prependedAll"}),", ",(0,i.jsx)(n.code,{children:"product"}),", ",(0,i.jsx)(n.code,{children:"reduce"}),", ",(0,i.jsx)(n.code,{children:"reduceLeft"}),", ",(0,i.jsx)(n.code,{children:"reduceLeftOption"}),", ",(0,i.jsx)(n.code,{children:"reduceOption"}),", ",(0,i.jsx)(n.code,{children:"reduceRight"}),", ",(0,i.jsx)(n.code,{children:"reduceRightOption"}),", ",(0,i.jsx)(n.code,{children:"removedAll"}),", ",(0,i.jsx)(n.code,{children:"reverse"}),", ",(0,i.jsx)(n.code,{children:"sameElements"}),", ",(0,i.jsx)(n.code,{children:"scan"}),", ",(0,i.jsx)(n.code,{children:"scanLeft"}),", ",(0,i.jsx)(n.code,{children:"scanRight"}),", ",(0,i.jsx)(n.code,{children:"segmentLength"}),", ",(0,i.jsx)(n.code,{children:"size"}),", ",(0,i.jsx)(n.code,{children:"slice"}),", ",(0,i.jsx)(n.code,{children:"sliding"}),", ",(0,i.jsx)(n.code,{children:"sortBy"}),", ",(0,i.jsx)(n.code,{children:"sorted"}),", ",(0,i.jsx)(n.code,{children:"span"}),", ",(0,i.jsx)(n.code,{children:"splitAt"}),", ",(0,i.jsx)(n.code,{children:"startsWith"}),", ",(0,i.jsx)(n.code,{children:"sum"}),", ",(0,i.jsx)(n.code,{children:"tail"}),", ",(0,i.jsx)(n.code,{children:"tails"}),", ",(0,i.jsx)(n.code,{children:"take"}),", ",(0,i.jsx)(n.code,{children:"takeRight"}),", ",(0,i.jsx)(n.code,{children:"takeWhile"}),", ",(0,i.jsx)(n.code,{children:"toList"}),", ",(0,i.jsx)(n.code,{children:"toMap"}),", ",(0,i.jsx)(n.code,{children:"toSet"}),", ",(0,i.jsx)(n.code,{children:"unzip"}),", ",(0,i.jsx)(n.code,{children:"unzip3"}),", ",(0,i.jsx)(n.code,{children:"zip"}),", ",(0,i.jsx)(n.code,{children:"zipAll"}),", ",(0,i.jsx)(n.code,{children:"zipWithIndex"})]}),"\n",(0,i.jsxs)(n.p,{children:["and on the ",(0,i.jsx)(n.code,{children:"Chunk"})," companion object:"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"fill"}),", ",(0,i.jsx)(n.code,{children:"fromList"})]}),"\n",(0,i.jsx)(n.h3,{id:"remoteduration",children:"Remote[Duration]"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"+"}),", ",(0,i.jsx)(n.code,{children:"*"}),", ",(0,i.jsx)(n.code,{children:"abs"}),", ",(0,i.jsx)(n.code,{children:"addTo"}),", ",(0,i.jsx)(n.code,{children:"dividedBy"}),", ",(0,i.jsx)(n.code,{children:"get"}),", ",(0,i.jsx)(n.code,{children:"getNano"}),", ",(0,i.jsx)(n.code,{children:"getSeconds"}),", ",(0,i.jsx)(n.code,{children:"isNegative"}),", ",(0,i.jsx)(n.code,{children:"isZero"}),", ",(0,i.jsx)(n.code,{children:"minus"}),", ",(0,i.jsx)(n.code,{children:"minusDays"}),", ",(0,i.jsx)(n.code,{children:"minusHours"}),", ",(0,i.jsx)(n.code,{children:"minusMinutes"}),", ",(0,i.jsx)(n.code,{children:"minusNanos"}),", ",(0,i.jsx)(n.code,{children:"minusSeconds"}),", ",(0,i.jsx)(n.code,{children:"multipliedBy"}),", ",(0,i.jsx)(n.code,{children:"negated"}),", ",(0,i.jsx)(n.code,{children:"plus"}),", ",(0,i.jsx)(n.code,{children:"plusDays"}),", ",(0,i.jsx)(n.code,{children:"plusHours"}),", ",(0,i.jsx)(n.code,{children:"plusMinutes"}),", ",(0,i.jsx)(n.code,{children:"plusNanos"}),", ",(0,i.jsx)(n.code,{children:"plusSeconds"}),", ",(0,i.jsx)(n.code,{children:"subtractFrom"}),", ",(0,i.jsx)(n.code,{children:"toDays"}),", ",(0,i.jsx)(n.code,{children:"toHours"}),", ",(0,i.jsx)(n.code,{children:"toMillis"}),", ",(0,i.jsx)(n.code,{children:"toMinutes"}),", ",(0,i.jsx)(n.code,{children:"toNanos"}),", ",(0,i.jsx)(n.code,{children:"toSeconds"}),", ",(0,i.jsx)(n.code,{children:"toDaysPart"}),", ",(0,i.jsx)(n.code,{children:"toHoursPart"}),", ",(0,i.jsx)(n.code,{children:"toMinutesPart"}),", ",(0,i.jsx)(n.code,{children:"toSecondsPart"}),", ",(0,i.jsx)(n.code,{children:"toMillisPart"}),", ",(0,i.jsx)(n.code,{children:"toNanosPart"}),", ",(0,i.jsx)(n.code,{children:"withNanos"}),", ",(0,i.jsx)(n.code,{children:"withSeconds"})]}),"\n",(0,i.jsxs)(n.p,{children:["and on the ",(0,i.jsx)(n.code,{children:"Duration"})," companion object:"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"between"}),", ",(0,i.jsx)(n.code,{children:"of"}),", ",(0,i.jsx)(n.code,{children:"ofDays"}),", ",(0,i.jsx)(n.code,{children:"ofHours"}),", ",(0,i.jsx)(n.code,{children:"ofMillis"}),", ",(0,i.jsx)(n.code,{children:"ofMinutes"}),", ",(0,i.jsx)(n.code,{children:"ofNanos"}),", ",(0,i.jsx)(n.code,{children:"ofSeconds"}),", ",(0,i.jsx)(n.code,{children:"parse"})]}),"\n",(0,i.jsx)(n.h3,{id:"remoteeitherl-r",children:"Remote[Either[L, R]]"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"contains"}),", ",(0,i.jsx)(n.code,{children:"exists"}),", ",(0,i.jsx)(n.code,{children:"filterOrElse"}),", ",(0,i.jsx)(n.code,{children:"flatMap"}),", ",(0,i.jsx)(n.code,{children:"flatten"}),", ",(0,i.jsx)(n.code,{children:"fold"}),", ",(0,i.jsx)(n.code,{children:"forall"}),", ",(0,i.jsx)(n.code,{children:"getOrElse"}),", ",(0,i.jsx)(n.code,{children:"isLeft"}),", ",(0,i.jsx)(n.code,{children:"isRight"}),", ",(0,i.jsx)(n.code,{children:"joinLeft"}),", ",(0,i.jsx)(n.code,{children:"joinRight"}),", ",(0,i.jsx)(n.code,{children:"left.getOrElse"}),", ",(0,i.jsx)(n.code,{children:"left.forall"}),", ",(0,i.jsx)(n.code,{children:"left.exists"}),", ",(0,i.jsx)(n.code,{children:"left.filterToOption"}),", ",(0,i.jsx)(n.code,{children:"left.flatMap"}),", ",(0,i.jsx)(n.code,{children:"left.map"}),", ",(0,i.jsx)(n.code,{children:"left.toSeq"}),", ",(0,i.jsx)(n.code,{children:"left.toOption"}),", ",(0,i.jsx)(n.code,{children:"map"}),", ",(0,i.jsx)(n.code,{children:"merge"}),", ",(0,i.jsx)(n.code,{children:"orElse"}),", ",(0,i.jsx)(n.code,{children:"swap"}),", ",(0,i.jsx)(n.code,{children:"toOption"}),", ",(0,i.jsx)(n.code,{children:"toSeq"}),", ",(0,i.jsx)(n.code,{children:"toTry"})]}),"\n",(0,i.jsx)(n.h3,{id:"remoteinstant",children:"Remote[Instant]"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"get"}),", ",(0,i.jsx)(n.code,{children:"getLong"}),", ",(0,i.jsx)(n.code,{children:"getEpochSecond"}),", ",(0,i.jsx)(n.code,{children:"getNano"}),", ",(0,i.jsx)(n.code,{children:"isAfter"}),", ",(0,i.jsx)(n.code,{children:"isBefore"}),", ",(0,i.jsx)(n.code,{children:"minus"}),", ",(0,i.jsx)(n.code,{children:"minusNanos"}),", ",(0,i.jsx)(n.code,{children:"minusSeconds"}),", ",(0,i.jsx)(n.code,{children:"minusMillis"}),", ",(0,i.jsx)(n.code,{children:"plus"}),", ",(0,i.jsx)(n.code,{children:"plusNanos"}),", ",(0,i.jsx)(n.code,{children:"plusSeconds"}),", ",(0,i.jsx)(n.code,{children:"plusMillis"}),", ",(0,i.jsx)(n.code,{children:"toEpochMilli"}),", ",(0,i.jsx)(n.code,{children:"truncatedTo"}),", ",(0,i.jsx)(n.code,{children:"until"}),", ",(0,i.jsx)(n.code,{children:"with"})]}),"\n",(0,i.jsxs)(n.p,{children:["and on the ",(0,i.jsx)(n.code,{children:"Instant"})," companion object:"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"now"}),", ",(0,i.jsx)(n.code,{children:"ofEpochSecond"}),", ",(0,i.jsx)(n.code,{children:"ofEpochMilli"}),", ",(0,i.jsx)(n.code,{children:"parse"})]}),"\n",(0,i.jsx)(n.h3,{id:"remotelista",children:"Remote[List[A]]"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"++"}),", ",(0,i.jsx)(n.code,{children:"++:"}),", ",(0,i.jsx)(n.code,{children:"+:"}),", ",(0,i.jsx)(n.code,{children:":+"}),", :++",(0,i.jsx)(n.code,{children:", "}),"::",(0,i.jsx)(n.code,{children:", "}),":::",(0,i.jsx)(n.code,{children:", appended"}),", ",(0,i.jsx)(n.code,{children:"appendedAll"}),", ",(0,i.jsx)(n.code,{children:"apply"}),", ",(0,i.jsx)(n.code,{children:"concat"}),", ",(0,i.jsx)(n.code,{children:"contains"}),", ",(0,i.jsx)(n.code,{children:"containsSlice"}),", ",(0,i.jsx)(n.code,{children:"corresponds"}),", ",(0,i.jsx)(n.code,{children:"count"}),", ",(0,i.jsx)(n.code,{children:"diff"}),", ",(0,i.jsx)(n.code,{children:"distinct"}),", ",(0,i.jsx)(n.code,{children:"distinctBy"}),", ",(0,i.jsx)(n.code,{children:"drop"}),", ",(0,i.jsx)(n.code,{children:"dropRight"}),", ",(0,i.jsx)(n.code,{children:"dropWhile"}),", ",(0,i.jsx)(n.code,{children:"endsWith"}),", ",(0,i.jsx)(n.code,{children:"empty"}),", ",(0,i.jsx)(n.code,{children:"exists"}),", ",(0,i.jsx)(n.code,{children:"filter"}),", ",(0,i.jsx)(n.code,{children:"filterNot"}),", ",(0,i.jsx)(n.code,{children:"find"}),", ",(0,i.jsx)(n.code,{children:"findLast"}),", ",(0,i.jsx)(n.code,{children:"flatMap"}),", ",(0,i.jsx)(n.code,{children:"flatten"}),", ",(0,i.jsx)(n.code,{children:"fold"}),", ",(0,i.jsx)(n.code,{children:"foldLeft"}),", ",(0,i.jsx)(n.code,{children:"foldRight"}),", ",(0,i.jsx)(n.code,{children:"forall"}),", ",(0,i.jsx)(n.code,{children:"groupBy"}),", ",(0,i.jsx)(n.code,{children:"groupMap"}),", ",(0,i.jsx)(n.code,{children:"groupMapReduce"}),", ",(0,i.jsx)(n.code,{children:"grouped"}),", ",(0,i.jsx)(n.code,{children:"head"}),", ",(0,i.jsx)(n.code,{children:"headOption"}),", ",(0,i.jsx)(n.code,{children:"indexOf"}),", ",(0,i.jsx)(n.code,{children:"indexOfSlice"}),", ",(0,i.jsx)(n.code,{children:"indexWhere"}),", ",(0,i.jsx)(n.code,{children:"init"}),", ",(0,i.jsx)(n.code,{children:"inits"}),", ",(0,i.jsx)(n.code,{children:"intersect"}),", ",(0,i.jsx)(n.code,{children:"isDefinedAt"}),", ",(0,i.jsx)(n.code,{children:"isEmpty"}),", ",(0,i.jsx)(n.code,{children:"last"}),", ",(0,i.jsx)(n.code,{children:"lastIndexOf"}),", ",(0,i.jsx)(n.code,{children:"lastIndexOfSlice"}),", ",(0,i.jsx)(n.code,{children:"lastIndexWhere"}),", ",(0,i.jsx)(n.code,{children:"lastOption"}),", ",(0,i.jsx)(n.code,{children:"length"}),", ",(0,i.jsx)(n.code,{children:"map"}),", ",(0,i.jsx)(n.code,{children:"max"}),", ",(0,i.jsx)(n.code,{children:"maxBy"}),", ",(0,i.jsx)(n.code,{children:"maxByOption"}),", ",(0,i.jsx)(n.code,{children:"maxOption"}),", ",(0,i.jsx)(n.code,{children:"min"}),", ",(0,i.jsx)(n.code,{children:"minBy"}),", ",(0,i.jsx)(n.code,{children:"minByOption"}),", ",(0,i.jsx)(n.code,{children:"minOption"}),", ",(0,i.jsx)(n.code,{children:"mkString"}),", ",(0,i.jsx)(n.code,{children:"nonEmpty"}),", ",(0,i.jsx)(n.code,{children:"padTo"}),", ",(0,i.jsx)(n.code,{children:"partition"}),", ",(0,i.jsx)(n.code,{children:"partitionMap"}),", ",(0,i.jsx)(n.code,{children:"patch"}),", ",(0,i.jsx)(n.code,{children:"permutations"}),", ",(0,i.jsx)(n.code,{children:"prepended"}),", ",(0,i.jsx)(n.code,{children:"prependedAll"}),", ",(0,i.jsx)(n.code,{children:"product"}),", ",(0,i.jsx)(n.code,{children:"reduce"}),", ",(0,i.jsx)(n.code,{children:"reduceLeft"}),", ",(0,i.jsx)(n.code,{children:"reduceLeftOption"}),", ",(0,i.jsx)(n.code,{children:"reduceOption"}),", ",(0,i.jsx)(n.code,{children:"reduceRight"}),", ",(0,i.jsx)(n.code,{children:"reduceRightOption"}),", ",(0,i.jsx)(n.code,{children:"removedAll"}),", ",(0,i.jsx)(n.code,{children:"reverse"}),", ",(0,i.jsx)(n.code,{children:"reverse_:::"}),", ",(0,i.jsx)(n.code,{children:"sameElements"}),", ",(0,i.jsx)(n.code,{children:"scan"}),", ",(0,i.jsx)(n.code,{children:"scanLeft"}),", ",(0,i.jsx)(n.code,{children:"scanRight"}),", ",(0,i.jsx)(n.code,{children:"segmentLength"}),", ",(0,i.jsx)(n.code,{children:"size"}),", ",(0,i.jsx)(n.code,{children:"slice"}),", ",(0,i.jsx)(n.code,{children:"sliding"}),", ",(0,i.jsx)(n.code,{children:"sortBy"}),", ",(0,i.jsx)(n.code,{children:"sorted"}),", ",(0,i.jsx)(n.code,{children:"span"}),", ",(0,i.jsx)(n.code,{children:"splitAt"}),", ",(0,i.jsx)(n.code,{children:"startsWith"}),", ",(0,i.jsx)(n.code,{children:"sum"}),", ",(0,i.jsx)(n.code,{children:"tail"}),", ",(0,i.jsx)(n.code,{children:"tails"}),", ",(0,i.jsx)(n.code,{children:"take"}),", ",(0,i.jsx)(n.code,{children:"takeRight"}),", ",(0,i.jsx)(n.code,{children:"takeWhile"}),", ",(0,i.jsx)(n.code,{children:"toList"}),", ",(0,i.jsx)(n.code,{children:"toMap"}),", ",(0,i.jsx)(n.code,{children:"toSet"}),", ",(0,i.jsx)(n.code,{children:"unzip"}),", ",(0,i.jsx)(n.code,{children:"unzip3"}),", ",(0,i.jsx)(n.code,{children:"zip"}),", ",(0,i.jsx)(n.code,{children:"zipAll"}),", ",(0,i.jsx)(n.code,{children:"zipWithIndex"})]}),"\n",(0,i.jsxs)(n.p,{children:["and on the ",(0,i.jsx)(n.code,{children:"List"})," companion object:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"fill"})}),"\n",(0,i.jsx)(n.h3,{id:"remotemapk-v",children:"Remote[Map[K, V]]"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"+"}),", ",(0,i.jsx)(n.code,{children:"++"}),", ",(0,i.jsx)(n.code,{children:"-"}),", ",(0,i.jsx)(n.code,{children:"--"}),", ",(0,i.jsx)(n.code,{children:"apply"}),", ",(0,i.jsx)(n.code,{children:"applyOrElse"}),", ",(0,i.jsx)(n.code,{children:"concat"}),", ",(0,i.jsx)(n.code,{children:"contains"}),", ",(0,i.jsx)(n.code,{children:"corresponds"}),", ",(0,i.jsx)(n.code,{children:"count"}),", ",(0,i.jsx)(n.code,{children:"drop"}),", ",(0,i.jsx)(n.code,{children:"dropRight"}),", ",(0,i.jsx)(n.code,{children:"dropWhile"}),", ",(0,i.jsx)(n.code,{children:"empty"}),", ",(0,i.jsx)(n.code,{children:"exists"}),", ",(0,i.jsx)(n.code,{children:"filter"}),", ",(0,i.jsx)(n.code,{children:"filterNot"}),", ",(0,i.jsx)(n.code,{children:"find"}),", ",(0,i.jsx)(n.code,{children:"flatMap"}),", ",(0,i.jsx)(n.code,{children:"fold"}),", ",(0,i.jsx)(n.code,{children:"foldLeft"}),", ",(0,i.jsx)(n.code,{children:"foldRight"}),", ",(0,i.jsx)(n.code,{children:"forall"}),", ",(0,i.jsx)(n.code,{children:"get"}),", ",(0,i.jsx)(n.code,{children:"getOrElse"}),", ",(0,i.jsx)(n.code,{children:"groupBy"}),", ",(0,i.jsx)(n.code,{children:"groupMap"}),", ",(0,i.jsx)(n.code,{children:"groupMapReduce"}),", ",(0,i.jsx)(n.code,{children:"grouped"}),", ",(0,i.jsx)(n.code,{children:"head"}),", ",(0,i.jsx)(n.code,{children:"headOption"}),", ",(0,i.jsx)(n.code,{children:"init"}),", ",(0,i.jsx)(n.code,{children:"inits"}),", ",(0,i.jsx)(n.code,{children:"intersect"}),", ",(0,i.jsx)(n.code,{children:"isDefinedAt"}),", ",(0,i.jsx)(n.code,{children:"isEmpty"}),", ",(0,i.jsx)(n.code,{children:"keySet"}),", ",(0,i.jsx)(n.code,{children:"keys"}),", ",(0,i.jsx)(n.code,{children:"last"}),", ",(0,i.jsx)(n.code,{children:"lastOption"}),", ",(0,i.jsx)(n.code,{children:"lift"}),", ",(0,i.jsx)(n.code,{children:"map"}),", ",(0,i.jsx)(n.code,{children:"mkString"}),", ",(0,i.jsx)(n.code,{children:"nonEmpty"}),", ",(0,i.jsx)(n.code,{children:"partition"}),", ",(0,i.jsx)(n.code,{children:"partitionMap"}),", ",(0,i.jsx)(n.code,{children:"reduce"}),", ",(0,i.jsx)(n.code,{children:"reduceLeft"}),", ",(0,i.jsx)(n.code,{children:"reduceLeftOption"}),", ",(0,i.jsx)(n.code,{children:"reduceOption"}),", ",(0,i.jsx)(n.code,{children:"reduceRight"}),", ",(0,i.jsx)(n.code,{children:"reduceRightOption"}),", ",(0,i.jsx)(n.code,{children:"removed"}),", ",(0,i.jsx)(n.code,{children:"removedAll"}),", ",(0,i.jsx)(n.code,{children:"scan"}),", ",(0,i.jsx)(n.code,{children:"scanLeft"}),", ",(0,i.jsx)(n.code,{children:"scanRight"}),", ",(0,i.jsx)(n.code,{children:"size"}),", ",(0,i.jsx)(n.code,{children:"slice"}),", ",(0,i.jsx)(n.code,{children:"sliding"}),", ",(0,i.jsx)(n.code,{children:"span"}),", ",(0,i.jsx)(n.code,{children:"splitAt"}),", ",(0,i.jsx)(n.code,{children:"tail"}),", ",(0,i.jsx)(n.code,{children:"tails"}),", ",(0,i.jsx)(n.code,{children:"take"}),", ",(0,i.jsx)(n.code,{children:"takeRight"}),", ",(0,i.jsx)(n.code,{children:"updated"}),", ",(0,i.jsx)(n.code,{children:"toList"}),", ",(0,i.jsx)(n.code,{children:"toSet"}),", ",(0,i.jsx)(n.code,{children:"unzip"}),", ",(0,i.jsx)(n.code,{children:"values"}),", ",(0,i.jsx)(n.code,{children:"zip"}),", ",(0,i.jsx)(n.code,{children:"zipAll"})]}),"\n",(0,i.jsx)(n.h3,{id:"remoteoffsetdatetime",children:"Remote[OffsetDateTime]"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"getYear"}),", ",(0,i.jsx)(n.code,{children:"getMonthValue"}),", ",(0,i.jsx)(n.code,{children:"getDayOfMonth"}),", ",(0,i.jsx)(n.code,{children:"getHour"}),", ",(0,i.jsx)(n.code,{children:"getMinute"}),", ",(0,i.jsx)(n.code,{children:"getSecond"}),", ",(0,i.jsx)(n.code,{children:"getNano, "}),"getOffset",(0,i.jsx)(n.code,{children:", "}),"toInstant`"]}),"\n",(0,i.jsxs)(n.p,{children:["and on the ",(0,i.jsx)(n.code,{children:"OffsetDateTime"})," companion object:"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"of"}),", ",(0,i.jsx)(n.code,{children:"ofInstant"})]}),"\n",(0,i.jsx)(n.h3,{id:"remoteoptiona",children:"Remote[Option[A]]"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"contains"}),", ",(0,i.jsx)(n.code,{children:"exists"}),", ",(0,i.jsx)(n.code,{children:"filter"}),", ",(0,i.jsx)(n.code,{children:"filterNot"}),", ",(0,i.jsx)(n.code,{children:"flatMap"}),", ",(0,i.jsx)(n.code,{children:"fold"}),", ",(0,i.jsx)(n.code,{children:"foldLeft"}),", ",(0,i.jsx)(n.code,{children:"foldRight"}),", ",(0,i.jsx)(n.code,{children:"forall"}),", ",(0,i.jsx)(n.code,{children:"get"}),", ",(0,i.jsx)(n.code,{children:"getOrElse"}),", ",(0,i.jsx)(n.code,{children:"head"}),", ",(0,i.jsx)(n.code,{children:"headOption"}),", ",(0,i.jsx)(n.code,{children:"isSome"}),", ",(0,i.jsx)(n.code,{children:"isNone"}),", ",(0,i.jsx)(n.code,{children:"isDefined"}),", ",(0,i.jsx)(n.code,{children:"isEmpty"}),", ",(0,i.jsx)(n.code,{children:"knownSize"}),", ",(0,i.jsx)(n.code,{children:"last"}),", ",(0,i.jsx)(n.code,{children:"lastOption"}),", ",(0,i.jsx)(n.code,{children:"map"}),", ",(0,i.jsx)(n.code,{children:"nonEmpty"}),", ",(0,i.jsx)(n.code,{children:"orElse"}),", ",(0,i.jsx)(n.code,{children:"toLeft"}),", ",(0,i.jsx)(n.code,{children:"toList"}),", ",(0,i.jsx)(n.code,{children:"toRight"}),", ",(0,i.jsx)(n.code,{children:"zip"})]}),"\n",(0,i.jsx)(n.h3,{id:"remoteregex",children:"Remote[Regex]"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"findFirstIn"}),", ",(0,i.jsx)(n.code,{children:"findMatches"}),", ",(0,i.jsx)(n.code,{children:"matches"}),", ",(0,i.jsx)(n.code,{children:"replaceAllIn"}),", ",(0,i.jsx)(n.code,{children:"replaceFirstIn"}),", ",(0,i.jsx)(n.code,{children:"split"}),", ",(0,i.jsx)(n.code,{children:"regex"})]}),"\n",(0,i.jsx)(n.h3,{id:"remoteseta",children:"Remote[Set[A]]"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"&"}),", ",(0,i.jsx)(n.code,{children:"&~"}),", ",(0,i.jsx)(n.code,{children:"+"}),", ",(0,i.jsx)(n.code,{children:"++"}),", ",(0,i.jsx)(n.code,{children:"-"}),", ",(0,i.jsx)(n.code,{children:"--"}),", ",(0,i.jsx)(n.code,{children:"apply"}),", ",(0,i.jsx)(n.code,{children:"concat"}),", ",(0,i.jsx)(n.code,{children:"contains"}),",",(0,i.jsx)(n.code,{children:"corresponds"}),", ",(0,i.jsx)(n.code,{children:"count"}),", ",(0,i.jsx)(n.code,{children:"diff"}),", ",(0,i.jsx)(n.code,{children:"drop"}),", ",(0,i.jsx)(n.code,{children:"dropRight"}),", ",(0,i.jsx)(n.code,{children:"dropWhile"}),", ",(0,i.jsx)(n.code,{children:"empty"}),", ",(0,i.jsx)(n.code,{children:"excl"}),", ",(0,i.jsx)(n.code,{children:"exists"}),", ",(0,i.jsx)(n.code,{children:"filter"}),", ",(0,i.jsx)(n.code,{children:"filterNot"}),", ",(0,i.jsx)(n.code,{children:"find"}),", ",(0,i.jsx)(n.code,{children:"flatMap"}),", ",(0,i.jsx)(n.code,{children:"flatten"}),", ",(0,i.jsx)(n.code,{children:"fold"}),", ",(0,i.jsx)(n.code,{children:"foldLeft"}),", ",(0,i.jsx)(n.code,{children:"foldRight"}),", ",(0,i.jsx)(n.code,{children:"forall"}),", ",(0,i.jsx)(n.code,{children:"groupBy"}),", ",(0,i.jsx)(n.code,{children:"groupMap"}),", ",(0,i.jsx)(n.code,{children:"groupMapReduce"}),", ",(0,i.jsx)(n.code,{children:"head"}),", ",(0,i.jsx)(n.code,{children:"headOption"}),", ",(0,i.jsx)(n.code,{children:"init"}),", ",(0,i.jsx)(n.code,{children:"inits"}),", ",(0,i.jsx)(n.code,{children:"intersect"}),", ",(0,i.jsx)(n.code,{children:"isEmpty"}),", ",(0,i.jsx)(n.code,{children:"last"}),", ",(0,i.jsx)(n.code,{children:"lastOption"}),", ",(0,i.jsx)(n.code,{children:"map"}),", ",(0,i.jsx)(n.code,{children:"max"}),", ",(0,i.jsx)(n.code,{children:"maxBy"}),", ",(0,i.jsx)(n.code,{children:"maxByOption"}),", ",(0,i.jsx)(n.code,{children:"maxOption"}),", ",(0,i.jsx)(n.code,{children:"min"}),", ",(0,i.jsx)(n.code,{children:"minBy"}),", ",(0,i.jsx)(n.code,{children:"minByOption"}),", ",(0,i.jsx)(n.code,{children:"minOption"}),", ",(0,i.jsx)(n.code,{children:"mkString"}),", ",(0,i.jsx)(n.code,{children:"nonEmpty"}),", , ",(0,i.jsx)(n.code,{children:"partition"}),", ",(0,i.jsx)(n.code,{children:"partitionMap"}),", ",(0,i.jsx)(n.code,{children:"product"}),", ",(0,i.jsx)(n.code,{children:"reduce"}),", ",(0,i.jsx)(n.code,{children:"reduceLeft"}),", ",(0,i.jsx)(n.code,{children:"reduceLeftOption"}),", ",(0,i.jsx)(n.code,{children:"reduceOption"}),", ",(0,i.jsx)(n.code,{children:"reduceRight"}),", ",(0,i.jsx)(n.code,{children:"reduceRightOption"}),", ",(0,i.jsx)(n.code,{children:"removedAll"}),",, ",(0,i.jsx)(n.code,{children:"sameElements"}),", ",(0,i.jsx)(n.code,{children:"scan"}),", ",(0,i.jsx)(n.code,{children:"scanLeft"}),", ",(0,i.jsx)(n.code,{children:"scanRight"}),", ",(0,i.jsx)(n.code,{children:"size"}),", ",(0,i.jsx)(n.code,{children:"slice"}),", ",(0,i.jsx)(n.code,{children:"sliding"}),", ",(0,i.jsx)(n.code,{children:"span"}),", ",(0,i.jsx)(n.code,{children:"splitAt"}),", ",(0,i.jsx)(n.code,{children:"sum"}),", ",(0,i.jsx)(n.code,{children:"tail"}),", ",(0,i.jsx)(n.code,{children:"tails"}),", ",(0,i.jsx)(n.code,{children:"take"}),", ",(0,i.jsx)(n.code,{children:"takeRight"}),", ",(0,i.jsx)(n.code,{children:"takeWhile"}),", ",(0,i.jsx)(n.code,{children:"toList"}),", ",(0,i.jsx)(n.code,{children:"toMap"}),", ",(0,i.jsx)(n.code,{children:"toSet"}),", ",(0,i.jsx)(n.code,{children:"union"}),", ",(0,i.jsx)(n.code,{children:"unzip"}),", ",(0,i.jsx)(n.code,{children:"unzip3"}),", ",(0,i.jsx)(n.code,{children:"zip"}),", ",(0,i.jsx)(n.code,{children:"zipAll"}),", ",(0,i.jsx)(n.code,{children:"zipWithIndex"}),", ",(0,i.jsx)(n.code,{children:"|"})]}),"\n",(0,i.jsx)(n.h3,{id:"remotestring",children:"Remote[String]"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"*"}),", ",(0,i.jsx)(n.code,{children:"+"}),", ",(0,i.jsx)(n.code,{children:"++"}),", ",(0,i.jsx)(n.code,{children:"++:"}),", ",(0,i.jsx)(n.code,{children:"+:"}),", ",(0,i.jsx)(n.code,{children:":+"}),", ",(0,i.jsx)(n.code,{children:":++"}),", ",(0,i.jsx)(n.code,{children:"appended"}),", ",(0,i.jsx)(n.code,{children:"appendedAll"}),", ",(0,i.jsx)(n.code,{children:"apply"}),", ",(0,i.jsx)(n.code,{children:"capitalize"}),", ",(0,i.jsx)(n.code,{children:"charAt"}),", ",(0,i.jsx)(n.code,{children:"concat"}),", ",(0,i.jsx)(n.code,{children:"contains"}),", ",(0,i.jsx)(n.code,{children:"count"}),", ",(0,i.jsx)(n.code,{children:"diff"}),", ",(0,i.jsx)(n.code,{children:"distrinct"}),", ",(0,i.jsx)(n.code,{children:"distinctBy"}),", ",(0,i.jsx)(n.code,{children:"drop"}),", ",(0,i.jsx)(n.code,{children:"dropRight"}),", ",(0,i.jsx)(n.code,{children:"dropWhile"}),", ",(0,i.jsx)(n.code,{children:"endsWith"}),", ",(0,i.jsx)(n.code,{children:"exists"}),", ",(0,i.jsx)(n.code,{children:"filter"}),", ",(0,i.jsx)(n.code,{children:"filterNot"}),", ",(0,i.jsx)(n.code,{children:"find"}),", ",(0,i.jsx)(n.code,{children:"flatMap"}),", ",(0,i.jsx)(n.code,{children:"fold"}),", ",(0,i.jsx)(n.code,{children:"foldLeft"}),", ",(0,i.jsx)(n.code,{children:"foldRight"}),", ",(0,i.jsx)(n.code,{children:"forall"}),", ",(0,i.jsx)(n.code,{children:"groupBy"}),", ",(0,i.jsx)(n.code,{children:"groupMap"}),", ",(0,i.jsx)(n.code,{children:"groupMapReduce"})," ",(0,i.jsx)(n.code,{children:"grouped"}),", ",(0,i.jsx)(n.code,{children:"head"}),", ",(0,i.jsx)(n.code,{children:"headOption"}),", ",(0,i.jsx)(n.code,{children:"inddexOf"}),", ",(0,i.jsx)(n.code,{children:"indexWhere"}),", ",(0,i.jsx)(n.code,{children:"init"}),", ",(0,i.jsx)(n.code,{children:"inits"}),", ",(0,i.jsx)(n.code,{children:"intersect"}),", ",(0,i.jsx)(n.code,{children:"isEmpty"}),", ",(0,i.jsx)(n.code,{children:"knownSize"}),", ",(0,i.jsx)(n.code,{children:"last"}),", ",(0,i.jsx)(n.code,{children:"lastIndexOf"}),", ",(0,i.jsx)(n.code,{children:"lastIndexWhere"}),", ",(0,i.jsx)(n.code,{children:"lastOption"}),", ",(0,i.jsx)(n.code,{children:"length"}),", ",(0,i.jsx)(n.code,{children:"map"}),", ",(0,i.jsx)(n.code,{children:"mkString"}),", ",(0,i.jsx)(n.code,{children:"nonEmpty"}),", ",(0,i.jsx)(n.code,{children:"padTo"}),", ",(0,i.jsx)(n.code,{children:"partition"}),", ",(0,i.jsx)(n.code,{children:"partitionMap"}),", ",(0,i.jsx)(n.code,{children:"patch"}),", ",(0,i.jsx)(n.code,{children:"permutations"}),", ",(0,i.jsx)(n.code,{children:"prepended"}),", ",(0,i.jsx)(n.code,{children:"prependedAll"}),", ",(0,i.jsx)(n.code,{children:"r"}),", ",(0,i.jsx)(n.code,{children:"replace"}),", ",(0,i.jsx)(n.code,{children:"replaceAll"}),", ",(0,i.jsx)(n.code,{children:"replaceFirst"}),", ",(0,i.jsx)(n.code,{children:"reverse"}),", ",(0,i.jsx)(n.code,{children:"size"}),", ",(0,i.jsx)(n.code,{children:"slice"}),", ",(0,i.jsx)(n.code,{children:"sliding"}),", ",(0,i.jsx)(n.code,{children:"span"}),", ",(0,i.jsx)(n.code,{children:"split"}),", ",(0,i.jsx)(n.code,{children:"splitAt"}),", ",(0,i.jsx)(n.code,{children:"startsWith"}),", ",(0,i.jsx)(n.code,{children:"strip"}),", ",(0,i.jsx)(n.code,{children:"stripLeading"}),", ",(0,i.jsx)(n.code,{children:"stripLineEnd"}),", ",(0,i.jsx)(n.code,{children:"stripMargin"}),", ",(0,i.jsx)(n.code,{children:"stripPrefix"}),", ",(0,i.jsx)(n.code,{children:"stripTrailing"}),", ",(0,i.jsx)(n.code,{children:"stripSuffix"}),", ",(0,i.jsx)(n.code,{children:"substring"}),", ",(0,i.jsx)(n.code,{children:"tail"}),", ",(0,i.jsx)(n.code,{children:"tails"}),", ",(0,i.jsx)(n.code,{children:"take"}),", ",(0,i.jsx)(n.code,{children:"takeRight"}),", ",(0,i.jsx)(n.code,{children:"takeWhile"}),", ",(0,i.jsx)(n.code,{children:"toBase64"}),", ",(0,i.jsx)(n.code,{children:"toBoolean"}),", ",(0,i.jsx)(n.code,{children:"toBooleanOption"}),", ",(0,i.jsx)(n.code,{children:"toByte"}),", toByteOption",(0,i.jsx)(n.code,{children:", "}),"toDouble",(0,i.jsx)(n.code,{children:", "}),"toDoubleOption",(0,i.jsx)(n.code,{children:", "}),"toFloat",(0,i.jsx)(n.code,{children:", "}),"toFloatOption",(0,i.jsx)(n.code,{children:", "}),"toInt",(0,i.jsx)(n.code,{children:", "}),"toIntOption",(0,i.jsx)(n.code,{children:", "}),"toList",(0,i.jsx)(n.code,{children:", "}),"toLong",(0,i.jsx)(n.code,{children:", "}),"toLongOption",(0,i.jsx)(n.code,{children:", "}),"toLowerCase",(0,i.jsx)(n.code,{children:", "}),"toShort",(0,i.jsx)(n.code,{children:", "}),"toShortOption",(0,i.jsx)(n.code,{children:", "}),"toUpperCase",(0,i.jsx)(n.code,{children:", "}),"trim`"]}),"\n",(0,i.jsx)(n.h3,{id:"remote-numeric-types",children:"Remote numeric types"}),"\n",(0,i.jsxs)(n.p,{children:["Applies to ",(0,i.jsx)(n.code,{children:"Char"}),", ",(0,i.jsx)(n.code,{children:"Byte"}),", ",(0,i.jsx)(n.code,{children:"Short"}),", ",(0,i.jsx)(n.code,{children:"Int"}),", ",(0,i.jsx)(n.code,{children:"Long"}),", ",(0,i.jsx)(n.code,{children:"Float"}),", ",(0,i.jsx)(n.code,{children:"Double"}),", ",(0,i.jsx)(n.code,{children:"BigDecimal"}),", ",(0,i.jsx)(n.code,{children:"BigInt"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"+"}),", ",(0,i.jsx)(n.code,{children:"/"}),", ",(0,i.jsx)(n.code,{children:"%"}),", ",(0,i.jsx)(n.code,{children:"*"}),", ",(0,i.jsx)(n.code,{children:"unary_-"}),", ",(0,i.jsx)(n.code,{children:"-"}),", ",(0,i.jsx)(n.code,{children:"abs"}),", ",(0,i.jsx)(n.code,{children:"sign"}),", ",(0,i.jsx)(n.code,{children:"min"}),", ",(0,i.jsx)(n.code,{children:"max"}),", ",(0,i.jsx)(n.code,{children:"toInt"}),", ",(0,i.jsx)(n.code,{children:"toChar"}),", ",(0,i.jsx)(n.code,{children:"toByte"}),", ",(0,i.jsx)(n.code,{children:"toShort"}),", ",(0,i.jsx)(n.code,{children:"toLong"}),", ",(0,i.jsx)(n.code,{children:"toFloat"}),", ",(0,i.jsx)(n.code,{children:"toDouble"}),", ",(0,i.jsx)(n.code,{children:"intValue"}),", ",(0,i.jsx)(n.code,{children:"shortValue"}),", ",(0,i.jsx)(n.code,{children:"longValue"}),", ",(0,i.jsx)(n.code,{children:"floatValue"}),", ",(0,i.jsx)(n.code,{children:"doubleValue"})]}),"\n",(0,i.jsx)(n.h3,{id:"remote-integral-types",children:"Remote integral types"}),"\n",(0,i.jsxs)(n.p,{children:["Applies to ",(0,i.jsx)(n.code,{children:"Char"}),", ",(0,i.jsx)(n.code,{children:"Byte"}),", ",(0,i.jsx)(n.code,{children:"Short"}),", ",(0,i.jsx)(n.code,{children:"Int"}),", ",(0,i.jsx)(n.code,{children:"Long"}),", ",(0,i.jsx)(n.code,{children:"BigInt"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:">>"}),", ",(0,i.jsx)(n.code,{children:"<<"}),", ",(0,i.jsx)(n.code,{children:">>>"}),", ",(0,i.jsx)(n.code,{children:"&"}),", ",(0,i.jsx)(n.code,{children:"|"}),", ",(0,i.jsx)(n.code,{children:"^"}),", ",(0,i.jsx)(n.code,{children:"toBinaryString"}),", ",(0,i.jsx)(n.code,{children:"toHexString"}),", ",(0,i.jsx)(n.code,{children:"toOctalString"})]}),"\n",(0,i.jsx)(n.h3,{id:"remote-fractional-types",children:"Remote fractional types"}),"\n",(0,i.jsxs)(n.p,{children:["Applies to ",(0,i.jsx)(n.code,{children:"Double"}),", ",(0,i.jsx)(n.code,{children:"Float"})," and ",(0,i.jsx)(n.code,{children:"BigDecimal"})," remotes."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"floor"}),", ",(0,i.jsx)(n.code,{children:"ceil"}),", ",(0,i.jsx)(n.code,{children:"round"}),", ",(0,i.jsx)(n.code,{children:"toRadians"}),", ",(0,i.jsx)(n.code,{children:"toDegrees"}),", ",(0,i.jsx)(n.code,{children:"isNaN"}),", ",(0,i.jsx)(n.code,{children:"isInifinity, "}),"isInfinite",(0,i.jsx)(n.code,{children:", "}),"isFinite",(0,i.jsx)(n.code,{children:", "}),"isPosInfinity",(0,i.jsx)(n.code,{children:", "}),"isNegInfinity`"]}),"\n",(0,i.jsx)(n.h3,{id:"remote-tuples",children:"Remote tuples"}),"\n",(0,i.jsxs)(n.p,{children:["The remote tuples have accessor fields generated with the usual ",(0,i.jsx)(n.code,{children:"_1"}),", ",(0,i.jsx)(n.code,{children:"_2"}),", ... ",(0,i.jsx)(n.code,{children:"_22"})," names."]}),"\n",(0,i.jsx)(n.h3,{id:"remote_",children:"Remote[_]"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"<"}),", ",(0,i.jsx)(n.code,{children:"<="}),", ",(0,i.jsx)(n.code,{children:">"}),", ",(0,i.jsx)(n.code,{children:">="}),", ",(0,i.jsx)(n.code,{children:"==="}),", ",(0,i.jsx)(n.code,{children:"!=="}),", ",(0,i.jsx)(n.code,{children:"toString"})]}),"\n",(0,i.jsx)(n.h3,{id:"math-object",children:"math object"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"zio.flow.remote.math"})," object contains Remote equivalents of the standard Scala ",(0,i.jsx)(n.code,{children:"math"})," package:"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"sin"}),", ",(0,i.jsx)(n.code,{children:"cos"}),", ",(0,i.jsx)(n.code,{children:"tan"}),", ",(0,i.jsx)(n.code,{children:"asin"}),", ",(0,i.jsx)(n.code,{children:"acos"}),", ",(0,i.jsx)(n.code,{children:"atan"}),", ",(0,i.jsx)(n.code,{children:"toRadians"}),", ",(0,i.jsx)(n.code,{children:"toDegrees"}),", ",(0,i.jsx)(n.code,{children:"atan2"}),", ",(0,i.jsx)(n.code,{children:"hypot"}),", ",(0,i.jsx)(n.code,{children:"ceil"}),", ",(0,i.jsx)(n.code,{children:"floor"}),", ",(0,i.jsx)(n.code,{children:"rint"}),", ",(0,i.jsx)(n.code,{children:"round"}),", ",(0,i.jsx)(n.code,{children:"abs"}),", ",(0,i.jsx)(n.code,{children:"max"}),", ",(0,i.jsx)(n.code,{children:"min"}),", ",(0,i.jsx)(n.code,{children:"signum"}),", ",(0,i.jsx)(n.code,{children:"floorDiv"}),", ",(0,i.jsx)(n.code,{children:"floorMod"}),", ",(0,i.jsx)(n.code,{children:"copySign"}),", ",(0,i.jsx)(n.code,{children:"nextAfter"}),", ",(0,i.jsx)(n.code,{children:"nextUp"}),", ",(0,i.jsx)(n.code,{children:"nextDown"}),", ",(0,i.jsx)(n.code,{children:"scalb"}),", ",(0,i.jsx)(n.code,{children:"sqrt"}),", ",(0,i.jsx)(n.code,{children:"cbrt"}),", ",(0,i.jsx)(n.code,{children:"pow"}),", ",(0,i.jsx)(n.code,{children:"exp"}),", ",(0,i.jsx)(n.code,{children:"expm1"}),", ",(0,i.jsx)(n.code,{children:"getExponent"}),", ",(0,i.jsx)(n.code,{children:"log"}),", ",(0,i.jsx)(n.code,{children:"log1p"}),", ",(0,i.jsx)(n.code,{children:"log10"}),", ",(0,i.jsx)(n.code,{children:"sinh"}),", ",(0,i.jsx)(n.code,{children:"cosh"}),", ",(0,i.jsx)(n.code,{children:"tanh"}),", ",(0,i.jsx)(n.code,{children:"ulp"}),", ",(0,i.jsx)(n.code,{children:"IEEEremainder"}),", ",(0,i.jsx)(n.code,{children:"addExact"}),", ",(0,i.jsx)(n.code,{children:"subtractExact"}),", ",(0,i.jsx)(n.code,{children:"multiplyExact"}),", ",(0,i.jsx)(n.code,{children:"incrementExact"}),", ",(0,i.jsx)(n.code,{children:"decrementExact"}),", ",(0,i.jsx)(n.code,{children:"negateExact"})]})]})}function a(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},28453:(e,n,d)=>{d.d(n,{R:()=>s,x:()=>r});var c=d(96540);const i={},o=c.createContext(i);function s(e){const n=c.useContext(o);return c.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),c.createElement(o.Provider,{value:n},e.children)}}}]);