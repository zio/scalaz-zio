"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[44859],{72570:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"reference/fiber/fiber","title":"Fiber","description":"To perform an effect without blocking the current process, we can use fibers, which are a lightweight concurrency mechanism.","source":"@site/docs/reference/fiber/fiber.md","sourceDirName":"reference/fiber","slug":"/reference/fiber/fiber.md","permalink":"/reference/fiber/fiber.md","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/fiber/fiber.md","tags":[],"version":"current","frontMatter":{"id":"fiber","slug":"fiber.md","title":"Fiber"},"sidebar":"reference-sidebar","previous":{"title":"Introduction to ZIO Fibers","permalink":"/reference/fiber/"},"next":{"title":"FiberId","permalink":"/reference/fiber/fiberid"}}');var r=i(74848),o=i(28453);const a={id:"fiber",slug:"fiber.md",title:"Fiber"},s=void 0,l={},c=[{value:"Lifetime of Child Fibers",id:"lifetime-of-child-fibers",level:2},{value:"Fork with Automatic Supervision",id:"fork-with-automatic-supervision",level:3},{value:"Fork in Global Scope (Daemon)",id:"fork-in-global-scope-daemon",level:3},{value:"Fork in Local Scope",id:"fork-in-local-scope",level:3},{value:"Fork in Specific Scope",id:"fork-in-specific-scope",level:3},{value:"Background Processes and Layers",id:"background-processes-and-layers",level:2},{value:"Operations",id:"operations",level:2},{value:"fork and join",id:"fork-and-join",level:3},{value:"interrupt",id:"interrupt",level:3},{value:"await",id:"await",level:3},{value:"Parallelism",id:"parallelism",level:3},{value:"Racing",id:"racing",level:3},{value:"Error Model",id:"error-model",level:2},{value:"Fiber Interruption",id:"fiber-interruption",level:2},{value:"Interruptible/Uninterruptible Regions",id:"interruptibleuninterruptible-regions",level:3},{value:"Fiber Finalization on Interruption",id:"fiber-finalization-on-interruption",level:3},{value:"Fast Interruption",id:"fast-interruption",level:3},{value:"Interrupting Blocking Operations",id:"interrupting-blocking-operations",level:3},{value:"Automatic Interruption",id:"automatic-interruption",level:3},{value:"Joining an Interrupted Fiber",id:"joining-an-interrupted-fiber",level:3},{value:"Thread Shifting - JVM",id:"thread-shifting---jvm",level:2},{value:"Types of Workloads",id:"types-of-workloads",level:2},{value:"CPU Work",id:"cpu-work",level:3},{value:"Blocking I/O",id:"blocking-io",level:3},{value:"Asynchronous I/O",id:"asynchronous-io",level:3}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"To perform an effect without blocking the current process, we can use fibers, which are a lightweight concurrency mechanism."}),"\n",(0,r.jsxs)(n.p,{children:["We can ",(0,r.jsx)(n.code,{children:"fork"})," any ",(0,r.jsx)(n.code,{children:"ZIO[R, E, A]"})," to immediately yield an ",(0,r.jsx)(n.code,{children:"URIO[R, Fiber[E, A]]"}),". The provided ",(0,r.jsx)(n.code,{children:"Fiber"})," can be used to ",(0,r.jsx)(n.code,{children:"join"})," the fiber, which will resume on production of the fiber's value, or to ",(0,r.jsx)(n.code,{children:"interrupt"})," the fiber, which immediately terminates the fiber and safely releases all resources acquired by the fiber."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"val analyzed =\n  for {\n    fiber1   <- analyzeData(data).fork  // IO[E, Analysis]\n    fiber2   <- validateData(data).fork // IO[E, Boolean]\n    // Do other stuff\n    valid    <- fiber2.join\n    _        <- if (!valid) fiber1.interrupt\n                else ZIO.unit\n    analyzed <- fiber1.join\n  } yield analyzed\n"})}),"\n",(0,r.jsx)(n.h2,{id:"lifetime-of-child-fibers",children:"Lifetime of Child Fibers"}),"\n",(0,r.jsx)(n.p,{children:"When we fork fibers, depending on how we fork them we can have four different lifetime strategies for the child fibers:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fork With Automatic Supervision"}),"\u2014 If we use the ordinary ",(0,r.jsx)(n.code,{children:"ZIO#fork"})," operation, the child fiber will be automatically supervised by the parent fiber. The lifetime child fibers are tied to the lifetime of their parent fiber. This means that these fibers will be terminated either when they end naturally, or when their parent fiber is terminated."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fork in Global Scope (Daemon)"}),"\u2014 Sometimes we want to run long-running background fibers that aren't tied to their parent fiber, and also we want to fork them in a global scope. Any fiber that is forked in global scope will become daemon fiber. This can be achieved by using the ",(0,r.jsx)(n.code,{children:"ZIO#forkDaemon"})," operator. As these fibers have no parent, they are not supervised, and they will be terminated when they end naturally, or when our application is terminated."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fork in Local Scope"}),"\u2014 Sometimes, we want to run a background fiber that isn't tied to its parent fiber, but we want to live that fiber in the local scope. We can fork fibers in the local scope by using ",(0,r.jsx)(n.code,{children:"ZIO#forkScoped"}),". Such fibers can outlive their parent fiber (so they are not supervised by their parents), and they will be terminated when their life end or their local scope is closed."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fork in Specific Scope"}),"\u2014 This is similar to the previous strategy, but we can have more fine-grained control over the lifetime of the child fiber by forking it in a specific scope. We can do this by using the ",(0,r.jsx)(n.code,{children:"ZIO#forkIn"})," operator."]}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsxs)(n.p,{children:["Forking with ",(0,r.jsx)(n.strong,{children:"automatic supervision"})," is the ",(0,r.jsx)(n.em,{children:"default strategy"}),". When we use the ",(0,r.jsx)(n.code,{children:"ZIO#fork"})," method, the lifetime of child fibers is tied to their parent fiber. However, sometimes we don't want this behavior. Instead, we use three other alternatives."]})}),"\n",(0,r.jsxs)(n.admonition,{type:"note",children:[(0,r.jsxs)(n.mdxAdmonitionTitle,{children:["Managing Fiber Lifetime Using ",(0,r.jsx)(n.code,{children:"Scope"})," Data Type"]}),(0,r.jsxs)(n.p,{children:["The second and third strategies are required to work with the ",(0,r.jsx)(n.code,{children:"Scope"})," data type. A contextual data type that describes a resource's lifetime, in this case, the fiber's lifetime. To learn more about ",(0,r.jsx)(n.code,{children:"Scope"})," we have a ",(0,r.jsx)(n.a,{href:"/reference/resource/scope",children:"separate section"})," on it."]})]}),"\n",(0,r.jsx)(n.h3,{id:"fork-with-automatic-supervision",children:"Fork with Automatic Supervision"}),"\n",(0,r.jsxs)(n.p,{children:["ZIO uses a ",(0,r.jsx)(n.strong,{children:"structured concurrency"})," model where fiber lifetimes are cleanly nested. The lifetime of a fiber depends on the lifetime of its parent fiber."]}),"\n",(0,r.jsx)(n.p,{children:"To illustrate this, let's look at some examples:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"In the following example, we have two fibers. The first fiber is responsible for running the first and last debug tasks. It is also responsible for creating the second fiber. The second fiber is a task that forked from the first fiber and will never produce anything:"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    for {\n      _ <- ZIO.debug(s"Application started!")\n      _ <- ZIO.never.onInterrupt(_ => ZIO.debug(s"The child fiber interrupted!")).fork\n      _ <- ZIO.debug(s"Application finished!")\n    } yield ()\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"In this example, the child fiber will be interrupted when the parent fiber is finished (successfully or interrupted)."}),"\n",(0,r.jsxs)(n.admonition,{type:"caution",children:[(0,r.jsxs)(n.p,{children:["The example above is just for educational purposes. In a real application, the ",(0,r.jsx)(n.code,{children:"onInterrupt"})," callback is not guaranteed to be called just before the parent fiber finishes its execution. It is possible that the parent fiber will be finished just before the ",(0,r.jsx)(n.code,{children:"onInterrupt"})," callback is called. So this example is the simplified version of the following example:"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    ZIO.fiberIdWith { parent =>\n      for {\n        _     <- ZIO.debug(s"fiber-${parent.id} Application started!")\n        latch <- Promise.make[Nothing, Unit]\n        _ <- ZIO.fiberIdWith { child =>\n               (latch.succeed(()) *> ZIO.never).onInterrupt(_ =>\n                 ZIO.debug(s"fiber-${child.id} The child fiber interrupted!")\n               )\n             }.fork\n        _ <- latch.await\n        _ <- ZIO.debug(s"fiber-${parent.id} Application finished!")\n      } yield ()\n    }\n}\n'})}),(0,r.jsxs)(n.p,{children:["In this version, other than making sure that the ",(0,r.jsx)(n.code,{children:"onInterrupt"})," callback is called, we also added fiber ids to the debug messages. Here is the output of the above example:"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"fiber-6 Application started!\nfiber-6 Application finished!\nfiber-7 The child fiber interrupted!\n"})})]}),"\n",(0,r.jsxs)(n.ol,{start:"2",children:["\n",(0,r.jsxs)(n.li,{children:["Here is another example. In this case, the ",(0,r.jsx)(n.code,{children:"foo"})," fiber creates the ",(0,r.jsx)(n.code,{children:"bar"})," fiber. The ",(0,r.jsx)(n.code,{children:"bar"})," fiber has a long-running task that never finishes. ZIO guarantees that the ",(0,r.jsx)(n.code,{children:"bar"})," fiber will not outlive the ",(0,r.jsx)(n.code,{children:"foo"})," fiber:"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  val barJob: ZIO[Any, Nothing, Long] =\n    ZIO\n      .debug("Bar: still running!")\n      .repeat(Schedule.fixed(1.seconds))\n\n  val fooJob: ZIO[Any, Nothing, Unit] =\n    for {\n      _ <- ZIO.debug("Foo: started!")\n      _ <- barJob.fork\n      _ <- ZIO.sleep(3.seconds)\n      _ <- ZIO.debug("Foo: finished!")\n    } yield ()\n\n  def run =\n    for {\n      f <- fooJob.fork\n      _ <- f.join\n    } yield ()\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"The output of the above program is:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Foo: started!\nBar: still running!\nBar: still running!\nBar: still running!\nFoo: finished!\n"})}),"\n",(0,r.jsx)(n.p,{children:"This pattern can be applied to any nested level of fibers."}),"\n",(0,r.jsx)(n.h3,{id:"fork-in-global-scope-daemon",children:"Fork in Global Scope (Daemon)"}),"\n",(0,r.jsxs)(n.p,{children:["Using ",(0,r.jsx)(n.code,{children:"ZIO#forkDaemon"})," we can create a daemon fiber from a ",(0,r.jsx)(n.code,{children:"ZIO"})," effect. Its lifetime is tied to the global scope. So if the parent fiber terminates, the daemon fiber will not be terminated. It will only will be terminated when the global scope is closed, or its life end naturaly."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  val barJob: ZIO[Any, Nothing, Long] =\n    ZIO\n      .debug("Bar: still running!")\n      .repeat(Schedule.fixed(1.seconds))\n\n  val fooJob: ZIO[Any, Nothing, Unit] =\n    for {\n      _ <- ZIO.debug("Foo: started!")\n      _ <- barJob.forkDaemon\n      _ <- ZIO.sleep(3.seconds)\n      _ <- ZIO.debug("Foo: finished!")\n    } yield ()\n\n  def run =\n    for {\n      f <- fooJob.fork\n      _ <- ZIO.sleep(5.seconds)\n    } yield ()\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["If we run the above program, we will see the following output which shows that while the lifetime of the ",(0,r.jsx)(n.code,{children:"foo"})," fiber ends after 3 seconds, the daemon fiber (",(0,r.jsx)(n.code,{children:"bar"}),") is still running until the global scope is closed:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Foo: started!\nBar: still running!\nBar: still running!\nBar: still running!\nFoo: finished!\nBar: still running!\nBar: still running!\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Even if we interrupt the ",(0,r.jsx)(n.code,{children:"foo"})," fiber, the daemon fiber (",(0,r.jsx)(n.code,{children:"foo"}),") will not be interrupted:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nobject MainApp2 extends ZIOAppDefault {\n  val barJob: ZIO[Any, Nothing, Long] =\n    ZIO\n      .debug("Bar: still running!")\n      .repeat(Schedule.fixed(1.seconds))\n\n  val fooJob: ZIO[Any, Nothing, Unit] =\n    (for {\n      _ <- ZIO.debug("Foo: started!")\n      _ <- barJob.forkDaemon\n      _ <- ZIO.sleep(3.seconds)\n      _ <- ZIO.debug("Foo: finished!")\n    } yield ()).onInterrupt(_ => ZIO.debug("Foo: interrupted!"))\n\n  def run =\n    for {\n      f <- fooJob.fork\n      _ <- ZIO.sleep(2.seconds)\n      _ <- f.interrupt\n      _ <- ZIO.sleep(3.seconds)\n    } yield ()\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"The output:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Foo: started!\nBar: still running!\nBar: still running!\nFoo: interrupted!\nBar: still running!\nBar: still running!\nBar: still running!\nBar: still running!\n"})}),"\n",(0,r.jsx)(n.h3,{id:"fork-in-local-scope",children:"Fork in Local Scope"}),"\n",(0,r.jsxs)(n.p,{children:["Sometimes we want to attach fiber to a local scope. In such cases, we can use the ",(0,r.jsx)(n.code,{children:"ZIO#forkScoped"})," operator. By using this operator, the lifetime of the forked fiber can be outlived the lifetime of its parent fiber, and it will be terminated when the local scope is closed:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  val barJob: ZIO[Any, Nothing, Long] =\n    ZIO\n      .debug("Bar: still running!")\n      .repeat(Schedule.fixed(1.seconds))\n\n  val fooJob: ZIO[Scope, Nothing, Unit] =\n    (for {\n      _ <- ZIO.debug("Foo: started!")\n      _ <- barJob.forkScoped\n      _ <- ZIO.sleep(2.seconds)\n      _ <- ZIO.debug("Foo: finished!")\n    } yield ()).onInterrupt(_ => ZIO.debug("Foo: interrupted!"))\n\n  def run =\n    for {\n      _ <- ZIO.scoped {\n        for {\n          _ <- ZIO.debug("Local scope started!")\n          _ <- fooJob.fork\n          _ <- ZIO.sleep(5.seconds)\n          _ <- ZIO.debug("Leaving the local scope!")\n        } yield ()\n      }\n      _ <- ZIO.debug("Do something else and sleep for 10 seconds")\n      _ <- ZIO.sleep(10.seconds)\n      _ <- ZIO.debug("Application exited!")\n    } yield ()\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["In the above example, the ",(0,r.jsx)(n.code,{children:"bar"})," fiber forked in the local scope has bigger lifetime than its parent fiber (",(0,r.jsx)(n.code,{children:"foo"}),"). So, when its parent fiber (",(0,r.jsx)(n.code,{children:"foo"}),") is terminated, the ",(0,r.jsx)(n.code,{children:"bar"})," fiber still running in the local scope until the local scope is closed. Let's see the output:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Local scope started!\nFoo: started!\nBar: still running!\nBar: still running!\nFoo: finished!\nBar: still running!\nBar: still running!\nBar: still running!\nLeaving the local scope!\nDo something else and sleep for 10 seconds\nApplication exited!\n"})}),"\n",(0,r.jsx)(n.h3,{id:"fork-in-specific-scope",children:"Fork in Specific Scope"}),"\n",(0,r.jsxs)(n.p,{children:["There are some cases where we need more fine-grained control, so we want to fork a fiber in a specific scope. We can use the ",(0,r.jsx)(n.code,{children:"ZIO#forkIn"})," operator which takes the target scope as an argument:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    ZIO.scoped {\n      for {\n        scope <- ZIO.scope\n        _     <-\n          ZIO.scoped {\n            for {\n              _ <- ZIO\n                     .debug("Still running ...")\n                     .repeat(Schedule.fixed(1.second))\n                     .forkIn(scope)\n              _ <- ZIO.sleep(3.seconds)\n              _ <- ZIO.debug("The innermost scope is about to be closed.")\n            } yield ()\n          }\n        _     <- ZIO.sleep(5.seconds)\n        _     <- ZIO.debug("The outer scope is about to be closed.")\n      } yield ()\n    }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"The output:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Still running ...\nStill running ...\nStill running ...\nThe innermost scope is about to be closed.\nStill running ...\nStill running ...\nStill running ...\nStill running ...\nStill running ...\nStill running ...\nThe outer scope is about to be closed.\n"})}),"\n",(0,r.jsx)(n.h2,{id:"background-processes-and-layers",children:"Background Processes and Layers"}),"\n",(0,r.jsx)(n.p,{children:"Sometimes, we want to create a layer that has a background process attached to the global scope. For example, think of a Kafka layer that has a background process that is constantly reading/writing messages from/to Kafka topics. In such situations, we can create a layer from such a background process."}),"\n",(0,r.jsxs)(n.p,{children:["In the following example, even though we have provided the ",(0,r.jsx)(n.code,{children:"layer"})," locally to one part of our application, the background process inside the layer is still running in the global scope:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  val layer: ZLayer[Scope, Nothing, Int] =\n    ZLayer.fromZIO {\n      ZIO\n        .debug("Still running ...")\n        .repeat(Schedule.fixed(1.second))\n        .forkDaemon\n        .as(42)\n    }\n\n  def run =\n    for {\n      _ <- ZIO.service[Int].provideLayer(layer) *> ZIO.debug("Int layer provided")\n      _ <- ZIO.sleep(5.seconds)\n    } yield ()\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Output:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Still running ...\nint layer provided\nStill running ...\nStill running ...\nStill running ...\nStill running ...\nStill running ...\n"})}),"\n",(0,r.jsx)(n.h2,{id:"operations",children:"Operations"}),"\n",(0,r.jsx)(n.h3,{id:"fork-and-join",children:"fork and join"}),"\n",(0,r.jsxs)(n.p,{children:["Whenever we need to start a fiber, we have to ",(0,r.jsx)(n.code,{children:"fork"})," an effect to get a new fiber. This is similar to the ",(0,r.jsx)(n.code,{children:"start"})," method on Java thread or submitting a new thread to the thread pool in Java, it is the same idea. Also, joining is a way of waiting for that fiber to compute its value. We are going to wait until it's done and receive its result."]}),"\n",(0,r.jsx)(n.p,{children:"In the following example, we create a separate fiber to output a delayed print message and then wait for that fiber to succeed with a value:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.Console._\nfor {\n  fiber <- (ZIO.sleep(3.seconds) *>\n    printLine("Hello, after 3 second") *>\n    ZIO.succeed(10)).fork\n  _ <- printLine(s"Hello, World!")\n  res <- fiber.join\n  _ <- printLine(s"Our fiber succeeded with $res")\n} yield ()\n'})}),"\n",(0,r.jsx)(n.h3,{id:"interrupt",children:"interrupt"}),"\n",(0,r.jsxs)(n.p,{children:["Whenever we want to get rid of our fiber, we can simply call ",(0,r.jsx)(n.code,{children:"interrupt"})," on that. The interrupt operation does not resume until the fiber has completed or has been interrupted and all its finalizers have been run. These precise semantics allow construction of programs that do not leak resources."]}),"\n",(0,r.jsx)(n.h3,{id:"await",children:"await"}),"\n",(0,r.jsxs)(n.p,{children:["To inspect whether our fiber succeeded or failed, we can call ",(0,r.jsx)(n.code,{children:"await"})," on that fiber. This call will wait for that fiber to terminate, and it will give us back the fiber's value as an ",(0,r.jsx)(n.code,{children:"Exit"}),". That exit value could be failure or success:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio.Console._\n\nfor {\n  b <- Random.nextBoolean\n  fiber <- (if (b) ZIO.succeed(10) else ZIO.fail("The boolean was not true")).fork\n  exitValue <- fiber.await\n  _ <- exitValue match {\n    case Exit.Success(value) => printLine(s"Fiber succeeded with $value")\n    case Exit.Failure(cause) => printLine(s"Fiber failed")\n  }\n} yield ()\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"await"})," is similar to ",(0,r.jsx)(n.code,{children:"join"}),", but they react differently to errors and interruption: ",(0,r.jsx)(n.code,{children:"await"})," always succeeds with ",(0,r.jsx)(n.code,{children:"Exit"})," information, even if the fiber fails or is interrupted. In contrast to that, ",(0,r.jsx)(n.code,{children:"join"})," on a fiber that fails will itself fail with the same error as the fiber, and ",(0,r.jsx)(n.code,{children:"join"})," on a fiber that is interrupted will itself become interrupted."]}),"\n",(0,r.jsx)(n.h3,{id:"parallelism",children:"Parallelism"}),"\n",(0,r.jsxs)(n.p,{children:["To execute actions in parallel, the ",(0,r.jsx)(n.code,{children:"zipPar"})," method can be used:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"def bigCompute(m1: Matrix, m2: Matrix, v: Matrix): UIO[Matrix] =\n  for {\n    t <- computeInverse(m1).zipPar(computeInverse(m2))\n    (i1, i2) = t\n    r <- applyMatrices(i1, i2, v)\n  } yield r\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"zipPar"})," combinator has resource-safe semantics. If one computation fails, the other computation will be interrupted, to prevent wasting resources."]}),"\n",(0,r.jsx)(n.h3,{id:"racing",children:"Racing"}),"\n",(0,r.jsxs)(n.p,{children:["Two actions can be ",(0,r.jsx)(n.em,{children:"raced"}),", which means they will be executed in parallel, and the value of the first action that completes successfully will be returned."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"fib(100) race fib(200)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"race"})," combinator is resource-safe, which means that if one of the two actions returns a value, the other one will be interrupted, to prevent wasting resources."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"race"})," and even ",(0,r.jsx)(n.code,{children:"zipPar"})," combinators are a specialization of a much-more powerful combinator called ",(0,r.jsx)(n.code,{children:"raceWith"}),", which allows executing user-defined logic when the first of two actions succeeds."]}),"\n",(0,r.jsxs)(n.p,{children:["On the JVM, fibers will use threads, but will not consume ",(0,r.jsx)(n.em,{children:"unlimited"})," threads. Instead, fibers yield cooperatively during periods of high-contention."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"def fib(n: Int): UIO[Int] =\n  if (n <= 1) {\n    ZIO.succeed(1)\n  } else {\n    for {\n      fiber1 <- fib(n - 2).fork\n      fiber2 <- fib(n - 1).fork\n      v2     <- fiber2.join\n      v1     <- fiber1.join\n    } yield v1 + v2\n  }\n"})}),"\n",(0,r.jsx)(n.h2,{id:"error-model",children:"Error Model"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"ZIO"})," error model is simple, consistent, permits both typed errors and termination, and does not violate any laws in the ",(0,r.jsx)(n.code,{children:"Functor"})," hierarchy."]}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.code,{children:"ZIO[R, E, A]"})," value may only raise errors of type ",(0,r.jsx)(n.code,{children:"E"}),". These errors are recoverable by using the ",(0,r.jsx)(n.code,{children:"either"})," method.  The resulting effect cannot fail, because the failure case has been exposed as part of the ",(0,r.jsx)(n.code,{children:"Either"})," success case."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'val error: Task[String] = ZIO.fail(new RuntimeException("Some Error"))\nval errorEither: ZIO[Any, Nothing, Either[Throwable, String]] = error.either\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Separately from errors of type ",(0,r.jsx)(n.code,{children:"E"}),", a fiber may be terminated for the following reasons:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"The fiber self-terminated or was interrupted by another fiber"}),'. The "main" fiber cannot be interrupted because it was not forked from any other fiber.']}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:["The fiber failed to handle some error of type ",(0,r.jsx)(n.code,{children:"E"})]}),". This can happen only when an ",(0,r.jsx)(n.code,{children:"ZIO.fail"})," is not handled. For values of type ",(0,r.jsx)(n.code,{children:"UIO[A]"}),", this type of failure is impossible."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"The fiber has a defect that leads to a non-recoverable error"}),". There are only two ways this can happen:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["A partial function is passed to a higher-order function such as ",(0,r.jsx)(n.code,{children:"map"})," or ",(0,r.jsx)(n.code,{children:"flatMap"}),". For example, ",(0,r.jsx)(n.code,{children:"io.map(_ => throw e)"}),", or ",(0,r.jsx)(n.code,{children:"io.flatMap(a => throw e)"}),". The solution to this problem is to not to pass impure functions to purely functional libraries like ZIO, because doing so leads to violations of laws and destruction of equational reasoning."]}),"\n",(0,r.jsxs)(n.li,{children:["Error-throwing code was embedded into some value via ",(0,r.jsx)(n.code,{children:"ZIO.succeed"}),", etc. For importing partial effects into ",(0,r.jsx)(n.code,{children:"ZIO"}),", the proper solution is to use a method such as ",(0,r.jsx)(n.code,{children:"ZIO.attempt"}),", which safely translates exceptions into values."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["When a fiber is terminated, the reason for the termination, expressed as a ",(0,r.jsx)(n.code,{children:"Throwable"}),", is passed to the fiber's supervisor, which may choose to log, print the stack trace, restart the fiber, or perform some other action appropriate to the context."]}),"\n",(0,r.jsx)(n.p,{children:"A fiber cannot stop its own interruption. However, all finalizers will be run during termination, even when some finalizers throw non-recoverable errors. Errors thrown by finalizers are passed to the fiber's supervisor."}),"\n",(0,r.jsxs)(n.p,{children:['There are no circumstances in which any errors will be "lost", which makes the ',(0,r.jsx)(n.code,{children:"ZIO"})," error model more diagnostic-friendly than the ",(0,r.jsx)(n.code,{children:"try"}),"/",(0,r.jsx)(n.code,{children:"catch"}),"/",(0,r.jsx)(n.code,{children:"finally"})," construct that is baked into both Scala and Java, which can easily lose errors."]}),"\n",(0,r.jsx)(n.h2,{id:"fiber-interruption",children:"Fiber Interruption"}),"\n",(0,r.jsxs)(n.p,{children:["In Java, a thread can be interrupted via ",(0,r.jsx)(n.code,{children:"Thread#interrupt"})," from another thread, but it may refuse the interruption request and continue processing. Unlike Java, in ZIO when a fiber interrupts another fiber, we know that the interruption occurs, and it always works."]}),"\n",(0,r.jsx)(n.p,{children:"When working with ZIO fibers, we should consider these notes about fiber interruptions:"}),"\n",(0,r.jsx)(n.h3,{id:"interruptibleuninterruptible-regions",children:"Interruptible/Uninterruptible Regions"}),"\n",(0,r.jsxs)(n.p,{children:["All fibers are interruptible by default. To make an effect uninterruptible we can use ",(0,r.jsx)(n.code,{children:"Fiber#uninterruptible"}),", ",(0,r.jsx)(n.code,{children:"ZIO#uninterruptible"})," or ",(0,r.jsx)(n.code,{children:"ZIO.uninterruptible"}),". ZIO provides also the reverse direction of these methods to make an uninterruptible effect interruptible."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"for {\n  fiber <- Clock.currentDateTime\n    .flatMap(time => printLine(time))\n    .schedule(Schedule.fixed(1.seconds))\n    .uninterruptible\n    .fork\n  _     <- fiber.interrupt // Runtime stuck here and does not go further\n} yield ()\n"})}),"\n",(0,r.jsx)(n.p,{children:"Note that there is no way to stop interruption. We can only delay it, by making an effect uninterruptible."}),"\n",(0,r.jsx)(n.h3,{id:"fiber-finalization-on-interruption",children:"Fiber Finalization on Interruption"}),"\n",(0,r.jsx)(n.p,{children:"When a fiber has done its work or has been interrupted, the finalizer of that fiber is guaranteed to be executed:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'for {\n  fiber <- printLine("Working on the first job")\n    .schedule(Schedule.fixed(1.seconds))\n    .ensuring {\n      (printLine(\n        "Finalizing or releasing a resource that is time-consuming"\n      ) *> ZIO.sleep(7.seconds)).orDie\n    }\n    .fork\n  _     <- fiber.interrupt.delay(4.seconds)\n  _     <- printLine(\n          "Starting another task when the interruption of the previous task finished"\n        )\n} yield ()\n'})}),"\n",(0,r.jsxs)(n.p,{children:["In the above example, the release action takes some time for freeing up resources. So it slows down the call to ",(0,r.jsx)(n.code,{children:"interrupt"})," the fiber."]}),"\n",(0,r.jsx)(n.h3,{id:"fast-interruption",children:"Fast Interruption"}),"\n",(0,r.jsxs)(n.p,{children:["As we saw in the previous section, the ZIO runtime gets stuck on interruption until the fiber's finalizer finishes its job. We can prevent this behavior by using ",(0,r.jsx)(n.code,{children:"ZIO#disconnect"})," or ",(0,r.jsx)(n.code,{children:"Fiber#interruptFork"})," which perform fiber's interruption in the background or in separate daemon fiber:"]}),"\n",(0,r.jsxs)(n.p,{children:["Let's try the ",(0,r.jsx)(n.code,{children:"Fiber#interruptFork"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'for {\n  fiber <- printLine("Working on the first job")\n    .schedule(Schedule.fixed(1.seconds))\n    .ensuring {\n      (printLine(\n        "Finalizing or releasing a resource that is time-consuming"\n      ) *> ZIO.sleep(7.seconds)).orDie\n    }\n    .fork\n  _ <- fiber.interruptFork.delay(4.seconds) // fast interruption\n  _ <- printLine(\n    "Starting another task while interruption of the previous fiber happening in the background"\n  )\n} yield ()\n'})}),"\n",(0,r.jsx)(n.h3,{id:"interrupting-blocking-operations",children:"Interrupting Blocking Operations"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"ZIO#attemptBlocking"})," is interruptible by default, but its interruption will not translate to JVM thread interruption. Instead, we can use ",(0,r.jsx)(n.code,{children:"ZIO#attemptBlockingInterrupt"})," to translate the ZIO interruption of that effect into JVM thread interruption. For details and examples on interrupting blocking operations see ",(0,r.jsx)(n.a,{href:"/reference/core/zio/#blocking-synchronous-side-effects",children:"here"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"automatic-interruption",children:"Automatic Interruption"}),"\n",(0,r.jsxs)(n.p,{children:["If we never ",(0,r.jsx)(n.em,{children:"cancel"})," a running effect explicitly, ZIO performs ",(0,r.jsx)(n.strong,{children:"automatic interruption"})," for several reasons:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Structured Concurrency"})," \u2014 If a parent fiber terminates, then by default, all child fibers are interrupted, and they cannot outlive their parent. We can prevent this behavior by using ",(0,r.jsx)(n.code,{children:"ZIO#forkDaemon"})," or ",(0,r.jsx)(n.code,{children:"ZIO#forkIn"})," instead of ",(0,r.jsx)(n.code,{children:"ZIO#fork"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Parallelism"})," \u2014 If one effect fails during the execution of many effects in parallel, the others will be canceled. Examples include ",(0,r.jsx)(n.code,{children:"foreachPar"}),", ",(0,r.jsx)(n.code,{children:"zipPar"}),", and all other parallel operators."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Timeouts"})," \u2014 If a running effect with a ",(0,r.jsx)(n.code,{children:"timeout"})," has not been completed in the specified amount of time, then the execution is canceled."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Racing"})," \u2014 The loser of a ",(0,r.jsx)(n.code,{children:"race"}),", if still running, is canceled."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"joining-an-interrupted-fiber",children:"Joining an Interrupted Fiber"}),"\n",(0,r.jsxs)(n.p,{children:["We can join an interrupted fiber, which will cause our fiber to become interrupted. This process preserves the proper finalization of the caller. So, ",(0,r.jsxs)(n.strong,{children:["ZIO's concurrency model respects brackets even when we ",(0,r.jsx)(n.em,{children:"join"})," an interrupted fiber"]}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'val myApp =\n  (\n    for {\n      fiber <- printLine("Running a job").delay(1.seconds).forever.fork\n      _     <- fiber.interrupt.delay(3.seconds)\n      _     <- fiber.join // Joining an interrupted fiber\n    } yield ()\n  ).ensuring(\n    printLine(\n      "This finalizer will be executed without occurring any deadlock"\n    ).orDie\n  )\n'})}),"\n",(0,r.jsxs)(n.p,{children:["A fiber that is interrupted because of joining another interrupted fiber will properly finalize; this is a distinction between ZIO and the other effect systems, which ",(0,r.jsx)(n.em,{children:"deadlock"})," the joining fiber."]}),"\n",(0,r.jsx)(n.h2,{id:"thread-shifting---jvm",children:"Thread Shifting - JVM"}),"\n",(0,r.jsx)(n.p,{children:"By default, fibers give no guarantees as to which thread they execute on. They may shift between threads, especially as they execute for long periods of time."}),"\n",(0,r.jsx)(n.p,{children:"Fibers only ever shift onto the thread pool of the runtime system, which means that by default, fibers running for a sufficiently long time will always return to the runtime system's thread pool, even when their (asynchronous) resumptions were initiated from other threads."}),"\n",(0,r.jsx)(n.p,{children:"For performance reasons, fibers will attempt to execute on the same thread for a (configurable) minimum period, before yielding to other fibers. Fibers that resume from asynchronous callbacks will resume on the initiating thread, and continue for some time before yielding and resuming on the runtime thread pool."}),"\n",(0,r.jsxs)(n.p,{children:["These defaults help to guarantee stack safety and cooperative multitasking. They can be changed in ",(0,r.jsx)(n.code,{children:"Runtime"})," if automatic thread shifting is not desired."]}),"\n",(0,r.jsx)(n.h2,{id:"types-of-workloads",children:"Types of Workloads"}),"\n",(0,r.jsx)(n.p,{children:"Let's discuss the types of workloads that a fiber can handle. There are three types of them:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"CPU Work/Pure CPU Bound"})," is a workload that exploits the processing power of a CPU for pure computations of a huge chunk of work, e.g. complex numerical computations."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Blocking I/O"})," is a workload that goes beyond pure computation by doing communication in a blocking fashion. For example, waiting for a certain amount of time to elapse or waiting for an external event to happen are blocking I/O operations."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Asynchronous I/O"})," is a workload that goes beyond pure computation by doing communication asynchronously, e.g. registering a callback for a specific event."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"cpu-work",children:"CPU Work"}),"\n",(0,r.jsx)(n.p,{children:"What we refer to as CPU Work is pure computational firepower without involving any interaction and communication with the outside world. It doesn't involve any I/O operation. It's a pure computation. By I/O, we mean anything that involves reading from and writing to an external resource such as a file or a socket or web API, or anything that would be characterized as I/O."}),"\n",(0,r.jsxs)(n.p,{children:["Fibers are designed to be ",(0,r.jsx)(n.strong,{children:"cooperative"})," which means that ",(0,r.jsx)(n.strong,{children:"they will yield to each other as required to preserve some level of fairness"}),". If we have a fiber that is doing CPU Work which passes through one or more ZIO operations such as ",(0,r.jsx)(n.code,{children:"flatMap"})," or ",(0,r.jsx)(n.code,{children:"map"}),", as long as there exists a touchpoint where the ZIO runtime system can sort of keep a tab on that ongoing CPU Work then that fiber will yield to other fibers. These touchpoints allow many fibers who are doing CPU Work to end up sharing the same thread."]}),"\n",(0,r.jsxs)(n.p,{children:["What if though, we have a CPU Work operation that takes a really long time to run? Let's say 30 seconds it does pure CPU Work very computationally intensive? What happens if we take that single gigantic function and put that into a ",(0,r.jsx)(n.code,{children:"ZIO#attempt"}),"? In that case there is no way for the ZIO Runtime to force that fiber to yield to other fibers. In this situation, the ZIO Runtime cannot preserve some level of fairness, and that single big CPU operation monopolizes the underlying thread. It is not a good practice to monopolize the underlying thread."]}),"\n",(0,r.jsxs)(n.p,{children:["ZIO has a special thread pool that can be used to do these computations. That's the ",(0,r.jsx)(n.strong,{children:"blocking thread pool"}),". The ",(0,r.jsx)(n.code,{children:"ZIO#blocking"})," operator and its variants (see ",(0,r.jsx)(n.a,{href:"/reference/core/zio/#blocking-synchronous-side-effects",children:"here"}),") can be used to run a big CPU Work on a dedicated thread. So, it doesn't interfere with all the other work that is going on simultaneously in the ZIO Runtime system."]}),"\n",(0,r.jsx)(n.p,{children:"If a CPU Work doesn't yield quickly, then that is going to monopolize a thread. So how can we determine that our CPU Work can yield quickly or not?"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"If that overall CPU Work composes many ZIO operations, then due to the composition of ZIO operations, it has a chance to yield quickly to other fibers and doesn't monopolize a thread."}),"\n",(0,r.jsx)(n.li,{children:"If that CPU work doesn't compose any ZIO operations, or we lift that from a legacy library, then the ZIO Runtime doesn't have any chance of yielding quickly to other fibers. So this fiber is going to monopolize the underlying thread."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The best practice is to run those huge CPU Work on a dedicated thread pool, by lifting them with ",(0,r.jsx)(n.code,{children:"ZIO#blocking"}),"."]}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsx)(n.p,{children:"So as a rule of thumb, when we have a huge CPU Work that is not chunked with built-in ZIO operations, and thus going to monopolize the underlying thread, we should run that on a dedicated thread pool that is designed to perform CPU-driven tasks."})}),"\n",(0,r.jsx)(n.h3,{id:"blocking-io",children:"Blocking I/O"}),"\n",(0,r.jsxs)(n.p,{children:["Inside Java, there are many methods that will put our thread to sleep. For example, if we call ",(0,r.jsx)(n.code,{children:"read"})," on a socket and there is nothing to read right now because not enough bytes have been read from the other side over the TCP/IP protocol, then that will put our thread to sleep."]}),"\n",(0,r.jsxs)(n.p,{children:["Most of the I/O operations and certainly all the classic I/O operations like ",(0,r.jsx)(n.code,{children:"InputStream"})," and ",(0,r.jsx)(n.code,{children:"OutputStream"})," are utilizing a locking mechanism that will ",(0,r.jsx)(n.code,{children:"park"})," a thread. When we ",(0,r.jsx)(n.code,{children:"write"})," to ",(0,r.jsx)(n.code,{children:"OutputStream"}),", this method will ",(0,r.jsx)(n.code,{children:"park"})," the thread and ",(0,r.jsx)(n.code,{children:"wait"})," until the data has actually been written to file. It is the same way for ",(0,r.jsx)(n.code,{children:"read"})," and similar blocking operations. Anytime we use a ",(0,r.jsx)(n.code,{children:"lock"}),", anything in ",(0,r.jsx)(n.code,{children:"java.util.concurrent.locks"}),", all those locks use this mechanism. All these operations are called blocking because they ",(0,r.jsx)(n.code,{children:"park"})," the thread that is doing the work, and the thread that's doing the work goes to sleep."]}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsxs)(n.p,{children:["What we refer to as blocking I/O is not necessarily just an I/O operation. Remember every time we use a ",(0,r.jsx)(n.code,{children:"lock"})," we are also ",(0,r.jsx)(n.code,{children:"park"}),"ing a thread. It goes to ",(0,r.jsx)(n.code,{children:"sleep"}),", and it has to be woken up again. We refer to this entire class of operations as ",(0,r.jsx)(n.strong,{children:"blocking I/O"}),"."]})}),"\n",(0,r.jsx)(n.p,{children:"There are multiple types of overhead associated with parking a thread:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["When we ",(0,r.jsx)(n.code,{children:"park"})," a thread then that thread is still consuming resources, it's still obviously consuming stack resources, the heap, and all metadata associated with the underlying thread in the JVM."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Since every JVM thread corresponds to an operating system level thread, there's a large amount of overhead even inside the operating system. Every thread has a pre-allocated stack size so that memory is reserved even if that thread is not doing any work. That memory is sort of reserved for the thread, and we cannot touch it."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Besides, the actual process of putting a thread to sleep and then later waking it up again is computationally intensive. It slows down our computations."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["This is why it has become a sort of best practice and part of the architectural pattern of reactive applications to design what is called ",(0,r.jsx)(n.strong,{children:"non-blocking application"}),". Non-blocking is synonymous with asynchronous. Non-blocking and asynchronous and to some degree even reactive, they're all trying to get at something which is what we want: scalable applications."]}),"\n",(0,r.jsx)(n.p,{children:"Scalable applications cannot afford to have thousands of threads just sitting around doing nothing and just consuming work and taking a long time to wake up again. We cannot do blocking I/O in scalable applications. It is considered an anti-pattern because it is not efficient. That is not a way to build scalable applications, but nonetheless, we have to support that use case."}),"\n",(0,r.jsxs)(n.p,{children:["Today, we have lots of common Java libraries that use blocking constructs, like ",(0,r.jsx)(n.code,{children:"InputStream"})," and ",(0,r.jsx)(n.code,{children:"OutputStream"}),", and ",(0,r.jsx)(n.code,{children:"Reader"})," and ",(0,r.jsx)(n.code,{children:"Writer"}),". Also, the JDBC is entirely blocking. The only way of doing database I/O in Java is blocking. So obviously, we have to do blocking I/O. We can do blocking I/O from a fiber. So is it best practice? No, it should be avoided whenever possible, but the reality is we have to do blocking I/O."]}),"\n",(0,r.jsx)(n.p,{children:"Whenever we lift a blocking I/O operation into ZIO, the ZIO Runtime is executing a fiber that is doing blocking I/O. The underlying thread will be parked, and it has to be woken up later. It doesn't have any ability to avoid this. It can't stop an underlying thread from being parked. That's just the way these APIs are designed. So, we have to block. There's no way around that. That fiber will be monopolizing the underneath thread and therefore that thread is not available for performing all the work of the other fibers in the system. So that can be a bottleneck point in our application."}),"\n",(0,r.jsxs)(n.p,{children:["And again, the solution to this problem is the same as the solution to the first class of problems, the CPU Work. The solution is to run this action ",(0,r.jsx)(n.strong,{children:"using the blocking thread pool"})," in ZIO which will ensure that this blocking code executes on its dedicated thread pool. ",(0,r.jsx)(n.strong,{children:"So it doesn't interfere or compete with the threads that are used for doing the bulk of work in your application"}),". So basically ZIO's philosophy is that if we ",(0,r.jsx)(n.em,{children:"have"})," to do CPU Work or blocking synchronous work that's ok we can do that. Just we need to do it in the right place. So it doesn't interfere with our primary thread pool."]}),"\n",(0,r.jsx)(n.p,{children:"ZIO has one primary built-in fixed thread pool. This sort of workhorse thread pool is designed to be used for the majority of our application requirements. It has a certain number of threads in it and that stays constant over the lifetime of our application."}),"\n",(0,r.jsx)(n.p,{children:"Why is that the case? Well because for the majority of workloads in our applications, it does not actually help things to create more threads than the number of CPU cores. If we have eight cores, it does not accelerate any sort of processing to create more than eight threads. Because at the end of the day our hardware is only capable of running eight things at the same time."}),"\n",(0,r.jsx)(n.p,{children:"If we create a thousand threads on a system that can only run eight of them in parallel at a time, then what does the operating system do? As we have not enough CPU cores, the operating system starts giving a little slice of the eight cores to all these threads by switching between them over and over again."}),"\n",(0,r.jsx)(n.p,{children:"The overhead for context switching between threads is significant. The CPU has to load in new registers, refill all its caches, it has to go through all these crazy complex processes that interfere with its main job to get stuff done. There's significant overhead associated with that. As a result, it's not going to be very efficient. We are going to waste a lot of our time and resources just switching back and forth between all these threads, that would kill our application."}),"\n",(0,r.jsx)(n.p,{children:"So for that reason, ZIO's default thread pool is fixed with a number of threads equal to the number of CPU cores. That is the best practice. That means that no matter how much work we create if we create a hundred thousand fibers, they will still run on a fixed number of threads."}),"\n",(0,r.jsx)(n.p,{children:"Let's say we do blocking I/O on the main ZIO thread pool, so we have got eight threads all sitting and parked on a socket read. What happens to all the other 100000 fibers in our system? They line up in a queue waiting for their chance to run. That's not ideal. That's why we should take these effects that either do blocking I/O, or they do big CPU Work that's not chunked and run them using ZIO's blocking thread pool which will give us a dedicated thread."}),"\n",(0,r.jsx)(n.p,{children:"That dedicated thread is not efficient, but again, sometimes we have to interact with legacy code and legacy code is full of blocking code. We just need to be able to handle that gracefully and ZIO does that using the blocking thread pool."}),"\n",(0,r.jsx)(n.h3,{id:"asynchronous-io",children:"Asynchronous I/O"}),"\n",(0,r.jsx)(n.p,{children:"The third category is asynchronous I/O, and we refer to it as Async Work. Async Work is code that whenever it runs into something that it needs to wait on, instead of blocking and parking the thread, it registers a callback, and returns immediately."}),"\n",(0,r.jsx)(n.p,{children:"It allows us to register a callback and when that result is available then our callback will be invoked. Callbacks are the fundamental way by which all async code on the JVM works. There is no mechanism in the JVM right now to support async code natively, but once that would happen in the future, probably in the Loom project, it will simplify a lot of things."}),"\n",(0,r.jsx)(n.p,{children:"But for now, in current days, sort of all published JVM versions have no such thing. The only way we can get a non-blocking async code is to have this callback registering mechanism."}),"\n",(0,r.jsx)(n.p,{children:"Callbacks have the pro that they don't wait for CPU. Instead of waiting to read the next chunk from a socket or instead of waiting to acquire a lock, all we have to do is call it and give it a callback. It doesn't need to do anything else. It can return control to the thread pool and then later on when that data has been read from the socket or when that lock has been acquired or when that amount of time has elapsed if we're sleeping for a certain amount of time, then our callback can be invoked."}),"\n",(0,r.jsxs)(n.p,{children:["It has the potential to be extraordinarily efficient. The drawback of callbacks is they are not so pretty and fun to work with. They don't compose well with ",(0,r.jsx)(n.code,{children:"try"})," / ",(0,r.jsx)(n.code,{children:"finally"})," constructs. Error handling is really terrible, we have to do error propagation on our own. So that is what gave rise to data types like ",(0,r.jsx)(n.code,{children:"Future"})," which eliminates the need for callbacks. By using ",(0,r.jsx)(n.code,{children:"Future"}),"s we can wrap callback-based APIs and get the benefits of async but without the callbacks. Also, it supports for-comprehension, so we can structure our code as a nice linear sequence."]}),"\n",(0,r.jsxs)(n.p,{children:["Similarly, in ZIO we never see a callback with ZIO, but fundamentally everything boils down to asynchronous operations on the JVM in a callback fashion. Callback base code is obscenely efficient, but it is extraordinarily painful to deal with directly. Data types like ",(0,r.jsx)(n.code,{children:"Future"})," and ",(0,r.jsx)(n.code,{children:"ZIO"})," allow us to avoid even seeing a callback in our code."]}),"\n",(0,r.jsxs)(n.p,{children:["With ZIO, we do not have to think about callbacks, unless sometimes, when we need to integrate with legacy code. ZIO has an appropriate constructor to turn that ugly callback-based API into a ZIO effect. It is the ",(0,r.jsx)(n.code,{children:"async"})," constructor."]}),"\n",(0,r.jsxs)(n.p,{children:["Most of the ZIO operations that one would expect to be blocking do actually not block the underlying thread, but they offer blocking semantics managed by ZIO. For example, every time we see something like ",(0,r.jsx)(n.code,{children:"ZIO.sleep"})," or when we take something from a queue (",(0,r.jsx)(n.code,{children:"queue.take"}),") or offer something to a queue (",(0,r.jsx)(n.code,{children:"queue.offer"}),") or if we acquire a permit from a semaphore (",(0,r.jsx)(n.code,{children:"semaphore.withPermit"}),") and so forth, we are just blocking semantically without actually blocking an underlying thread. If we use the corresponding methods in Java, like ",(0,r.jsx)(n.code,{children:"Thread.sleep"})," or any of its ",(0,r.jsx)(n.code,{children:"lock"})," machinery, then those methods are going to block a thread. So this is why we say that ZIO is 100% non-blocking, while Java threads are not."]}),"\n",(0,r.jsx)(n.p,{children:"All of the pieces of machinery that ZIO gives us are 100% asynchronous and non-blocking. As they don't block and monopolize the thread, all of the async work is executed on the primary thread pool in ZIO."})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>s});var t=i(96540);const r={},o=t.createContext(r);function a(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);