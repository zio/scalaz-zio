"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[83375],{28453:(e,n,l)=>{l.d(n,{R:()=>i,x:()=>o});var a=l(96540);const t={},r=a.createContext(t);function i(e){const n=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),a.createElement(r.Provider,{value:n},e.children)}},61904:(e,n,l)=>{l.r(n),l.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>a,toc:()=>s});const a=JSON.parse('{"id":"reference/stream/zchannel/channel-operations","title":"Channel Operations","description":"Piping","source":"@site/docs/reference/stream/zchannel/channel-operations.md","sourceDirName":"reference/stream/zchannel","slug":"/reference/stream/zchannel/channel-operations","permalink":"/reference/stream/zchannel/channel-operations","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/stream/zchannel/channel-operations.md","tags":[],"version":"current","frontMatter":{"id":"channel-operations","title":"Channel Operations"},"sidebar":"reference-sidebar","previous":{"title":"Running a Channel","permalink":"/reference/stream/zchannel/running-a-channel"},"next":{"title":"Channel Interruption","permalink":"/reference/stream/zchannel/channel-interruption"}}');var t=l(74848),r=l(28453);const i={id:"channel-operations",title:"Channel Operations"},o=void 0,c={},s=[{value:"Piping",id:"piping",level:2},{value:"Sequencing",id:"sequencing",level:2},{value:"Concatenating",id:"concatenating",level:2},{value:"Zipping",id:"zipping",level:2},{value:"Mapping",id:"mapping",level:2},{value:"Mapping The Terminal Done Value (<code>OutDone</code>)",id:"mapping-the-terminal-done-value-outdone",level:3},{value:"Mapping The Done Value of The Input Port (<code>InDone</code>)",id:"mapping-the-done-value-of-the-input-port-indone",level:3},{value:"Mapping The Error Value of The Output Port (<code>OutErr</code>)",id:"mapping-the-error-value-of-the-output-port-outerr",level:3},{value:"Mapping The Output Elements of a Channel (<code>OutElem</code>)",id:"mapping-the-output-elements-of-a-channel-outelem",level:3},{value:"Mapping The Input Elements of a Channel (<code>InElem</code>)",id:"mapping-the-input-elements-of-a-channel-inelem",level:3},{value:"Merging",id:"merging",level:2},{value:"Collecting",id:"collecting",level:2},{value:"Converting",id:"converting",level:2},{value:"concatMap",id:"concatmap",level:2},{value:"mergeMap",id:"mergemap",level:2},{value:"collect",id:"collect",level:2}];function h(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"piping",children:"Piping"}),"\n",(0,t.jsx)(n.p,{children:"The values from the output port of the first channel are passed to the input port of the second channel when we pipe a channel to another channel:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import zio.stream._\n\n(ZChannel.writeAll(1,2,3) >>> (ZChannel.read[Int] <*> ZChannel.read[Int])).runCollect.debug\n// Output: (Chunk(),(1,2))\n"})}),"\n",(0,t.jsx)(n.h2,{id:"sequencing",children:"Sequencing"}),"\n",(0,t.jsxs)(n.p,{children:["In order to sequence channels, we can use the ",(0,t.jsx)(n.code,{children:"ZChannel#flatMap"})," operator. When we use the ",(0,t.jsx)(n.code,{children:"flatMap"})," operator, we have the ability to chain two channels together. After the first channel is finished, we can create a new channel based on the terminal value of the first channel:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.stream._\n\nZChannel\n  .fromZIO(\n    Console.readLine("Please enter a number: ").map(_.toInt)\n  )\n  .flatMap {\n    case n if n < 0 => ZChannel.fail("Number must be positive")\n    case n          => ZChannel.writeAll((0 to n): _*)\n  }\n  .runCollect\n  .debug\n// Sample Output:\n// Please enter a number: 5\n// (Chunk(0,1,2,3,4,5),())\n'})}),"\n",(0,t.jsx)(n.h2,{id:"concatenating",children:"Concatenating"}),"\n",(0,t.jsxs)(n.p,{children:["Suppose there is a channel that creates a new channel for each element of the outer channel and emits them to the output port. We can use ",(0,t.jsx)(n.code,{children:"concatOut"})," to concatenate all the inner channels into a single channel:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'import zio.stream._\n\nZChannel\n  .writeAll("a", "b", "c")\n  .mapOut { l =>\n    ZChannel.writeAll((1 to 3).map(i => s"$l$i"):_*) \n  }\n  .concatOut\n  .runCollect\n  .debug\n// Output: (Chunk(a1,a2,a3,b1,b2,b3,c1,c2,c3),())\n'})}),"\n",(0,t.jsxs)(n.p,{children:["We can do the same with ",(0,t.jsx)(n.code,{children:"ZChannel.concatAll"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'import zio.stream._\n\nZChannel\n  .concatAll(\n    ZChannel\n      .writeAll("a", "b", "c")\n      .mapOut { l =>\n        ZChannel.writeAll((1 to 3).map(i => s"$l$i"): _*)\n      }\n  )\n  .runCollect\n  .debug\n  \n// Output: (Chunk(a1,a2,a3,b1,b2,b3,c1,c2,c3),())\n'})}),"\n",(0,t.jsx)(n.h2,{id:"zipping",children:"Zipping"}),"\n",(0,t.jsxs)(n.p,{children:["We have two categories of ",(0,t.jsx)(n.code,{children:"zip"})," operators: ordinary ",(0,t.jsx)(n.code,{children:"zipXYZ"})," operators which run sequentially, and parallel ",(0,t.jsx)(n.code,{children:"zipXYZ"})," operators which run in parallel."]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"zip"}),"/",(0,t.jsx)(n.code,{children:"<*>"})," operator:"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'import zio.stream._\n\nval first = ZChannel.write(1,2,3) *> ZChannel.succeed("Done!")\nval second = ZChannel.write(4,5,6) *> ZChannel.succeed("Bye!")\n\n(first <*> second).runCollect.debug\n// Output: (Chunk((1,2,3),(4,5,6)),(Done!,Bye!))\n'})}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"zipRight"}),"/",(0,t.jsx)(n.code,{children:"*>"})," operator:"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"(first *> second).runCollect.debug\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"3",children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"zipLeft"}),"/",(0,t.jsx)(n.code,{children:"<*"})," operator:"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"(first <* second).runCollect.debug\n"})}),"\n",(0,t.jsx)(n.h2,{id:"mapping",children:"Mapping"}),"\n",(0,t.jsxs)(n.h3,{id:"mapping-the-terminal-done-value-outdone",children:["Mapping The Terminal Done Value (",(0,t.jsx)(n.code,{children:"OutDone"}),")"]}),"\n",(0,t.jsxs)(n.p,{children:["The ordinary ",(0,t.jsx)(n.code,{children:"map"})," operator is used to map the done value of a channel:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import zio.stream._\n\nZChannel.writeAll(1, 2, 3).map(_ => 5).runCollect.debug \n// (Chunk(1,2,3),5)\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"mapping-the-done-value-of-the-input-port-indone",children:["Mapping The Done Value of The Input Port (",(0,t.jsx)(n.code,{children:"InDone"}),")"]}),"\n",(0,t.jsxs)(n.p,{children:["To map the done value of the input port, we use the ",(0,t.jsx)(n.code,{children:"contramap"})," operator:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'import zio.stream._\n\n(ZChannel.succeed("5") >>>\n  ZChannel\n    .readWith(\n      (i: Int) => ZChannel.write(ZChannel.write(i)),\n      (_: Any) => ZChannel.unit,\n      (d: Int) => ZChannel.succeed(d * 2)\n    )\n    .contramap[String](_.toInt)).runCollect.debug\n// Output: (Chunk(),(10))\n'})}),"\n",(0,t.jsxs)(n.h3,{id:"mapping-the-error-value-of-the-output-port-outerr",children:["Mapping The Error Value of The Output Port (",(0,t.jsx)(n.code,{children:"OutErr"}),")"]}),"\n",(0,t.jsxs)(n.p,{children:["To map the failure value of a channel, we use the ",(0,t.jsx)(n.code,{children:"mapError"})," operator:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.stream._\n\nval channel =\n  ZChannel\n    .fromZIO(Console.readLine("Please enter you name: "))\n    .mapError(_.toString)\n'})}),"\n",(0,t.jsxs)(n.h3,{id:"mapping-the-output-elements-of-a-channel-outelem",children:["Mapping The Output Elements of a Channel (",(0,t.jsx)(n.code,{children:"OutElem"}),")"]}),"\n",(0,t.jsxs)(n.p,{children:["To map the output elements of a channel, we use the ",(0,t.jsx)(n.code,{children:"mapOutput"})," operator:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import zio.stream._\n\nZChannel.writeAll(1,2,3).mapOut(_ * 2).runCollect.debug\n// Output: (Chunk(2,4,6),())\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"mapping-the-input-elements-of-a-channel-inelem",children:["Mapping The Input Elements of a Channel (",(0,t.jsx)(n.code,{children:"InElem"}),")"]}),"\n",(0,t.jsxs)(n.p,{children:["To map the input elements of a channel, we use the ",(0,t.jsx)(n.code,{children:"contramapIn"})," operator:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'import zio.stream._\n\n(ZChannel.write("123") >>> ZChannel.read[Int].contramapIn[String](_.toInt * 2)).runCollect.debug\n// Output: (Chunk(),(246))\n'})}),"\n",(0,t.jsx)(n.h2,{id:"merging",children:"Merging"}),"\n",(0,t.jsx)(n.p,{children:"Merge operators are used to merging multiple channels into a single channel. They are used to combine the output port of channels concurrently. Every time any of the channels produces a value, the output port of the resulting channel will produce a value."}),"\n",(0,t.jsx)(n.p,{children:"Assume we have the following channel:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import zio._\nimport zio.stream._\n\ndef iterate(\n    from: Int,\n    to: Int\n): ZChannel[Any, Any, Any, Any, Nothing, Int, Unit] =\n  if (from <= to)\n    ZChannel.write(from) *>\n      ZChannel.fromZIO(\n        Random\n          .nextLongBounded(1000)\n          .flatMap(delay => ZIO.sleep(Duration.fromMillis(delay)))\n      ) *> iterate(from + 1, to)\n  else ZChannel.unit\n"})}),"\n",(0,t.jsx)(n.p,{children:"Now let's merge some channels:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.stream._\n\nZChannel\n  .mergeAllUnbounded(\n    ZChannel.writeAll(\n      iterate(1, 3),\n      iterate(4, 6),\n      iterate(6, 9)\n    )\n  )\n  .mapOutZIO(i => Console.print(i + " "))\n  .runDrain\n// Sample output: 1 4 6 7 8 2 3 5 6 9\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"ZChannel.mergeAllUnbounded"})," uses the maximum buffer size, which is ",(0,t.jsx)(n.code,{children:"Int.MaxValue"})," by default. This means that if we use this operator for long-running channels, which produce a lot of values, it can cause the program to run out of memory."]}),"\n",(0,t.jsxs)(n.p,{children:["We have another operator called ",(0,t.jsx)(n.code,{children:"ZChannel.mergeAll"}),", which allows us to specify the buffer size, the concurrency level, and also the strategy for merging the channels."]}),"\n",(0,t.jsxs)(n.p,{children:["Note that if we want to merge channels sequentially, we can use the ",(0,t.jsx)(n.code,{children:"zip"})," or ",(0,t.jsx)(n.code,{children:"flatMap"})," operators:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import zio.stream._\n\n(iterate(1, 3) <*> iterate(4, 6) <*> iterate(6, 9)).runCollect.debug\n// Output: (Chunk(1,2,3,4,5,6,7,8,9),())\n"})}),"\n",(0,t.jsx)(n.h2,{id:"collecting",children:"Collecting"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"collectElements"})," collects all the elements of the channel along with its done value as a tuple and returns a new channel with a terminal value of that tuple:"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import zio.stream._\n\nZChannel.writeAll(1,2,3,4,5)\n  .collectElements\n  .runCollect\n  .debug\n// Output: (Chunk(),(Chunk(1,2,3,4,5),()))\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"emitCollect"})," is like the ",(0,t.jsx)(n.code,{children:"collectElements"})," operator, but it emits the result of the collection to the output port of the new channel:"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import zio.stream._\n\nZChannel.writeAll(1,2,3,4,5)\n  .emitCollect\n  .runCollect\n  .debug\n// Output: (Chunk((Chunk(1,2,3,4,5),())),())\n"})}),"\n",(0,t.jsx)(n.h2,{id:"converting",children:"Converting"}),"\n",(0,t.jsxs)(n.p,{children:["We can convert a channel to other data types using the ",(0,t.jsx)(n.code,{children:"ZChannel.toXYZ"})," methods:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"ZChannel#toStream"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"ZChannel#toPipeline"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"ZChannel#toSink"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"ZChannel#toPull"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"ZChannel#toQueue"})}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"concatmap",children:"concatMap"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"concatMap"})," is a combination of two operators: mapping and concatenation. Using this operator, we can map every emitted element of a channel (outer channel) to a new channel (inner channels), and then concatenate all the inner channels into a single channel. The concatenation is done ",(0,t.jsx)(n.strong,{children:"sequentially"}),", so we use this operator when the order of the elements is important:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'import zio.stream._\n\nZChannel\n  .writeAll("a", "b", "c")\n  .concatMap { l =>\n    def inner(from: Int, to: Int): ZChannel[Any, Any, Any, Any, Nothing, String, Unit] =\n      if (from <= to) ZChannel.write(s"$l$from") *> inner(from + 1, to)\n      else ZChannel.unit  \n    inner(0, 5)\n  }\n  .runCollect\n  .debug\n// Output: (Chunk(a0,a1,a2,a3,a4,a5,b0,b1,b2,b3,b4,b5,c0,c1,c2,c3,c4,c5),())\n'})}),"\n",(0,t.jsxs)(n.p,{children:["In the above example, we create a new channel for every element of the outer channel. The new inner channel is responsible for emitting from zero to five with the label of the outer channel. When an inner channel is done, it moves to the next inner channel sequentially. There is a similar operator called ",(0,t.jsx)(n.code,{children:"mergeMap"})," that works in parallel and doesn't preserve the order of the elements."]}),"\n",(0,t.jsx)(n.h2,{id:"mergemap",children:"mergeMap"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"mergeMap"})," is a combination of two operators: mapping and merging. Using this operator, we can map every emitted element of a channel (outer channel) to a new channel (inner channel), and then run all the inner channels in parallel and merge them into a single channel. The merge operation is done ",(0,t.jsx)(n.strong,{children:"in parallel"}),", so we use this operator when the order of the elements is not important, and we want to process all inner channels in parallel:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'import zio.stream._\nimport zio.stream.ZChannel._\n\nZChannel\n  .writeAll("a", "b", "c")\n  .mergeMap(8, 1, MergeStrategy.BackPressure) { l =>\n    def inner(\n        from: Int,\n        to: Int\n    ): ZChannel[Any, Any, Any, Any, Nothing, String, Unit] =\n      if (from <= to) ZChannel.write(s"$l$from") *> inner(from + 1, to)\n      else ZChannel.unit\n    inner(0, 5)\n  }\n  .runCollect\n  .debug\n// Non-deterministic output: (Chunk(a0,a1,a2,b0,b1,b2,b3,c0,b4,c1,a3,c2,b5,a4,c3,c4,a5,c5),())\n'})}),"\n",(0,t.jsx)(n.h2,{id:"collect",children:"collect"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"collect"})," is a combination of two operations: filtering and mapping. Using this operator, we can filter the elements of a channel using a partial function, and then map the filtered elements:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import zio.stream._\n\nZChannel\n  .writeAll((1 to 10): _*)\n  .collect { case i if i % 3 == 0 => i * 2 }\n  .runCollect\n  .debug\n// Output: (Chunk(6,12,18),())\n"})})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}}}]);