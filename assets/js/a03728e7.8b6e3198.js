"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[81468],{97128:(e,r,i)=>{i.r(r),i.d(r,{assets:()=>l,contentTitle:()=>t,default:()=>x,frontMatter:()=>n,metadata:()=>d,toc:()=>o});const d=JSON.parse('{"id":"can_fail","title":"Compile Time Errors for Handling Combinators","description":"ZIO provides a variety of combinators to handle errors such as orElse, catchAll, catchSome, option, either, and retry. However, these combinators only make sense for effects that can fail (i.e. where the error type is not Nothing). To help you identify code that doesn\'t make sense, error handling combinators require implicit evidence CanFail[E], which is automatically available for all types except Nothing. The table below includes a list of combinators that only make sense for effects that can fail along with value preserving rewrites.","source":"@site/docs/canfail.md","sourceDirName":".","slug":"/can_fail","permalink":"/can_fail","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/canfail.md","tags":[],"version":"current","frontMatter":{"id":"can_fail","title":"Compile Time Errors for Handling Combinators","slug":"can_fail"}}');var s=i(74848),c=i(28453);const n={id:"can_fail",title:"Compile Time Errors for Handling Combinators",slug:"can_fail"},t=void 0,l={},o=[{value:"ZIO",id:"zio",level:2},{value:"ZStream",id:"zstream",level:2},{value:"ZStreamChunk",id:"zstreamchunk",level:2},{value:"(*) Notes:",id:"-notes",level:2}];function h(e){const r={code:"code",h2:"h2",li:"li",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,c.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.p,{children:["ZIO provides a variety of combinators to handle errors such as ",(0,s.jsx)(r.code,{children:"orElse"}),", ",(0,s.jsx)(r.code,{children:"catchAll"}),", ",(0,s.jsx)(r.code,{children:"catchSome"}),", ",(0,s.jsx)(r.code,{children:"option"}),", ",(0,s.jsx)(r.code,{children:"either"}),", and ",(0,s.jsx)(r.code,{children:"retry"}),". However, these combinators only make sense for effects that can fail (i.e. where the error type is not ",(0,s.jsx)(r.code,{children:"Nothing"}),"). To help you identify code that doesn't make sense, error handling combinators require implicit evidence ",(0,s.jsx)(r.code,{children:"CanFail[E]"}),", which is automatically available for all types except ",(0,s.jsx)(r.code,{children:"Nothing"}),". The table below includes a list of combinators that only make sense for effects that can fail along with value preserving rewrites."]}),"\n",(0,s.jsx)(r.h2,{id:"zio",children:"ZIO"}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Code"}),(0,s.jsx)(r.th,{children:"Rewrite"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio <> zio"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio.catchAll(f)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio.catchSome(pf)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio.either"})}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"uio"}),"*"]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio.eventually"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio.flatMapError(f)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio.fold(f, g)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio.map(g)"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio.foldZIO(f, g)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio.flatMap(g)"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio.mapBoth(f, g)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio.map(g)"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio.mapError(f)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio.option"})}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"uio"}),"*"]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio.orDie"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio.orDieWith(f)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio.orElse(zio)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio.orElseEither(zio)"})}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"uio"}),"*"]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio.orElseFail(e)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio.asElseSucceed(a)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio.refineOrDie(pf)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio.refineOrDieWith(pf)(f)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio.refineToOrDie"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio.retry(s)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio.retryOrElse(s, f)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio.retryOrElseEither(s, f)"})}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"uio"}),"*"]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio.tapBoth(f, g)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio.tap(g)"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio.tapError(f)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"uio"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"ZIO.partitionZIO(in)(f)"})}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"ZIO.foreach(in)(f)"}),"*"]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"ZIO.partitionZIOPar(in)(f)"})}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"ZIO.foreachPar(in)(f)"}),"*"]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"ZIO.validateZIO(in)(f)"})}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"ZIO.foreach(in)(f)"}),"*"]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"ZIO.validateFirstZIO(in)(f)"})}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"ZIO.foreach(in)(f)"}),"*"]})]})]})]}),"\n",(0,s.jsx)(r.h2,{id:"zstream",children:"ZStream"}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Code"}),(0,s.jsx)(r.th,{children:"Rewrite"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"ustream.catchAll(f)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"ustream"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"ustream.either"})}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"ustream"}),"*"]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"ustream.mapBoth(f, g)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"ustream.map(g)"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"ustream.mapError(f)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"ustream"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"ustream.orElse(zstream)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"ustream"})})]})]})]}),"\n",(0,s.jsx)(r.h2,{id:"zstreamchunk",children:"ZStreamChunk"}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Code"}),(0,s.jsx)(r.th,{children:"Rewrite"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"ustream.either"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"ustream"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"ustream.orElse(zstream)"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"ustream"})})]})]})]}),"\n",(0,s.jsx)(r.h2,{id:"-notes",children:"(*) Notes:"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"either"}),", ",(0,s.jsx)(r.code,{children:"option"}),", ",(0,s.jsx)(r.code,{children:"orElseEither"}),", and ",(0,s.jsx)(r.code,{children:"retryOrElseEither"})," wrap their results in ",(0,s.jsx)(r.code,{children:"Some"})," or ",(0,s.jsx)(r.code,{children:"Right"})," so after rewriting, code calling these methods can be simplified to accept an ",(0,s.jsx)(r.code,{children:"A"})," rather than an ",(0,s.jsx)(r.code,{children:"Option[A]"})," or ",(0,s.jsx)(r.code,{children:"Either[E, A]"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"partitionZIO"}),", ",(0,s.jsx)(r.code,{children:"partitionZIOPar"}),", ",(0,s.jsx)(r.code,{children:"validateZIO"})," and ",(0,s.jsx)(r.code,{children:"validateFirstZIO"})," have error accumulating semantics on either error channel or success channel. After rewrite the error type can be simplified to ",(0,s.jsx)(r.code,{children:"E"})," rather than ",(0,s.jsx)(r.code,{children:"List[E]"})," or the success type ",(0,s.jsx)(r.code,{children:"List[B]"})," instead of ",(0,s.jsx)(r.code,{children:"(List[E], List[B])"}),"."]}),"\n"]}),"\n"]})]})}function x(e={}){const{wrapper:r}={...(0,c.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},28453:(e,r,i)=>{i.d(r,{R:()=>n,x:()=>t});var d=i(96540);const s={},c=d.createContext(s);function n(e){const r=d.useContext(c);return d.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function t(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:n(e.components),d.createElement(c.Provider,{value:r},e.children)}}}]);