"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[64724],{95584:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"reference/test/assertions/smart-assertions","title":"Smart Assertions","description":"The smart assertion is a simple way to assert both ordinary values and ZIO effects. It uses the assertTrue function, which uses macro under the hood.","source":"@site/docs/reference/test/assertions/smart-assertions.md","sourceDirName":"reference/test/assertions","slug":"/reference/test/assertions/smart-assertions","permalink":"/reference/test/assertions/smart-assertions","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/test/assertions/smart-assertions.md","tags":[],"version":"current","frontMatter":{"id":"smart-assertions","title":"Smart Assertions"},"sidebar":"reference-sidebar","previous":{"title":"Classic Assertions","permalink":"/reference/test/assertions/classic-assertions"},"next":{"title":"Built-in Assertions","permalink":"/reference/test/assertions/built-in-assertions"}}');var r=t(74848),i=t(28453);const a={id:"smart-assertions",title:"Smart Assertions"},l=void 0,o={},c=[{value:"Asserting Ordinary Values",id:"asserting-ordinary-values",level:2},{value:"Asserting ZIO effects",id:"asserting-zio-effects",level:2},{value:"Assertion Operators",id:"assertion-operators",level:2},{value:"Asserting Nested Values",id:"asserting-nested-values",level:2},{value:"Testing Optional Values",id:"testing-optional-values",level:3},{value:"Testing Either Values",id:"testing-either-values",level:3},{value:"Testing Exit Values",id:"testing-exit-values",level:3},{value:"Deeply Nested Values",id:"deeply-nested-values",level:2},{value:"Custom Assertions",id:"custom-assertions",level:2},{value:"More Examples",id:"more-examples",level:2}];function d(e){const s={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(s.p,{children:["The smart assertion is a simple way to assert both ",(0,r.jsx)(s.em,{children:"ordinary values"})," and ",(0,r.jsx)(s.em,{children:"ZIO effects"}),". It uses the ",(0,r.jsx)(s.code,{children:"assertTrue"})," function, which uses macro under the hood."]}),"\n",(0,r.jsx)(s.h2,{id:"asserting-ordinary-values",children:"Asserting Ordinary Values"}),"\n",(0,r.jsxs)(s.p,{children:["In the following example, we assert simple ordinary values using the ",(0,r.jsx)(s.code,{children:"assertTrue"})," method:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:'import zio._\nimport zio.test.{test, _}\n\ntest("sum"){\n  assertTrue(1 + 1 == 2)\n}\n'})}),"\n",(0,r.jsxs)(s.p,{children:["We can assert multiple assertions inside a single ",(0,r.jsx)(s.code,{children:"assertTrue"}),":"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:'test("multiple assertions"){\n  assertTrue(\n    true,\n    1 + 1 == 2,\n    Some(1 + 1) == Some(2)\n  )\n}\n'})}),"\n",(0,r.jsx)(s.h2,{id:"asserting-zio-effects",children:"Asserting ZIO effects"}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.code,{children:"assertTrue"})," method can also be used to assert ZIO effects:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:'import zio._\nimport zio.test.{test, _}\n\ntest("updating ref") {\n  for {\n    r <- Ref.make(0)\n    _ <- r.update(_ + 1)\n    v <- r.get\n  } yield assertTrue(v == 1)\n}\n'})}),"\n",(0,r.jsxs)(s.p,{children:["Using ",(0,r.jsx)(s.code,{children:"assertTrue"})," with for-comprehension style, we can think of testing as these three steps:"]}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Set up the test"})," \u2014 In this section we should setup the system under test (e.g. ",(0,r.jsx)(s.code,{children:"Ref.make(0)"}),")."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Running the test"})," \u2014 Then we run the test scenario according to the test specification. (e.g ",(0,r.jsx)(s.code,{children:"ref.update(_ + 1)"}),")"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Making assertions about the test"})," - Finally, we should assert the result with the right expectations (e.g. ",(0,r.jsx)(s.code,{children:"assertTrue(v == 1)"}),")"]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"assertion-operators",children:"Assertion Operators"}),"\n",(0,r.jsxs)(s.p,{children:["Each ",(0,r.jsx)(s.code,{children:"assertTrue"})," returns a ",(0,r.jsx)(s.code,{children:"AssertResult"}),", so they have the same operators as ",(0,r.jsx)(s.code,{children:"AssertResult"}),". Here are some of the useful operators:"]}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.code,{children:"&&"})})," - This is the logical and operator to make sure that both assertions are true:"]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:'import zio.test._\n\ntest("&&") {\n  check(Gen.int <*> Gen.int) { case (x: Int, y: Int) =>\n    assertTrue(x + y == y + x) && assertTrue(x * y == y * x)\n  }\n}\n'})}),"\n",(0,r.jsxs)(s.ol,{start:"2",children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"||"})," - This is the logical or operator to make sure that at least one of the assertions is true:"]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:'import zio.test._\n\nsuite("||")(\n  test("false || true") {\n    assertTrue(false) || assertTrue(true) // this will pass\n  },\n  test("true || false") {\n    assertTrue(true) || assertTrue(false) // this will pass\n  },\n  test("true || true") {\n    assertTrue(true) || assertTrue(true) // this will pass\n  },\n  test("false || false") {\n    assertTrue(false) || assertTrue(false) // this will false\n  },\n)\n'})}),"\n",(0,r.jsxs)(s.ol,{start:"3",children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.code,{children:"!"})})," - This is the logical not operator to negate the assertion:"]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:'import zio.test._\n\nsuite("unary !") (\n    test("negate true") {\n        !assertTrue(true) // this will fail\n    },\n    test("negate false") {\n        !assertTrue(false) // this will pass\n    }\n)\n'})}),"\n",(0,r.jsxs)(s.ol,{start:"4",children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"implies"})," - This is the logical implies operator to make sure that the first assertion implies the second assertion. It is equivalent to ",(0,r.jsx)(s.code,{children:"!p || q"}),' which is a conditional statement of the form "if p, then q" where p and q are propositions. The ',(0,r.jsx)(s.code,{children:"==>"})," operator is an alias for ",(0,r.jsx)(s.code,{children:"implies"}),"."]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:'import zio.test._\n\nsuite("implies") (\n  test("true implies true")(\n    assertTrue(true) implies assertTrue(true) // this will pass\n  ),\n  test("true implies false")(\n    assertTrue(true) implies assertTrue(false) // this will fail\n  ),\n  test("false implies true")(\n    assertTrue(false) implies assertTrue(true) // this will pass\n  ),\n  test("false implies false")(\n    assertTrue(false) implies assertTrue(false) // this will pass\n  ),\n)\n'})}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.code,{children:"implies"})," assertion is true if either the p is false or when both p and q are true:"]}),"\n",(0,r.jsxs)(s.table,{children:[(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{children:"P"}),(0,r.jsx)(s.th,{children:"Q"}),(0,r.jsx)(s.th,{children:"P implies Q"})]})}),(0,r.jsxs)(s.tbody,{children:[(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"true"}),(0,r.jsx)(s.td,{children:"true"}),(0,r.jsx)(s.td,{children:"true"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"true"}),(0,r.jsx)(s.td,{children:"false"}),(0,r.jsx)(s.td,{children:"false"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"false"}),(0,r.jsx)(s.td,{children:"true"}),(0,r.jsx)(s.td,{children:"true"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"false"}),(0,r.jsx)(s.td,{children:"false"}),(0,r.jsx)(s.td,{children:"true"})]})]})]}),"\n",(0,r.jsxs)(s.ol,{start:"5",children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"iff"})," - This is the logical iff operator to make sure that the first assertion is true if and only if the second assertion is true. It is equivalent to ",(0,r.jsx)(s.code,{children:"(p implies q) && (q implies p)"}),". The ",(0,r.jsx)(s.code,{children:"<==>"})," operator is an alias for ",(0,r.jsx)(s.code,{children:"iff"}),"."]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:'import zio.test._\n\nsuite("iff") (\n  test("true iff true")(\n    assertTrue(true) iff assertTrue(true) // this will pass\n  ),\n  test("true iff false")(\n    assertTrue(true) iff assertTrue(false) // this will fail\n  ),\n  test("false iff true")(\n    assertTrue(false) iff assertTrue(true) // this will fail\n  ),\n  test("false iff false")(\n    assertTrue(false) iff assertTrue(false) // this will pass\n  )\n)\n'})}),"\n",(0,r.jsx)(s.p,{children:"Here is the truth table for the iff operator:"}),"\n",(0,r.jsxs)(s.table,{children:[(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{children:"P"}),(0,r.jsx)(s.th,{children:"Q"}),(0,r.jsx)(s.th,{children:"P iff Q"})]})}),(0,r.jsxs)(s.tbody,{children:[(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"true"}),(0,r.jsx)(s.td,{children:"true"}),(0,r.jsx)(s.td,{children:"true"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"true"}),(0,r.jsx)(s.td,{children:"false"}),(0,r.jsx)(s.td,{children:"false"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"false"}),(0,r.jsx)(s.td,{children:"true"}),(0,r.jsx)(s.td,{children:"false"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"false"}),(0,r.jsx)(s.td,{children:"false"}),(0,r.jsx)(s.td,{children:"true"})]})]})]}),"\n",(0,r.jsxs)(s.ol,{start:"6",children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"??"}),"- We can add a custom message to the assertion using the ",(0,r.jsx)(s.code,{children:"??"})," operator. This will be useful when assertion fails, and we want to provide more information about the failure:"]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:'import zio.test._\n\nassertTrue(1 + 1 == 3) ?? "1 + 1 should be equal to 2"\n'})}),"\n",(0,r.jsx)(s.h2,{id:"asserting-nested-values",children:"Asserting Nested Values"}),"\n",(0,r.jsxs)(s.p,{children:["There are several operators designed specifically for use within the ",(0,r.jsx)(s.code,{children:"assertTrue"})," macro, enhancing the ease and readability of assertions. These operators, intended exclusively for the ",(0,r.jsx)(s.code,{children:"assertTrue"})," macro, leverage the ",(0,r.jsx)(s.code,{children:"TestLens[A]"})," type-class to access the underlying value of the type ",(0,r.jsx)(s.code,{children:"A"}),"."]}),"\n",(0,r.jsxs)(s.p,{children:["We use the ",(0,r.jsx)(s.code,{children:"is"})," extension method inside the ",(0,r.jsx)(s.code,{children:"assertTrue"})," macro to convert the given value to a ",(0,r.jsx)(s.code,{children:"TestLens"}),". Now no matter how deeply nested the value is, we can access the underlying values using extension method defined for ",(0,r.jsx)(s.code,{children:"TestLens"})," values:"]}),"\n",(0,r.jsx)(s.h3,{id:"testing-optional-values",children:"Testing Optional Values"}),"\n",(0,r.jsx)(s.p,{children:"There are two operators for testing optional values:"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.code,{children:"TestLens#some"})})," - This operator is used to peek into the ",(0,r.jsx)(s.code,{children:"Some"})," value:"]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:'import zio.test._\n\ntest("optional value is some(42)") {\n  val sut: Option[Int] = Some(40 + 2)\n  assertTrue(sut.is(_.some) == 42)\n}\n'})}),"\n",(0,r.jsxs)(s.ol,{start:"2",children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.code,{children:"TestLens#anything"})})," - This operator is used to assert that the value is ",(0,r.jsx)(s.code,{children:"Some"}),":"]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:'import zio.test._\n\ntest("optional value is anything") {\n  val sut: Option[Int] = Some(42)\n  assertTrue(sut.is(_.anything))\n}\n'})}),"\n",(0,r.jsx)(s.h3,{id:"testing-either-values",children:"Testing Either Values"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.code,{children:"TestLens#right"})})," - This operator is used to peek into the ",(0,r.jsx)(s.code,{children:"Right"})," value:"]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:'import zio.test._\n\ntest("TestLens#right") {\n  val sut: Either[Error, Int] = Right(40 + 2)\n  assertTrue(sut.is(_.right) == 42)\n}\n'})}),"\n",(0,r.jsxs)(s.ol,{start:"2",children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.code,{children:"TestLens#left"})})," - This operator is used to peek into the ",(0,r.jsx)(s.code,{children:"Left"})," value:"]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:'import zio.test._\n\ncase class Error(errorMessage: String)\n\ntest("TestLens#left") {\n  val sut: Either[Error, Int] = Left(Error("Boom!"))\n  assertTrue(sut.is(_.left).errorMessage == "Boom!")\n}\n'})}),"\n",(0,r.jsxs)(s.ol,{start:"3",children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.code,{children:"TestLens#anything"})})," - This operator is used to assert that the value is ",(0,r.jsx)(s.code,{children:"Right"}),":"]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:'import zio.test._\n\ntest("TestLens#anything") {\n  val sut: Either[Error, Int] = Right(42)\n  assertTrue(sut.is(_.anything))\n}\n'})}),"\n",(0,r.jsx)(s.h3,{id:"testing-exit-values",children:"Testing Exit Values"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.code,{children:"TestLens#success"})})," - This operator transforms the ",(0,r.jsx)(s.code,{children:"Exit"})," value to its success type ",(0,r.jsx)(s.code,{children:"A"})," if it is a ",(0,r.jsx)(s.code,{children:"Exit.Success"}),", otherwise it will fail. So this can be used for asserting the success value of the ",(0,r.jsx)(s.code,{children:"Exit"}),":"]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:'import zio.Exit\nimport zio.test._\n\ntest("TestLens#success") {\n  val sut: Exit[Error, Int] = Exit.succeed(42)\n  assertTrue(sut.is(_.success) == 42)\n}\n'})}),"\n",(0,r.jsxs)(s.ol,{start:"2",children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.code,{children:"TestLens#failure"})})," - This operator transforms the ",(0,r.jsx)(s.code,{children:"Exit"})," value to its failure type ",(0,r.jsx)(s.code,{children:"E"})," if it is a ",(0,r.jsx)(s.code,{children:"Exit.Failure"}),", otherwise it will fail. So this can be used for asserting the failure value of the ",(0,r.jsx)(s.code,{children:"Exit"}),":"]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:'import zio.Exit\nimport zio.test._\n\ncase class Error(errorMessage: String)\n\ntest("TestLens#failure") {\n  val sut: Exit[Error, Int] = Exit.fail(Error("Boom!"))\n  assertTrue(sut.is(_.failure).errorMessage == "Boom!")\n}\n'})}),"\n",(0,r.jsxs)(s.ol,{start:"3",children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.code,{children:"TestLens#die"})})," - This operator transforms the ",(0,r.jsx)(s.code,{children:"Exit"})," value to its die type ",(0,r.jsx)(s.code,{children:"E"})," if it is a ",(0,r.jsx)(s.code,{children:"Exit.Die"}),", otherwise it will fail. So this can be used for asserting the die value of the ",(0,r.jsx)(s.code,{children:"Exit"}),":"]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:'import zio.Exit\nimport zio.test._\n\ntest("TestLens#die") {\n  val sut: Exit[Error, Int] = Exit.die(new RuntimeException("Boom!"))\n  assertTrue(sut.is(_.die).getMessage == "Boom!")\n}\n'})}),"\n",(0,r.jsxs)(s.ol,{start:"4",children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.code,{children:"TestLens#cause"})})," - This operator transforms the ",(0,r.jsx)(s.code,{children:"Exit"})," value to its underlying ",(0,r.jsx)(s.code,{children:"Cause"})," value if it has one otherwise it will fail. So this can be used for asserting the cause of the ",(0,r.jsx)(s.code,{children:"Exit"}),":"]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:'import zio.{ZIO, Cause}\nimport zio.test._\n\ntest("TestLens#cause") {\n  for {\n    exit <- ZIO.failCause(Cause.fail("Boom!")).exit\n  } yield assertTrue(exit.is(_.cause) == Cause.fail("Boom!"))\n}\n// error: Error is already defined as case class Error\n'})}),"\n",(0,r.jsxs)(s.ol,{start:"5",children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.code,{children:"TestLens#interrupt"})})," - This operator transforms the ",(0,r.jsx)(s.code,{children:"Exit"})," value to its interrupt value if it is a ",(0,r.jsx)(s.code,{children:"Exit.Interrupt"}),", otherwise it will fail. So this can be used for asserting the interrupt value of the ",(0,r.jsx)(s.code,{children:"Exit"}),":"]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:'import zio.{durationInt, ZIO}\nimport zio.test._\n\ntest("TestLens#interrupt") {\n  for {\n    exit <- ZIO.sleep(5.seconds).fork.flatMap(_.interrupt)\n  } yield assertTrue(exit.is(_.interrupted))\n}\n'})}),"\n",(0,r.jsx)(s.h2,{id:"deeply-nested-values",children:"Deeply Nested Values"}),"\n",(0,r.jsx)(s.p,{children:"Sometimes we need to test values with more than one level of nesting. There is no difference in the way we test nested values:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:'import zio.test._\n\ntest("assertion of multiple nested values (TestLens#right.some)") {\n  val sut: Either[Error, Option[Int]] = Right(Some(40 + 2))\n  assertTrue(sut.is(_.right.some) == 42)\n}\n'})}),"\n",(0,r.jsx)(s.h2,{id:"custom-assertions",children:"Custom Assertions"}),"\n",(0,r.jsxs)(s.p,{children:["Using ",(0,r.jsx)(s.code,{children:"CustomAssertion"})," we can create our own custom assertions for use in ",(0,r.jsx)(s.code,{children:"assertTrue"}),". We can define custom assertions using the ",(0,r.jsx)(s.code,{children:"CustomAssertion.make"})," method. This method takes a partial function from the type ",(0,r.jsx)(s.code,{children:"A"})," to ",(0,r.jsx)(s.code,{children:"Either[String, B]"}),". If the partial function is defined for the given value, it returns ",(0,r.jsx)(s.code,{children:"Right[B]"}),", otherwise it returns ",(0,r.jsx)(s.code,{children:"Left[String]"}),"."]}),"\n",(0,r.jsx)(s.p,{children:"Here is an example of a custom assertion for a sealed trait and case classes:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:'import zio.test._\n\n// Define the sealed trait and case classes\nsealed trait Book\ncase class Novel(pageCount: Int) extends Book\ncase class Comic(illustrations: Int) extends Book\ncase class Textbook(subject: String) extends Book\n\n// Custom assertion for Book\nval subject =\n  CustomAssertion.make[Book] {\n    case Textbook(subject) => Right(subject)\n    case other => Left(s"Expected $$other to be Textbook")\n  }\n\n// Usage\nsuite("custom assertions")(\n  test("subject assertion") {\n    val book: Option[Book] = Some(Textbook("Mathematics"))\n    assertTrue(book.is(_.some.custom(subject)) == "Mathematics")\n  }\n)\n'})}),"\n",(0,r.jsxs)(s.p,{children:["In the above example, we define a custom assertion for the ",(0,r.jsx)(s.code,{children:"Book"})," sealed trait. The custom assertion ",(0,r.jsx)(s.code,{children:"subject"})," is defined to extract the ",(0,r.jsx)(s.code,{children:"subject"})," from the ",(0,r.jsx)(s.code,{children:"Textbook"})," case class. So then we can assert the ",(0,r.jsx)(s.code,{children:"subject"})," of the ",(0,r.jsx)(s.code,{children:"Textbook"})," case class."]}),"\n",(0,r.jsx)(s.h2,{id:"more-examples",children:"More Examples"}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.code,{children:"assertTrue"})," macro is designed to make it easy to write assertions in a more readable way. Most test cases can be written as when we're comparing ordinary values in Scala. However, we have a ",(0,r.jsx)(s.a,{href:"https://github.com/zio/zio/blob/series/2.x/test-tests/shared/src/test/scala/zio/test/SmartAssertionSpec.scala",children:(0,r.jsx)(s.code,{children:"SmartAssertionSpec"})})," which is a collection of examples to demonstrate the power of the ",(0,r.jsx)(s.code,{children:"assertTrue"})," macro."]})]})}function h(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,s,t)=>{t.d(s,{R:()=>a,x:()=>l});var n=t(96540);const r={},i=n.createContext(r);function a(e){const s=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),n.createElement(i.Provider,{value:s},e.children)}}}]);