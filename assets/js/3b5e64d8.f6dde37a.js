"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[60200],{59945:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"zio-aws/migration-guide","title":"Migration guide","description":"There are some major changes compared to the ZIO 1 version (v3.x.x.x and v4.x.x.x). This section contains detailed information about what changed and how to modify existing code.","source":"@site/docs/zio-aws/migration_guide.md","sourceDirName":"zio-aws","slug":"/zio-aws/migration-guide","permalink":"/zio-aws/migration-guide","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-aws/migration_guide.md","tags":[],"version":"current","frontMatter":{"id":"migration-guide","title":"Migration guide"},"sidebar":"ecosystem-sidebar","previous":{"title":"Changelog","permalink":"/zio-aws/changelog"},"next":{"title":"ZIO Actors","permalink":"/zio-actors/"}}');var a=i(74848),r=i(28453);const t={id:"migration-guide",title:"Migration guide"},o="Migration from v3.x.x.x",c={},l=[{value:"New package names",id:"new-package-names",level:2},{value:"New getter names",id:"new-getter-names",level:2},{value:"New service pattern",id:"new-service-pattern",level:2},{value:"Optional parameters",id:"optional-parameters",level:2},{value:"Newtypes",id:"newtypes",level:2},{value:"Aspects",id:"aspects",level:2},{value:"New built-in aspects",id:"new-built-in-aspects",level:3},{value:"Changes in defining aspects",id:"changes-in-defining-aspects",level:3},{value:"New config library",id:"new-config-library",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"migration-from-v3xxx",children:"Migration from v3.x.x.x"})}),"\n",(0,a.jsx)(n.p,{children:"There are some major changes compared to the ZIO 1 version (v3.x.x.x and v4.x.x.x). This section contains detailed information about what changed and how to modify existing code."}),"\n",(0,a.jsx)(n.h2,{id:"new-package-names",children:"New package names"}),"\n",(0,a.jsxs)(n.p,{children:["Previously the zio-aws packages had the root package ",(0,a.jsx)(n.code,{children:"io.github.vigoo.zioaws"}),". By moving to the ZIO organisation this changed to be simply ",(0,a.jsx)(n.code,{children:"zio.aws"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"So imports for something using the EC2 and ElasticBeanstalk APIs would change from:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"import io.github.vigoo.zioaws.core._\nimport io.github.vigoo.zioaws.ec2.Ec2\nimport io.github.vigoo.zioaws.ec2.model._\nimport io.github.vigoo.zioaws.elasticbeanstalk.ElasticBeanstalk\nimport io.github.vigoo.zioaws.elasticbeanstalk.model._\n"})}),"\n",(0,a.jsx)(n.p,{children:"to"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"import zio.aws.core._\nimport zio.aws.ec2.Ec2\nimport zio.aws.ec2.model._\nimport zio.aws.ec2.model.primitives._\nimport zio.aws.elasticbeanstalk.ElasticBeanstalk\nimport zio.aws.elasticbeanstalk.model._\nimport zio.aws.elasticbeanstalk.model.primitives._\n"})}),"\n",(0,a.jsx)(n.p,{children:"Some other changes to the imports may be necessary because of switching to the new service pattern of ZIO, described below."}),"\n",(0,a.jsx)(n.h2,{id:"new-getter-names",children:"New getter names"}),"\n",(0,a.jsx)(n.p,{children:"In previous version of zio-aws the generated models provided to ways to access fields:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["a ZIO effect that failed if the value is ",(0,a.jsx)(n.code,{children:"None"})," with the name of the field (for example ",(0,a.jsx)(n.code,{children:".instanceId"}),")"]}),"\n",(0,a.jsxs)(n.li,{children:["a simple value accessor returning an ",(0,a.jsx)(n.code,{children:"Option"})," value with the ",(0,a.jsx)(n.code,{children:"Value"})," suffix (for example ",(0,a.jsx)(n.code,{children:".instanceIdValue"}),")"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["This has been changed to match the convention used in ",(0,a.jsx)(n.code,{children:"zio-k8s"})," to the following:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["the ZIO effect for requiring that a field has value now has the ",(0,a.jsx)(n.code,{children:"get"})," prefix (for example ",(0,a.jsx)(n.code,{children:".getInstanceId"}),")"]}),"\n",(0,a.jsxs)(n.li,{children:["the value with the field name is the simple accessor returning the optional value: (for example ",(0,a.jsx)(n.code,{children:".instanceId"}),")"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"So for example the following code that prints information about EC2 instances:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'for {\n    id <- instance.instanceId\n    typ <- instance.instanceType\n    launchTime <- instance.launchTime\n    _ <- console.putStrLn(s"  instance $id:").ignore\n    _ <- console.putStrLn(s"    type: $typ").ignore\n    _ <- console.putStrLn(s"    launched at: $launchTime").ignore\n} yield ()\n'})}),"\n",(0,a.jsx)(n.p,{children:"would have to be changed to:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'for {\n    id <- instance.getInstanceId\n    typ <- instance.getInstanceType\n    launchTime <- instance.getLaunchTime\n    _ <- Console.printLine(s"  instance $id:").ignore\n    _ <- Console.printLine(s"    type: $typ").ignore\n    _ <- Console.printLine(s"    launched at: $launchTime").ignore\n} yield ()\n'})}),"\n",(0,a.jsx)(n.h2,{id:"new-service-pattern",children:"New service pattern"}),"\n",(0,a.jsxs)(n.p,{children:["Previous versions were following the ",(0,a.jsx)(n.em,{children:"ZIO module pattern 1.0"}),", so all the generated AWS services consisted of a type alias using ",(0,a.jsx)(n.code,{children:"Has"}),", a trait called ",(0,a.jsx)(n.code,{children:"Service"})," and a package object with the service's name. With ZIO 2 we no longer have ",(0,a.jsx)(n.code,{children:"Has"})," and the recommended way to structure services was changed to the simple new service pattern, where each service is just a ",(0,a.jsx)(n.code,{children:"trait"})," and one or more implementation classes, constructed by layers."]}),"\n",(0,a.jsx)(n.p,{children:"In practice this means that:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["instead of the package object with lower-case name, the accessor functions are now in the service companion object (",(0,a.jsx)(n.code,{children:"ElasticBeanstalk.describeApplications"})," instead of ",(0,a.jsx)(n.code,{children:"elasticbeanstalk.describeApplications"}),")"]}),"\n",(0,a.jsxs)(n.li,{children:["same for the layers, for example ",(0,a.jsx)(n.code,{children:"Ec2.live"})," instead of ",(0,a.jsx)(n.code,{children:"ec2.live"})]}),"\n",(0,a.jsxs)(n.li,{children:["the service trait has the name of the service (for example ",(0,a.jsx)(n.code,{children:"Ec2"}),") instead of ",(0,a.jsx)(n.code,{children:"Service"})]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["The new service pattern is also applied to the core services like ",(0,a.jsx)(n.code,{children:"AwsConfig"})," and the http implementations."]}),"\n",(0,a.jsx)(n.h2,{id:"optional-parameters",children:"Optional parameters"}),"\n",(0,a.jsxs)(n.p,{children:["A very large part of the fields of AWS models are optional. These previously had the type ",(0,a.jsx)(n.code,{children:"Option"}),", and although for extracting data from them the library already had the generated getters, constructing these data types still required wrapping most of the parameters in ",(0,a.jsx)(n.code,{children:"Some(...)"}),". To reduce this boilerplate zio-aws now uses the ",(0,a.jsx)(n.code,{children:"Optional"})," type instead of ",(0,a.jsx)(n.code,{children:"Option"}),", which was first used in ",(0,a.jsx)(n.a,{href:"https://coralogix.github.io/zio-k8s/docs/overview/overview_resources#model",children:"zio-k8s"}),". Now the two libraries share the same type which was moved to ",(0,a.jsx)(n.a,{href:"https://zio.github.io/zio-prelude/",children:"zio-prelude"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"The following example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"kinesis.describeStreamConsumer(\n  DescribeStreamConsumerRequest(\n    consumerName = Some(consumerName),\n    streamARN = Some(streamDescription.streamDescriptionValue.streamARNValue)\n  )\n)\n"})}),"\n",(0,a.jsx)(n.p,{children:"becomes"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"Kinesis.describeStreamConsumer(\n  DescribeStreamConsumerRequest(\n    consumerName = consumerName,\n    streamARN = streamDescription.streamDescription.streamARN\n  )\n)\n"})}),"\n",(0,a.jsx)(n.h2,{id:"newtypes",children:"Newtypes"}),"\n",(0,a.jsxs)(n.p,{children:["Previously zio-aws generated simple Scala type aliases for primitive types in the AWS SDKs. For example the ",(0,a.jsx)(n.code,{children:"TableName"})," type in ",(0,a.jsx)(n.code,{children:"zio-aws-dynamodb"})," was just a type alias for ",(0,a.jsx)(n.code,{children:"String"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"package io.github.vigoo.zioaws.dynamodb.model\n\npackage object primitives {\n  type TableName = String\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The new version uses ",(0,a.jsx)(n.a,{href:"https://zio.github.io/zio-prelude/docs/newtypes/",children:"zio-prelude's newtype wrappers"})," to provide better type safety:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"package zio.aws.dynamodb.model\n\npackage object primitives {\n  object TableName extends Subtype[String]\n  type TableName = TableName.Type\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"In practice this means that we have to explicitly wrap these primitive values, for example instead of:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'elasticbeanstalk.describeApplications(\n  DescribeApplicationsRequest(applicationNames = Some(List("my-service")))\n)\n'})}),"\n",(0,a.jsx)(n.p,{children:"now we have to write"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'ElasticBeanstalk.describeApplications(\n  DescribeApplicationsRequest(applicationNames = List(ApplicationName("my-service")))\n)\n'})}),"\n",(0,a.jsxs)(n.p,{children:["and if we need to convert them to the underlying primitive type we need to call ",(0,a.jsx)(n.code,{children:"unwrap"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"ResourceId.unwrap(id)\n"})}),"\n",(0,a.jsx)(n.h2,{id:"aspects",children:"Aspects"}),"\n",(0,a.jsxs)(n.p,{children:["zio-aws introduced ",(0,a.jsx)(n.code,{children:"AwsCallAspect"})," soon after Adam Fraser's ",(0,a.jsx)(n.a,{href:"https://www.youtube.com/watch?v=gcqWdNwNEPg&t=2s",children:"talk"})," but it was a custom implementation, defined as:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"trait AwsCallAspect[-R] { self =>\n  def apply[R1 <: R, A](\n    f: ZIO[R1, AwsError, Described[A]]\n  ): ZIO[R1, AwsError, Described[A]]\n\n  // ...\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"These aspects can be applied to whole zio-aws service layers to add logging, metrics, retries etc for every AWS Java SDK call."}),"\n",(0,a.jsx)(n.p,{children:"The ZIO 2.0.0 version is now using ZIO's built-in aspect support as a base:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"type AwsCallAspect[-R] =\n  ZIOAspect[Nothing, R, AwsError, AwsError, Nothing, Described[_]]\n"})}),"\n",(0,a.jsx)(n.h3,{id:"new-built-in-aspects",children:"New built-in aspects"}),"\n",(0,a.jsx)(n.p,{children:"With ZIO 2 we have logging and metrics support built-in, so zio-aws now provides ready to use aspects for logging and monitoring AWS calls:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"val callLogging: AwsCallAspect[Any]\ndef callDuration(prefix: String, boundaries: MetricKeyType.Histogram.Boundaries): AwsCallAspect[Any]\n"})}),"\n",(0,a.jsx)(n.h3,{id:"changes-in-defining-aspects",children:"Changes in defining aspects"}),"\n",(0,a.jsxs)(n.p,{children:["The following example aspect uses ",(0,a.jsx)(n.code,{children:"rezilience"})," to add circuit breaking for an AWS service:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"def circuitBreaking(cb: CircuitBreaker[AwsError]): AwsCallAspect[Any] =\n  new AwsCallAspect[Any] {\n    override final def apply[R1 <: Any, A](\n      f: ZIO[R1, AwsError, Described[A]]\n    ): ZIO[R1, AwsError, Described[A]] =\n      cb(f).mapError(policyError =>\n        AwsError.fromThrowable(policyError.toException)\n      )\n  }\n"})}),"\n",(0,a.jsxs)(n.p,{children:["because of the changed base type for ",(0,a.jsx)(n.code,{children:"AwsCallAspect"})," with the new version the same aspect is defined like this:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"def circuitBreaking(cb: CircuitBreaker[AwsError]): AwsCallAspect[Any] =\n  new AwsCallAspect[Any] {\n    override final def apply[R, E >: AwsError <: AwsError, A <: Described[_]](\n      f: ZIO[R, E, A]\n    )(implicit trace: Trace): ZIO[R, E, A] =\n      cb(f).mapError(policyError =>\n        AwsError.fromThrowable(policyError.toException)\n      )\n  }\n"})}),"\n",(0,a.jsx)(n.p,{children:"The main differences:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["requiring the implicit ",(0,a.jsx)(n.code,{children:"Trace"})]}),"\n",(0,a.jsx)(n.li,{children:"the constraints on the error and result types are now expressed as type bounds because the ZIO aspect is more generic"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"new-config-library",children:"New config library"}),"\n",(0,a.jsxs)(n.p,{children:["The 3.x series of zio-aws was using ",(0,a.jsx)(n.code,{children:"zio-config 1.x"}),". The recently released 4.x series was using ",(0,a.jsx)(n.code,{children:"zio-config 2.x"})," which is the ZIO 1 version of the config library's new API; The ZIO 2 version of zio-aws uses ",(0,a.jsx)(n.code,{children:"zio-config 3.x"})," which is the same new config API but for ZIO 2."]}),"\n",(0,a.jsxs)(n.p,{children:["This means that coming from zio-aws 3.x requires upgrading to the new config API. For more information about the changes in zio-config, ",(0,a.jsx)(n.a,{href:"https://github.com/zio/zio-config/releases/tag/v2.0.0-RC1",children:"see it's release notes"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>o});var s=i(96540);const a={},r=s.createContext(a);function t(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);