"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[90838],{62286:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>t,contentTitle:()=>r,default:()=>u,frontMatter:()=>c,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"zio-json/encoding","title":"Encoding","description":"Automatic Derivation","source":"@site/docs/zio-json/encoding.md","sourceDirName":"zio-json","slug":"/zio-json/encoding","permalink":"/zio-json/encoding","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-json/encoding.md","tags":[],"version":"current","frontMatter":{"id":"encoding","title":"Encoding"},"sidebar":"ecosystem-sidebar","previous":{"title":"Decoding","permalink":"/zio-json/decoding"},"next":{"title":"Configuration","permalink":"/zio-json/configuration"}}');var o=a(74848),i=a(28453);const c={id:"encoding",title:"Encoding"},r=void 0,t={},l=[{value:"Automatic Derivation",id:"automatic-derivation",level:2},{value:"ADTs",id:"adts",level:3},{value:"Sealed families and enums for Scala 3",id:"sealed-families-and-enums-for-scala-3",level:3},{value:"Manual instances",id:"manual-instances",level:2},{value:"<code>.contramap</code>",id:"contramap",level:3}];function d(e){const n={code:"code",em:"em",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"automatic-derivation",children:"Automatic Derivation"}),"\n",(0,o.jsx)(n.p,{children:"Assume we want to encode this case class"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"case class Banana(curvature: Double)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["To produce JSON from our data we define a ",(0,o.jsx)(n.code,{children:"JsonEncoder"})," like this:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio.json._\n\nobject Banana {\n  implicit val encoder: JsonEncoder[Banana] =\n    DeriveJsonEncoder.gen[Banana]\n}\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'Banana(0.5).toJson\n// res0: String = "{\\"curvature\\":0.5}"\n'})}),"\n",(0,o.jsx)(n.h3,{id:"adts",children:"ADTs"}),"\n",(0,o.jsx)(n.p,{children:"Say we extend our data model to include more data types"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"sealed trait Fruit\n\ncase class Banana(curvature: Double) extends Fruit\ncase class Apple (poison: Boolean)   extends Fruit\n"})}),"\n",(0,o.jsxs)(n.p,{children:["we can generate the encoder for the entire ",(0,o.jsx)(n.code,{children:"sealed"})," family"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio.json._\n\nobject Fruit {\n  implicit val encoder: JsonEncoder[Fruit] =\n    DeriveJsonEncoder.gen[Fruit]\n}\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'val apple: Fruit = Apple(poison = false)\n// apple: Fruit = Apple(poison = false)\napple.toJson\n// res2: String = "{\\"Apple\\":{\\"poison\\":false}}"\n'})}),"\n",(0,o.jsx)(n.p,{children:"Almost all of the standard library data types are supported as fields on the case class, and it is easy to add support if one is missing."}),"\n",(0,o.jsx)(n.h3,{id:"sealed-families-and-enums-for-scala-3",children:"Sealed families and enums for Scala 3"}),"\n",(0,o.jsx)(n.p,{children:"Sealed families where all members are only objects, or a Scala 3 enum with all cases parameterless are interpreted as enumerations and will encode 1:1 with their value-names."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"enum Foo derives JsonEncoder:\n  case Bar\n  case Baz\n  case Qux\n"})}),"\n",(0,o.jsx)(n.p,{children:"or"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"sealed trait Foo derives JsonEncoder\nobject Foo:\n  case object Bar extends Foo\n  case object Baz extends Foo\n  case object Qux extends Foo\n"})}),"\n",(0,o.jsx)(n.h2,{id:"manual-instances",children:"Manual instances"}),"\n",(0,o.jsxs)(n.p,{children:["Sometimes it is easier to reuse an existing ",(0,o.jsx)(n.code,{children:"JsonEncoder"})," rather than generate a new one. This can be accomplished using convenience methods on the ",(0,o.jsx)(n.code,{children:"JsonEncoder"})," typeclass to ",(0,o.jsx)(n.em,{children:"derive"})," new decoders:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"trait JsonEncoder[A] {\n  def contramap[B](f: B => A): JsonEncoder[B]\n  ...\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"contramap",children:(0,o.jsx)(n.code,{children:".contramap"})}),"\n",(0,o.jsxs)(n.p,{children:["We can use ",(0,o.jsx)(n.code,{children:"contramap"})," from an already existing encoder:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import zio.json._\n\ncase class FruitCount(value: Int)\n\nobject FruitCount {\n  implicit val encoder: JsonEncoder[FruitCount] =\n    JsonEncoder[Int].contramap(_.value)\n}\n\nFruitCount(3).toJson\n// res3: String = "3"\n'})})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,n,a)=>{a.d(n,{R:()=>c,x:()=>r});var s=a(96540);const o={},i=s.createContext(o);function c(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:c(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);