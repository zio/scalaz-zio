"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[40167],{28453:(e,n,c)=>{c.d(n,{R:()=>r,x:()=>d});var s=c(96540);const l={},i=s.createContext(l);function r(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:r(e.components),s.createElement(i.Provider,{value:n},e.children)}},37596:(e,n,c)=>{c.r(n),c.d(n,{assets:()=>t,contentTitle:()=>d,default:()=>o,frontMatter:()=>r,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"reference/schedule/built-in-schedules","title":"Built-in Schedules","description":"succeed","source":"@site/docs/reference/schedule/built-in-schedules.md","sourceDirName":"reference/schedule","slug":"/reference/schedule/built-in-schedules","permalink":"/reference/schedule/built-in-schedules","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/schedule/built-in-schedules.md","tags":[],"version":"current","frontMatter":{"id":"built-in-schedules","title":"Built-in Schedules"},"sidebar":"reference-sidebar","previous":{"title":"Retrying","permalink":"/reference/schedule/retrying"},"next":{"title":"Schedule Combinators","permalink":"/reference/schedule/combinators"}}');var l=c(74848),i=c(28453);const r={id:"built-in-schedules",title:"Built-in Schedules"},d=void 0,t={},a=[{value:"succeed",id:"succeed",level:2},{value:"fromFunction",id:"fromfunction",level:2},{value:"stop",id:"stop",level:2},{value:"once",id:"once",level:2},{value:"forever",id:"forever",level:2},{value:"recurs",id:"recurs",level:2},{value:"spaced",id:"spaced",level:2},{value:"fixed",id:"fixed",level:2},{value:"exponential",id:"exponential",level:2},{value:"fibonacci",id:"fibonacci",level:2},{value:"identity",id:"identity",level:2},{value:"unfold",id:"unfold",level:2}];function u(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.h2,{id:"succeed",children:"succeed"}),"\n",(0,l.jsx)(n.p,{children:"Returns a schedule that repeats one time, producing the specified constant value:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"val constant = Schedule.succeed(5)\n"})}),"\n",(0,l.jsx)(n.h2,{id:"fromfunction",children:"fromFunction"}),"\n",(0,l.jsx)(n.p,{children:"A schedule that always recurs, mapping input values through the specified function:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"val inc = Schedule.fromFunction[Int, Int](_ + 1)\n"})}),"\n",(0,l.jsx)(n.h2,{id:"stop",children:"stop"}),"\n",(0,l.jsxs)(n.p,{children:["A schedule that does not recur, just stops and returns one ",(0,l.jsx)(n.code,{children:"Unit"})," element:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"val stop = Schedule.stop\n"})}),"\n",(0,l.jsx)(n.h2,{id:"once",children:"once"}),"\n",(0,l.jsxs)(n.p,{children:["A schedule that recurs one time an returns one ",(0,l.jsx)(n.code,{children:"Unit"})," element:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"val once = Schedule.once\n"})}),"\n",(0,l.jsx)(n.h2,{id:"forever",children:"forever"}),"\n",(0,l.jsx)(n.p,{children:"A schedule that always recurs and produces number of recurrence at each run:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"val forever = Schedule.forever\n"})}),"\n",(0,l.jsx)(n.h2,{id:"recurs",children:"recurs"}),"\n",(0,l.jsx)(n.p,{children:"A schedule that only recurs the specified number of times:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"val recurs = Schedule.recurs(5)\n"})}),"\n",(0,l.jsx)(n.h2,{id:"spaced",children:"spaced"}),"\n",(0,l.jsx)(n.p,{children:"A schedule that recurs continuously, each repetition spaced the specified duration from the last run:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"val spaced = Schedule.spaced(10.milliseconds)\n"})}),"\n",(0,l.jsx)(n.h2,{id:"fixed",children:"fixed"}),"\n",(0,l.jsx)(n.p,{children:"A schedule that recurs on a fixed interval. Returns the number of repetitions of the schedule so far:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"val fixed = Schedule.fixed(10.seconds)\n"})}),"\n",(0,l.jsx)(n.h2,{id:"exponential",children:"exponential"}),"\n",(0,l.jsx)(n.p,{children:"A schedule that recurs using exponential backoff:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"val exponential = Schedule.exponential(10.milliseconds)\n"})}),"\n",(0,l.jsx)(n.h2,{id:"fibonacci",children:"fibonacci"}),"\n",(0,l.jsx)(n.p,{children:"A schedule that always recurs, increasing delays by summing the preceding two delays (similar to the fibonacci sequence). Returns the current duration between recurrences:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"val fibonacci = Schedule.fibonacci(10.milliseconds)\n"})}),"\n",(0,l.jsx)(n.h2,{id:"identity",children:"identity"}),"\n",(0,l.jsxs)(n.p,{children:["A schedule that always decides to continue. It recurs forever, without any delay. ",(0,l.jsx)(n.code,{children:"identity"})," schedule consumes input, and emit the same as output (",(0,l.jsx)(n.code,{children:"Schedule[Any, A, A]"}),"):"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"val identity = Schedule.identity[Int]\n"})}),"\n",(0,l.jsx)(n.h2,{id:"unfold",children:"unfold"}),"\n",(0,l.jsx)(n.p,{children:"A schedule that repeats one time from the specified state and iterator:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-scala",children:"val unfold = Schedule.unfold(0)(_ + 1)\n"})})]})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(u,{...e})}):u(e)}}}]);