"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[49590],{21552:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>c,default:()=>l,frontMatter:()=>o,metadata:()=>a,toc:()=>i});const a=JSON.parse('{"id":"zio-http/reference/routing/path_codec","title":"PathCodec","description":"PathCodec[A] represents a codec for paths of type A, comprising segments where each segment can be a literal, an integer, a long, a string, a UUID, or the trailing path.","source":"@site/docs/zio-http/reference/routing/path_codec.md","sourceDirName":"zio-http/reference/routing","slug":"/zio-http/reference/routing/path_codec","permalink":"/zio-http/reference/routing/path_codec","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-http/reference/routing/path_codec.md","tags":[],"version":"current","frontMatter":{"id":"path_codec","title":"PathCodec"},"sidebar":"ecosystem-sidebar","previous":{"title":"RoutePattern","permalink":"/zio-http/reference/routing/route_pattern"},"next":{"title":"Request Handler","permalink":"/zio-http/reference/handler"}}');var s=n(74848),r=n(28453);const o={id:"path_codec",title:"PathCodec"},c=void 0,d={},i=[{value:"Building PathCodecs",id:"building-pathcodecs",level:2},{value:"Decoding and Formatting PathCodecs",id:"decoding-and-formatting-pathcodecs",level:2},{value:"Rendering PathCodecs",id:"rendering-pathcodecs",level:2},{value:"Attaching Documentation to PathCodecs",id:"attaching-documentation-to-pathcodecs",level:2},{value:"Attaching Examples to PathCodecs",id:"attaching-examples-to-pathcodecs",level:2},{value:"Using Value Objects with PathCodecs",id:"using-value-objects-with-pathcodecs",level:2},{value:"Trailing Path Segments",id:"trailing-path-segments",level:2}];function h(e){const t={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"PathCodec[A]"})," represents a codec for paths of type ",(0,s.jsx)(t.code,{children:"A"}),", comprising segments where each segment can be a literal, an integer, a long, a string, a UUID, or the trailing path."]}),"\n",(0,s.jsxs)(t.p,{children:["The three basic operations that ",(0,s.jsx)(t.code,{children:"PathCodec"})," supports are:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"decode"}),": converting a path into a value of type ",(0,s.jsx)(t.code,{children:"A"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"format"}),": converting a value of type ",(0,s.jsx)(t.code,{children:"A"})," into a path."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"++ or /"}),": combining two ",(0,s.jsx)(t.code,{children:"PathCodec"})," values to create a new ",(0,s.jsx)(t.code,{children:"PathCodec"})," that matches both paths, so the resulting of the decoding operation will be a tuple of the two values."]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["So we can think of ",(0,s.jsx)(t.code,{children:"PathCodec"})," as the following simplified trait:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:"trait PathCodec[A] {\n  def /[B](that: PathCodec[B]): PathCodec[(A, B)]\n\n  def decode(path: Path): Either[String, A]\n  def format(value: A): : Either[String, Path]\n}\n"})}),"\n",(0,s.jsx)(t.h2,{id:"building-pathcodecs",children:"Building PathCodecs"}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"PathCodec"})," data type offers several predefined codecs for common types:"]}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"PathCodec"}),(0,s.jsx)(t.th,{children:"Description"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"PathCodec.bool"})}),(0,s.jsx)(t.td,{children:"A codec for a boolean path segment."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"PathCodec.empty"})}),(0,s.jsx)(t.td,{children:"A codec for an empty path."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"PathCodec.literal"})}),(0,s.jsx)(t.td,{children:"A codec for a literal path segment."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"PathCodec.long"})}),(0,s.jsx)(t.td,{children:"A codec for a long path segment."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"PathCodec.string"})}),(0,s.jsx)(t.td,{children:"A codec for a string path segment."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"PathCodec.uuid"})}),(0,s.jsx)(t.td,{children:"A codec for a UUID path segment."})]})]})]}),"\n",(0,s.jsxs)(t.p,{children:["Complex ",(0,s.jsx)(t.code,{children:"PathCodecs"})," can be constructed by combining them using the ",(0,s.jsx)(t.code,{children:"/"})," operator:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:'import zio.http.codec.PathCodec\nimport PathCodec._\n\nval pathCodec = empty / "users" / int("user-id") / "posts" / string("post-id")\n'})}),"\n",(0,s.jsxs)(t.p,{children:["By combining ",(0,s.jsx)(t.code,{children:"PathCodec"})," values, the resulting ",(0,s.jsx)(t.code,{children:"PathCodec"})," type reflects the types of the path segments it matches. In the provided example, the type of ",(0,s.jsx)(t.code,{children:"pathCodec"})," is ",(0,s.jsx)(t.code,{children:"(Int, String)"})," because it matches a path with two segments of type ",(0,s.jsx)(t.code,{children:"Int"})," and ",(0,s.jsx)(t.code,{children:"String"}),", respectively."]}),"\n",(0,s.jsx)(t.h2,{id:"decoding-and-formatting-pathcodecs",children:"Decoding and Formatting PathCodecs"}),"\n",(0,s.jsxs)(t.p,{children:["To decode a path into a value of type ",(0,s.jsx)(t.code,{children:"A"}),", we can use the ",(0,s.jsx)(t.code,{children:"PathCodec#decode"})," method:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:'import zio.http._\n\npathCodec.decode(Path("users/123/posts/abc"))\n// res0: Either[String, (Int, String)] = Right(value = (123, "abc"))\n'})}),"\n",(0,s.jsxs)(t.p,{children:["To format (encode) a value of type ",(0,s.jsx)(t.code,{children:"A"})," into a path, we can use the ",(0,s.jsx)(t.code,{children:"PathCodec#format"})," method:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:'pathCodec.format((123, "abc"))\n// res1: Either[String, Path] = Right(\n//   value = Path(flags = 1, segments = IndexedSeq("users", "123", "posts", "abc"))\n// )\n'})}),"\n",(0,s.jsx)(t.h2,{id:"rendering-pathcodecs",children:"Rendering PathCodecs"}),"\n",(0,s.jsxs)(t.p,{children:["If we render the previous ",(0,s.jsx)(t.code,{children:"PathCodec"})," to a string using ",(0,s.jsx)(t.code,{children:"PathCodec#render"})," or ",(0,s.jsx)(t.code,{children:"PathCodec#toString"}),", we get the following result:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:'pathCodec.render\n// res2: String = "/users/{user-id}/posts/{post-id}"\n\npathCodec.toString\n// res3: String = "/users/{user-id}/posts/{post-id}"\n'})}),"\n",(0,s.jsx)(t.h2,{id:"attaching-documentation-to-pathcodecs",children:"Attaching Documentation to PathCodecs"}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"PathCodec#??"})," operator, takes a ",(0,s.jsx)(t.code,{children:"Doc"})," and annotate the ",(0,s.jsx)(t.code,{children:"PathCodec"})," with it. It is useful for generating developer-friendly documentation for the API:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:'import zio.http.codec._\n\nval users = PathCodec.literal("users") ?? (Doc.p("Managing users including CRUD operations"))\n// users: PathCodec[Unit] = Annotated(\n//   codec = Segment(segment = Literal(value = "users")),\n//   annotations = IndexedSeq(\n//     Documented(\n//       value = Paragraph(\n//         value = Text(value = "Managing users including CRUD operations")\n//       )\n//     )\n//   )\n// )\n'})}),"\n",(0,s.jsx)(t.p,{children:"When generating OpenAPI documentation, these annotations will be used to generate the API documentation."}),"\n",(0,s.jsx)(t.h2,{id:"attaching-examples-to-pathcodecs",children:"Attaching Examples to PathCodecs"}),"\n",(0,s.jsxs)(t.p,{children:["Similarly to attaching documentation, we can attach examples to ",(0,s.jsx)(t.code,{children:"PathCodec"})," using the ",(0,s.jsx)(t.code,{children:"PathCodec#example"})," operator:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:'import zio.http.codec._\n\nval userId = PathCodec.int("user-id") ?? (Doc.p("The user id")) example ("user-id", 123)\n// userId: PathCodec[Int] = Annotated(\n//   codec = Segment(segment = IntSeg(name = "user-id")),\n//   annotations = IndexedSeq(\n//     Documented(value = Paragraph(value = Text(value = "The user id"))),\n//     Examples(examples = Map("user-id" -> 123))\n//   )\n// )\n'})}),"\n",(0,s.jsx)(t.h2,{id:"using-value-objects-with-pathcodecs",children:"Using Value Objects with PathCodecs"}),"\n",(0,s.jsxs)(t.p,{children:["Other than the common ",(0,s.jsx)(t.code,{children:"PathCodec"})," constructors, it's also possible to transform a ",(0,s.jsx)(t.code,{children:"PathCodec"})," into a more specific data type using the ",(0,s.jsx)(t.code,{children:"transform"})," method."]}),"\n",(0,s.jsx)(t.p,{children:"This becomes particularly useful when adhering to domain-driven design principles and opting for value objects instead of primitive types:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:'import zio.http.codec.PathCodec\nimport PathCodec._\n\ncase class UserId private(value: Int)\n\nobject UserId {\n  def apply(value: Int): UserId =\n    if (value > 0) \n      new UserId(value)\n    else \n      throw new IllegalArgumentException("User id must be positive")\n}\n\n\nval userIdPathCodec: PathCodec[UserId] = int("user-id").transform(UserId.apply)(_.value)\n'})}),"\n",(0,s.jsxs)(t.p,{children:["This approach enables us to utilize the ",(0,s.jsx)(t.code,{children:"UserId"})," value object in our routes, and the ",(0,s.jsx)(t.code,{children:"PathCodec"})," will take care of the conversion between the path segment and the value object."]}),"\n",(0,s.jsxs)(t.p,{children:["In the previous example, instead of throwing an exception, we can model the failure using the ",(0,s.jsx)(t.code,{children:"Either"})," data type and then use the ",(0,s.jsx)(t.code,{children:"transformOrFailLeft"})," to create a ",(0,s.jsx)(t.code,{children:"PathCodec"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:'import zio.http.codec.PathCodec\nimport PathCodec._\n\ncase class UserId private(value: Int)\nobject UserId {\n  def apply(value: Int): Either[String, UserId] =\n    if (value > 0) \n      Right(new UserId(value))\n    else \n      Left("User id must be positive")\n}\n\nval userIdPathCodec: PathCodec[UserId] = int("user-id").transformOrFailLeft(UserId.apply)(_.value)\n'})}),"\n",(0,s.jsx)(t.p,{children:"Here is a list of the available transformation methods:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:"trait PathCodec[A] {\n  def transform[A2](f: A => A2)(g: A2 => A): PathCodec[A2]\n  def transformOrFail[A2](f: A => Either[String, A2])(g: A2 => Either[String, A]): PathCodec[A2]\n  def transformOrFailLeft[A2](f: A => Either[String, A2])(g: A2 => A): PathCodec[A2]\n  def transformOrFailRight[A2](f: A => A2)(g: A2 => Either[String, A]): PathCodec[A2]\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"Here is a complete example:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:'import zio._\nimport zio.http._\nimport zio.Cause.{Die, Stackless}\nimport zio.http.codec.PathCodec\n\nobject Main extends ZIOAppDefault {\n\n  import zio.http.codec.PathCodec\n  import PathCodec._\n\n  case class UserId private (value: Int)\n\n  object UserId {\n    def apply(value: Int): Either[String, UserId] =\n      if (value > 0)\n        Right(new UserId(value))\n      else\n        Left("User id must be greater than zero")\n  }\n\n  val userId: PathCodec[UserId] = int("user-id").transformOrFailLeft(UserId.apply)(_.value)\n\n  val routes: Routes[Any, Response] =\n    Routes(\n      Method.GET / "users" / userId ->\n        Handler.fromFunctionHandler[(UserId, Request)] { case (userId: UserId, request: Request) =>\n          Handler.text(userId.value.toString)\n        },\n    ).handleErrorCause { case Stackless(cause, _) =>\n      cause match {\n        case Die(value, _) =>\n          if (value.getMessage == "User id must be greater than zero")\n            Response.badRequest(value.getMessage)\n          else\n            Response.internalServerError\n      }\n    }\n\n  def run = Server.serve(routes).provide(Server.default)\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"trailing-path-segments",children:"Trailing Path Segments"}),"\n",(0,s.jsx)(t.p,{children:"Sometimes, there may be a need to match a path with a trailing segment, regardless of the number of segments it contains. This is where the trailing codec comes into play:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:'import zio._\nimport zio.http._\n\nobject TrailingExample extends ZIOAppDefault {\n  def staticFileHandler(path: Path): Handler[Any, Throwable, Request, Response] =\n    for {\n      file <- Handler.getResourceAsFile(path.encode)\n      http <-\n        if (file.isFile)\n          Handler.fromFile(file)\n        else\n          Handler.notFound\n    } yield http\n\n  val routes =\n    Routes(\n      Method.GET / "static" / trailing ->\n        Handler.fromFunctionHandler[(Path, Request)] { case (path: Path, _: Request) =>\n          staticFileHandler(path).contramap[(Path, Request)](_._2)\n        },\n      ).sandbox @@ HandlerAspect.requestLogging()\n\n  val run = Server.serve(routes).provide(Server.default)\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["In the provided example, if an incoming request matches the route pattern ",(0,s.jsx)(t.code,{children:"GET /static/*"}),", the ",(0,s.jsx)(t.code,{children:"trailing"})," codec will match the remaining path segments and bind them to the ",(0,s.jsx)(t.code,{children:"Path"})," type. Therefore, a request to ",(0,s.jsx)(t.code,{children:"/static/foo/bar/baz.txt"})," will match the route pattern, and the ",(0,s.jsx)(t.code,{children:"Path"})," will be ",(0,s.jsx)(t.code,{children:"foo/bar/baz.txt"}),"."]})]})}function l(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>c});var a=n(96540);const s={},r=a.createContext(s);function o(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);