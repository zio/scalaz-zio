"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[76530],{68565:(e,n,c)=>{c.r(n),c.d(n,{assets:()=>a,contentTitle:()=>t,default:()=>h,frontMatter:()=>d,metadata:()=>o,toc:()=>s});const o=JSON.parse('{"id":"zio-schema/derivations/codecs/index","title":"Introduction to ZIO Schema Codecs","description":"Once we generate a schema for a type, we can derive a codec for that type.","source":"@site/docs/zio-schema/derivations/codecs/index.md","sourceDirName":"zio-schema/derivations/codecs","slug":"/zio-schema/derivations/codecs/","permalink":"/zio-schema/derivations/codecs/","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-schema/derivations/codecs/index.md","tags":[],"version":"current","frontMatter":{"id":"index","title":"Introduction to ZIO Schema Codecs","sidebar_label":"Codecs"},"sidebar":"ecosystem-sidebar","previous":{"title":"ZIO Test Gen Derivation","permalink":"/zio-schema/derivations/zio-test-gen-derivation"},"next":{"title":"Apache Avro","permalink":"/zio-schema/derivations/codecs/avro"}}');var i=c(74848),r=c(28453);const d={id:"index",title:"Introduction to ZIO Schema Codecs",sidebar_label:"Codecs"},t=void 0,a={},s=[{value:"Codec",id:"codec",level:2},{value:"Binary Codecs",id:"binary-codecs",level:2}];function l(e){const n={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Once we generate a schema for a type, we can derive a codec for that type."}),"\n",(0,i.jsxs)(n.p,{children:["A codec is a utility that can encode/decode a value of some type ",(0,i.jsx)(n.code,{children:"A"})," to/from some format (e.g. binary format, JSON, etc.)"]}),"\n",(0,i.jsx)(n.h2,{id:"codec",children:"Codec"}),"\n",(0,i.jsx)(n.p,{children:"Unlike codecs in other libraries, a codec in ZIO Schema has no type parameter:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"trait Codec {\n  def encoder[A](schema: Schema[A]): ZTransducer[Any, Nothing, A, Byte]\n  def decoder[A](schema: Schema[A]): ZTransducer[Any, String, Byte, A]\n\n  def encode[A](schema: Schema[A]): A => Chunk[Byte]\n  def decode[A](schema: Schema[A]): Chunk[Byte] => Either[String, A]\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Codec"})," trait has two basic methods:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"encode[A]"}),": Given a ",(0,i.jsx)(n.code,{children:"Schema[A]"})," it is capable of generating an ",(0,i.jsx)(n.code,{children:"Encoder[A]"})," ( ",(0,i.jsx)(n.code,{children:"A => Chunk[Byte]"}),") for any Schema."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"decode[A]"}),": Given a ",(0,i.jsx)(n.code,{children:"Schema[A]"})," it is capable of generating a ",(0,i.jsx)(n.code,{children:"Decoder[A]"})," ( ",(0,i.jsx)(n.code,{children:"Chunk[Byte] => Either[String, A]"}),") for any Schema."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"binary-codecs",children:"Binary Codecs"}),"\n",(0,i.jsxs)(n.p,{children:["The binary codecs are codecs that can encode/decode a value of some type ",(0,i.jsx)(n.code,{children:"A"})," to/from binary format (e.g. ",(0,i.jsx)(n.code,{children:"Chunk[Byte]"}),").  In ZIO Schema, by having a ",(0,i.jsx)(n.code,{children:"BinaryCodec[A]"})," instance, other than being able to encode/decode a value of type ",(0,i.jsx)(n.code,{children:"A"})," to/from binary format, we can also encode/decode a stream of values of type ",(0,i.jsx)(n.code,{children:"A"})," to/from a stream of binary format."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"import zio.Chunk\nimport zio.stream.ZPipeline\n\ntrait Decoder[Whole, Element, +A] {\n  def decode(whole: Whole): Either[DecodeError, A]\n  def streamDecoder: ZPipeline[Any, DecodeError, Element, A]\n}\n\ntrait Encoder[Whole, Element, -A] {\n  def encode(value: A): Whole\n  def streamEncoder: ZPipeline[Any, Nothing, A, Element]\n}\n\ntrait Codec[Whole, Element, A] extends Encoder[Whole, Element, A] with Decoder[Whole, Element, A]\n\ntrait BinaryCodec[A] extends Codec[Chunk[Byte], Byte, A]\n"})}),"\n",(0,i.jsxs)(n.p,{children:["To make it simpler, we can think of a ",(0,i.jsx)(n.code,{children:"BinaryCodec[A]"})," as the following trait:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"import zio.Chunk\nimport zio.stream.ZPipeline\n\ntrait BinaryCodec[A] {\n  def encode(value: A): Chunk[Byte]\n  def decode(whole: Chunk[Byte]): Either[DecodeError, A]\n\n  def streamEncoder: ZPipeline[Any, Nothing, A, Byte]\n  def streamDecoder: ZPipeline[Any, DecodeError, Byte, A]\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Example of possible codecs are:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"CSV Codec"}),"\n",(0,i.jsx)(n.li,{children:"JSON Codec (already available)"}),"\n",(0,i.jsx)(n.li,{children:"Apache Avro Codec (in progress)"}),"\n",(0,i.jsx)(n.li,{children:"Apache Thrift Codec (in progress)"}),"\n",(0,i.jsx)(n.li,{children:"XML Codec"}),"\n",(0,i.jsx)(n.li,{children:"YAML Codec"}),"\n",(0,i.jsx)(n.li,{children:"Protobuf Codec (already available)"}),"\n",(0,i.jsx)(n.li,{children:"QueryString Codec"}),"\n",(0,i.jsx)(n.li,{children:"etc."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},28453:(e,n,c)=>{c.d(n,{R:()=>d,x:()=>t});var o=c(96540);const i={},r=o.createContext(i);function d(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);