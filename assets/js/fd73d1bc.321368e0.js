"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[25771],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>s});var i=t(96540);const a={},o=i.createContext(a);function r(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(o.Provider,{value:n},e.children)}},67222:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"zio-prelude/functional-abstractions/parameterized-types/invariant","title":"Invariant","description":"Invariant[F] describes a parameterized type F[A] that potentially both consumes and produces A values.","source":"@site/docs/zio-prelude/functional-abstractions/parameterized-types/invariant.md","sourceDirName":"zio-prelude/functional-abstractions/parameterized-types","slug":"/zio-prelude/functional-abstractions/parameterized-types/invariant","permalink":"/zio-prelude/functional-abstractions/parameterized-types/invariant","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-prelude/functional-abstractions/parameterized-types/invariant.md","tags":[],"version":"current","frontMatter":{"id":"invariant","title":"Invariant"},"sidebar":"ecosystem-sidebar","previous":{"title":"IdentityFlatten","permalink":"/zio-prelude/functional-abstractions/parameterized-types/identityflatten"},"next":{"title":"NonEmptyForEach","permalink":"/zio-prelude/functional-abstractions/parameterized-types/nonemptyforeach"}}');var a=t(74848),o=t(28453);const r={id:"invariant",title:"Invariant"},s=void 0,d={},c=[];function l(e){const n={code:"code",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"Invariant[F]"})," describes a parameterized type ",(0,a.jsx)(n.code,{children:"F[A]"})," that potentially both consumes and produces ",(0,a.jsx)(n.code,{children:"A"})," values."]}),"\n",(0,a.jsx)(n.p,{children:"Its signature is:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"trait Invariant[F[_]] {\n  def invmap[A, B](f: A <=> B): F[A] <=> F[B]\n}\n\ntype <=>[A, B] = Equivalence[A, B]\n\ncase class Equivalence[A, B](to: A => B, from: B => A)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"invmap"}),' operator says we can "lift" an equivalence relationship between ',(0,a.jsx)(n.code,{children:"A"})," and ",(0,a.jsx)(n.code,{children:"B"})," into an equivalence relationship between ",(0,a.jsx)(n.code,{children:"F[A]"})," and ",(0,a.jsx)(n.code,{children:"F[B]"}),". An equivalence relationship says we can transform back and forth between ",(0,a.jsx)(n.code,{children:"A"})," and ",(0,a.jsx)(n.code,{children:"B"})," values without losing any information and is described by the ",(0,a.jsx)(n.code,{children:"Equivalence"})," data type in ZIO Prelude."]}),"\n",(0,a.jsxs)(n.p,{children:["If we import ",(0,a.jsx)(n.code,{children:"zio.prelude._"})," we can use the ",(0,a.jsx)(n.code,{children:"invmap"})," operator in infix form to transform an ",(0,a.jsx)(n.code,{children:"F[A]"})," into an ",(0,a.jsx)(n.code,{children:"F[B]"})," with an equivalence relationship ",(0,a.jsx)(n.code,{children:"A <=> B"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["The law is that the lifting of this equivalence relationship can transform ",(0,a.jsx)(n.code,{children:"A"})," and ",(0,a.jsx)(n.code,{children:"B"})," values but cannot otherwise change the structure of ",(0,a.jsx)(n.code,{children:"F"}),", so using ",(0,a.jsx)(n.code,{children:"invmap"})," with the identity equivalence relationship is an identity and separately using ",(0,a.jsx)(n.code,{children:"invmap"})," with two equivalence relationships is the same as doing it with the composition of those equivalence relationships."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"fa.invmap(Equivalence.identity) === fa\nfa.invmap(f).invmap(g) === fa.invmap(f.andThen(g))\n"})}),"\n",(0,a.jsx)(n.p,{children:"An example of a data type that is invariant is a JSON codec."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"trait JsonCodec[A] {\n  def decode(json: String): Either[String, A]\n  def encode(a: A): String\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Notice that ",(0,a.jsx)(n.code,{children:"A"})," appears in both the output type of the ",(0,a.jsx)(n.code,{children:"decode"})," operator and the input type of the ",(0,a.jsx)(n.code,{children:"encode"})," operator. This makes ",(0,a.jsx)(n.code,{children:"JsonCodec"})," naturally invariant with respect to the ",(0,a.jsx)(n.code,{children:"A"})," type parameter."]}),"\n",(0,a.jsxs)(n.p,{children:["Let's try implementing an ",(0,a.jsx)(n.code,{children:"invmap"})," operator for our ",(0,a.jsx)(n.code,{children:"JsonCodec"})," type."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"import zio.prelude._\n\ntrait JsonCodec[A] { self =>\n\n  def decode(json: String): Either[String, A]\n\n  def encode(a: A): String\n\n  def invmap[B](f: A <=> B): JsonCodec[B] =\n    new JsonCodec[B] {\n      def decode(json: String): Either[String, B] =\n        self.decode(json).map(f.to)\n      def encode(b: B): String =\n        self.encode(f.from(b))\n    }\n}\n\nobject JsonCode {\n  implicit val JsonCodecInvariant: Invariant[JsonCodec] =\n    new Invariant[JsonCodec] {\n      def invmap[A, B](f: A <=> B): JsonCodec[A] <=> JsonCodec[B] =\n        Equivalence(_.invmap(f), _.invmap(f.flip))\n    }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The implementation of ",(0,a.jsx)(n.code,{children:"invmap"})," was quite simple and follows a pattern we can always use when implementing ",(0,a.jsx)(n.code,{children:"invmap"})," for our own data types."]}),"\n",(0,a.jsxs)(n.p,{children:["For every operator that outputs ",(0,a.jsx)(n.code,{children:"A"})," values, we can output ",(0,a.jsx)(n.code,{children:"B"})," values instead by taking the ",(0,a.jsx)(n.code,{children:"A"})," values and transforming them to ",(0,a.jsx)(n.code,{children:"B"})," values with the equivalence relationship. For example, in our implementation of ",(0,a.jsx)(n.code,{children:"decode"})," we decode a string to produce an ",(0,a.jsx)(n.code,{children:"Either[String, A]"})," with the original codec and then map over the ",(0,a.jsx)(n.code,{children:"Either[String, A]"})," with the equivalence relationship to produce an ",(0,a.jsx)(n.code,{children:"Either[String, B]"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Similarly, for every operator that accepts ",(0,a.jsx)(n.code,{children:"A"})," values as an input, we can accept ",(0,a.jsx)(n.code,{children:"B"})," values instead and then simply transform them into ",(0,a.jsx)(n.code,{children:"A"})," values with the equivalence relationship. So in our implementation of ",(0,a.jsx)(n.code,{children:"encode"})," we accept ",(0,a.jsx)(n.code,{children:"B"})," values to be encoded, transform them into ",(0,a.jsx)(n.code,{children:"A"})," values with the equivalence relationship, and then feed them to the ",(0,a.jsx)(n.code,{children:"encode"})," operator of the original codec to get a JSON string."]}),"\n",(0,a.jsxs)(n.p,{children:["The operators may vary and we may need to do slightly different things to transform the inputs or outputs like mapping over the ",(0,a.jsx)(n.code,{children:"Either"})," in the ",(0,a.jsx)(n.code,{children:"JsonCodec"})," example, but this basic pattern applies to implementing the ",(0,a.jsx)(n.code,{children:"invmap"})," operator for all invariant types."]}),"\n",(0,a.jsxs)(n.p,{children:["Other data types that are invariant are the ",(0,a.jsx)(n.code,{children:"Set"})," data type in the Scala standard library and the ",(0,a.jsx)(n.code,{children:"Ref"}),", ",(0,a.jsx)(n.code,{children:"Queue"}),", and ",(0,a.jsx)(n.code,{children:"Hub"})," data types in ",(0,a.jsx)(n.code,{children:"ZIO"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"Invariant"})," data type itself describes very limited structure. It just says that this parameterized type potentially consumes and produces ",(0,a.jsx)(n.code,{children:"A"})," values, which are conceptually the only things it could do with ",(0,a.jsx)(n.code,{children:"A"})," values."]}),"\n",(0,a.jsxs)(n.p,{children:["As a result, the ",(0,a.jsx)(n.code,{children:"invmap"})," operator itself is not very powerful. It only lets us go back and forth between ",(0,a.jsx)(n.code,{children:"F[A]"})," and ",(0,a.jsx)(n.code,{children:"F[B]"})," values when there is an equivalence relationship between ",(0,a.jsx)(n.code,{children:"A"})," and ",(0,a.jsx)(n.code,{children:"B"}),", which basically means that ",(0,a.jsx)(n.code,{children:"A"})," and ",(0,a.jsx)(n.code,{children:"B"})," contain the same information."]}),"\n",(0,a.jsxs)(n.p,{children:["However, ",(0,a.jsx)(n.code,{children:"Invariant"}),' can be useful when we do have an equivalence relationship between two data types to "lift" that equivalence relationship to the level of the parameterized type.']}),"\n",(0,a.jsxs)(n.p,{children:["For example, if we have two different versions of our data model it could be generally useful to define an ",(0,a.jsx)(n.code,{children:"Equivalence"})," between those different versions of our data model so we could translate back and forth between different versions of the data model. With that, we could also use ",(0,a.jsx)(n.code,{children:"Invariant"})," to generate a ",(0,a.jsx)(n.code,{children:"JsonCodec"})," for the new data model given a ",(0,a.jsx)(n.code,{children:"JsonCodec"})," for the old data model, or vice versa."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}}}]);