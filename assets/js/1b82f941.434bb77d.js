"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[98242],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var s=t(96540);const a={},i=s.createContext(a);function r(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(i.Provider,{value:n},e.children)}},67175:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"overview/overview_testing_effects","title":"Testing Effects","description":"There are many approaches to testing functional effects, including using free monads, using tagless-final, and using environmental effects. Although all of these approaches are compatible with ZIO, the simplest and most ergonomic is environmental effects.","source":"@site/versioned_docs/version-1.0.18/overview/testing_effects.md","sourceDirName":"overview","slug":"/overview/overview_testing_effects","permalink":"/1.0.18/overview/overview_testing_effects","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/versioned_docs/version-1.0.18/overview/testing_effects.md","tags":[],"version":"1.0.18","frontMatter":{"id":"overview_testing_effects","title":"Testing Effects"},"sidebar":"overview_sidebar","previous":{"title":"Basic Concurrency","permalink":"/1.0.18/overview/overview_basic_concurrency"},"next":{"title":"Running Effects","permalink":"/1.0.18/overview/overview_running_effects"}}');var a=t(74848),i=t(28453);const r={id:"overview_testing_effects",title:"Testing Effects"},o=void 0,c={},l=[{value:"Environments",id:"environments",level:2},{value:"Providing Environments",id:"providing-environments",level:3},{value:"Environmental Effects",id:"environmental-effects",level:2},{value:"Define the Service",id:"define-the-service",level:3},{value:"Provide Helpers",id:"provide-helpers",level:3},{value:"Use the Service",id:"use-the-service",level:3},{value:"Implement Live Service",id:"implement-live-service",level:3},{value:"Run the Database Effect",id:"run-the-database-effect",level:3},{value:"Implement Test Service",id:"implement-test-service",level:3},{value:"Test Database Code",id:"test-database-code",level:3},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["There are many approaches to testing functional effects, including using free monads, using tagless-final, and using environmental effects. Although all of these approaches are compatible with ZIO, the simplest and most ergonomic is ",(0,a.jsx)(n.em,{children:"environmental effects"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"This section introduces environmental effects and shows you how to write testable functional code using them."}),"\n",(0,a.jsx)(n.h2,{id:"environments",children:"Environments"}),"\n",(0,a.jsxs)(n.p,{children:["The ZIO data type has an ",(0,a.jsx)(n.code,{children:"R"})," type parameter, which is used to describe the type of ",(0,a.jsx)(n.em,{children:"environment"})," required by the effect."]}),"\n",(0,a.jsxs)(n.p,{children:["ZIO effects can access the environment using ",(0,a.jsx)(n.code,{children:"ZIO.environment"}),", which provides direct access to the environment, as a value of type ",(0,a.jsx)(n.code,{children:"R"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'for {\n  env <- ZIO.environment[Int]\n  _   <- putStrLn(s"The value of the environment is: $env")\n} yield env\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The environment does not have to be a primitive value like an integer. It can be much more complex, like a ",(0,a.jsx)(n.code,{children:"trait"})," or ",(0,a.jsx)(n.code,{children:"case class"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["When the environment is a type with fields, then the ",(0,a.jsx)(n.code,{children:"ZIO.access"})," method can be used to access a given part of the environment in a single method call:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'final case class Config(server: String, port: Int)\n\nval configString: URIO[Config, String] = \n  for {\n    server <- ZIO.access[Config](_.server)\n    port   <- ZIO.access[Config](_.port)\n  } yield s"Server: $server, port: $port"\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Even effects themselves can be stored in the environment! In this case, to access and execute an effect, the ",(0,a.jsx)(n.code,{children:"ZIO.accessM"})," method can be used."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'trait DatabaseOps {\n  def getTableNames: Task[List[String]]\n  def getColumnNames(table: String): Task[List[String]]\n}\n\nval tablesAndColumns: ZIO[DatabaseOps, Throwable, (List[String], List[String])] = \n  for {\n    tables  <- ZIO.accessM[DatabaseOps](_.getTableNames)\n    columns <- ZIO.accessM[DatabaseOps](_.getColumnNames("user_table"))\n  } yield (tables, columns)\n'})}),"\n",(0,a.jsxs)(n.p,{children:["When an effect is accessed from the environment, as in the preceding example, the effect is called an ",(0,a.jsx)(n.em,{children:"environmental effect"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"Later, we'll see how environmental effects provide an easy way to test ZIO applications."}),"\n",(0,a.jsx)(n.h3,{id:"providing-environments",children:"Providing Environments"}),"\n",(0,a.jsxs)(n.p,{children:["Effects that require an environment cannot be run without first ",(0,a.jsx)(n.em,{children:"providing"})," their environment to them."]}),"\n",(0,a.jsxs)(n.p,{children:["The simplest way to provide an effect the environment that it requires is to use the ",(0,a.jsx)(n.code,{children:"ZIO#provide"})," method:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"val square: URIO[Int, Int] = \n  for {\n    env <- ZIO.environment[Int]\n  } yield env * env\n\nval result: UIO[Int] = square.provide(42)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Once you provide an effect with the environment it requires, then you get back an effect whose environment type is ",(0,a.jsx)(n.code,{children:"Any"}),", indicating its requirements have been fully satisfied."]}),"\n",(0,a.jsxs)(n.p,{children:["The combination of ",(0,a.jsx)(n.code,{children:"ZIO.accessM"})," and ",(0,a.jsx)(n.code,{children:"ZIO#provide"})," are all that is necessary to fully use environmental effects for easy testability."]}),"\n",(0,a.jsx)(n.h2,{id:"environmental-effects",children:"Environmental Effects"}),"\n",(0,a.jsxs)(n.p,{children:["The fundamental idea behind environmental effects is to ",(0,a.jsx)(n.em,{children:"program to an interface, not an implementation"}),". In the case of functional Scala, interfaces do not contain any methods that perform side-effects, although they may contain methods that return ",(0,a.jsx)(n.em,{children:"functional effects"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Rather than passing interfaces throughout our code base manually, injecting them using dependency injection, or threading them using incoherent implicits, we use ",(0,a.jsx)(n.em,{children:"ZIO Environment"})," to do the heavy lifting, which results in elegant, inferrable, and painless code."]}),"\n",(0,a.jsx)(n.p,{children:"In this section, we'll explore how to use environmental effects by developing a testable database service."}),"\n",(0,a.jsx)(n.h3,{id:"define-the-service",children:"Define the Service"}),"\n",(0,a.jsx)(n.p,{children:"We will define the database service with the help of a module, which is an interface that contains only a single field, which provides access to the service."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"object Database {\n  trait Service {\n    def lookup(id: UserID): Task[UserProfile]\n    def update(id: UserID, profile: UserProfile): Task[Unit]\n  }\n}\ntrait Database {\n  def database: Database.Service\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["In this example,  ",(0,a.jsx)(n.code,{children:"Database"})," is the ",(0,a.jsx)(n.em,{children:"module"}),", which contains the ",(0,a.jsx)(n.code,{children:"Database.Service"})," ",(0,a.jsx)(n.em,{children:"service"}),". The ",(0,a.jsx)(n.em,{children:"service"})," is just an ordinary interface, placed inside the companion object of the module, which contains functions provide the ",(0,a.jsx)(n.em,{children:"capabilities"})," of the service."]}),"\n",(0,a.jsx)(n.h3,{id:"provide-helpers",children:"Provide Helpers"}),"\n",(0,a.jsxs)(n.p,{children:["In order to make it easier to access the database service as an environmental effect, we will define helper functions that use ",(0,a.jsx)(n.code,{children:"ZIO.accessM"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"object db {\n  def lookup(id: UserID): RIO[Database, UserProfile] =\n    ZIO.accessM(_.database.lookup(id))\n\n  def update(id: UserID, profile: UserProfile): RIO[Database, Unit] =\n    ZIO.accessM(_.database.update(id, profile))\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["While these helpers are not required, because we can access the database module directly through ",(0,a.jsx)(n.code,{children:"ZIO.accessM"}),", the helpers are easy to write and make use-site code simpler."]}),"\n",(0,a.jsx)(n.h3,{id:"use-the-service",children:"Use the Service"}),"\n",(0,a.jsx)(n.p,{children:"Now that we have defined a module and helper functions, we are now ready to build an example that uses the database service:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"val lookedupProfile: RIO[Database, UserProfile] = \n  for {\n    profile <- db.lookup(userId)\n  } yield profile\n"})}),"\n",(0,a.jsx)(n.p,{children:"The effect in this example interacts with the database solely through the environment, which in this case, is a module that provides access to the database service."}),"\n",(0,a.jsx)(n.p,{children:"To actually run such an effect, we need to provide an implementation of the database module."}),"\n",(0,a.jsx)(n.h3,{id:"implement-live-service",children:"Implement Live Service"}),"\n",(0,a.jsx)(n.p,{children:"Now we will implement a live database module, which will actually interact with our production database:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"trait DatabaseLive extends Database {\n  def database: Database.Service = \n    new Database.Service {\n      def lookup(id: UserID): Task[UserProfile] = ???\n      def update(id: UserID, profile: UserProfile): Task[Unit] = ???\n    }\n}\nobject DatabaseLive extends DatabaseLive\n"})}),"\n",(0,a.jsx)(n.p,{children:"In the preceding snippet, the implementation of the two database methods is not provided, because that would require details beyond the scope of this tutorial."}),"\n",(0,a.jsx)(n.h3,{id:"run-the-database-effect",children:"Run the Database Effect"}),"\n",(0,a.jsx)(n.p,{children:"We now have a database module, helpers to interact with the database module, and a live implementation of the database module."}),"\n",(0,a.jsxs)(n.p,{children:["We can now provide the live database module to our application, using ",(0,a.jsx)(n.code,{children:"ZIO.provide"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"def main: RIO[Database, Unit] = ???\n\ndef main2: Task[Unit] = \n  main.provide(DatabaseLive)\n"})}),"\n",(0,a.jsx)(n.p,{children:"The resulting effect has no requirements, so it can now be executed with a ZIO runtime."}),"\n",(0,a.jsx)(n.h3,{id:"implement-test-service",children:"Implement Test Service"}),"\n",(0,a.jsx)(n.p,{children:"To test code that interacts with the database, we don't want to interact with a real database, because our tests would be slow and brittle, and fail randomly even when our application logic is correct."}),"\n",(0,a.jsx)(n.p,{children:"Although you can use mocking libraries to create test modules, in this section, we will simply create a test module directly, to show that no magic is involved:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"class TestService extends Database.Service {\n  private var map: Map[UserID, UserProfile] = Map()\n\n  def setTestData(map0: Map[UserID, UserProfile]): Task[Unit] = \n    Task { map = map0 }\n\n  def getTestData: Task[Map[UserID, UserProfile]] = \n    Task(map)\n\n  def lookup(id: UserID): Task[UserProfile] = \n    Task(map(id))\n\n  def update(id: UserID, profile: UserProfile): Task[Unit] = \n    Task.effect { map = map + (id -> profile) }\n}\ntrait TestDatabase extends Database {\n  val database: TestService = new TestService\n}\nobject TestDatabase extends TestDatabase\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Because this module will only be used in tests, it simulates interaction with a database by extracting and updating data in a hard-coded map. To make this module fiber-safe, you could instead use a ",(0,a.jsx)(n.code,{children:"Ref"})," and not a ",(0,a.jsx)(n.code,{children:"var"})," to hold the map."]}),"\n",(0,a.jsx)(n.h3,{id:"test-database-code",children:"Test Database Code"}),"\n",(0,a.jsx)(n.p,{children:"To test code that requires the database, we need only provide it with our test database module:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"def code: RIO[Database, Unit] = ???\n\ndef code2: Task[Unit] = \n  code.provide(TestDatabase)\n"})}),"\n",(0,a.jsx)(n.p,{children:"Our application code can work with either our production database module, or the test database module."}),"\n",(0,a.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,a.jsxs)(n.p,{children:["If you are comfortable with testing effects, then the next step is to learn about ",(0,a.jsx)(n.a,{href:"/1.0.18/overview/overview_running_effects",children:"running effects"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);