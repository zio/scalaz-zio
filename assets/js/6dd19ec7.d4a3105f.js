"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[90372],{48305:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>s,contentTitle:()=>o,default:()=>p,frontMatter:()=>l,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"reference/stream/zsink/parallel-operators","title":"Parallel Operators","description":"Parallel Zipping","source":"@site/docs/reference/stream/zsink/concurrency-and-parallelism.md","sourceDirName":"reference/stream/zsink","slug":"/reference/stream/zsink/parallel-operators","permalink":"/reference/stream/zsink/parallel-operators","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/stream/zsink/concurrency-and-parallelism.md","tags":[],"version":"current","frontMatter":{"id":"parallel-operators","title":"Parallel Operators"},"sidebar":"reference-sidebar","previous":{"title":"Sink Operations","permalink":"/reference/stream/zsink/operations"},"next":{"title":"Leftovers","permalink":"/reference/stream/zsink/leftovers"}}');var t=n(74848),i=n(28453);const l={id:"parallel-operators",title:"Parallel Operators"},o=void 0,s={},c=[{value:"Parallel Zipping",id:"parallel-zipping",level:2},{value:"Racing",id:"racing",level:2}];function d(e){const r={code:"code",h2:"h2",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.h2,{id:"parallel-zipping",children:"Parallel Zipping"}),"\n",(0,t.jsxs)(r.p,{children:["Like ",(0,t.jsx)(r.code,{children:"ZStream"}),", two ",(0,t.jsx)(r.code,{children:"ZSink"})," can be zipped together. Both of them will be run in parallel, and their results will be combined in a tuple:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-scala",children:"import zio._\nimport zio.stream._\n\nval kafkaSink: ZSink[Any, Throwable, Record, Record, Unit] =\n  ZSink.foreach[Any, Throwable, Record](record => ZIO.attempt(???))\n\nval pulsarSink: ZSink[Any, Throwable, Record, Record, Unit] =\n  ZSink.foreach[Any, Throwable, Record](record => ZIO.attempt(???))\n\nval stream: ZSink[Any, Throwable, Record, Record, Unit] =\n  kafkaSink zipPar pulsarSink \n"})}),"\n",(0,t.jsx)(r.h2,{id:"racing",children:"Racing"}),"\n",(0,t.jsxs)(r.p,{children:["We are able to ",(0,t.jsx)(r.code,{children:"race"})," multiple sinks, they will run in parallel, and the one that wins will provide the result of our program:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-scala",children:"val stream: ZSink[Any, Throwable, Record, Record, Unit] =\n  kafkaSink race pulsarSink \n"})}),"\n",(0,t.jsxs)(r.p,{children:["To determine which one succeeded, we should use the ",(0,t.jsx)(r.code,{children:"ZSink#raceBoth"})," combinator, it returns an ",(0,t.jsx)(r.code,{children:"Either"})," result."]})]})}function p(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,r,n)=>{n.d(r,{R:()=>l,x:()=>o});var a=n(96540);const t={},i=a.createContext(t);function l(e){const r=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),a.createElement(i.Provider,{value:r},e.children)}}}]);