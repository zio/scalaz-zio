"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[39904],{31088:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"overview/basic-concurrency","title":"Basic Concurrency","description":"ZIO is a highly concurrent framework, powered by fibers, which are lightweight virtual threads that achieve massive scalability compared to threads, augmented with resource-safe cancellation, which powers many features in ZIO.","source":"@site/docs/overview/basic-concurrency.md","sourceDirName":"overview","slug":"/overview/basic-concurrency","permalink":"/overview/basic-concurrency","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/overview/basic-concurrency.md","tags":[],"version":"current","frontMatter":{"id":"basic-concurrency","title":"Basic Concurrency"},"sidebar":"overview_sidebar","previous":{"title":"Handling Resources","permalink":"/overview/handling-resources"},"next":{"title":"Running Effects","permalink":"/overview/running-effects"}}');var t=n(74848),s=n(28453);const l={id:"basic-concurrency",title:"Basic Concurrency"},c=void 0,o={},a=[{value:"Fibers",id:"fibers",level:2},{value:"The Fiber Data Type",id:"the-fiber-data-type",level:3},{value:"Forking Effects",id:"forking-effects",level:3},{value:"Joining Fibers",id:"joining-fibers",level:3},{value:"Awaiting Fibers",id:"awaiting-fibers",level:3},{value:"Interrupting Fibers",id:"interrupting-fibers",level:3},{value:"Composing Fibers",id:"composing-fibers",level:3},{value:"Parallelism",id:"parallelism",level:2},{value:"Racing",id:"racing",level:2},{value:"Timeout",id:"timeout",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const i={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(i.p,{children:["ZIO is a highly concurrent framework, powered by ",(0,t.jsx)(i.em,{children:"fibers"}),", which are lightweight virtual threads that achieve massive scalability compared to threads, augmented with resource-safe cancellation, which powers many features in ZIO."]}),"\n",(0,t.jsx)(i.p,{children:"This powerful concurrency model lets you do more with less, achieving highly-scalable, ultra low-latency applications that are globally efficient and resource-safe."}),"\n",(0,t.jsx)(i.p,{children:"In this section, you will learn the basics of fibers, and become acquainted with some of the powerful high-level operators that are powered by fibers."}),"\n",(0,t.jsx)(i.h2,{id:"fibers",children:"Fibers"}),"\n",(0,t.jsxs)(i.p,{children:["All effects in ZIO are executed by ",(0,t.jsx)(i.em,{children:"some"})," fiber. If you did not create the fiber, then the fiber was created by some operation you are using (if the operation is concurrent or parallel), or by the ZIO runtime system."]}),"\n",(0,t.jsx)(i.p,{children:'Even if you only write "single-threaded" code, with no parallel or concurrent operations, there will be at least one fiber: the "main" fiber that executes your effect.'}),"\n",(0,t.jsx)(i.p,{children:"Like operating system-level threads, ZIO fibers have a well-defined lifecycle, defined by the effect they are executing."}),"\n",(0,t.jsx)(i.p,{children:"Every fiber exits with failure or success, depending on whether the effect it is executing fails or succeeds."}),"\n",(0,t.jsxs)(i.p,{children:["Also like operating system threads, ZIO fibers have unique identities, stacks (including stack traces), local state, and a status (such as ",(0,t.jsx)(i.em,{children:"done"}),", ",(0,t.jsx)(i.em,{children:"running"}),", or ",(0,t.jsx)(i.em,{children:"suspended"}),")."]}),"\n",(0,t.jsx)(i.p,{children:"Compared to operating system threads, ZIO fibers:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Consume almost no memory"}),"\n",(0,t.jsx)(i.li,{children:"Have dynamic stacks that grow and shrink"}),"\n",(0,t.jsx)(i.li,{children:"Don't waste operating system threads with blocking operations"}),"\n",(0,t.jsx)(i.li,{children:"Can be safely interrupted at any point in time"}),"\n",(0,t.jsx)(i.li,{children:"Are strongly typed"}),"\n",(0,t.jsx)(i.li,{children:"Let you query them to discover their children"}),"\n",(0,t.jsx)(i.li,{children:"Will be garbage collected automatically if they are suspended and cannot be reactivated"}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"These make fibers a superior choice for building modern applications."}),"\n",(0,t.jsx)(i.p,{children:"Fibers are scheduled onto operating system threads by the ZIO runtime. Because fibers cooperatively yield to each other, ZIO fibers always execute concurrently, even when running in a single-threaded environment like JavaScript (or the JVM, when ZIO is configured with one work thread)."}),"\n",(0,t.jsx)(i.h3,{id:"the-fiber-data-type",children:"The Fiber Data Type"}),"\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:"Fiber"}),' data type in ZIO represents a "handle" on the execution of an effect. The ',(0,t.jsx)(i.code,{children:"Fiber"})," data type is most similar to Scala's ",(0,t.jsx)(i.code,{children:"Future"}),' data type, which represents a "handle" on a running asynchronous operation.']}),"\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:"Fiber[E, A]"})," data type in ZIO has two type parameters:"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsxs)(i.strong,{children:[(0,t.jsx)(i.code,{children:"E"})," Failure Type"]}),". The fiber may fail with a value of this type."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsxs)(i.strong,{children:[(0,t.jsx)(i.code,{children:"A"})," Success Type"]}),". The fiber may succeed with a value of this type."]}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:["Fibers do not have an ",(0,t.jsx)(i.code,{children:"R"})," type parameter, because fibers only execute effects that have already had their requirements provided to them."]}),"\n",(0,t.jsx)(i.h3,{id:"forking-effects",children:"Forking Effects"}),"\n",(0,t.jsxs)(i.p,{children:["The most fundamental way of creating a fiber is to take an existing effect and ",(0,t.jsx)(i.em,{children:"fork"})," it. Conceptually, ",(0,t.jsx)(i.em,{children:"forking"})," an effect begins executing the effect on a new fiber, giving you a reference to the newly-created fiber."]}),"\n",(0,t.jsxs)(i.p,{children:["The following code creates a single fiber using ",(0,t.jsx)(i.code,{children:"fork"}),", which executes ",(0,t.jsx)(i.code,{children:"fib(100)"})," independently of the main fiber:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-scala",children:"def fib(n: Long): UIO[Long] = \n  ZIO.suspendSucceed {\n    if (n <= 1) ZIO.succeed(n)\n    else fib(n - 1).zipWith(fib(n - 2))(_ + _)\n  }\n\nval fib100Fiber: UIO[Fiber[Nothing, Long]] = \n  for {\n    fiber <- fib(100).fork\n  } yield fiber\n"})}),"\n",(0,t.jsx)(i.h3,{id:"joining-fibers",children:"Joining Fibers"}),"\n",(0,t.jsxs)(i.p,{children:["One of the methods on ",(0,t.jsx)(i.code,{children:"Fiber"})," is ",(0,t.jsx)(i.code,{children:"Fiber#join"}),", which returns an effect. The effect returned by ",(0,t.jsx)(i.code,{children:"Fiber#join"})," will succeed or fail as per the fiber:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-scala",children:'for {\n  fiber   <- ZIO.succeed("Hi!").fork\n  message <- fiber.join\n} yield message\n'})}),"\n",(0,t.jsx)(i.p,{children:"When a parent fiber joins a child fiber, it will succeed or fail in the same way as the child fiber, and the local states of the fibers will be merged."}),"\n",(0,t.jsx)(i.h3,{id:"awaiting-fibers",children:"Awaiting Fibers"}),"\n",(0,t.jsxs)(i.p,{children:["Another method on ",(0,t.jsx)(i.code,{children:"Fiber"})," is ",(0,t.jsx)(i.code,{children:"Fiber#await"}),", which returns an effect containing an ",(0,t.jsx)(i.code,{children:"Exit"})," value, which provides full information on how the fiber completed."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-scala",children:'for {\n  fiber <- ZIO.succeed("Hi!").fork\n  exit  <- fiber.await\n} yield exit\n'})}),"\n",(0,t.jsx)(i.p,{children:"Awaiting the exit values of fibers is different than joining them, because awaiting will not tie the fate of the parent fiber to that of the child fiber, and nor will it attempt to merge the local states of the fibers."}),"\n",(0,t.jsx)(i.h3,{id:"interrupting-fibers",children:"Interrupting Fibers"}),"\n",(0,t.jsxs)(i.p,{children:["A fiber whose result is no longer needed may be ",(0,t.jsx)(i.em,{children:"interrupted"}),", which immediately terminates the fiber, safely releasing all resources by running all finalizers."]}),"\n",(0,t.jsxs)(i.p,{children:["Like ",(0,t.jsx)(i.code,{children:"await"}),", ",(0,t.jsx)(i.code,{children:"Fiber#interrupt"})," returns an ",(0,t.jsx)(i.code,{children:"Exit"})," describing how the fiber completed."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-scala",children:'for {\n  fiber <- ZIO.succeed("Hi!").forever.fork\n  exit  <- fiber.interrupt\n} yield exit\n'})}),"\n",(0,t.jsxs)(i.p,{children:["By design, the effect returned by ",(0,t.jsx)(i.code,{children:"Fiber#interrupt"})," does not resume until the fiber has completed, which helps ensure your code does not spin up new fibers until the old one has terminated."]}),"\n",(0,t.jsxs)(i.p,{children:['If this behavior (often called "back-pressuring") is not desired, you can ',(0,t.jsx)(i.code,{children:"ZIO#fork"})," the interruption itself into a new fiber:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-scala",children:'for {\n  fiber <- ZIO.succeed("Hi!").forever.fork\n  _     <- fiber.interrupt.fork // I don\'t care!\n} yield ()\n'})}),"\n",(0,t.jsxs)(i.p,{children:["There is a shorthand for background interruption, which is the method ",(0,t.jsx)(i.code,{children:"Fiber#interruptFork"}),"."]}),"\n",(0,t.jsx)(i.h3,{id:"composing-fibers",children:"Composing Fibers"}),"\n",(0,t.jsxs)(i.p,{children:["ZIO lets you compose fibers with ",(0,t.jsx)(i.code,{children:"Fiber#zip"})," or ",(0,t.jsx)(i.code,{children:"Fiber#zipWith"}),"."]}),"\n",(0,t.jsx)(i.p,{children:"These methods combine two fibers into a single fiber that produces the results of both. If either fiber fails, then the composed fiber will fail."}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-scala",children:'for {\n  fiber1 <- ZIO.succeed("Hi!").fork\n  fiber2 <- ZIO.succeed("Bye!").fork\n  fiber   = fiber1.zip(fiber2)\n  tuple  <- fiber.join\n} yield tuple\n'})}),"\n",(0,t.jsxs)(i.p,{children:["Another way fibers compose is with ",(0,t.jsx)(i.code,{children:"Fiber#orElse"}),". If the first fiber succeeds, the composed fiber will succeed with its result; otherwise, the composed fiber will complete with the exit value of the second fiber (whether success or failure)."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-scala",children:'for {\n  fiber1 <- ZIO.fail("Uh oh!").fork\n  fiber2 <- ZIO.succeed("Hurray!").fork\n  fiber   = fiber1.orElse(fiber2)\n  message  <- fiber.join\n} yield message\n'})}),"\n",(0,t.jsx)(i.h2,{id:"parallelism",children:"Parallelism"}),"\n",(0,t.jsxs)(i.p,{children:["ZIO provides parallel versions of many methods, which are named with a ",(0,t.jsx)(i.code,{children:"Par"})," suffix that helps you identify opportunities to parallelize your code."]}),"\n",(0,t.jsxs)(i.p,{children:["For example, the ordinary ",(0,t.jsx)(i.code,{children:"ZIO#zip"})," method zips two effects together sequentially. But there is also a ",(0,t.jsx)(i.code,{children:"ZIO#zipPar"})," method, which zips two effects together in parallel."]}),"\n",(0,t.jsx)(i.p,{children:"The following table summarizes some of the sequential operations and their corresponding parallel versions:"}),"\n",(0,t.jsxs)(i.table,{children:[(0,t.jsx)(i.thead,{children:(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.th,{style:{textAlign:"right"},children:(0,t.jsx)(i.strong,{children:"Description"})}),(0,t.jsx)(i.th,{style:{textAlign:"center"},children:(0,t.jsx)(i.strong,{children:"Sequential"})}),(0,t.jsx)(i.th,{style:{textAlign:"center"},children:(0,t.jsx)(i.strong,{children:"Parallel"})})]})}),(0,t.jsxs)(i.tbody,{children:[(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{style:{textAlign:"right"},children:"Zips two effects into one"}),(0,t.jsx)(i.td,{style:{textAlign:"center"},children:(0,t.jsx)(i.code,{children:"ZIO#zip"})}),(0,t.jsx)(i.td,{style:{textAlign:"center"},children:(0,t.jsx)(i.code,{children:"ZIO#zipPar"})})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{style:{textAlign:"right"},children:"Zips two effects into one"}),(0,t.jsx)(i.td,{style:{textAlign:"center"},children:(0,t.jsx)(i.code,{children:"ZIO#zipWith"})}),(0,t.jsx)(i.td,{style:{textAlign:"center"},children:(0,t.jsx)(i.code,{children:"ZIO#zipWithPar"})})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{style:{textAlign:"right"},children:"Zips multiple effects into one"}),(0,t.jsx)(i.td,{style:{textAlign:"center"},children:(0,t.jsx)(i.code,{children:"ZIO#tupled"})}),(0,t.jsx)(i.td,{style:{textAlign:"center"},children:(0,t.jsx)(i.code,{children:"ZIO#tupledPar"})})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{style:{textAlign:"right"},children:"Collects from many effects"}),(0,t.jsx)(i.td,{style:{textAlign:"center"},children:(0,t.jsx)(i.code,{children:"ZIO.collectAll"})}),(0,t.jsx)(i.td,{style:{textAlign:"center"},children:(0,t.jsx)(i.code,{children:"ZIO.collectAllPar"})})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{style:{textAlign:"right"},children:"Effectfully loop over values"}),(0,t.jsx)(i.td,{style:{textAlign:"center"},children:(0,t.jsx)(i.code,{children:"ZIO.foreach"})}),(0,t.jsx)(i.td,{style:{textAlign:"center"},children:(0,t.jsx)(i.code,{children:"ZIO.foreachPar"})})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{style:{textAlign:"right"},children:"Reduces many values"}),(0,t.jsx)(i.td,{style:{textAlign:"center"},children:(0,t.jsx)(i.code,{children:"ZIO.reduceAll"})}),(0,t.jsx)(i.td,{style:{textAlign:"center"},children:(0,t.jsx)(i.code,{children:"ZIO.reduceAllPar"})})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{style:{textAlign:"right"},children:"Merges many values"}),(0,t.jsx)(i.td,{style:{textAlign:"center"},children:(0,t.jsx)(i.code,{children:"ZIO.mergeAll"})}),(0,t.jsx)(i.td,{style:{textAlign:"center"},children:(0,t.jsx)(i.code,{children:"ZIO.mergeAllPar"})})]})]})]}),"\n",(0,t.jsx)(i.p,{children:"Because all these parallel operators return all the results, if any effect being parallelized fails, ZIO will automatically cancel the other running effects, as their results will not be used."}),"\n",(0,t.jsxs)(i.p,{children:["If the fail-fast behavior is not desired, potentially failing effects can be first converted into infallible effects using the ",(0,t.jsx)(i.code,{children:"ZIO#either"})," or ",(0,t.jsx)(i.code,{children:"ZIO#option"})," methods."]}),"\n",(0,t.jsx)(i.h2,{id:"racing",children:"Racing"}),"\n",(0,t.jsx)(i.p,{children:"ZIO lets you race multiple effects concurrently, returning the first successful result:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-scala",children:'for {\n  winner <- ZIO.succeed("Hello").race(ZIO.succeed("Goodbye"))\n} yield winner\n'})}),"\n",(0,t.jsxs)(i.p,{children:["If you want the first success ",(0,t.jsx)(i.strong,{children:"or"})," failure, rather than the first success, then you can use ",(0,t.jsx)(i.code,{children:"left.either.race(right.either)"}),", for any two effects ",(0,t.jsx)(i.code,{children:"left"})," and ",(0,t.jsx)(i.code,{children:"right"}),"."]}),"\n",(0,t.jsx)(i.h2,{id:"timeout",children:"Timeout"}),"\n",(0,t.jsx)(i.p,{children:'ZIO has resource-safe, compositional timeouts that work on "small" effects, such as querying a database or calling a cloud API, or even "large" effects, such as running a streaming pipeline or fully handling a web request.'}),"\n",(0,t.jsxs)(i.p,{children:["ZIO lets you timeout effects using the ",(0,t.jsx)(i.code,{children:"ZIO#timeout"})," method, which returns a new effect that succeeds with an ",(0,t.jsx)(i.code,{children:"Option"})," value."]}),"\n",(0,t.jsxs)(i.p,{children:["A value of ",(0,t.jsx)(i.code,{children:"None"})," indicates the timeout elapsed before the effect completed."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-scala",children:'ZIO.succeed("Hello").timeout(10.seconds)\n'})}),"\n",(0,t.jsx)(i.p,{children:"If an effect times out, then instead of continuing to execute in the background, it will be interrupted, for automatic efficiency."}),"\n",(0,t.jsx)(i.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsxs)(i.p,{children:["If you are comfortable with basic concurrency, the next step is to learn about ",(0,t.jsx)(i.a,{href:"/overview/running-effects",children:"running effects"}),"."]})]})}function h(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,i,n)=>{n.d(i,{R:()=>l,x:()=>c});var r=n(96540);const t={},s=r.createContext(t);function l(e){const i=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function c(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),r.createElement(s.Provider,{value:i},e.children)}}}]);