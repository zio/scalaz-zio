"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[59075],{6383:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>c,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"zio-cache/index","title":"Introduction to ZIO Cache","description":"ZIO Cache is a library that makes it easy to optimize the performance of our application by caching values.","source":"@site/docs/zio-cache/index.md","sourceDirName":"zio-cache","slug":"/zio-cache/","permalink":"/zio-cache/","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-cache/index.md","tags":[],"version":"current","frontMatter":{"id":"index","title":"Introduction to ZIO Cache","sidebar_label":"ZIO Cache"},"sidebar":"ecosystem-sidebar","previous":{"title":"Advanced example","permalink":"/zio-cli/examples"},"next":{"title":"Lookup","permalink":"/zio-cache/lookup"}}');var s=i(74848),t=i(28453);const a={id:"index",title:"Introduction to ZIO Cache",sidebar_label:"ZIO Cache"},c=void 0,r={},l=[{value:"Introduction",id:"introduction",level:2},{value:"How to Define a Cache?",id:"how-to-define-a-cache",level:2},{value:"Installation",id:"installation",level:2},{value:"Example",id:"example",level:2},{value:"Resources",id:"resources",level:2}];function h(e){const n={a:"a",code:"code",em:"em",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"ZIO Cache is a library that makes it easy to optimize the performance of our application by caching values."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://github.com/zio/zio/wiki/Project-Stages",children:(0,s.jsx)(n.img,{src:"https://img.shields.io/badge/Project%20Stage-Development-green.svg",alt:"Development"})})," ",(0,s.jsx)(n.img,{src:"https://github.com/zio/zio-cache/workflows/CI/badge.svg",alt:"CI Badge"})," ",(0,s.jsx)(n.a,{href:"https://oss.sonatype.org/content/repositories/releases/dev/zio/zio-cache_2.13/",children:(0,s.jsx)(n.img,{src:"https://img.shields.io/nexus/r/https/oss.sonatype.org/dev.zio/zio-cache_2.13.svg?label=Sonatype%20Release",alt:"Sonatype Releases"})})," ",(0,s.jsx)(n.a,{href:"https://oss.sonatype.org/content/repositories/snapshots/dev/zio/zio-cache_2.13/",children:(0,s.jsx)(n.img,{src:"https://img.shields.io/nexus/s/https/oss.sonatype.org/dev.zio/zio-cache_2.13.svg?label=Sonatype%20Snapshot",alt:"Sonatype Snapshots"})})," ",(0,s.jsx)(n.a,{href:"https://javadoc.io/doc/dev.zio/zio-cache-docs_2.13",children:(0,s.jsx)(n.img,{src:"https://javadoc.io/badge2/dev.zio/zio-cache-docs_2.13/javadoc.svg",alt:"javadoc"})})," ",(0,s.jsx)(n.a,{href:"https://github.com/zio/zio-cache",children:(0,s.jsx)(n.img,{src:"https://img.shields.io/github/stars/zio/zio-cache?style=social",alt:"ZIO Cache"})})]}),"\n",(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsxs)(n.p,{children:["Sometimes we may call or receive requests to do overlapping work. Assume we are writing a service that is going to handle all incoming requests. We don't want to handle duplicate requests. Using ZIO Cache we can make our application to be more ",(0,s.jsx)(n.strong,{children:"performant"})," by preventing duplicated works."]}),"\n",(0,s.jsx)(n.p,{children:"Some key features of ZIO Cache:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Compositionality"})," \u2014 If we want our applications to be ",(0,s.jsx)(n.strong,{children:"compositional"}),", different parts of our application may do overlapping work. ZIO Cache helps us to stay benefit from compositionality while using caching."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Unification of Synchronous and Asynchronous Caches"})," \u2014 Compositional definition of cache in terms of ",(0,s.jsx)(n.em,{children:"lookup function"})," unifies synchronous and asynchronous caches. So the lookup function can compute value either synchronously or asynchronously."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Deep ZIO Integration"})," \u2014 ZIO Cache is a ZIO native solution. So without losing the power of ZIO it includes support for ",(0,s.jsx)(n.em,{children:"concurrent lookups"}),", ",(0,s.jsx)(n.em,{children:"failure"}),", and ",(0,s.jsx)(n.em,{children:"interruption"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Caching Policy"})," \u2014 Using caching policy, the ZIO Cache can determine when values should/may be removed from the cache. So, if we want to build something more complex and custom we have a lot of flexibility. The caching policy has two parts and together they define a whole caching policy:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Priority (Optional Removal)"})," \u2014 When we are running out of space, it defines the order that the existing values ",(0,s.jsx)(n.strong,{children:"might"})," be removed from the cache to make more space."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Evict (Mandatory Removal)"})," \u2014 Regardless of space when we ",(0,s.jsx)(n.strong,{children:"must"})," remove existing values because they are no longer valid anymore. They might be invalid because they do not satisfy business requirements (e.g., maybe it's too old). This is a function that determines whether an entry is valid based on the entry and the current time."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Composition Caching Policy"})," \u2014 We can define much more complicated caching policies out of much simpler ones."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cache/Entry Statistics"})," \u2014 ZIO Cache maintains some good statistic metrics, such as entries, memory size, hits, misses, loads, evictions, and total load time. So we can look at how our cache is doing and decide where we should change our caching policy to improve caching metrics."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"how-to-define-a-cache",children:"How to Define a Cache?"}),"\n",(0,s.jsx)(n.p,{children:"A cache is defined in terms of a lookup function that describes how to compute the value associated with a key if a value is not already in the cache."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"import zio._\n\ntrait Lookup[-Key, -Environment, +Error, +Value] {\n  def lookup(key: Key): ZIO[Environment, Error, Value]\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The lookup function takes a key of type ",(0,s.jsx)(n.code,{children:"Key"})," and returns a ",(0,s.jsx)(n.code,{children:"ZIO"})," effect that requires an environment of type ",(0,s.jsx)(n.code,{children:"Environment"})," and can fail with an error of type ",(0,s.jsx)(n.code,{children:"Error"})," or succeed with a value of type ",(0,s.jsx)(n.code,{children:"Value"}),". Because the lookup function returns a ",(0,s.jsx)(n.code,{children:"ZIO"})," effect it can describe both synchronous and asynchronous workflows."]}),"\n",(0,s.jsx)(n.p,{children:"We construct a cache using a lookup function as well as a maximum size and a time to live."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"trait Cache[-Key, +Error, +Value] {\n  def get(k: Key): IO[Error, Value]\n}\n\nobject Cache {\n\n  def make[Key, Environment, Error, Value](\n    capacity: Int,\n    timeToLive: Duration,\n    lookup: Lookup[Key, Environment, Error, Value]\n  ): ZIO[Environment, Nothing, Cache[Key, Error, Value]] =\n    ???\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Once we have created a cache the most idiomatic way to work with it is the ",(0,s.jsx)(n.code,{children:"get"})," operator. The ",(0,s.jsx)(n.code,{children:"get"})," operator will return the current value in the cache if it exists or else compute a new value, put it in the cache, and return it."]}),"\n",(0,s.jsx)(n.p,{children:"If multiple concurrent processes get the value at the same time the value will only be computed once, with all of the other processes receiving the computed value as soon as it is available. All of this will be done using ZIO's fiber based concurrency model without ever blocking any underlying operating system threads."}),"\n",(0,s.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,s.jsxs)(n.p,{children:["In order to use this library, we need to add the following line in our ",(0,s.jsx)(n.code,{children:"build.sbt"})," file:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'libraryDependencies += "dev.zio" %% "zio-cache" % "0.2.3"\n'})}),"\n",(0,s.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,s.jsxs)(n.p,{children:["In this example, we are calling ",(0,s.jsx)(n.code,{children:"timeConsumingEffect"})," three times in parallel with the same key. The ZIO Cache runs this effect only once. So the concurrent lookups will suspend until the value being computed is available:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.cache.{Cache, Lookup}\n\nobject ZIOCacheExample extends ZIOAppDefault {\n  def timeConsumingEffect(key: String) =\n    ZIO.sleep(5.seconds).as(key.hashCode)\n\n  def run =\n    for {\n      cache <- Cache.make(\n        capacity = 100,\n        timeToLive = Duration.Infinity,\n        lookup = Lookup(timeConsumingEffect)\n      )\n      result <- cache\n        .get("key1")\n        .zipPar(cache.get("key1"))\n        .zipPar(cache.get("key1"))\n      _ <- ZIO.debug(\n        s"Result of parallel execution of three effects with the same key: $result"\n      )\n\n      hits <- cache.cacheStats.map(_.hits)\n      misses <- cache.cacheStats.map(_.misses)\n      _ <- ZIO.debug(s"Number of cache hits: $hits")\n      _ <- ZIO.debug(s"Number of cache misses: $misses")\n    } yield ()\n\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"The output of this program should be as follows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Result of parallel execution three effects with the same key: ((3288498,3288498),3288498)\nNumber of cache hits: 2\nNumber of cache misses: 1\n"})}),"\n",(0,s.jsx)(n.h2,{id:"resources",children:"Resources"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://www.youtube.com/watch?v=iFeTUhYpPLs",children:"Compositional Caching"})," by Adam Fraser (December 2020) \u2014 In this talk, Adam will introduce ZIO Cache, a new library in the ZIO ecosystem that provides a drop-in caching solution for ZIO applications. We will see how ZIO\u2019s support for asynchrony and concurrent lets us implement a cache in terms of a single lookup function and how we get many other things such as typed errors and compositional caching policies for free. See how easy it can be to add caching to your ZIO application!"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>c});var o=i(96540);const s={},t=o.createContext(s);function a(e){const n=o.useContext(t);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),o.createElement(t.Provider,{value:n},e.children)}}}]);