"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[87240],{7995:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"zio-http/reference/server","title":"Server","description":"Using the ZIO HTTP Server, we can serve one or more HTTP applications. It provides methods to install HTTP applications into the server. Also it offers a comprehensive Config class that allows fine-grained control over server behavior. We can configure settings such as SSL/TLS, address binding, request decompression and response compression, and more.","source":"@site/docs/zio-http/reference/server.md","sourceDirName":"zio-http/reference","slug":"/zio-http/reference/server","permalink":"/zio-http/reference/server","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-http/reference/server.md","tags":[],"version":"current","frontMatter":{"id":"server","title":"Server"},"sidebar":"ecosystem-sidebar","previous":{"title":"Overview","permalink":"/zio-http/reference/overview"},"next":{"title":"Client","permalink":"/zio-http/reference/client"}}');var o=t(74848),i=t(28453);const s={id:"server",title:"Server"},a=void 0,l={},c=[{value:"Starting a Server with Default Configurations",id:"starting-a-server-with-default-configurations",level:2},{value:"Starting a Server with Custom Configurations",id:"starting-a-server-with-custom-configurations",level:2},{value:"Configuring SSL",id:"configuring-ssl",level:2},{value:"Binding to Specific Host and Port",id:"binding-to-specific-host-and-port",level:2},{value:"Accepting Continue",id:"accepting-continue",level:2},{value:"Keep-Alive Configuration",id:"keep-alive-configuration",level:2},{value:"Integration with ZIO Config",id:"integration-with-zio-config",level:2},{value:"Enabling Request Decompression",id:"enabling-request-decompression",level:2},{value:"Enabling Response Compression",id:"enabling-response-compression",level:2},{value:"Enabling Streaming of Request Bodies",id:"enabling-streaming-of-request-bodies",level:2},{value:"Logging on Fatal Errors",id:"logging-on-fatal-errors",level:2},{value:"Serving on Any Open Port",id:"serving-on-any-open-port",level:2},{value:"Graceful Shutdown Configuration",id:"graceful-shutdown-configuration",level:2},{value:"Idle Timeout Configuration",id:"idle-timeout-configuration",level:2},{value:"Websocket Configuration",id:"websocket-configuration",level:2},{value:"Netty Configuration",id:"netty-configuration",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:["Using the ZIO HTTP Server, we can serve one or more HTTP applications. It provides methods to install HTTP applications into the server. Also it offers a comprehensive ",(0,o.jsx)(n.code,{children:"Config"})," class that allows fine-grained control over server behavior. We can configure settings such as SSL/TLS, address binding, request decompression and response compression, and more."]}),"\n",(0,o.jsx)(n.p,{children:"This section describes, ZIO HTTP Server and different configurations you can provide while creating the Server:"}),"\n",(0,o.jsx)(n.h2,{id:"starting-a-server-with-default-configurations",children:"Starting a Server with Default Configurations"}),"\n",(0,o.jsxs)(n.p,{children:["Assuming we have written a ",(0,o.jsx)(n.code,{children:"Routes"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import zio.http._\nimport zio._\n\nval routes: Routes[Any, Response] =\n  Routes(\n    Method.GET / "hello" ->\n      handler(Response.text("Hello, World!"))\n    )\n'})}),"\n",(0,o.jsxs)(n.p,{children:["We can serve it using the ",(0,o.jsx)(n.code,{children:"Server.serve"})," method:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"Server.serve(routes).provide(Server.default)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["By default, it will start the server on port ",(0,o.jsx)(n.code,{children:"8080"}),". A quick shortcut to only customize the port is ",(0,o.jsx)(n.code,{children:"Server.defaultWithPort"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"Server.serve(routes).provide(Server.defaultWithPort(8081))\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Or to customize more properties of the ",(0,o.jsx)(n.em,{children:"default configuration"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"Server.serve(routes).provide(\n  Server.defaultWith(\n    _.port(8081).enableRequestStreaming\n  )\n)\n"})}),"\n",(0,o.jsx)(n.admonition,{type:"note",children:(0,o.jsxs)(n.p,{children:["Sometimes we may want to have more control over installation of the http application into the server. In such cases, we may want to use the ",(0,o.jsx)(n.code,{children:"Server.install"})," method. This method only installs the ",(0,o.jsx)(n.code,{children:"Routes"})," into the server, and the lifecycle of the server can be managed separately."]})}),"\n",(0,o.jsx)(n.h2,{id:"starting-a-server-with-custom-configurations",children:"Starting a Server with Custom Configurations"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"live"})," layer expects a ",(0,o.jsx)(n.code,{children:"Server.Config"})," holding the custom configuration for the server:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"Server\n  .serve(routes)\n  .provide(\n    ZLayer.succeed(Server.Config.default.port(8081)),\n    Server.live\n  )\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"Server.Config"})," class provides a wide range of configuration options, including SSL/TLS, address binding, request decompression and response compression, request streaming, and more. Here is the full list of available configurations:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"case class Config(\n  sslConfig: Option[SSLConfig],\n  address: InetSocketAddress,\n  acceptContinue: Boolean,\n  keepAlive: Boolean,\n  requestDecompression: Decompression,\n  responseCompression: Option[ResponseCompressionConfig],\n  requestStreaming: RequestStreaming,\n  maxInitialLineLength: Int,\n  maxHeaderSize: Int,\n  logWarningOnFatalError: Boolean,\n  gracefulShutdownTimeout: Duration,\n  webSocketConfig: WebSocketConfig,\n  idleTimeout: Option[Duration],\n)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["There is also the default configuration, which can be used as a starting point for custom configurations. Then we can use the ",(0,o.jsx)(n.code,{children:"Server.Config#copy"})," method or its builder methods to customize the configuration:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio.http._\n\nval config =\n  Server.Config.default\n    .idleTimeout(60.seconds)\n    .gracefulShutdownTimeout(20.seconds)\n    .requestDecompression(true)\n"})}),"\n",(0,o.jsx)(n.h2,{id:"configuring-ssl",children:"Configuring SSL"}),"\n",(0,o.jsxs)(n.p,{children:["By default, the server is not configured to use SSL. To enable it, we need to update the server config, and use the ",(0,o.jsx)(n.code,{children:"Server.Config#ssl"})," field to specify the SSL configuration:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import zio.http._\n\nval sslConfig = SSLConfig.fromResource(\n  behaviour = SSLConfig.HttpBehaviour.Accept,\n  certPath = "server.crt",\n  keyPath = "server.key",\n)\n\nval config = Server.Config.default\n  .ssl(sslConfig)\n'})}),"\n",(0,o.jsx)(n.p,{children:"Here is the full example of how to configure SSL:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",metastring:'title="zio-http-example/src/main/scala/example/HttpsHelloWorld.scala" ',children:'package example\n\nimport zio._\n\nimport zio.http._\n\nobject HttpsHelloWorld extends ZIOAppDefault {\n  // Create HTTP route\n  val routes: Routes[Any, Response] = Routes(\n    Method.GET / "text" -> handler(Response.text("Hello World!")),\n    Method.GET / "json" -> handler(Response.json("""{"greetings": "Hello World!"}""")),\n  )\n\n  /**\n   * In this example, a private key and certificate are loaded from resources.\n   * For testing this example with curl, make sure the private key "server.key",\n   * and the certificate "server.crt" are inside the resources directory, which\n   * is by default "src/main/resources".\n   *\n   * You can use the following command to create a self-signed TLS certificate.\n   * This command will create two files: "server.key" and "server.crt".\n   *\n   * openssl req -x509 -newkey rsa:4096 -sha256 -days 365 -nodes \\ -keyout\n   * server.key -out server.crt \\ -subj "/CN=example.com/OU=?/O=?/L=?/ST=?/C=??"\n   * \\ -addext "subjectAltName=DNS:example.com,DNS:www.example.com,IP:10.0.0.1"\n   *\n   * Alternatively you can create the keystore and certificate using the\n   * following link\n   * https://medium.com/@maanadev/netty-with-https-tls-9bf699e07f01\n   */\n\n  val sslConfig = SSLConfig.fromResource(\n    behaviour = SSLConfig.HttpBehaviour.Accept,\n    certPath = "server.crt",\n    keyPath = "server.key",\n  )\n\n  private val config = Server.Config.default\n    .port(8090)\n    .ssl(sslConfig)\n\n  private val configLayer = ZLayer.succeed(config)\n\n  override val run =\n    Server.serve(routes).provide(configLayer, Server.live)\n\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"binding-to-specific-host-and-port",children:"Binding to Specific Host and Port"}),"\n",(0,o.jsxs)(n.p,{children:["By default, the server binds to the ",(0,o.jsx)(n.code,{children:"0.0.0.0"})," address and listens on port ",(0,o.jsx)(n.code,{children:"8080"}),". We can customize the address and port using the ",(0,o.jsx)(n.code,{children:"Server.Config#binding"})," methods, for example:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import zio.http._\n\nval config1 = Server.Config.default.binding("example.com", 80)\n\nval config2 = Server.Config.default.port(80)\n'})}),"\n",(0,o.jsx)(n.h2,{id:"accepting-continue",children:"Accepting Continue"}),"\n",(0,o.jsx)(n.p,{children:"Sometimes, a client may need to send a large request to the server and want to check if the server is willing to accept the request before sending the entire request body. This is especially useful when the request body is large, and the client wants to avoid sending the data if the server isn't ready to accept it. This approach helps optimize network utilization and resource consumption by avoiding unnecessary data transmissions."}),"\n",(0,o.jsx)(n.p,{children:"Here's how it typically works:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:'The client sends a request to the server with the "Expect: 100-continue" header included.'}),"\n",(0,o.jsx)(n.li,{children:"Upon receiving such a request, the server checks if it can handle the request and if it's willing to accept the incoming data."}),"\n",(0,o.jsx)(n.li,{children:'If the server is ready to accept the data, it responds with a "100 Continue" status code.'}),"\n",(0,o.jsx)(n.li,{children:'Upon receiving the "100 Continue" response, the client knows it\'s safe to proceed sending the request body.'}),"\n",(0,o.jsx)(n.li,{children:"The client then sends the request body."}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["By default, this feature is disabled in ZIO HTTP. To enable it, we can use the ",(0,o.jsx)(n.code,{children:"Server.Config#acceptContinue"})," method:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio.http._\n\nval config = Server.Config.default.acceptContinue(true)\n"})}),"\n",(0,o.jsx)(n.h2,{id:"keep-alive-configuration",children:"Keep-Alive Configuration"}),"\n",(0,o.jsx)(n.p,{children:"Typically, in HTTP 1.0, each request/response pair requires a separate TCP connection, which can lead to increased overhead due to the establishment and teardown of connections for each interaction. So assuming the following HTTP Application:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.http._\n\nobject KeepAliveExample extends ZIOAppDefault {\n  val routes = handler(Response.text("Hello World!")).toRoutes\n\n  override val run =\n    Server.serve(routes).provide(Server.default)\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["When we send the following request to the server, the server will respond with ",(0,o.jsx)(n.code,{children:"Connection: close"})," header:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"$ curl --http1.0 localhost:8080 -i\nHTTP/1.1 200 OK\ncontent-type: text/plain\ncontent-length: 12\nconnection: close\n\nHello World!\n"})}),"\n",(0,o.jsxs)(n.p,{children:["However, with the ",(0,o.jsx)(n.code,{children:"Connection: Keep-Alive"})," header, the client can request that the connection remain open after the initial request, allowing for subsequent requests to be sent over the same connection without needing to establish a new one each time."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:'$ curl --http1.0 localhost:8080 -i -H "connection: keep-alive"\nHTTP/1.1 200 OK\ncontent-type: text/plain\ncontent-length: 12\n'})}),"\n",(0,o.jsxs)(n.p,{children:["In HTTP 1.1, persistent connections are the default behavior, so the ",(0,o.jsx)(n.code,{children:"Connection: Keep-Alive"})," header is often unnecessary:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"$ curl --http1.1 localhost:8080 -i\nHTTP/1.1 200 OK\ncontent-type: text/plain\ncontent-length: 12\n"})}),"\n",(0,o.jsx)(n.p,{children:"However, it can still be used to override the default behavior or to provide additional parameters related to connection management. In the following example, we are going to ask the server to close the connection after serving the request:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:'$ curl --http1.1 localhost:8080 -i -H "Connection: close"\nHTTP/1.1 200 OK\ncontent-type: text/plain\ncontent-length: 12\nconnection: close\n\nHello World!\u23ce\n'})}),"\n",(0,o.jsxs)(n.p,{children:["The ZIO HTTP server by default supports keep-alive connections. To disable it, we can use the ",(0,o.jsx)(n.code,{children:"Server.Config#keepAlive"})," method, by setting it to ",(0,o.jsx)(n.code,{children:"false"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio.http._\n\nval config = Server.Config.default.keepAlive(false)\n"})}),"\n",(0,o.jsx)(n.h2,{id:"integration-with-zio-config",children:"Integration with ZIO Config"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"Server"})," module has a predefined config description, i.e. ",(0,o.jsx)(n.code,{children:"Server.Config.config"}),", that can be used to load the server configuration from the environment, system properties, or any other configuration source."]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"configured"})," layer loads the server configuration using the application's ",(0,o.jsx)(n.em,{children:"ZIO configuration provider"}),", which is using the environment by default but can be attached to a different backends using the ",(0,o.jsx)(n.a,{href:"https://zio.github.io/zio-config/",children:"ZIO Config library"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"Server\n  .serve(routes)\n  .provide(\n    Server.configured()\n  )\n"})}),"\n",(0,o.jsxs)(n.p,{children:["For example, to load the server configuration from the hocon file, we should add the ",(0,o.jsx)(n.code,{children:"zio-config-typesafe"})," dependency to our ",(0,o.jsx)(n.code,{children:"build.sbt"})," file:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'libraryDependencies += "dev.zio" %% "zio-config"          % "<version>"\nlibraryDependencies += "dev.zio" %% "zio-config-magnolia" % "<version>"\nlibraryDependencies += "dev.zio" %% "zio-config-typesafe" % "<version>"\n'})}),"\n",(0,o.jsxs)(n.p,{children:["And put the ",(0,o.jsx)(n.code,{children:"application.conf"})," file in the ",(0,o.jsx)(n.code,{children:"src/main/resources"})," directory:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-conf",metastring:'title="zio-http-example/src/main/resources/application.conf" ',children:"zio.http.server {\n  binding-port: 8083\n  response-compression {\n    content-threshold: 0\n    options: [{\n      level: 6\n      bits: 15\n      mem: 8\n      type: gzip\n    }]\n  }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Then we can load the server configuration from the ",(0,o.jsx)(n.code,{children:"application.conf"})," file using the ",(0,o.jsx)(n.code,{children:"ConfigProvider.fromResourcePath()"})," method:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",metastring:'title="zio-http-example/src/main/scala/example/ServerConfigurationExample.scala" ',children:'package example\n\nimport zio._\n\nimport zio.config.typesafe._\n\nimport zio.http._\n\nobject ServerConfigurationExample extends ZIOAppDefault {\n  val routes = Routes(\n    Method.GET / "hello" -> handler(Response.text("Hello, World!")),\n  ).sandbox\n\n  override val bootstrap: ZLayer[ZIOAppArgs, Any, Any] =\n    Runtime.setConfigProvider(ConfigProvider.fromResourcePath())\n\n  def run = Server.serve(routes).provide(Server.configured())\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"enabling-request-decompression",children:"Enabling Request Decompression"}),"\n",(0,o.jsxs)(n.p,{children:["By default, ZIO HTTP does not decompress incoming request bodies. But we can enable it by updating the ",(0,o.jsx)(n.code,{children:"Server.Config#requestDecompression"})," field to any of the ",(0,o.jsx)(n.code,{children:"Decompression.Strict"})," and ",(0,o.jsx)(n.code,{children:"Decompression.NonStrict"})," modes:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio.http._\n\nval config1 = Server.Config.default.requestDecompression(true) // strict mode\n\nval config2 = Server.Config.default.requestDecompression(false) // non-strict mode\n"})}),"\n",(0,o.jsx)(n.p,{children:"Let's try an example server with enabled request decompression:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio._\nimport zio.http._\n\nobject EchoServerWithDecompression extends ZIOAppDefault {\n  override val run =\n    Server\n      .serve(\n        handler { (req: Request) =>\n          req.body.asString.map(Response.text)\n        }.sandbox.toRoutes,\n      )\n      .provide(Server.live, ZLayer.succeed(Server.Config.default.requestDecompression(true)))\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["To send a compressed request body, first, we need to compress the request body using the ",(0,o.jsx)(n.code,{children:"gzip"})," command:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:'echo "Hello, World!" | gzip > body.gz\n'})}),"\n",(0,o.jsx)(n.p,{children:"Now we are ready to send the compressed body to the server:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-http",children:'$ curl --compressed -X POST -H "Content-Encoding: gzip" --data-binary @body.gz http://localhost:8080/ -i\nHTTP/1.1 200 OK\ncontent-type: text/plain\ncontent-length: 14\n\nHello, World!\n'})}),"\n",(0,o.jsx)(n.p,{children:"We can do the same with the ZIO HTTP client:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.http._\nimport java.io.ByteArrayOutputStream\nimport java.util.zip.GZIPOutputStream\n\nobject ClientWithRequestCompression extends ZIOAppDefault {\n  def compressStringToGzip(input: String): Chunk[Byte] = {\n    val outputStream     = new ByteArrayOutputStream()\n    val gzipOutputStream = new GZIPOutputStream(outputStream)\n    gzipOutputStream.write(input.getBytes("UTF-8"))\n    gzipOutputStream.close()\n    Chunk.fromArray(outputStream.toByteArray)\n  }\n\n  val app =\n    for {\n      url <- ZIO.from(URL.decode("http://localhost:8080"))\n      res <-\n        Client.batched(\n          Request\n            .post(url, Body.fromChunk(compressStringToGzip("Hello, World!")))\n            .addHeader(Header.ContentEncoding.GZip),\n        )\n      _   <- res.body.asString.debug("response: ")\n    } yield ()\n\n  override val run = app.provide(Client.default)\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"enabling-response-compression",children:"Enabling Response Compression"}),"\n",(0,o.jsx)(n.p,{children:"Response compression is a crucial technique for optimizing data transfer efficiency and improving performance in web applications. By compressing response bodies, servers can significantly reduce the amount of data sent over the network, leading to faster loading times and better user experiences."}),"\n",(0,o.jsx)(n.p,{children:"To enable response compression, it's essential to configure both the server and the client correctly. On the server side, we need to ensure that our web server is properly configured to compress outgoing responses."}),"\n",(0,o.jsxs)(n.p,{children:["On the client side, we need to indicate to the server that we support response compression by including the ",(0,o.jsx)(n.code,{children:"Accept-Encoding"})," header in our HTTP requests. The ",(0,o.jsx)(n.code,{children:"Accept-Encoding"})," header specifies the compression algorithms that the client can handle, such as ",(0,o.jsx)(n.code,{children:"gzip"})," or ",(0,o.jsx)(n.code,{children:"deflate"}),". When the server receives a request with the ",(0,o.jsx)(n.code,{children:"Accept-Encoding"})," header, it can compress the response body using one of the supported algorithms before sending it back to the client."]}),"\n",(0,o.jsxs)(n.p,{children:["Here's an example of how to include the ",(0,o.jsx)(n.code,{children:"Accept-Encoding"})," header in an HTTP request:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-http",children:"GET https://example.com/\nAccept-Encoding: gzip, deflate\n"})}),"\n",(0,o.jsxs)(n.p,{children:["When the server responds with a compressed body, it includes the ",(0,o.jsx)(n.code,{children:"Content-Encoding"})," header in the response to indicate the compression algorithm used. The client then needs to decompress the response body before processing its contents."]}),"\n",(0,o.jsx)(n.p,{children:"For instance, a compressed response might have headers like this:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-http",children:"200 OK\nContent-Encoding: gzip\nContent-Type: application/json; charset=utf-8\n<compressed-body>\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In ZIO HTTP, response compression is disabled by default. To enable it, we need to update the server config, i.e. ",(0,o.jsx)(n.code,{children:"Server.Config"}),", and use the ",(0,o.jsx)(n.code,{children:"responseCompression"})," field to specify the compression configuration:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio.http._\n\nval config = \n  Server.Config.default.copy(\n    responseCompression = Some(Server.Config.ResponseCompressionConfig.default),\n  )\n"})}),"\n",(0,o.jsx)(n.p,{children:"Here is the full example of how to enable response compression:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",metastring:'title="zio-http-example/src/main/scala/example/ServerResponseCompression.scala" ',children:'package example\n\nimport zio._\n\nimport zio.http._\n\nobject ServerResponseCompression extends ZIOAppDefault {\n  val routes = Routes(\n    Method.GET / "hello" -> handler(Response.text("Hello, World!")),\n  ).sandbox\n\n  val config = ZLayer.succeed(\n    Server.Config.default.copy(\n      responseCompression = Some(Server.Config.ResponseCompressionConfig.default),\n    ),\n  )\n\n  def run = Server.serve(routes).provide(Server.live, config)\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["After running the server, we can test it using the following ",(0,o.jsx)(n.code,{children:"curl"})," command:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:' curl -X GET http://localhost:8080/hello -H "Accept-Encoding: gzip" -i --output response.bin\n'})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"response.bin"})," file will contain the compressed response body."]}),"\n",(0,o.jsx)(n.h2,{id:"enabling-streaming-of-request-bodies",children:"Enabling Streaming of Request Bodies"}),"\n",(0,o.jsx)(n.p,{children:"Enabling streaming of request bodies in the ZIO HTTP server typically involves configuring the server to handle incoming requests asynchronously and process request bodies as they arrive, rather than waiting for the entire request body to be received before processing begins."}),"\n",(0,o.jsxs)(n.p,{children:["There are two streaming methods available on request bodies: ",(0,o.jsx)(n.code,{children:"Body#asStream"})," and ",(0,o.jsx)(n.code,{children:"Body#asMultipartFormStream"}),". When we receive a request with a streaming body, whether it's a single part or a multipart form, if the server is configured to handle request streaming, we can process the body as a stream of bytes, which allows us to handle large request bodies more efficiently."]}),"\n",(0,o.jsxs)(n.p,{children:["By default, request streaming is disabled in ZIO HTTP. To enable it, we need to update the server config with the ",(0,o.jsx)(n.code,{children:"Server.Config#enableRequestStreaming"})," method."]}),"\n",(0,o.jsx)(n.p,{children:"The following example demonstrates a server that handles streaming request bodies:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.http._\nimport zio.stream.{ZSink, ZStream}\n\nobject RequestStreamingServerExample extends ZIOAppDefault {\n  def logBytes = (b: Byte) => ZIO.log(s"received byte: $b")\n\n  private val routes: Routes[Any, Response] =\n    Routes(\n      Method.POST / "upload-stream" / "simple"     -> handler { (req: Request) =>\n        for {\n          count <- req.body.asStream.tap(logBytes).run(ZSink.count)\n          _     <- ZIO.debug(s"Read $count bytes")\n        } yield Response.text(count.toString)\n      },\n      Method.POST / "upload-stream" / "form-field" -> handler { (req: Request) =>\n        if (req.header(Header.ContentType).exists(_.mediaType == MediaType.multipart.`form-data`))\n          for {\n            _     <- ZIO.debug("Starting to read multipart/form stream")\n            form  <- req.body.asMultipartFormStream\n              .mapError(ex =>\n                Response(\n                  Status.InternalServerError,\n                  body = Body.fromString(s"Failed to decode body as multipart/form-data (${ex.getMessage}"),\n                ),\n              )\n            count <- form.fields\n              .tap(f => ZIO.log(s"started reading new field: ${f.name}"))\n              .flatMap {\n                case sb: FormField.StreamingBinary =>\n                  sb.data.tap(logBytes)\n                case _                             =>\n                  ZStream.empty\n              }\n              .run(ZSink.count)\n\n            _ <- ZIO.debug(s"Finished reading multipart/form stream, received $count bytes of data")\n          } yield Response.text(count.toString)\n        else ZIO.succeed(Response(status = Status.NotFound))\n      },\n    ).sandbox @@ Middleware.debug\n\n  override def run =\n    Server\n      .serve(routes)\n      .provide(\n        ZLayer.succeed(Server.Config.default.enableRequestStreaming),\n        Server.live,\n      )\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"To test the 'upload-stream/simple' endpoint, let's run the following client code:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.http._\nimport zio.stream.ZStream\n\nobject SimpleStreamingClientExample extends ZIOAppDefault {\n  val app = for {\n    url    <- ZIO.fromEither(URL.decode("http://localhost:8080/upload-stream"))\n    client <- ZIO.serviceWith[Client](_.url(url) @@ ZClientAspect.requestLogging())\n    res    <- client.batched(\n      Request.post(\n        path = "simple",\n        body = Body.fromStreamChunked(\n          ZStream.fromIterable("Let\'s send this text as a byte array".getBytes()),\n        ),\n      ),\n    )\n    _      <- ZIO.debug(res.status)\n\n  } yield ()\n\n  def run = app.provide(Client.default)\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"We will see that the server logs the received bytes as they arrive, and the client will receive the response with the number of bytes received."}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"upload-stream/form-field"})," endpoint is designed to handle multipart form data. To test it, we can use the following client code:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.http._\nimport zio.stream.ZStream\n\nobject FormFieldStreamingClientExample extends ZIOAppDefault {\n  val app = for {\n    url    <- ZIO.fromEither(URL.decode("http://localhost:8080/upload-stream"))\n    client <- ZIO.serviceWith[Client](_.url(url) @@ ZClientAspect.requestLogging())\n    form = Form(\n      Chunk(\n        ("foo", "This is the first part of the foo form field."),\n        ("foo", "This is the second part of the foo form field."),\n        ("bar", "This is the body of the bar form field."),\n      ).map { case (name, data) =>\n        FormField.streamingBinaryField(\n          name = name,\n          data = ZStream.fromChunk(Chunk.fromArray(data.getBytes)).schedule(Schedule.fixed(200.milli)),\n          mediaType = MediaType.application.`octet-stream`,\n        )\n      },\n    )\n    res <- client.batched(\n      Request\n        .post(\n          path = "form-field",\n          body = Body.fromMultipartForm(form, Boundary("boundary123")),\n        ),\n    )\n    _ <- ZIO.debug(res.status)\n\n  } yield ()\n\n  def run = app.provide(Client.default)\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"The server will log the received form fields as they arrive, and the client will receive the response with the number of bytes received."}),"\n",(0,o.jsx)(n.h2,{id:"logging-on-fatal-errors",children:"Logging on Fatal Errors"}),"\n",(0,o.jsxs)(n.p,{children:["When we are writing an API, it is essential to handle expected errors with proper error-handling mechanisms. However, there may be unexpected or fatal errors that can occur during the execution of the server. In such cases, if the ",(0,o.jsx)(n.code,{children:"Server.Config#logWarningOnFatalError"})," is enabled, the server will log the errors at the warning log lever."]}),"\n",(0,o.jsxs)(n.p,{children:["By default, the feature is enabled. To disable that, we can make it to ",(0,o.jsx)(n.code,{children:"false"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio.http._\n\nval config = Server.Config.default.logWarningOnFatalError(false)\n"})}),"\n",(0,o.jsx)(n.h2,{id:"serving-on-any-open-port",children:"Serving on Any Open Port"}),"\n",(0,o.jsxs)(n.p,{children:["If we want to start the server on any open port, we can use the ",(0,o.jsx)(n.code,{children:"Server.Config#onAnyOpenPort"})," method:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",metastring:'title="zio-http-example/src/main/scala/example/ServeOnAnyOpenPort.scala" ',children:'package example\n\nimport scala.annotation.nowarn\n\nimport zio._\n\nimport zio.http._\n\nobject ServeOnAnyOpenPort extends ZIOAppDefault {\n  val routes =\n    Routes(\n      Method.GET / "hello" -> handler(Response.text("Hello, World!")),\n    )\n\n  @nowarn("msg=dead code")\n  val app = for {\n    port <- Server.install(routes)\n    _    <- ZIO.log(s"server started on port $port")\n    _    <- ZIO.never\n  } yield ()\n\n  def run = app.provide(Server.defaultWith(_.onAnyOpenPort))\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"graceful-shutdown-configuration",children:"Graceful Shutdown Configuration"}),"\n",(0,o.jsx)(n.p,{children:"When a ZIO HTTP server is running, it handles incoming requests from clients, processes them, and sends back appropriate responses. In-flight requests are requests that have been received by the server but have not yet been fully processed or responded to. These requests might be in various stages of processing, such as waiting for database queries to complete or for resources to become available."}),"\n",(0,o.jsx)(n.p,{children:"When we're shutting down the server, it's important to handle these in-flight requests gracefully. ZIO HTTP has a built-in mechanism to allow in-flight requests to finalize before shutting down the server. The default behavior is to wait for 10 seconds for in-flight requests to finalize before shutting down the server. During this time, the server will not accept new requests, but it will continue to process existing requests until they're fully completed."}),"\n",(0,o.jsxs)(n.p,{children:["To change the default graceful shutdown timeout, we can use the ",(0,o.jsx)(n.code,{children:"Server.Config#gracefulShutdownTimeout"})," method. It takes a ",(0,o.jsx)(n.code,{children:"Duration"})," as an argument, and returns a new ",(0,o.jsx)(n.code,{children:"Server.Config"})," with the specified graceful shutdown timeout:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio.http._\n\nval config = Server.Config.default.gracefulShutdownTimeout(20.seconds)\n"})}),"\n",(0,o.jsx)(n.p,{children:"In the following example, we can test such behavior by sending a request to the server and while the server is processing the request, we interrupt the server, and we will see that the server will wait for the request to be processed before shutting down:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",metastring:'title="zio-http-example/src/main/scala/example/GracefulShutdown.scala" ',children:'/*\n * Copyright 2021 - 2023 Sporta Technologies PVT LTD & the ZIO HTTP contributors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage example\n\nimport zio._\n\nimport zio.http._\n\nobject GracefulShutdown extends ZIOAppDefault {\n\n  val routes: Routes[Any, Response] = Handler\n    .fromFunctionZIO[Request] { _ =>\n      ZIO.sleep(10.seconds).debug("request handler delay done").as(Response.text("done"))\n    }\n    .sandbox\n    .toRoutes\n\n  override def run: ZIO[Any, Throwable, Unit] =\n    (for {\n      started  <- Promise.make[Nothing, Unit]\n      fiber    <- Server\n        .install(routes)\n        .zipRight(started.succeed(()))\n        .zipRight(ZIO.never)\n        .provide(\n          Server.live,\n          ZLayer.succeed(Server.Config.default.port(8080)),\n        )\n        .fork\n      _        <- started.await\n      _        <- fiber.interrupt.delay(2.seconds).fork\n      response <- ZClient.batched(Request.get(url"http://localhost:8080/test"))\n      body     <- response.body.asString\n      _        <- Console.printLine(response.status)\n      _        <- Console.printLine(body)\n    } yield ()).provide(Client.default)\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"This approach ensures that clients receive appropriate responses for their requests, rather than encountering errors or abrupt disconnections. It helps maintain the integrity of the communication between clients and the server, providing a smoother experience for users and preventing potential data loss or corruption."}),"\n",(0,o.jsx)(n.h2,{id:"idle-timeout-configuration",children:"Idle Timeout Configuration"}),"\n",(0,o.jsx)(n.p,{children:"The idle timeout is a mechanism by which the server automatically terminates an inactive connection after a certain period of inactivity. When a client connects to the server, it establishes a connection to request and receive responses. However, there may be instances where the client becomes slow, inactive, or unresponsive, and the server needs to reclaim resources associated with idle connections to optimize server performance and resource utilization."}),"\n",(0,o.jsxs)(n.p,{children:["By default, ZIO HTTP does not have an idle timeout configured. To enable it, we can use the ",(0,o.jsx)(n.code,{children:"Server.Config#idleTimeout"})," method. It takes a ",(0,o.jsx)(n.code,{children:"Duration"})," as an argument, and returns a new ",(0,o.jsx)(n.code,{children:"Server.Config"})," with the specified idle timeout:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio.http._\n\nval config = Server.Config.default.idleTimeout(60.seconds)\n"})}),"\n",(0,o.jsx)(n.p,{children:"For example, if a server has an idle timeout set to 60 seconds, any connection that remains idle (i.e., without any data being sent or received) for more than 60 seconds will be automatically terminated by the server."}),"\n",(0,o.jsx)(n.h2,{id:"websocket-configuration",children:"Websocket Configuration"}),"\n",(0,o.jsxs)(n.p,{children:["ZIO HTTP supports WebSockets, which is a communication protocol that provides full-duplex communication channels over a single TCP connection. To configure the WebSocket settings, we can use the ",(0,o.jsx)(n.code,{children:"Server.Config#webSocketConfig"})," method. It takes a ",(0,o.jsx)(n.code,{children:"WebSocketConfig"})," as an argument, and returns a new ",(0,o.jsx)(n.code,{children:"Server.Config"})," with the specified WebSocket configuration."]}),"\n",(0,o.jsxs)(n.p,{children:["Let's break down the structure of the ",(0,o.jsx)(n.code,{children:"WebSocketConfig"})," case class:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"case class WebSocketConfig(\n  subprotocols: Option[String] = None,\n  handshakeTimeoutMillis: Long = 10000L,\n  forceCloseTimeoutMillis: Long = -1L,\n  handleCloseFrames: Boolean = true,\n  sendCloseFrame: WebSocketConfig.CloseStatus = WebSocketConfig.CloseStatus.NormalClosure,\n  dropPongFrames: Boolean = true,\n  decoderConfig: SocketDecoder = SocketDecoder.default,\n)\n"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"subprotocols"}),": Optional sub-protocol for WebSocket communication. This is an optional feature in WebSocket communication that allows the client and server to negotiate and agree upon a specific sub-protocol during the WebSocket handshake process."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"handshakeTimeoutMillis"}),": Timeout for the WebSocket handshake process, defaulting to 10 seconds (10,000 milliseconds). This parameter sets the maximum duration, in milliseconds, for completing the WebSocket handshake process. If the handshake exceeds this limit, the server aborts the connection attempt, ensuring timely resource management and handling of potential issues like unresponsive clients or network delays."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"forceCloseTimeoutMillis"}),": When a WebSocket connection is established, it remains open until either the client or the server explicitly closes it or until it times out due to inactivity. This parameter allows the server to set a timeout period after which it will forcibly close the WebSocket connection if no activity is detected within that time frame."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"handleCloseFrames"}),": When set to ",(0,o.jsx)(n.code,{children:"true"}),", indicates that close frames in WebSocket communication are solely handled by ZIO HTTP. If set to ",(0,o.jsx)(n.code,{children:"false"}),", it signifies that close frames should be forwarded instead of being solely managed by ZIO HTTP, which means that they're handled by the WebSocket application itself. This parameter allows for flexibility in how WebSocket close frames are managed, giving control over whether ZIO HTTP or the application handles them."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"sendCloseFrame"}),": This parameter which is type of ",(0,o.jsx)(n.code,{children:"WebSocketConfig.CloseStatus"}),", defines the close status to be sent when a close frame is not manually transmitted. This parameter allows the WebSocket server to specify the reason for closing the connection, such as indicating a normal closure or providing a custom close status code and reason. By default, if no close frame is sent manually, the server sends a close frame indicating a normal closure."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"dropPongFrames"}),": Determines whether the WebSocket server drops pong frames. If set to ",(0,o.jsx)(n.code,{children:"true"}),", pong frames are dropped, meaning the server does not respond to ping frames with pong frames. Conversely, setting it to ",(0,o.jsx)(n.code,{children:"false"})," means pong frames are not dropped, and the server responds to ping frames with pong frames, adhering to the WebSocket protocol's requirement for maintaining the connection's liveliness."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"decoderConfig"}),": This parameter allows for fine-grained control over the WebSocket frame decoding process, including settings such as the maximum frame payload length, whether to expect masked frames, whether to allow mask mismatch and so on. The ",(0,o.jsx)(n.code,{children:"SocketDecoder"})," case class contains all the configuration options for the WebSocket frame decoder:"]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"final case class SocketDecoder(\n  maxFramePayloadLength: Int = 65536,\n  expectMaskedFrames: Boolean = true,\n  allowMaskMismatch: Boolean = false,\n  allowExtensions: Boolean = false,\n  closeOnProtocolViolation: Boolean = true,\n  withUTF8Validator: Boolean = true,\n)\n"})}),"\n",(0,o.jsx)(n.h2,{id:"netty-configuration",children:"Netty Configuration"}),"\n",(0,o.jsxs)(n.p,{children:["In order to customize Netty-specific properties, the ",(0,o.jsx)(n.code,{children:"customized"})," layer can be used, providing not only ",(0,o.jsx)(n.code,{children:"Server.Config"}),"\nbut also ",(0,o.jsx)(n.code,{children:"NettyConfig"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"object Server {\n  val customized: ZLayer[Config & NettyConfig, Throwable, Server] = ???\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"NettyConfig"})," class provides a more low-level configuration, such as channel type, number of threads, shutdown quiet period, and shutdown timeout. Here is the full list of available configurations:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"final case class NettyConfig(\n  leakDetectionLevel: LeakDetectionLevel,\n  channelType: ChannelType,\n  nThreads: Int,\n  shutdownQuietPeriodDuration: Duration,\n  shutdownTimeoutDuration: Duration,\n)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The companion object of ",(0,o.jsx)(n.code,{children:"NettyConfig"})," class provides a default configuration that can be used as a starting point for custom configurations:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio.http.netty._\n\nval nettyConfig = NettyConfig.default.channelType(ChannelType.URING)\n"})}),"\n",(0,o.jsx)(n.p,{children:"Let's try an example server with a custom Netty configuration:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",metastring:'title="zio-http-example/src/main/scala/example/HelloWorldAdvanced.scala" ',children:'package example\n\nimport scala.util.Try\n\nimport zio._\n\nimport zio.http._\nimport zio.http.netty.NettyConfig\nimport zio.http.netty.NettyConfig.LeakDetectionLevel\n\nobject HelloWorldAdvanced extends ZIOAppDefault {\n  // Set a port\n  val PORT = 58080\n\n  val fooBar =\n    Routes(\n      Method.GET / "foo" -> Handler.from(Response.text("bar")),\n      Method.GET / "bar" -> Handler.from(Response.text("foo")),\n    )\n\n  val app = Routes(\n    Method.GET / "random" -> handler(Random.nextString(10).map(Response.text(_))),\n    Method.GET / "utc"    -> handler(Clock.currentDateTime.map(s => Response.text(s.toString))),\n  )\n\n  val run = ZIOAppArgs.getArgs.flatMap { args =>\n    // Configure thread count using CLI\n    val nThreads: Int = args.headOption.flatMap(x => Try(x.toInt).toOption).getOrElse(0)\n\n    val config           = Server.Config.default\n      .port(PORT)\n    val nettyConfig      = NettyConfig.default\n      .leakDetection(LeakDetectionLevel.PARANOID)\n      .maxThreads(nThreads)\n    val configLayer      = ZLayer.succeed(config)\n    val nettyConfigLayer = ZLayer.succeed(nettyConfig)\n\n    (fooBar ++ app)\n      .serve[Any]\n      .provide(configLayer, nettyConfigLayer, Server.customized)\n  }\n}\n'})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var r=t(96540);const o={},i=r.createContext(o);function s(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);