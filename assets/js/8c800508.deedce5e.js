"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[92977],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>c});var i=t(96540);const r={},a=i.createContext(r);function o(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(a.Provider,{value:n},e.children)}},74270:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>c,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"reference/service-pattern/service-pattern","title":"The Four Elements of Service Pattern","description":"Writing services in ZIO using the Service Pattern is very similar to the object-oriented way of defining services. We use scala traits to define services, classes to implement services, and constructors to define service dependencies. Finally, we lift the class constructor into the ZLayer.","source":"@site/docs/reference/service-pattern/service-pattern.md","sourceDirName":"reference/service-pattern","slug":"/reference/service-pattern/","permalink":"/reference/service-pattern/","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/service-pattern/service-pattern.md","tags":[],"version":"current","frontMatter":{"id":"service-pattern","title":"The Four Elements of Service Pattern","sidebar_label":"Service Pattern"},"sidebar":"reference-sidebar","previous":{"title":"Introduction to Writing ZIO Services","permalink":"/reference/service-pattern/introduction"},"next":{"title":"Polymorphic Services","permalink":"/reference/service-pattern/defining-polymorphic-services-in-zio"}}');var r=t(74848),a=t(28453);const o={id:"service-pattern",title:"The Four Elements of Service Pattern",sidebar_label:"Service Pattern"},c=void 0,s={},d=[{value:"1. Service Definition",id:"1-service-definition",level:2},{value:"2. Service Implementation",id:"2-service-implementation",level:2},{value:"3. Service Dependencies",id:"3-service-dependencies",level:2},{value:"4. ZLayer (Constructor)",id:"4-zlayer-constructor",level:2},{value:"Assembling the application",id:"assembling-the-application",level:2}];function l(e){const n={code:"code",em:"em",h2:"h2",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["Writing services in ZIO using the ",(0,r.jsx)(n.em,{children:"Service Pattern"})," is very similar to the object-oriented way of defining services. We use scala traits to define services, classes to implement services, and constructors to define service dependencies. Finally, we lift the class constructor into the ",(0,r.jsx)(n.code,{children:"ZLayer"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Let's start learning this service pattern by writing a ",(0,r.jsx)(n.code,{children:"DocRepo"})," service:"]}),"\n",(0,r.jsx)(n.h2,{id:"1-service-definition",children:"1. Service Definition"}),"\n",(0,r.jsxs)(n.p,{children:["Traits are how we define services. A service could be all the stuff that is related to one concept with singular responsibility. We define the service definition with a trait named ",(0,r.jsx)(n.code,{children:"DocRepo"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nfinal case class Doc(\n  title: String,\n  description: String,\n  language: String,\n  format: String,\n  content: Array[Byte]\n)\n\ntrait DocRepo {\n  def get(id: String): ZIO[Any, Throwable, Doc]\n\n  def save(document: Doc): ZIO[Any, Throwable, String]\n\n  def delete(id: String): ZIO[Any, Throwable, Unit]\n\n  def findByTitle(title: String): ZIO[Any, Throwable, List[Doc]]\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"2-service-implementation",children:"2. Service Implementation"}),"\n",(0,r.jsx)(n.p,{children:"It is the same as what we did in an object-oriented fashion. We implement the service with the Scala class:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"final class DocRepoLive() extends DocRepo {\n  override def get(id: String): ZIO[Any, Throwable, Doc] = ???\n\n  override def save(document: Doc): ZIO[Any, Throwable, String] = ???\n\n  override def delete(id: String): ZIO[Any, Throwable, Unit] = ???\n\n  override def findByTitle(title: String): ZIO[Any, Throwable, List[Doc]] = ???\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"3-service-dependencies",children:"3. Service Dependencies"}),"\n",(0,r.jsxs)(n.p,{children:["We might need ",(0,r.jsx)(n.code,{children:"MetadataRepo"})," and ",(0,r.jsx)(n.code,{children:"BlobStorage"})," services to implement the ",(0,r.jsx)(n.code,{children:"DocRepo"})," service. Here, we put its dependencies into its constructor. All the dependencies are just interfaces, not implementation. Just like what we did in object-oriented style."]}),"\n",(0,r.jsxs)(n.p,{children:["First, we need to define the interfaces for ",(0,r.jsx)(n.code,{children:"MetadataRepo"})," and ",(0,r.jsx)(n.code,{children:"BlobStorage"})," services:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"final case class Metadata(\n  title: String,\n  description: String,\n  language: String,\n  format: String\n)\n\ntrait MetadataRepo {\n  def get(id: String): ZIO[Any, Throwable, Metadata]\n\n  def put(id: String, metadata: Metadata): ZIO[Any, Throwable, Unit]\n\n  def delete(id: String): ZIO[Any, Throwable, Unit]\n\n  def findByTitle(title: String): ZIO[Any, Throwable, Map[String, Metadata]]\n}\n\ntrait BlobStorage {\n  def get(id: String): ZIO[Any, Throwable, Array[Byte]]\n\n  def put(content: Array[Byte]): ZIO[Any, Throwable, String]\n\n  def delete(id: String): ZIO[Any, Throwable, Unit]\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Now, we can implement the ",(0,r.jsx)(n.code,{children:"DocRepo"})," service:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"final class DocRepoLive(\n  metadataRepo: MetadataRepo,\n  blobStorage: BlobStorage\n) extends DocRepo {\n  override def get(id: String): ZIO[Any, Throwable, Doc] =\n    (metadataRepo.get(id) <&> blobStorage.get(id)).map {\n      case (metadata, content) =>\n        Doc(\n          title = metadata.title,\n          description = metadata.description,\n          language = metadata.language,\n          format = metadata.format,\n          content = content\n        )\n    }\n    \n  override def save(document: Doc): ZIO[Any, Throwable, String] =\n    for {\n      id       <- blobStorage.put(document.content)\n      metadata = Metadata(\n        title = document.title,\n        description = document.description,\n        language = document.language,\n        format = document.format\n      )\n      _        <- metadataRepo.put(id, metadata)\n    } yield id\n\n  override def delete(id: String): ZIO[Any, Throwable, Unit] = blobStorage.delete(id) &> metadataRepo.delete(id).unit\n\n  override def findByTitle(title: String): ZIO[Any, Throwable, List[Doc]] =\n    for {\n      metadatas <- metadataRepo.findByTitle(title)\n      content   <- ZIO.foreachPar(metadatas) { (id, metadata) =>\n                     blobStorage\n                       .get(id)\n                       .map { content =>\n                         val doc = Doc(\n                           title = metadata.title,\n                           description = metadata.description,\n                           language = metadata.language,\n                           format = metadata.format,\n                           content = content\n                         )\n                    \n                         id -> doc\n                       }\n                   }\n    } yield content.values.toList\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"4-zlayer-constructor",children:"4. ZLayer (Constructor)"}),"\n",(0,r.jsxs)(n.p,{children:["Now, we create a companion object for ",(0,r.jsx)(n.code,{children:"DocRepoLive"})," data type and lift the service implementation into the ",(0,r.jsx)(n.code,{children:"ZLayer"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'object DocRepo {\n  /**\n   * The "live" implementation of the `DocRepo` service.\n   */\n  val live: ZLayer[BlobStorage & MetadataRepo, Nothing, DocRepo] =\n    ZLayer {\n      for {\n        metadataRepo <- ZIO.service[MetadataRepo]\n        blobStorage  <- ZIO.service[BlobStorage]\n      } yield new DocRepoLive(metadataRepo, blobStorage)\n    }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["And voila! We have implemented the ",(0,r.jsx)(n.code,{children:"DocRepo"})," service using the ",(0,r.jsx)(n.em,{children:"Service Pattern"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"assembling-the-application",children:"Assembling the application"}),"\n",(0,r.jsxs)(n.p,{children:["Similarly, we need to implement the ",(0,r.jsx)(n.code,{children:"BlobStorage"})," and ",(0,r.jsx)(n.code,{children:"MetadataRepo"})," services:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"object InmemoryBlobStorage {\n  /**\n   * An in-memory implementation of the `BlobStorage` service.\n   */\n  val layer = \n    ZLayer {\n      ???\n    } \n}\n\nobject InmemoryMetadataRepo {\n  /**\n   * An in-memory implementation of the `MetadataRepo` service.\n   */\n  val layer = \n    ZLayer {\n      ???\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This is how ZIO services are created. Let's use the ",(0,r.jsx)(n.code,{children:"DocRepo"})," service in our application. We should provide ",(0,r.jsx)(n.code,{children:"DocRepo"})," layer to be able to run the application:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport java.io.IOException\n\nobject MainApp extends ZIOAppDefault {\n  val app =\n    for {\n      docRepo <- ZIO.service[DocRepo]\n      id      <- docRepo.save(\n                    Doc(\n                      "title",\n                      "description",\n                      "en",\n                      "text/plain",\n                      "content".getBytes()\n                    )\n                 )\n      doc     <- docRepo.get(id)\n      _       <- Console.printLine(\n                   s"""\n                     |Downloaded the document with $id id:\n                     |  title: ${doc.title}\n                     |  description: ${doc.description}\n                     |  language: ${doc.language}\n                     |  format: ${doc.format}\n                     |""".stripMargin\n                 )  \n      _       <- docRepo.delete(id)\n      _       <- Console.printLine(s"Deleted the document with $id id")\n    } yield ()\n\n  def run =\n    app.provide(\n      DocRepo.live,\n      InmemoryBlobStorage.layer,\n      InmemoryMetadataRepo.layer\n    )\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["During writing the application, we don't care which implementation version of the ",(0,r.jsx)(n.code,{children:"BlobStorage"})," and ",(0,r.jsx)(n.code,{children:"MetadataRepo"})," services will be injected into our ",(0,r.jsx)(n.code,{children:"app"}),". Later at the end of the day, it will be provided by one of ",(0,r.jsx)(n.code,{children:"ZIO#provide*"})," methods."]}),"\n",(0,r.jsx)(n.p,{children:"That's it! Very simple! ZIO encourages us to follow some of the best practices in object-oriented programming. So it doesn't require us to throw away all our object-oriented knowledge."})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}}}]);