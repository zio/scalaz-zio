"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[54701],{28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>l});var a=i(96540);const r={},t=a.createContext(r);function o(e){const n=a.useContext(t);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),a.createElement(t.Provider,{value:n},e.children)}},28978:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>f,frontMatter:()=>o,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"reference/error-management/recovering/fallback","title":"Fallback","description":"ZIO#orElse","source":"@site/docs/reference/error-management/recovering/fallback.md","sourceDirName":"reference/error-management/recovering","slug":"/reference/error-management/recovering/fallback","permalink":"/reference/error-management/recovering/fallback","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/error-management/recovering/fallback.md","tags":[],"version":"current","frontMatter":{"id":"fallback","title":"Fallback","sidebar_label":"2. Fallback"},"sidebar":"reference-sidebar","previous":{"title":"1. Catching","permalink":"/reference/error-management/recovering/catching"},"next":{"title":"3. Folding","permalink":"/reference/error-management/recovering/folding"}}');var r=i(74848),t=i(28453);const o={id:"fallback",title:"Fallback",sidebar_label:"2. Fallback"},l=void 0,s={},c=[{value:"<code>ZIO#orElse</code>",id:"zioorelse",level:2},{value:"<code>ZIO#orElseEither</code>",id:"zioorelseeither",level:2},{value:"<code>ZIO#orElseSucceed</code>/<code>ZIO#orElseFail</code>",id:"zioorelsesucceedzioorelsefail",level:2},{value:"<code>ZIO#orElseOptional</code>",id:"zioorelseoptional",level:2},{value:"<code>ZIO.firstSuccessOf</code>/<code>ZIO#firstSuccessOf</code>",id:"ziofirstsuccessofziofirstsuccessof",level:2}];function d(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"zioorelse",children:(0,r.jsx)(n.code,{children:"ZIO#orElse"})}),"\n",(0,r.jsxs)(n.p,{children:["We can try one effect, or if it fails, try another effect with the ",(0,r.jsx)(n.code,{children:"orElse"})," combinator:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"trait ZIO[-R, +E, +A] {\n  def orElse[R1 <: R, E2, A1 >: A](that: => ZIO[R1, E2, A1]): ZIO[R1, E2, A1]\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Let's try an example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport java.io.IOException\n\nval primaryOrBackupData: ZIO[Any, IOException, Array[Byte]] =\n  readFile("primary.data").orElse(readFile("backup.data"))\n'})}),"\n",(0,r.jsx)(n.h2,{id:"zioorelseeither",children:(0,r.jsx)(n.code,{children:"ZIO#orElseEither"})}),"\n",(0,r.jsx)(n.p,{children:"If the original effect fails, this operator tries another effect, and as a result, returns either:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"trait ZIO[-R, +E, +A] {\n  def orElseEither[R1 <: R, E2, B](that: => ZIO[R1, E2, B]): ZIO[R1, E2, Either[A, B]]\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This operator is useful when the fallback effect has a different result type than the original effect. So this will unify both in the ",(0,r.jsx)(n.code,{children:"Either[A, B]"})," data type. Here is an example usage of this operator:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"import zio._\n\ntrait LocalConfig\ntrait RemoteConfig\n\ndef readLocalConfig: ZIO[Any, Throwable, LocalConfig] = ???\ndef readRemoteConfig: ZIO[Any, Throwable, RemoteConfig] = ???\n\nval result: ZIO[Any, Throwable, Either[LocalConfig, RemoteConfig]] =\n  readLocalConfig.orElseEither(readRemoteConfig)\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"zioorelsesucceedzioorelsefail",children:[(0,r.jsx)(n.code,{children:"ZIO#orElseSucceed"}),"/",(0,r.jsx)(n.code,{children:"ZIO#orElseFail"})]}),"\n",(0,r.jsx)(n.p,{children:"These two operators convert the original failure with constant succeed or failure values:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"trait ZIO[-R, +R, +E] {\n  def orElseFail[E1](e1: => E1): ZIO[R, E1, A]\n\n  def orElseSucceed[A1 >: A](a1: => A1): ZIO[R, Nothing, A1]\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"ZIO#orElseFail"})," will always replace the original failure with the new one, so ",(0,r.jsx)(n.code,{children:"E1"})," does not have to be a supertype of ",(0,r.jsx)(n.code,{children:"E"}),". It is useful when we have ",(0,r.jsx)(n.code,{children:"Unit"})," as an error, and we want to unify that with something else:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nsealed trait AgeValidationException extends Exception\ncase class NegativeAgeException(age: Int) extends AgeValidationException\ncase class IllegalAgeException(age: Int)  extends AgeValidationException\n\ndef validate(age: Int): ZIO[Any, AgeValidationException, Int] = {\n  if (age < 0)\n    ZIO.fail(NegativeAgeException(age))\n  else if (age < 18)\n    ZIO.fail(IllegalAgeException(age))\n  else ZIO.succeed(age)\n}\n\nval result: ZIO[Any, String, Int] =\n  validate(3).orElseFail("invalid age")\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"ZIO#orElseSucceed"})," will always replace the original failure with a success value so the resulting effect cannot fail. It is useful when we have a constant value that will work in case the effect fails:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"val result: ZIO[Any, Nothing, Int] =\n  validate(3).orElseSucceed(0)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"zioorelseoptional",children:(0,r.jsx)(n.code,{children:"ZIO#orElseOptional"})}),"\n",(0,r.jsxs)(n.p,{children:["When dealing with optional failure types, we might need to fall back to another effect when the failure value is ",(0,r.jsx)(n.code,{children:"None"}),". This operator helps to do so:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"trait ZIO[-R, +E, +A] {\n  def orElseOptional[R1 <: R, E1, A1 >: A](\n      that: => ZIO[R1, Option[E1], A1]\n    )(implicit ev: E IsSubtypeOfError Option[E1]): ZIO[R1, Option[E1], A1] =\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In the following example, the ",(0,r.jsx)(n.code,{children:'parseInt(" ")'})," fails with ",(0,r.jsx)(n.code,{children:"None"}),", so then the fallback effect results in a zero:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio._\n\ndef parseInt(input: String): ZIO[Any, Option[String], Int] =\n  input.toIntOption match {\n    case Some(value) => ZIO.succeed(value)\n    case None =>\n      if (input.trim.isEmpty)\n        ZIO.fail(None)\n      else\n        ZIO.fail(Some(s"invalid non-integer input: $input"))\n  }\n\nval result = parseInt("  ").orElseOptional(ZIO.succeed(0)).debug\n'})}),"\n",(0,r.jsxs)(n.h2,{id:"ziofirstsuccessofziofirstsuccessof",children:[(0,r.jsx)(n.code,{children:"ZIO.firstSuccessOf"}),"/",(0,r.jsx)(n.code,{children:"ZIO#firstSuccessOf"})]}),"\n",(0,r.jsx)(n.p,{children:"These two operators make it easy for a user to run an effect, and in case it fails, it will run a series of ZIO effects until one succeeds:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"object ZIO {\n  def firstSuccessOf[R, R1 <: R, E, A](\n    zio: => ZIO[R, E, A],\n    rest: => Iterable[ZIO[R1, E, A]]\n  ): ZIO[R1, E, A] =\n}\n\ntrait ZIO[-R, +E, +A] {\n  final def firstSuccessOf[R1 <: R, E1 >: E, A1 >: A](\n    rest: => Iterable[ZIO[R1, E1, A1]]\n  ): ZIO[R1, E1, A1]\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["These methods use ",(0,r.jsx)(n.code,{children:"orElse"})," to reduce the non-empty iterable of effects into a single effect."]}),"\n",(0,r.jsx)(n.p,{children:"In the following example, we are trying to get the config from the master node, and if it fails, we will try successively to retrieve the config from the next available node:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio._\n\ntrait Config\n\ndef remoteConfig(name: String): ZIO[Any, Throwable, Config] =\n  ZIO.attempt(???)\n\nval masterConfig: ZIO[Any, Throwable, Config] =\n  remoteConfig("master")\n\nval nodeConfigs: Seq[ZIO[Any, Throwable, Config]] =\n  List("node1", "node2", "node3", "node4").map(remoteConfig)\n\nval config: ZIO[Any, Throwable, Config] =\n  ZIO.firstSuccessOf(masterConfig, nodeConfigs)\n'})})]})}function f(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);