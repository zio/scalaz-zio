"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[37908],{28453:(e,o,n)=>{n.d(o,{R:()=>a,x:()=>c});var r=n(96540);const t={},s=r.createContext(t);function a(e){const o=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function c(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(s.Provider,{value:o},e.children)}},96110:(e,o,n)=>{n.r(o),n.d(o,{assets:()=>i,contentTitle:()=>c,default:()=>u,frontMatter:()=>a,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"zio-schema/derivations/codecs/protobuf","title":"Protobuf Codecs","description":"Introduction","source":"@site/docs/zio-schema/derivations/codecs/protobuf.md","sourceDirName":"zio-schema/derivations/codecs","slug":"/zio-schema/derivations/codecs/protobuf","permalink":"/zio-schema/derivations/codecs/protobuf","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-schema/derivations/codecs/protobuf.md","tags":[],"version":"current","frontMatter":{"id":"protobuf","title":"Protobuf Codecs","sidebar_label":"Protobuf"},"sidebar":"ecosystem-sidebar","previous":{"title":"MessagePack","permalink":"/zio-schema/derivations/codecs/message-pack"},"next":{"title":"Mapping DTO to Domain Object","permalink":"/zio-schema/examples/mapping-dto-to-domain-object"}}');var t=n(74848),s=n(28453);const a={id:"protobuf",title:"Protobuf Codecs",sidebar_label:"Protobuf"},c=void 0,i={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Installation",id:"installation",level:2},{value:"BinaryCodec",id:"binarycodec",level:2},{value:"Example: Streaming Codecs",id:"example-streaming-codecs",level:2}];function l(e){const o={code:"code",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(o.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsx)(o.p,{children:"Protocol Buffers (protobuf) is a binary serialization format developed by Google. It is designed for efficient data exchange between different systems and languages. In this article, we will explore how to derive Protobuf codecs from a ZIO Schema. Protobuf codecs allow us to easily serialize and deserialize data in Protobuf format, making it simple to interact with APIs and data sources that use Protobuf as their data format."}),"\n",(0,t.jsx)(o.h2,{id:"installation",children:"Installation"}),"\n",(0,t.jsx)(o.p,{children:"To start using Protobuf codecs in ZIO, you need to add the following dependency to your build.sbt file:"}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-scala",children:'libraryDependencies += "dev.zio" %% "zio-schema-protobuf" % "1.6.2"\n'})}),"\n",(0,t.jsx)(o.h2,{id:"binarycodec",children:"BinaryCodec"}),"\n",(0,t.jsxs)(o.p,{children:["The ",(0,t.jsx)(o.code,{children:"ProtobufCodec"})," object inside the ",(0,t.jsx)(o.code,{children:"zio.schema.codec"})," package provides the ",(0,t.jsx)(o.code,{children:"protobufCodec"})," operator which allows us to derive Protobuf codecs from a ZIO Schema:"]}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-scala",children:"object ProtobufCodec {\n  implicit def protobufCodec[A](implicit schema: Schema[A]): BinaryCodec[A] = ???\n}\n"})}),"\n",(0,t.jsxs)(o.p,{children:["Optionally the ",(0,t.jsx)(o.code,{children:"@fieldNumber(1)"})," annotation can be used on fields to specify the field number for a case class field. This together with default values\ncan be used to keep binary compatibility when evolving schemas. Default field numbers are indexed starting from 1."]}),"\n",(0,t.jsx)(o.p,{children:"For example considering the following three versions of a record:"}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-scala",children:'final case class RecordV1(x: Int, y: Int)\nfinal case class RecordV2(x: Int = 100, y: Int, z: Int)\nfinal case class RecordV3(@fieldNumber(2) y: Int, @fieldNumber(4) extra: String = "unknown", @fieldNumber(3) z: Int)\n'})}),"\n",(0,t.jsx)(o.p,{children:"The decoder of V1 can decode a binary encoded by V2, but cannot decode a binary encoded by V3 because it does not have a field number 1 (x).\nThe decoder of V2 can decode a binary encoded by V3 because it has a default value for field number 1 (x), 100. The decoder of V3 can read V2 but\ncannot read V1 (as it does not have field number 3 (z)). As demonstrated, using explicit field numbers also allows reordering the fields without\nbreaking the format."}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-scala",children:'\n## Example: BinaryCodec\n\nLet\'s try an example:\n\n```scala mdoc:compile-only\nimport zio._\nimport zio.schema.codec._\nimport zio.schema.{DeriveSchema, Schema}\n\ncase class Person(name: String, age: Int)\n\nobject Person {\n  implicit val schema       : Schema[Person]      =\n    DeriveSchema.gen\n  implicit val protobufCodec: BinaryCodec[Person] =\n    ProtobufCodec.protobufCodec(schema)\n}\n\nobject Main extends ZIOAppDefault {\n  def run = for {\n    _ <- ZIO.debug("Protobuf Codec Example:")\n    person: Person = Person("John", 42)\n    encoded: Chunk[Byte] = Person.protobufCodec.encode(person)\n    _ <- ZIO.debug(\n      s"person object encoded to Protobuf\'s binary format: ${toHex(encoded)}"\n    )\n    decoded <- ZIO.fromEither(Person.protobufCodec.decode(encoded))\n    _ <- ZIO.debug(s"Protobuf object decoded to Person class: $decoded")\n  } yield ()\n\n  def toHex(bytes: Chunk[Byte]): String =\n    bytes.map("%02x".format(_)).mkString(" ")\n}\n'})}),"\n",(0,t.jsx)(o.p,{children:"Here is the output of running the above program:"}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-scala",children:"Protobuf Codec Example:\nperson object encoded to Protobuf's binary format: 0a 04 4a 6f 68 6e 10 2a\nProtobuf object decoded to Person class: Person(John,42)\n"})}),"\n",(0,t.jsx)(o.h2,{id:"example-streaming-codecs",children:"Example: Streaming Codecs"}),"\n",(0,t.jsx)(o.p,{children:"The following example shows how to use Protobuf codecs to encode and decode streams of data:"}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-scala",children:'import zio._\nimport zio.schema.codec.{BinaryCodec, ProtobufCodec}\nimport zio.schema.{DeriveSchema, Schema}\nimport zio.stream.ZStream\n\ncase class Person(name: String, age: Int)\n\nobject Person {\n  implicit val schema: Schema[Person] =\n    DeriveSchema.gen\n  implicit val protobufCodec: BinaryCodec[Person] =\n    ProtobufCodec.protobufCodec(schema)\n}\n\nobject Main extends ZIOAppDefault {\n\n  def run = for {\n    _ <- ZIO.debug("Protobuf Stream Codecs Example:")\n    person = Person("John", 42)\n\n    personToProto = Person.protobufCodec.streamEncoder\n    protoToPerson = Person.protobufCodec.streamDecoder\n\n    newPerson <- ZStream(person)\n      .via(personToProto)\n      .via(protoToPerson)\n      .runHead\n      .some\n      .catchAll(error => ZIO.debug(error))\n    _ <- ZIO.debug(\n      "is old person the new person? " + (person == newPerson).toString\n    )\n    _ <- ZIO.debug("old person: " + person)\n    _ <- ZIO.debug("new person: " + newPerson)\n  } yield ()\n}\n'})}),"\n",(0,t.jsx)(o.p,{children:"The output of running the above program is:"}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-scala",children:"Protobuf Stream Codecs Example:\nis old person the new person? true\nold person: Person(John,42)\nnew person: Person(John,42)\n"})})]})}function u(e={}){const{wrapper:o}={...(0,s.R)(),...e.components};return o?(0,t.jsx)(o,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}}}]);