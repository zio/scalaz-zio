"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[1801],{28453:(e,n,a)=>{a.d(n,{R:()=>t,x:()=>s});var o=a(96540);const i={},r=o.createContext(i);function t(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),o.createElement(r.Provider,{value:n},e.children)}},95377:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>t,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"reference/di/manual-layer-construction","title":"Manual Layer Construction","description":"We said that we can think of the ZLayer as a more powerful constructor. Constructors are not composable, because they are not values. While a constructor is not composable, ZLayer has a nice facility to compose with other ZLayers. So we can say that a ZLayer turns a constructor into values.","source":"@site/docs/reference/di/manual-layer-construction.md","sourceDirName":"reference/di","slug":"/reference/di/manual-layer-construction","permalink":"/reference/di/manual-layer-construction","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/di/manual-layer-construction.md","tags":[],"version":"current","frontMatter":{"id":"manual-layer-construction","title":"Manual Layer Construction"},"sidebar":"reference-sidebar","previous":{"title":"Building Dependency Graph","permalink":"/reference/di/building-dependency-graph"},"next":{"title":"Automatic Layer Construction","permalink":"/reference/di/automatic-layer-construction"}}');var i=a(74848),r=a(28453);const t={id:"manual-layer-construction",title:"Manual Layer Construction"},s=void 0,l={},c=[{value:"Vertical and Horizontal Composition",id:"vertical-and-horizontal-composition",level:2},{value:"Horizontal Composition",id:"horizontal-composition",level:3},{value:"Vertical Composition",id:"vertical-composition",level:3},{value:"Hidden Versus Passed-through Dependencies",id:"hidden-versus-passed-through-dependencies",level:2},{value:"Updating Local Dependencies",id:"updating-local-dependencies",level:2},{value:"Cyclic Dependencies",id:"cyclic-dependencies",level:2}];function d(e){const n={admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["We said that we can think of the ",(0,i.jsx)(n.code,{children:"ZLayer"})," as a more powerful ",(0,i.jsx)(n.em,{children:"constructor"}),". Constructors are not composable, because they are not values. While a constructor is not composable, ",(0,i.jsx)(n.code,{children:"ZLayer"})," has a nice facility to compose with other ",(0,i.jsx)(n.code,{children:"ZLayer"}),"s. So we can say that a ",(0,i.jsx)(n.code,{children:"ZLayer"})," turns a constructor into values."]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["In a regular ZIO application we are not required to build the dependency graph through composing layers tougher. Instead, we can provide all dependencies to the ZIO application using ",(0,i.jsx)(n.code,{children:"ZIO#provide"}),", and the ZIO will create the dependency graph manually under the hood. Therefore, use manual layer composition if you know what you're doing."]})}),"\n",(0,i.jsx)(n.h2,{id:"vertical-and-horizontal-composition",children:"Vertical and Horizontal Composition"}),"\n",(0,i.jsxs)(n.p,{children:["Assume we have several services with their dependencies, and we need a way to compose and wire up these dependencies to create the dependency graph of our application. ",(0,i.jsx)(n.code,{children:"ZLayer"})," is a ZIO solution for this problem, it allows us to build up the whole application dependency graph by composing layers horizontally and vertically."]}),"\n",(0,i.jsx)(n.h3,{id:"horizontal-composition",children:"Horizontal Composition"}),"\n",(0,i.jsxs)(n.p,{children:["Layers can be composed together horizontally with the ",(0,i.jsx)(n.code,{children:"++"})," operator. When we compose layers horizontally, the new layer requires all the services that both of them require and produces all services that both of them produce. Horizontal composition is a way of composing two layers side-by-side. It is useful when we combine two layers that don't have any relationship with each other."]}),"\n",(0,i.jsxs)(n.p,{children:["We can compose ",(0,i.jsx)(n.code,{children:"fooLayer"})," and ",(0,i.jsx)(n.code,{children:"barLayer"})," ",(0,i.jsx)(n.em,{children:"horizontally"})," to build a layer that has the requirements of both, to provide the capabilities of both, through ",(0,i.jsx)(n.code,{children:"fooLayer ++ barLayer"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nval fooLayer: ZLayer[A, Throwable, B] = ???        // A ==> B\nval barLayer: ZLayer[C, Nothing  , D] = ???        // C ==> D\n\nval horizontal: ZLayer[A & C, Throwable, B & D] =  // A & C ==> B & D\n  fooLayer ++ barLayer\n"})}),"\n",(0,i.jsx)(n.h3,{id:"vertical-composition",children:"Vertical Composition"}),"\n",(0,i.jsxs)(n.p,{children:["We can also compose layers ",(0,i.jsx)(n.em,{children:"vertically"})," using the ",(0,i.jsx)(n.code,{children:">>>"})," operator, meaning the output of one layer is used as input for the subsequent layer, resulting in one layer with the requirement of the first, and the output of the second."]}),"\n",(0,i.jsxs)(n.p,{children:["For example if we have a layer that requires ",(0,i.jsx)(n.code,{children:"A"})," and produces ",(0,i.jsx)(n.code,{children:"B"}),", we can compose this with another layer that requires ",(0,i.jsx)(n.code,{children:"B"})," and produces ",(0,i.jsx)(n.code,{children:"C"}),"; this composition produces a layer that requires ",(0,i.jsx)(n.code,{children:"A"})," and produces ",(0,i.jsx)(n.code,{children:"C"}),". The feed operator, ",(0,i.jsx)(n.code,{children:">>>"}),", stack them on top of each other by using vertical composition. This sort of composition is like ",(0,i.jsx)(n.em,{children:"function composition"}),", feeding an output of one layer to an input of another:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nval fooLayer: ZLayer[A, Throwable, B] = ???  // A ==> B\nval barLayer: ZLayer[B, Nothing  , C] = ???  // B ==> C\n\nval horizontal: ZLayer[A, Throwable, C] =    // A ==> C\n  fooLayer >>> barLayer\n"})}),"\n",(0,i.jsx)(n.h2,{id:"hidden-versus-passed-through-dependencies",children:"Hidden Versus Passed-through Dependencies"}),"\n",(0,i.jsxs)(n.p,{children:["ZLayer has a ",(0,i.jsx)(n.code,{children:"passthrough"})," operator which returns a new layer that produces the outputs of this layer but also passes-through the inputs:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nval fooLayer: ZLayer[A, Nothing, B] = ???  // A ==> B\n\nval result1 : ZLayer[A, Nothing, A & B] =  // A ==> A & B\n  fooLayer.passthrough\n  \nval result2 : ZLayer[A, Nothing, A & B] =  // A ==> A & B\n  ZLayer.service[A] ++ fooLayer\n \n// (A ==> A) ++ (A ==> B)\n// (A ==> A & B)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["By default, the ",(0,i.jsx)(n.code,{children:"ZLayer"})," hides intermediate dependencies when composing vertically. For example, when we compose ",(0,i.jsx)(n.code,{children:"fooLayer"})," with ",(0,i.jsx)(n.code,{children:"barLayer"})," vertically, the output would be a ",(0,i.jsx)(n.code,{children:"ZLayer[A, Throwable, C]"}),". This hides the dependency on the ",(0,i.jsx)(n.code,{children:"B"})," layer. By using the above technique, we can pass through hidden dependencies."]}),"\n",(0,i.jsxs)(n.p,{children:["Let's include the ",(0,i.jsx)(n.code,{children:"B"})," service into the upstream dependencies of the final layer using the ",(0,i.jsx)(n.code,{children:"ZIO.service[B]"}),". We can think of ",(0,i.jsx)(n.code,{children:"ZIO.service[B]"})," as an ",(0,i.jsx)(n.em,{children:"identity function"})," (",(0,i.jsx)(n.code,{children:"B ==> B"}),")."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nval fooLayer: ZLayer[A, Throwable, B] = ???  // A  ==> B\nval barLayer: ZLayer[B, Throwable, C] = ???  // B  ==> C\n\nval finalLayer: ZLayer[A & B, Throwable, C] = // A & B ==> C\n  (fooLayer ++ ZLayer.service[B]) >>> barLayer\n\n// ((A ==> B) ++ (B ==> B)) >>> (B ==> C)\n// (A & B ==> B) >> (B ==> C)\n// (A & B ==> C)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Or we may want to include the middle services in the output channel of the final layer, resulting in a new layer with the inputs of the first layer and the outputs of both layers:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nval fooLayer: ZLayer[A, Throwable, B] = ??? // A  ==> B\nval barLayer: ZLayer[B, Throwable, C] = ??? // B  ==> C\n\nval finalLayer: ZLayer[A, Throwable, B & C] = // A ==> B & C\n  fooLayer >>> (ZLayer.service[B] ++ barLayer)\n  \n// (A ==> B) >>> ((B ==> B) ++ (B ==> C))\n// (A ==> B) >>> (B ==> B & C)\n// (A ==> B & C)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["We can do the same with the ",(0,i.jsx)(n.code,{children:">+>"})," operator:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nval fooLayer: ZLayer[A, Throwable, B] = ??? // A  ==> B\nval barLayer: ZLayer[B, Throwable, C] = ??? // B  ==> C\n\nval finalLayer: ZLayer[A, Throwable, B & C] = // A ==> B & C\n  fooLayer >+> barLayer\n"})}),"\n",(0,i.jsx)(n.p,{children:"This technique is useful when we want to defer the creation of some intermediate services and require them as part of the input of the final layer. For example, assume we have these two layers:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nval fooLayer: ZLayer[A    , Throwable, B] = ???   // A     ==> B\nval barLayer: ZLayer[B & C, Throwable, D] = ???   // B & C ==> D\n\nval finalLayer: ZLayer[A & C, Throwable, D] = // A & C ==> B & D\n  fooLayer >>> barLayer\n"})}),"\n",(0,i.jsxs)(n.p,{children:["So we can defer the creation of the ",(0,i.jsx)(n.code,{children:"C"})," layer using ",(0,i.jsx)(n.code,{children:"ZLayer.service[C]"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nval fooLayer: ZLayer[A    , Throwable, B] = ??? // A ==> B \nval barLayer: ZLayer[B & C, Throwable, D] = ??? // B & C ==> D\n\nval layer: ZLayer[A & C, Throwable, D] =        // A & C ==> D\n  (fooLayer ++ ZLayer.service[C]) >>> barLayer\n\n// ((A ==> B) ++ (C ==> C)) >>> (B & C ==> D)\n// (A & C ==> B & C) >>> (B & C ==> D)\n// (A & C ==> D)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Here is an example in which we passthrough all requirements to bake a ",(0,i.jsx)(n.code,{children:"Cake"})," so all the requirements are available to all the downstream services:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"import zio._\n\ntrait Baker \ntrait Ingredients\ntrait Oven\ntrait Dough\ntrait Cake\n\nlazy val baker      : ZLayer[Any, Nothing, Baker] = ???\nlazy val ingredients: ZLayer[Any, Nothing, Ingredients] = ???\nlazy val oven       : ZLayer[Any, Nothing, Oven] = ???\nlazy val dough      : ZLayer[Baker & Ingredients, Nothing, Dough] = ???\nlazy val cake       : ZLayer[Baker & Oven & Dough, Nothing, Cake] = ???\n\nlazy val all: ZLayer[Any, Nothing, Baker & Ingredients & Oven & Dough & Cake] =\n  baker >+>       // Baker\n  ingredients >+> // Baker & Ingredients\n  oven >+>        // Baker & Ingredients & Oven\n  dough >+>       // Baker & Ingredients & Oven & Dough\n  cake            // Baker & Ingredients & Oven & Dough & Cake\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This allows a style of composition where the ",(0,i.jsx)(n.code,{children:">+>"})," operator is used to build a progressively larger set of services, with each new service able to depend on all the services before it. If we passthrough dependencies and later want to hide them we can do so through a simple type ascription:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"lazy val hidden: ZLayer[Any, Nothing, Cake] = all\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"ZLayer"})," makes it easy to mix and match these styles. If we build our dependency graph more explicitly, we can be confident that dependencies used in multiple parts of the dependency graph will only be created once due to memoization and sharing."]}),"\n",(0,i.jsx)(n.p,{children:"Using these simple operators we can build complex dependency graphs."}),"\n",(0,i.jsx)(n.h2,{id:"updating-local-dependencies",children:"Updating Local Dependencies"}),"\n",(0,i.jsx)(n.p,{children:"Given a layer, it is possible to update one or more components it provides. We update a dependency in two ways:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["Using the ",(0,i.jsx)(n.code,{children:"update"})," Method"]})," \u2014 This method allows us to replace one requirement with a different implementation:"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nval origin: ZLayer[Any, Nothing, String & Int & Double] = \n  ZLayer.succeedEnvironment(ZEnvironment[String, Int, Double]("foo", 123, 1.3))\n\nval updated1 = origin.update[String](_ + "bar")\nval updated2 = origin.update[Int](_ + 5)\nval updated3 = origin.update[Double](_ - 0.3)\n'})}),"\n",(0,i.jsx)(n.p,{children:"Here is an example of updating a config layer:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nimport java.io.IOException\n\ncase class AppConfig(poolSize: Int)\n\nobject MainApp extends ZIOAppDefault {\n\n  val myApp: ZIO[AppConfig, IOException, Unit] =\n    for {\n      config <- ZIO.service[AppConfig]\n      _ <- Console.printLine(s"Application config after the update operation: $config")\n    } yield ()\n\n\n  val appLayers: ZLayer[Any, Nothing, AppConfig] =\n    ZLayer(ZIO.succeed(AppConfig(5)).debug("Application config initialized"))\n\n  val updatedConfig: ZLayer[Any, Nothing, AppConfig] =\n    appLayers.update[AppConfig](c =>\n      c.copy(poolSize = c.poolSize + 10)\n    )\n\n  def run = myApp.provide(updatedConfig)\n}\n\n// Output:\n// Application config initialized: AppConfig(5)\n// Application config after the update operation: AppConfig(15)\n'})}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Using Horizontal Composition"})," \u2014 Another way to update a requirement is to horizontally compose in a layer that provides the updated service. The resulting composition will replace the old layer with the new one:"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nval origin: ZLayer[Any, Nothing, String & Int & Double] =\n  ZLayer.succeedEnvironment(ZEnvironment[String, Int, Double]("foo", 123, 1.3))\n\nval updated = origin ++ ZLayer.succeed(321)\n'})}),"\n",(0,i.jsx)(n.p,{children:"Let's see an example of updating a config layer:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nimport java.io.IOException\n\ncase class AppConfig(poolSize: Int)\n\nobject MainApp extends ZIOAppDefault {\n\n  val myApp: ZIO[AppConfig, IOException, Unit] =\n    for {\n      config <- ZIO.service[AppConfig]\n      _      <- Console.printLine(s"Application config after the update operation: $config")\n    } yield ()\n\n\n  val appLayers: ZLayer[Any, Nothing, AppConfig] =\n    ZLayer(ZIO.succeed(AppConfig(5)).debug("Application config initialized"))\n\n  val updatedConfig: ZLayer[Any, Nothing, AppConfig] =\n    appLayers ++ ZLayer.succeed(AppConfig(8))\n\n  def run = myApp.provide(updatedConfig)\n}\n// Output:\n// Application config initialized: AppConfig(5)\n// Application config after the update operation: AppConfig(8)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"cyclic-dependencies",children:"Cyclic Dependencies"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"ZLayer"})," mechanism makes it impossible to build cyclic dependencies, making the initialization process very linear, by construction."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);