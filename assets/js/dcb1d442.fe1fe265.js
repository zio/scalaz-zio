"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[55081],{54256:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"zio-dynamodb/reference/hi-level-api/creating-models/field-traversal","title":"Field Traversal","description":"We will be using the below model for the examples which contains a complex collection field hobbies and a nested case","source":"@site/docs/zio-dynamodb/reference/hi-level-api/creating-models/field-traversal.md","sourceDirName":"zio-dynamodb/reference/hi-level-api/creating-models","slug":"/zio-dynamodb/reference/hi-level-api/creating-models/field-traversal","permalink":"/zio-dynamodb/reference/hi-level-api/creating-models/field-traversal","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-dynamodb/reference/hi-level-api/creating-models/field-traversal.md","tags":[],"version":"current","frontMatter":{"id":"field-traversal","title":"Field Traversal"},"sidebar":"ecosystem-sidebar","previous":{"title":"Creating Models","permalink":"/zio-dynamodb/reference/hi-level-api/creating-models/"},"next":{"title":"CRUD Operations","permalink":"/zio-dynamodb/reference/hi-level-api/crud-operations/"}}');var i=s(74848),t=s(28453);const o={id:"field-traversal",title:"Field Traversal"},a=void 0,l={},c=[{value:"<code>ProjectionExpression</code> field traversal combinators",id:"projectionexpression-field-traversal-combinators",level:2},{value:"Product traversal",id:"product-traversal",level:2},{value:"Sum type traversal",id:"sum-type-traversal",level:2}];function d(e){const n={code:"code",em:"em",h2:"h2",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["We will be using the below model for the examples which contains a complex collection field ",(0,i.jsx)(n.code,{children:"hobbies"})," and a nested case\nclass field ",(0,i.jsx)(n.code,{children:"address"}),". Note that ZIO DynamoDB also supports case classes as collection elements (not shown in this example)."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"final case class Address(number: String, street: String)\nobject Address {\n  implicit lazy val schema: Schema.CaseClass2[String, String, Address] = DeriveSchema.gen[Address]\n\n  // (1) number and street are ProjectionExpressions\n  val (number, street) = ProjectionExpression.accessors[Address]\n}\nfinal case class Person(email: String, hobbies: Map[String, List[String]], address: Address)\nobject Person {\n  implicit lazy val schema: Schema.CaseClass3[String, Map[String, List[String]], Address, Person] = DeriveSchema.gen[Person]\n\n  // (2) email, hobbies and address are ProjectionExpressions\n  val (email, hobbies, address) = ProjectionExpression.accessors[Person]\n}\n"})}),"\n",(0,i.jsxs)(n.h2,{id:"projectionexpression-field-traversal-combinators",children:[(0,i.jsx)(n.code,{children:"ProjectionExpression"})," field traversal combinators"]}),"\n",(0,i.jsxs)(n.p,{children:["DynamoDB allows us to dig into nested structures when updating or querying data using path expressions. Using the High Level API we do this in a ",(0,i.jsx)(n.em,{children:"type safe"})," way by\nusing the ",(0,i.jsx)(n.code,{children:"ProjectionExpression"}),"'s generated by the ",(0,i.jsx)(n.code,{children:"accessors"})," method (see comments ",(0,i.jsx)(n.code,{children:"1"})," and ",(0,i.jsx)(n.code,{children:"2"})," above) as springboard\nfor a bunch of traversal combinators. Note the ",(0,i.jsx)(n.code,{children:"accessors"})," method in turn uses the reified optics feature of ZIO Schema."]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Traversal Combinator"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:">>>"})}),(0,i.jsxs)(n.td,{children:["Returns a ",(0,i.jsx)(n.code,{children:"ProjectionExpression"})," that traverses into a ",(0,i.jsx)(n.strong,{children:"product"})," (case class) or a ",(0,i.jsx)(n.strong,{children:"sum"})," type (sealed trait concrete instance)"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"valueAt(key)"})}),(0,i.jsxs)(n.td,{children:["Returns a ",(0,i.jsx)(n.code,{children:"ProjectionExpression"})," that traverses into a map field using a string key"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"elementAt(N)"})}),(0,i.jsxs)(n.td,{children:["Returns a ",(0,i.jsx)(n.code,{children:"ProjectionExpression"})," that traverses into a list field using a zero based index"]})]})]})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'  val person                                                             =\n    Person("john@gmail.com", Map("sports" -> List("cricket", "football")), Address("1", "Main St"))\n\n  // ProjectionExpressions extracted deliberately to illustrate the types\n  val addressToStreetPE: ProjectionExpression[Person, String]            =\n    (Person.address >>> Address.street) \n  val valueAtHobbiesPE: ProjectionExpression[Person, List[String]]       =\n    Person.hobbies.valueAt("sports")\n  val valueAtAndElementAtHobbiesPE: ProjectionExpression[Person, String] =\n    Person.hobbies.valueAt("sports").elementAt(0)\n\n  for {\n    _ <- DynamoDBQuery.put("people", person).execute\n\n    _ <- DynamoDBQuery\n           .update("people")(Person.email.partitionKey === "john@gmail.com")(\n             addressToStreetPE.set("2nd St")\n           )\n           .execute\n\n    _ <- DynamoDBQuery\n           .update("people")(Person.email.partitionKey === "john@gmail.com")(\n             valueAtHobbiesPE.set(List("tennis", "rugby"))\n           )\n           .execute\n\n    _ <- DynamoDBQuery\n           .update("people")(Person.email.partitionKey === "john@gmail.com")(\n             valueAtAndElementAtHobbiesPE.set("cricket")\n           )\n           .execute\n\n  } yield ()\n'})}),"\n",(0,i.jsx)(n.h2,{id:"product-traversal",children:"Product traversal"}),"\n",(0,i.jsx)(n.p,{children:"From the the example above:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"  val addressToStreetPE: ProjectionExpression[Person, String]            =\n    (Person.address >>> Address.street) \n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"addressToStreetPE"})," is an example of traversing into a product (case class)."]}),"\n",(0,i.jsx)(n.h2,{id:"sum-type-traversal",children:"Sum type traversal"}),"\n",(0,i.jsxs)(n.p,{children:["To illustrate sum type traversal, consider the below model with sum type (sealed trait) ",(0,i.jsx)(n.code,{children:"BilledBody"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'  @discriminatorName("billedType")\n  sealed trait BilledBody\n\n  object BilledBody {\n    final case class BilledMonthly(month: Int) extends BilledBody\n    object BilledMonthly {\n      implicit lazy val schema: Schema.CaseClass1[Int, BilledMonthly] = DeriveSchema.gen[BilledMonthly]\n      val month: ProjectionExpression[BilledMonthly, Int]             = ProjectionExpression.accessors[BilledMonthly]\n    }\n    final case class BilledYearly(year: Int) extends BilledBody\n    object BilledYearly  {\n      implicit lazy val schema: Schema.CaseClass1[Int, BilledYearly] = DeriveSchema.gen[BilledYearly]\n      val year: ProjectionExpression[BilledYearly, Int]              = ProjectionExpression.accessors[BilledYearly]\n    }\n    implicit val schema: Schema.Enum2[BilledMonthly, BilledYearly, BilledBody] = DeriveSchema.gen[BilledBody]\n    val (monthly, yearly) = ProjectionExpression.accessors[BilledBody]\n  }\n\n  final case class Invoice(int: Int, body: BilledBody)\n  object Invoice {\n    implicit lazy val schema: Schema.CaseClass2[Int, BilledBody, Invoice] = DeriveSchema.gen[Invoice]\n    val (int, body)                                                       = ProjectionExpression.accessors[Invoice]\n  }\n'})}),"\n",(0,i.jsxs)(n.p,{children:["We can access the ",(0,i.jsx)(n.code,{children:"BilledYearly"})," case class field ",(0,i.jsx)(n.code,{children:"year"})," using the ",(0,i.jsx)(n.code,{children:">>>"})," combinator as shown below:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'  val invoiceToBilledYearlyToYearPE: ProjectionExpression[Invoice, Int] =\n    Invoice.body >>> BilledBody.yearly >>> BilledYearly.year\n\n  val yearlyInvoice = Invoice(1, BilledYearly(2021))\n\n  for {\n    _ <- DynamoDBQuery.put("invoices", yearlyInvoice).execute\n    _ <- DynamoDBQuery\n           .update("invoices")(Invoice.int.partitionKey === 1)(\n             invoiceToBilledYearlyToYearPE.set(2022)\n           )\n           .execute\n\n  } yield ()\n'})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var r=s(96540);const i={},t=r.createContext(i);function o(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);