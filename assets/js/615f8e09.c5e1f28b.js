"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[71317],{1307:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"zio-kafka/consumer-tuning","title":"Tuning the consumer","description":"Zio-kafka\'s consumer can be tuned with the ConsumerSettings class.","source":"@site/docs/zio-kafka/consumer-tuning.md","sourceDirName":"zio-kafka","slug":"/zio-kafka/consumer-tuning","permalink":"/zio-kafka/consumer-tuning","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-kafka/consumer-tuning.md","tags":[],"version":"current","frontMatter":{"id":"consumer-tuning","title":"Tuning the consumer"},"sidebar":"ecosystem-sidebar","previous":{"title":"Zio-Kafka Metrics","permalink":"/zio-kafka/metrics"},"next":{"title":"Preventing duplicates","permalink":"/zio-kafka/preventing-duplicates"}}');var s=t(74848),r=t(28453);const o={id:"consumer-tuning",title:"Tuning the consumer"},a=void 0,l={},c=[{value:"Names",id:"names",level:2},{value:"Throughput and latency",id:"throughput-and-latency",level:2},{value:"Small and large records",id:"small-and-large-records",level:2},{value:"High number of partitions",id:"high-number-of-partitions",level:2},{value:"Long processing durations",id:"long-processing-durations",level:2},{value:"Using metrics to tune the consumer",id:"using-metrics-to-tune-the-consumer",level:2}];function h(e){const n={a:"a",code:"code",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Zio-kafka's consumer can be tuned with the ",(0,s.jsx)(n.code,{children:"ConsumerSettings"})," class."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"val settings = ConsumerSettings(bootstrapServers)\n  .withGroupId(groupId)\n  .withProperties(properties)\n  .... etc.\n"})}),"\n",(0,s.jsx)(n.h2,{id:"names",children:"Names"}),"\n",(0,s.jsx)(n.p,{children:"Two very similarly named settings are relevant. Don't mix them up:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"pollTimeout"})," \u2014 how long a poll may take"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"max.poll.interval.ms"})," \u2014 the maximum time between polls"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"throughput-and-latency",children:"Throughput and latency"}),"\n",(0,s.jsx)(n.p,{children:"The kafka client can be tuned for either high throughput or low latency, unfortunately not both.\nThe most important settings for tuning throughput and latency are:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["zio-kafka's ",(0,s.jsx)(n.code,{children:"pollTimeout"})," \u2014 This is the maximum time to block while polling the Kafka consumer. Zio-kafka's default\nis ",(0,s.jsx)(n.code,{children:"50ms"})," which is good for low latency applications. Set this higher, e.g. ",(0,s.jsx)(n.code,{children:"500ms"})," for better throughput."]}),"\n",(0,s.jsxs)(n.li,{children:["kafka's ",(0,s.jsxs)(n.a,{href:"https://kafka.apache.org/documentation/#consumerconfigs_max.poll.records",children:["configuration ",(0,s.jsx)(n.code,{children:"max.poll.records"})]})," \u2014 The maximum number of records a poll will return. Kafka defaults\nthis to ",(0,s.jsx)(n.code,{children:"500"}),". You can set this higher for more throughput, or lower for lower latency."]}),"\n",(0,s.jsxs)(n.li,{children:["zio-kafka's fetch-strategy ",(0,s.jsx)(n.code,{children:"partitionPreFetchBufferLimit"})," \u2014 when the number of records in a partition queue is\nat or below this value, zio-kafka will start to pre-fetch and buffer more records from Kafka. The default value for\nthis parameter is ",(0,s.jsx)(n.code,{children:"1024"}),"; 2 * the default ",(0,s.jsx)(n.code,{children:"max.poll.records"})," of 500, rounded to the nearest power of 2."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Zio-kafka provides 2 methods that set these settings for 2 common use cases: ",(0,s.jsx)(n.code,{children:"ConsumerSettings.tuneForHighThroughput"}),"\nand ",(0,s.jsx)(n.code,{children:"ConsumerSettings.tuneForLowLatency"}),".\nNote that their implementation may vary over time. You can use them as follows:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"val highThroughputSettings = ConsumerSettings(bootstrapServers).tuneForHighThroughput\nval lowLatencySettings = ConsumerSettings(bootstrapServers).tuneForLowLatency\n"})}),"\n",(0,s.jsx)(n.h2,{id:"small-and-large-records",children:"Small and large records"}),"\n",(0,s.jsxs)(n.p,{children:["Kafka\u2019s performance is not very sensitive to record size. However, when records become very small (< 100 bytes) it\nmight be beneficial to increase ",(0,s.jsx)(n.code,{children:"max.poll.records"})," and ",(0,s.jsx)(n.code,{children:"partitionPreFetchBufferLimit"}),". Similarly, when records are\nvery large (> 100Kb), ",(0,s.jsx)(n.code,{children:"max.poll.records"})," can be decreased. Also, pre-fetching can be limited by decreasing\n",(0,s.jsx)(n.code,{children:"partitionPreFetchBufferLimit"})," or even disabled by using ",(0,s.jsx)(n.code,{children:"ConsumerSettngs.withoutPartitionPreFetching"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"high-number-of-partitions",children:"High number of partitions"}),"\n",(0,s.jsxs)(n.p,{children:["When a lot of partitions need to be consumed, we need to take into account that heap is needed to store the records in\nthe partition queues. A very rough estimate for the maximum amount of heap needed is given by: ",(0,s.jsx)(n.code,{children:"average record size"})," *\n",(0,s.jsx)(n.code,{children:"number of of partitions"})," * max(",(0,s.jsx)(n.code,{children:"partitionPreFetchBufferLimit"}),", ",(0,s.jsx)(n.code,{children:"max.poll.records"}),")."]}),"\n",(0,s.jsxs)(n.p,{children:["The total can be tuned by changing the ",(0,s.jsx)(n.code,{children:"partitionPreFetchBufferLimit"}),", ",(0,s.jsx)(n.code,{children:"max.poll.records"})," settings."]}),"\n",(0,s.jsxs)(n.p,{children:["Another option is to write a custom ",(0,s.jsx)(n.code,{children:"FetchStrategy"}),". For example the ",(0,s.jsx)(n.code,{children:"ManyPartitionsQueueSizeBasedFetchStrategy"})," in\n",(0,s.jsx)(n.a,{href:"https://github.com/zio/zio-kafka/pull/970",children:"draft PR 970"})," (merged into zio-kafka since 2.8.1)."]}),"\n",(0,s.jsx)(n.h2,{id:"long-processing-durations",children:"Long processing durations"}),"\n",(0,s.jsxs)(n.p,{children:["To detect stalled consumers, Kafka revokes a partition when a consumer does not poll within the max poll interval (see\n",(0,s.jsxs)(n.a,{href:"https://kafka.apache.org/documentation/#consumerconfigs_max.poll.interval.ms",children:["configuration ",(0,s.jsx)(n.code,{children:"max.poll.interval.ms"})]}),"). The default max poll interval is 5 minutes. After a partition is revoked,\nit will be assigned to another consumer."]}),"\n",(0,s.jsx)(n.p,{children:"In zio-kafka (versions 2.5.1+) a stream needs to pull data within the max poll interval. If this doesn't happen, the\nstream is interrupted with a failure and the whole consumer shuts down."}),"\n",(0,s.jsxs)(n.p,{children:["To see if your application must be configured with a higher ",(0,s.jsx)(n.code,{children:"max.poll.interval.ms"})," value we need to consider the\nmaximum duration between polls. If processing is sequential, we can obtain this maximum by multiplying\n",(0,s.jsx)(n.code,{children:"max.poll.records"})," with the maximum duration to process a single record. To also accommodate things like long garbage\ncollections and buffering, configuration ",(0,s.jsx)(n.code,{children:"max.poll.interval.ms"})," should be substantially higher than the maximum\nprocessing time."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"max.poll.interval.ms"})," can be set with:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"  .withMaxPollInterval(15.minutes)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["On older zio-kafka versions ",(0,s.jsx)(n.code,{children:"withMaxPollInterval"})," is not available. Use the following instead:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'  .withProperty("max.poll.interval.ms", 15.minutes.toMillis.toString)\n'})}),"\n",(0,s.jsxs)(n.p,{children:["\u26a0\ufe0fIn zio-kafka versions 2.2 up to 2.5.0 it may also be necessary to increase the ",(0,s.jsx)(n.code,{children:"runloopTimeout"})," setting.\nWhen no stream is processing data for this amount of time (while new data is available), the consumer will halt with a\nfailure. In zio-kafka 2.5.0 ",(0,s.jsx)(n.code,{children:"runloopTimeout"})," defaults to 4 minutes, a little bit lower than ",(0,s.jsx)(n.code,{children:"max.poll.interval.ms"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"using-metrics-to-tune-the-consumer",children:"Using metrics to tune the consumer"}),"\n",(0,s.jsxs)(n.p,{children:["Zio-Kafka exposes ",(0,s.jsx)(n.a,{href:"/zio-kafka/metrics",children:"metrics"})," that can be used to further tune the consumer. To interpret these metrics you need to know how zio-kafka works internally."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:t(4438).A+""})}),"\n",(0,s.jsxs)(n.p,{children:["The runloop is at the heart of every zio-kafka consumer.\nIt creates a zstream for each partition, eventually this is the zstream your applications consumes from.\nWhen the zstream starts, and every time the records queue is empty, it sends a request for data to the runloop.\nThe request causes the runloop to resume the partition so that the next poll may receive records.\nAny received records are put in the records queue.\nWhen the queue reaches a certain size (as determined by the configured ",(0,s.jsx)(n.code,{children:"FetchStrategy"}),"), the partition is paused.\nMeanwhile, the zstream reads from the queue and emits the records to your application."]}),"\n",(0,s.jsx)(n.p,{children:"An optimally configured consumer has the following properties:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"the zstreams never have to wait for new records (to get high throughput),"}),"\n",(0,s.jsx)(n.li,{children:"most of the time, the record queues are empty (to get low latency and low heap usage)."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The following strategy can help you get to this state:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["First make sure that ",(0,s.jsx)(n.code,{children:"pollTimeout"})," and ",(0,s.jsx)(n.code,{children:"max.poll.records"})," make sense for the latency and throughput requirements\nof your application."]}),"\n",(0,s.jsxs)(n.li,{children:["Configure ",(0,s.jsx)(n.code,{children:"partitionPreFetchBufferLimit"})," to ",(0,s.jsx)(n.code,{children:"0"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Observe metric ",(0,s.jsx)(n.code,{children:"ziokafka_consumer_queue_polls"})," which gives the number of polls during which records are idling in\nthe queue."]}),"\n",(0,s.jsxs)(n.li,{children:["Increase ",(0,s.jsx)(n.code,{children:"partitionPreFetchBufferLimit"})," in steps until most measurements of the ",(0,s.jsx)(n.code,{children:"ziokafka_consumer_queue_polls"}),"\nhistogram are in the ",(0,s.jsx)(n.code,{children:"0"})," bucket ."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["During this process, it is useful to observe metric ",(0,s.jsx)(n.code,{children:"ziokafka_consumer_queue_size"})," (number of records in the queues) to\nsee if the queues are indeed increasing in size."]}),"\n",(0,s.jsxs)(n.p,{children:["When many (hundreds of) partitions need to be consumed, the metric ",(0,s.jsx)(n.code,{children:"ziokafka_consumer_all_queue_size"})," should also be\nobserved as increasing ",(0,s.jsx)(n.code,{children:"partitionPreFetchBufferLimit"})," can lead to high heap usage. (See 'High number of partitions'\nabove.)"]})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},4438:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/consumer-internals-17dfcf281e5bbd90aa8f808aeddb97cc.svg"},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var i=t(96540);const s={},r=i.createContext(s);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);