"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[47466],{24890:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"interop-monix/index","title":"Introduction to ZIO Interop Monix","description":"This library provides interoperability between Monix 3.4 and ZIO 1 and ZIO 2. Both JVM and Scala.js are supported.","source":"@site/docs/interop-monix/index.md","sourceDirName":"interop-monix","slug":"/interop-monix/","permalink":"/interop-monix/","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/interop-monix/index.md","tags":[],"version":"current","frontMatter":{"id":"index","title":"Introduction to ZIO Interop Monix","sidebar_label":"ZIO Interop Monix"},"sidebar":"ecosystem-sidebar","previous":{"title":"ZIO Interop Guava","permalink":"/zio-interop-guava/"},"next":{"title":"ZIO Interop Reactive Streams","permalink":"/zio-interop-reactivestreams/"}}');var o=i(74848),s=i(28453);const r={id:"index",title:"Introduction to ZIO Interop Monix",sidebar_label:"ZIO Interop Monix"},a=void 0,l={},c=[{value:"Tasks",id:"tasks",level:2},{value:"Monix Scheduler",id:"monix-scheduler",level:2}];function d(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:["This library provides interoperability between ",(0,o.jsx)(n.strong,{children:"Monix 3.4"})," and ",(0,o.jsx)(n.strong,{children:"ZIO 1 and ZIO 2"}),". Both JVM and Scala.js are supported."]}),"\n",(0,o.jsx)(n.h2,{id:"tasks",children:"Tasks"}),"\n",(0,o.jsx)(n.p,{children:"Monix tasks can be converted to ZIO tasks:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio._\nimport zio.interop.monix._\nimport monix.eval\n\nval monixTask: eval.Task[String] = ???\n\nval zioTask: Task[String] = ZIO.fromMonixTask(monixTask)\n"})}),"\n",(0,o.jsx)(n.p,{children:"The conversion is lazy: the Monix task will only be executed if the returned ZIO task is executed."}),"\n",(0,o.jsx)(n.p,{children:"ZIO tasks can be converted to Monix tasks:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio._\nimport zio.interop.monix._\nimport monix.eval\nimport monix.execution.Scheduler.Implicits.global\n\nval zioTask: Task[String] = ???\n\nval createMonixTask: UIO[eval.Task[String]] = zioTask.toMonixTask()\n\n// illustrative, you wouldn't usually do things this way\nval monixTask: eval.Task[String] = Runtime.default.unsafeRun(createMonixTask)\nval stringResult = monixTask.runSyncUnsafe\n"})}),"\n",(0,o.jsx)(n.p,{children:"The conversion is lazy: the ZIO effect so converted will only be executed if the returned Monix task is executed."}),"\n",(0,o.jsxs)(n.p,{children:["Sometimes you need to provide a Monix task in a context where using a ZIO effect is difficult. For example, when an API requires you to provide a function that returns a Monix task. In these situations, the ",(0,o.jsx)(n.code,{children:"toMonixTaskUsingRuntime"})," method can be used:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio._\nimport zio.interop.monix._\nimport monix.eval\n\ndef monixBasedApi(f: String => eval.Task[Unit]): eval.Task[Unit] = ???\n\ndef zioBasedProcessor(s: String): Task[Unit] = ???\n\nval zioEffects = for {\n    zioRuntime <- ZIO.runtime[Any]\n    _ <- ZIO.fromMonixTask {\n        monixBasedApi(s =>\n            zioBasedProcessor(s).toMonixTaskUsingRuntime(zioRuntime)\n        )\n    }\n} yield ()\n"})}),"\n",(0,o.jsx)(n.p,{children:"Cancellation/Interruption is propagated between the effect systems. Interrupting a ZIO task based on a Monix task will cancel the underlying Monix task and vice-versa. Be aware that ZIO interruption does not return until cancellation effects have completed, whereas Monix cancellation returns as soon as the signal is sent, without waiting for the cancellation effects to complete."}),"\n",(0,o.jsx)(n.h2,{id:"monix-scheduler",children:"Monix Scheduler"}),"\n",(0,o.jsxs)(n.p,{children:["Sometimes it is useful to have a Monix ",(0,o.jsx)(n.code,{children:"Scheduler"})," available for interop purposes. The ",(0,o.jsx)(n.code,{children:"Runtime#monixScheduler"})," method will create a scheduler that shares its execution context with the ZIO runtime:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio._\nimport zio.interop.monix._\nimport monix.execution.Scheduler\n\nZIO.runtime[Any].flatMap { runtime =>\n    implicit val monixScheduler: Scheduler = runtime.monixScheduler()\n\n    // do Monixy things\n}\n"})})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>a});var t=i(96540);const o={},s=t.createContext(o);function r(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);