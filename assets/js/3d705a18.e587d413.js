"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[40006],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>s});var a=t(96540);const i={},r=a.createContext(i);function o(e){const n=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),a.createElement(r.Provider,{value:n},e.children)}},46982:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"zio-telemetry/opentracing","title":"OpenTracing","description":"OpenTracing is a standard and API for distributed tracing, i.e. collecting timings,","source":"@site/docs/zio-telemetry/opentracing.md","sourceDirName":"zio-telemetry","slug":"/zio-telemetry/opentracing","permalink":"/zio-telemetry/opentracing","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-telemetry/opentracing.md","tags":[],"version":"current","frontMatter":{"id":"opentracing","title":"OpenTracing"},"sidebar":"ecosystem-sidebar","previous":{"title":"ZIO Telemetry","permalink":"/zio-telemetry/"},"next":{"title":"OpenTracing Example","permalink":"/zio-telemetry/opentracing-example"}}');var i=t(74848),r=t(28453);const o={id:"opentracing",title:"OpenTracing"},s=void 0,c={},l=[{value:"Installation",id:"installation",level:2},{value:"Usage",id:"usage",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["OpenTracing is a standard and API for distributed tracing, i.e. collecting timings,\nand logs across process boundaries. Well known implementations are ",(0,i.jsx)(n.a,{href:"https://www.jaegertracing.io",children:"Jaeger"})," and ",(0,i.jsx)(n.a,{href:"https://www.zipkin.io",children:"Zipkin"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,i.jsx)(n.p,{children:"First, add the following dependency to your build.sbt:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'"dev.zio" %% "zio-opentracing" % "<version>"\n'})}),"\n",(0,i.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,i.jsxs)(n.p,{children:["To use ZIO Telemetry, you will need an ",(0,i.jsx)(n.code,{children:"OpenTracing"})," service in your\nenvironment. You also need to provide a ",(0,i.jsx)(n.code,{children:"tracer"})," (for this example we use ",(0,i.jsx)(n.code,{children:"JaegerTracer.live"})," from ",(0,i.jsx)(n.code,{children:"opentracing-example"})," module) implementation:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'import zio.telemetry.opentracing.OpenTracing\nimport zio.telemetry.opentracing.example.JaegerTracer\nimport zio._\nimport io.opentracing.tag.Tags\n\nval app =\n  ZIO.serviceWithZIO[OpenTracing] { tracing =>\n    import tracing.aspects._\n\n    (for {\n      _       <- tracing.tag(Tags.SPAN_KIND.getKey, Tags.SPAN_KIND_CLIENT)\n      _       <- tracing.tag(Tags.HTTP_METHOD.getKey, "GET")\n      _       <- tracing.setBaggageItem("proxy-baggage-item-key", "proxy-baggage-item-value")\n      message <- Console.readline\n      _       <- tracing.log("Message has been read")\n    } yield message) @@ root("/app")\n  }.provide(OpenTracing.live, JaegerTracer.live("my-app"))\n'})}),"\n",(0,i.jsxs)(n.p,{children:["After importing ",(0,i.jsx)(n.code,{children:"import tracing.aspects._"}),", additional ",(0,i.jsx)(n.code,{children:"ZIOAspect"})," combinators\non ",(0,i.jsx)(n.code,{children:"ZIO"}),"s are available to support starting child spans, tagging, logging and\nmanaging baggage."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'ZIO.serviceWithZIO[OpenTracing] { tracing =>\n  import tracing.aspects._\n  \n  // start a new root span and set some baggage item\n  val zio1 = tracing.setBaggage("foo", "bar") @@ root("root span")\n\n  // start a child of the current span, set a tag and log a message\n  val zio2 = \n    (for {\n      _ <- tracing.tag("http.status_code", 200)\n      _ <- tracing.log("doing some serious work here!")\n    } yield ()) @@ span("child span")\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["To propagate contexts across process boundaries, extraction and injection can be\nused. The current span context is injected into a carrier, which is passed\nthrough some side channel to the next process. There it is injected back and a\nchild span of it is started. For the example we use the standardized ",(0,i.jsx)(n.code,{children:"TextMap"}),"\ncarrier. For details about extraction and injection, please refer to\n",(0,i.jsx)(n.a,{href:"https://opentracing.io/docs/overview/inject-extract/",children:"OpenTracing Documentation"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Due to the use of the (mutable) OpenTracing carrier APIs, injection and extraction\nare not referentially transparent."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'ZIO.serviceWithZIO[OpenTracing] { tracing =>\n  import tracing.aspects._\n  \n  val buffer = new TextMapAdapter(mutable.Map.empty.asJava)\n  for {\n    _ <- tracing.inject(Format.Builtin.TEXT_MAP, buffer)\n    _ <- ZIO.unit @@ spanFrom(Format.Builtin.TEXT_MAP, buffer, "child of remote span")\n  } yield buffer\n}\n'})})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);