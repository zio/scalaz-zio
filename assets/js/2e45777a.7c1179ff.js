"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[14147],{28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>i});var a=n(96540);const s={},r=a.createContext(s);function o(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),a.createElement(r.Provider,{value:t},e.children)}},29829:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"reference/state-management/zstate","title":"ZState","description":"ZStateS] models a value of type S that can be read from and written to during the execution of an effect. This is a higher-level construct built on top of [FiberRef and the environment type to support using ZIO where we might have traditionally used state monad transformers.","source":"@site/docs/reference/state-management/zstate.md","sourceDirName":"reference/state-management","slug":"/reference/state-management/zstate","permalink":"/reference/state-management/zstate","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/state-management/zstate.md","tags":[],"version":"current","frontMatter":{"id":"zstate","title":"ZState"},"sidebar":"reference-sidebar","previous":{"title":"FiberRef","permalink":"/reference/state-management/fiberref"},"next":{"title":"Introduction to Concurrent Programming in ZIO","permalink":"/reference/concurrency/"}}');var s=n(74848),r=n(28453);const o={id:"zstate",title:"ZState"},i=void 0,c={},d=[];function l(e){const t={a:"a",code:"code",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"ZState[S]"})," models a value of type ",(0,s.jsx)(t.code,{children:"S"})," that can be read from and written to during the execution of an effect. This is a higher-level construct built on top of ",(0,s.jsx)(t.a,{href:"/reference/state-management/fiberref",children:(0,s.jsx)(t.code,{children:"FiberRef"})})," and the environment type to support using ZIO where we might have traditionally used state monad transformers."]}),"\n",(0,s.jsxs)(t.p,{children:["Let's try a simple example of using ",(0,s.jsx)(t.code,{children:"ZState"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:'import zio._\n\nimport java.io.IOException\n\nobject ZStateExample extends zio.ZIOAppDefault {\n  val myApp: ZIO[ZState[Int], IOException, Unit] = for {\n    s <- ZIO.service[ZState[Int]]\n    _ <- s.update(_ + 1)\n    _ <- s.update(_ + 2)\n    state <- s.get\n    _ <- Console.printLine(s"current state: $state")\n  } yield ()\n\n  def run = ZIO.stateful(0)(myApp)\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["The idiomatic way to work with ",(0,s.jsx)(t.code,{children:"ZState"})," is as part of the environment using operators defined on ",(0,s.jsx)(t.code,{children:"ZIO"})," to access the ",(0,s.jsx)(t.code,{children:"ZState"})," from the environment, and finally, allocate the initial state using the ",(0,s.jsx)(t.code,{children:"ZIO.stateful"})," operator."]}),"\n",(0,s.jsxs)(t.p,{children:["Because we typically use ",(0,s.jsx)(t.code,{children:"ZState"})," as part of the environment, it is recommended to define our own state type ",(0,s.jsx)(t.code,{children:"S"})," such as ",(0,s.jsx)(t.code,{children:"MyState"})," rather than using a type such as ",(0,s.jsx)(t.code,{children:"Int"})," to avoid the risk of ambiguity:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:'import zio._\n\nimport java.io.IOException\n\nfinal case class MyState(counter: Int)\n\nobject ZStateExample extends zio.ZIOAppDefault {\n\n  val myApp: ZIO[ZState[MyState], IOException, Unit] =\n    for {\n      counter <- ZIO.service[ZState[MyState]]\n      _ <- counter.update(state => state.copy(counter = state.counter + 1))\n      _ <- counter.update(state => state.copy(counter = state.counter + 2))\n      state <- counter.get\n      _ <- Console.printLine(s"Current state: $state")\n    } yield ()\n\n  def run = ZIO.stateful(MyState(0))(myApp)\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"ZIO"})," data type also has some helper methods to work with ",(0,s.jsx)(t.code,{children:"ZState"})," as the environment of ",(0,s.jsx)(t.code,{children:"ZIO"})," effect such as ",(0,s.jsx)(t.code,{children:"ZIO.updateState"}),", ",(0,s.jsx)(t.code,{children:"ZIO.getState"}),", and ",(0,s.jsx)(t.code,{children:"ZIO.getStateWith"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:'import zio._\n\nimport java.io.IOException\n\nfinal case class MyState(counter: Int)\n\nval myApp: ZIO[ZState[MyState], IOException, Int] =\n  for {\n    _ <- ZIO.updateState[MyState](state => state.copy(counter = state.counter + 1))\n    _ <- ZIO.updateState[MyState](state => state.copy(counter = state.counter + 2))\n    state <- ZIO.getStateWith[MyState](_.counter)\n    _ <- Console.printLine(s"Current state: $state")\n  } yield state\n'})}),"\n",(0,s.jsxs)(t.p,{children:["An important note about ",(0,s.jsx)(t.code,{children:"ZState"})," is that it is on top of the ",(0,s.jsx)(t.code,{children:"FiberRef"})," data type. So it will inherit its behavior from the ",(0,s.jsx)(t.code,{children:"FiberRef"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"For example, when a fiber is going to join to its parent fiber, its state will be merged with its parent state:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:'import zio._\n\ncase class MyState(counter: Int)\n\nobject ZStateExample extends ZIOAppDefault {\n  val myApp = for {\n    _ <- ZIO.updateState[MyState](state => state.copy(counter = state.counter + 1))\n    fiber <-\n      (for {\n        _ <- ZIO.updateState[MyState](state => state.copy(counter = state.counter + 1))\n        state <- ZIO.getState[MyState]\n        _ <- Console.printLine(s"Current state inside the forked fiber: $state")\n      } yield ()).fork\n    _ <- ZIO.updateState[MyState](state => state.copy(counter = state.counter + 5))\n    state1 <- ZIO.getState[MyState]\n    _ <- Console.printLine(s"Current state before merging the fiber: $state1")\n    _ <- fiber.join\n    state2 <- ZIO.getState[MyState]\n    _ <- Console.printLine(s"The final state: $state2")\n  } yield ()\n\n  def run =\n    ZIO.stateful(MyState(0))(myApp)\n}\n'})}),"\n",(0,s.jsx)(t.p,{children:"The output of running this snippet code would be as below:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"Current state before merging the fiber: MyState(6)\nCurrent state inside the forked fiber: MyState(2)\nThe final state: MyState(2)\n"})})]})}function p(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}}}]);