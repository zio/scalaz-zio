"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[18646],{58460:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"zio-nio/resources","title":"Resource Management","description":"NIO offers several objects, primarily channels, that consume resources (such as operating system file handles) that need to be released when no longer needed. If channels are not closed reliably, resource leaks can occur, causing a number of issues.","source":"@site/docs/zio-nio/resources.md","sourceDirName":"zio-nio","slug":"/zio-nio/resources","permalink":"/zio-nio/resources","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-nio/resources.md","tags":[],"version":"current","frontMatter":{"id":"resources","title":"Resource Management"},"sidebar":"ecosystem-sidebar","previous":{"title":"Socket Channel","permalink":"/zio-nio/sockets"},"next":{"title":"Character Sets","permalink":"/zio-nio/charsets"}}');var a=s(74848),t=s(28453);const i={id:"resources",title:"Resource Management"},l=void 0,r={},c=[{value:"Simple Usage",id:"simple-usage",level:2},{value:"Flexible Resource Scoping",id:"flexible-resource-scoping",level:2},{value:"Using <code>close</code> for Early Release",id:"using-close-for-early-release",level:3},{value:"Manual Resource Management",id:"manual-resource-management",level:2}];function h(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"NIO offers several objects, primarily channels, that consume resources (such as operating system file handles) that need to be released when no longer needed. If channels are not closed reliably, resource leaks can occur, causing a number of issues."}),"\n",(0,a.jsxs)(n.p,{children:["For this reason, ZIO-NIO provides such resources using the ",(0,a.jsxs)(n.a,{href:"https://zio.dev/docs/datatypes/datatypes_managed",children:["ZIO ",(0,a.jsx)(n.code,{children:"ZManaged"})," API"]}),". For example, calling ",(0,a.jsx)(n.code,{children:"FileChannel.open"})," will produce a value of ",(0,a.jsx)(n.code,{children:"ZManaged[Blocking, IOException, FileChannel]"}),". The file will not actually be opened until the managed value is ",(0,a.jsx)(n.em,{children:"used"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"simple-usage",children:"Simple Usage"}),"\n",(0,a.jsxs)(n.p,{children:["The most straight-forward way to use a managed resource is with the ",(0,a.jsx)(n.code,{children:"use"})," method:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.blocking.Blocking\nimport zio.nio.channels._\nimport zio.nio.file.Path\nimport java.io.IOException\n\ndef useChannel(f: FileChannel): ZIO[Blocking, IOException, Unit] = ???\n\nval effect: ZIO[Blocking, IOException, Unit] = FileChannel.open(Path("foo.txt"))\n  .use { fileChannel =>\n    // fileChannel is only valid in this lexical scope\n    useChannel(fileChannel)\n  }\n'})}),"\n",(0,a.jsxs)(n.p,{children:["In the above example, the ",(0,a.jsx)(n.code,{children:"FileChannel"})," will be opened and then provided to the function passed to ",(0,a.jsx)(n.code,{children:"use"}),". The channel will always be closed when the ",(0,a.jsx)(n.code,{children:"use"})," function completes, regardless of whether the operation succeeds, fails, dies or is interrupted. As long as the channel is only used within the function passed to ",(0,a.jsx)(n.code,{children:"use"}),", then we're guaranteed not to have leaks."]}),"\n",(0,a.jsx)(n.h2,{id:"flexible-resource-scoping",children:"Flexible Resource Scoping"}),"\n",(0,a.jsxs)(n.p,{children:["Sometimes there are situations where ",(0,a.jsx)(n.code,{children:"ZManaged#use"})," is too limiting, because the resource lifecycle needs to extend beyond a lexical scope. An example of this is registering channels with a ",(0,a.jsx)(n.code,{children:"Selector"}),". How can we do this using ",(0,a.jsx)(n.code,{children:"ZManaged"})," while still avoiding the possibility of leaks? One way is to use ",(0,a.jsxs)(n.a,{href:"https://javadoc.io/doc/dev.zio/zio_2.13/latest/zio/ZManaged$.html#scope:zio.Managed%5BNothing,zio.ZManaged.Scope%5D",children:['the "scope" feature of ',(0,a.jsx)(n.code,{children:"ZManaged"})]}),"."]}),"\n",(0,a.jsx)(n.p,{children:"A scope is itself a managed resource. Other managed resources can be attached to a scope, which gives them the same lifecycle as the scope. When the scope is released, all the other resources that have been attached to it will also be released."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"ZManaged.scope.use { scope =>\n\n  val channel: IO[IOException, SocketChannel] = scope(SocketChannel.open).map {\n    case (earlyRelease @ _, channel) => channel\n  }\n\n  // use channel, perhaps with a Selector\n  channel.flatMap(_.useNonBlocking(_.readChunk(10)))\n\n}\n// the scope has now been released, as have all the resources attached to it\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Note that ",(0,a.jsx)(n.code,{children:"scope"}),' returns both the resource and an "early release" effect. This allows you to release the resource before the scope exits, if you know it is no longer needed. This allows efficient use of the resource while still having the safety net of the scope to ensure the release happens even if there are failures, defects or interruptions.']}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"zio.nio.channels.SelectorSpec"})," test demonstrates the use of scoping to ensure nothing leaks if an error occurs."]}),"\n",(0,a.jsxs)(n.h3,{id:"using-close-for-early-release",children:["Using ",(0,a.jsx)(n.code,{children:"close"})," for Early Release"]}),"\n",(0,a.jsxs)(n.p,{children:["In the case of channels, we don't actually need the early release features that ",(0,a.jsx)(n.code,{children:"ZManaged"})," provides, as every channel has a built-in early release in the form of the ",(0,a.jsx)(n.code,{children:"close"})," method. Closing a channel more than once is a perfectly safe thing to do, so you can use ",(0,a.jsx)(n.code,{children:"close"})," to release a channel's resources early. When the ",(0,a.jsx)(n.code,{children:"ZManaged"})," scope of the channel later ends, ",(0,a.jsx)(n.code,{children:"close"})," will be called again, but it will be a no-op."]}),"\n",(0,a.jsx)(n.h2,{id:"manual-resource-management",children:"Manual Resource Management"}),"\n",(0,a.jsxs)(n.p,{children:["It is also possible to switch to completely manual resource management. ",(0,a.jsxs)(n.a,{href:"https://javadoc.io/doc/dev.zio/zio_2.13/latest/zio/ZManaged.html#reserve:zio.UIO%5Bzio.Reservation%5BR,E,A%5D%5D",children:["The ",(0,a.jsx)(n.code,{children:"reserve"})," method"]})," can be called on any ",(0,a.jsx)(n.code,{children:"ZManaged"})," value, which gives you the acquisition and release of the resource as two separate effect values that you can use as you like. If you use these reservation effects directly, it is entirely up to you to avoid leaking resources. This requires code to be written very carefully, and an understanding the finer details of how failures, defects and interruption work in ZIO."]})]})}function d(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>l});var o=s(96540);const a={},t=o.createContext(a);function i(e){const n=o.useContext(t);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),o.createElement(t.Provider,{value:n},e.children)}}}]);