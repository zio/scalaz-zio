"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[53379],{28453:(e,s,t)=>{t.d(s,{R:()=>l,x:()=>i});var n=t(96540);const a={},r=n.createContext(a);function l(e){const s=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function i(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),n.createElement(r.Provider,{value:s},e.children)}},97620:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>o,contentTitle:()=>i,default:()=>c,frontMatter:()=>l,metadata:()=>n,toc:()=>h});const n=JSON.parse('{"id":"zio-http/reference/headers/session/flash","title":"Flash Messages","description":"Flash messages are temporary short-lived messages that are displayed to users on web applications to inform users about the outcome of certain actions, such as form submissions. These messages are typically stored in session data but are automatically removed after being displayed to the user.","source":"@site/docs/zio-http/reference/headers/session/flash.md","sourceDirName":"zio-http/reference/headers/session","slug":"/zio-http/reference/headers/session/flash","permalink":"/zio-http/reference/headers/session/flash","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-http/reference/headers/session/flash.md","tags":[],"version":"current","frontMatter":{"id":"flash","title":"Flash Messages","sidebar_label":"Flash"},"sidebar":"ecosystem-sidebar","previous":{"title":"Cookies","permalink":"/zio-http/reference/headers/session/cookies"},"next":{"title":"Body","permalink":"/zio-http/reference/body/"}}');var a=t(74848),r=t(28453);const l={id:"flash",title:"Flash Messages",sidebar_label:"Flash"},i=void 0,o={},h=[{value:"Motivation",id:"motivation",level:2},{value:"Solution",id:"solution",level:2},{value:"Setting/Retrieving Flash Messages",id:"settingretrieving-flash-messages",level:2},{value:"Setting/Retrieving Multiple Flash Messages",id:"settingretrieving-multiple-flash-messages",level:2},{value:"Flash Backends",id:"flash-backends",level:2},{value:"Cookie-based Flash-scope",id:"cookie-based-flash-scope",level:3},{value:"Backend-based Flash-scope",id:"backend-based-flash-scope",level:3}];function d(e){const s={admonition:"admonition",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components},{Details:t}=s;return t||function(e,s){throw new Error("Expected "+(s?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(s.p,{children:"Flash messages are temporary short-lived messages that are displayed to users on web applications to inform users about the outcome of certain actions, such as form submissions. These messages are typically stored in session data but are automatically removed after being displayed to the user."}),"\n",(0,a.jsx)(s.p,{children:"Flash messages are particularly useful in scenarios involving HTTP redirections, where there may not be a dedicated view to display messages directly. They help maintain a smooth user experience by providing timely feedback without cluttering the interface."}),"\n",(0,a.jsx)(s.h2,{id:"motivation",children:"Motivation"}),"\n",(0,a.jsx)(s.p,{children:"Assume we have a simple web application that allows users to submit a form. After the form is submitted, we want to display a success message to the user. We also want to display an error message if the form submission fails. How can we implement this?"}),"\n",(0,a.jsxs)(s.p,{children:["Assume we have a simple form that submits a user's name and age to the ",(0,a.jsx)(s.code,{children:"/users/save"})," endpoint:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-html",children:'<form id="myform" action="/users/save" method="POST">\n  <label for="name">Name:</label><br/>\n  <input type="text" id="name" name="name"/><br/>\n  <label for="age">Age:</label><br/>\n  <input type="number" id="age" name="age"/><br/><br/>\n  <button type="submit">Submit</button>\n</form>\n'})}),"\n",(0,a.jsx)(s.p,{children:"After the form is submitted, we want to display the outcome of the form submission to the user. We want to display a success message if the form submission is successful, and an error message if the form submission fails. Additionally, we want to display the list of users we have submitted so far."}),"\n",(0,a.jsxs)(s.p,{children:["One simple solution is to respond with an HTML page that contains the messages and the list of users on the same endpoint (",(0,a.jsx)(s.code,{children:"/users/save"}),"). However, this approach has a drawback: if the user refreshes the page, the form will be resubmitted, which may lead to duplicate submissions:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-scala",children:'import zio._\nimport zio.http._\n\nval saveUserRoute: Route[Ref[List[User]], Nothing] =\n  Method.POST / "users" / "save" -> handler { (req: Request) =>\n    for {\n      usersDb <- ZIO.service[Ref[List[User]]]\n      form    <- req.body.asURLEncodedForm.orDie\n      name    <- ZIO.fromOption(form.get("name")).flatMap(_.asText)\n      age     <- ZIO.fromOption(form.get("age")).flatMap(_.asText).map(_.toInt)\n      users   <- usersDb.updateAndGet(_ appended User(name, age))\n    } yield Response.html(ui.renderNotice("User saved successfully!") ++ ui.renderUsers(users))\n  }.catchAll { _ =>\n    handler {\n      Response.html(\n        data = ui.renderAlert("Failed to save user! Something went wrong!"),\n        status = Status.Forbidden\n      )\n    }\n  }\n'})}),"\n",(0,a.jsxs)(t,{children:[(0,a.jsx)("summary",{children:(0,a.jsx)("b",{children:"Full Implementation Showcase"})}),(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-scala",children:'import zio._\nimport zio.http._\nimport zio.http.codec.PathCodec\nimport zio.http.template._\n\ncase class User(name: String, age: Int)\n\nobject ui {\n\n  def renderNotice(html: Html): Html = div(styleAttr := "background: green", html)\n\n  def renderAlert(html: Html): Html = div(styleAttr := "background: red", html)\n\n  def renderUsers(users: List[User]): Html = {\n    table(\n      borderAttr := "1",\n      tHead(\n        tr(\n          th("Name"),\n          th("Age"),\n        ),\n      ),\n      tBody(\n        ol(users.map { u =>\n          tr(\n            td(u.name),\n            td(u.age.toString),\n          )\n        }),\n      ),\n    )\n  }\n\n}\n\nobject NotificationWithoutFlash extends ZIOAppDefault {\n  val homeRoute: Route[Any, Nothing] =\n    Method.GET / PathCodec.empty -> handler {\n      Response.html(\n        form(idAttr := "myform", actionAttr := "/users/save", methodAttr := "POST",\n          label("Name:", forAttr("name")), br(),\n          input(typeAttr := "text", idAttr := "name", nameAttr := "name"), br(),\n          label("Age:", forAttr := "age"), br(),\n          input(typeAttr := "number", idAttr := "age", nameAttr := "age"), br(), br(),\n          button("Submit", typeAttr := "submit"),\n        ),\n      )\n    }\n\n  val saveUserRoute: Route[Ref[List[User]], Nothing] =\n    Method.POST / "users" / "save" -> handler { (req: Request) =>\n      for {\n        usersDb <- ZIO.service[Ref[List[User]]]\n        form    <- req.body.asURLEncodedForm.orDie\n        name    <- ZIO.fromOption(form.get("name")).flatMap(_.asText)\n        age     <- ZIO.fromOption(form.get("age")).flatMap(_.asText).map(_.toInt)\n        users   <- usersDb.updateAndGet(_ appended User(name, age))\n      } yield Response.html(ui.renderNotice("User saved successfully!") ++ ui.renderUsers(users))\n    }.catchAll { _ =>\n      handler {\n        Response.html(\n          data = ui.renderAlert("Failed to save user! Something went wrong!"),\n          status = Status.Forbidden\n        )\n      }\n    }\n\n\n  def run = Server.serve(Routes(saveUserRoute, homeRoute))\n    .provide(Server.default, ZLayer(Ref.make(List.empty[User])))\n}\n'})}),(0,a.jsxs)(s.p,{children:["Run the server and open the browser to ",(0,a.jsx)(s.code,{children:"http://localhost:8080"}),". You will see a form to submit user details. After submitting the form, you will see the outcome of the form submission on the ",(0,a.jsx)(s.code,{children:"/users/save"})," endpoint. Now refresh the page and you will see the form is resubmitted."]})]}),"\n",(0,a.jsxs)(s.p,{children:["So it is better to redirect the user to a different endpoint after the form submission. In this case, we may want to redirect the user to the ",(0,a.jsx)(s.code,{children:"/users"})," endpoint after the form submission. However, we need to find a way to pass the notification messages ",(0,a.jsx)(s.code,{children:"/users"})," endpoint."]}),"\n",(0,a.jsx)(s.h2,{id:"solution",children:"Solution"}),"\n",(0,a.jsxs)(s.p,{children:["The flash messages are designed to solve this problem. In such a scenario, the form endpoint (",(0,a.jsx)(s.code,{children:"/users/save"}),") will not be responsible for displaying the messages. Instead, it will be responsible for adding the new user to the database, storing the outcome of the form submission in the session data, and finally redirecting the user to the ",(0,a.jsx)(s.code,{children:"/users"})," endpoint."]}),"\n",(0,a.jsxs)(s.p,{children:["The ",(0,a.jsx)(s.code,{children:"/users"})," endpoint will then read the message from the session data and display it to the user. The message will be removed from the session data after being displayed to the user."]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-scala",children:'import zio._\nimport zio.http._\n\nval saveUserRoute: Route[Flash.Backend with Ref[List[User]], Nothing] =\n  Method.POST / "users" / "save" -> handler { (req: Request) =>\n    for {\n      usersDb <- ZIO.service[Ref[List[User]]]\n      flashBackend <- ZIO.service[Flash.Backend]\n      form    <- req.body.asURLEncodedForm\n      name    <- ZIO.fromOption(form.get("name")).flatMap(_.asText)\n      age     <- ZIO.fromOption(form.get("age")).flatMap(_.asText).map(_.toInt)\n      _       <- usersDb.update(_ appended User(name, age))\n      response <- flashBackend.addFlash(\n          response = Response.seeOther(URL.root / "users"),\n          setter = Flash.setNotice("User saved successfully!")\n        )\n    } yield response\n  }.catchAll { _ =>\n    handler {\n      for {\n        flashBackend <- ZIO.service[Flash.Backend]\n        response <- flashBackend.addFlash(\n            response = Response.seeOther(URL.root / "users"),\n            setter = Flash.setAlert("Failed to save user! Something went wrong!")\n          )\n      } yield response\n    }\n  }\n\nval getUsersRoute: Route[Ref[List[User]] with Flash.Backend, Nothing] =\n  Method.GET / "users" -> handler { (req: Request) =>\n    for {\n      flashBackend <- ZIO.service[Flash.Backend]\n      usersDb      <- ZIO.service[Ref[List[User]]]\n      users        <- usersDb.get\n      usersHTML = ui.renderUsers(users)\n      html <- flashBackend.flashOrElse(\n        request = req,\n        flash = Flash.getMessageHtml.foldHtml(ui.renderNotice, ui.renderAlert)(ui.renderBothMessage),\n      )(ui.renderNoFlash)\n    } yield Response.html(html ++ usersHTML)\n  }\n'})}),"\n",(0,a.jsxs)(t,{children:[(0,a.jsx)("summary",{children:(0,a.jsx)("b",{children:"Full Implementation Showcase"})}),(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-scala",children:'import zio._\nimport zio.http._\nimport zio.http.codec.PathCodec\n\ncase class User(name: String, age: Int)\n\nimport zio.http.template._\n\nobject ui {\n  def renderNoFlash = Html.fromString("no-flash")\n\n  def renderBothMessage(notice: Html, alert: Html): Html = notice ++ alert\n\n  def renderNotice(html: Html): Html = div(styleAttr := "background: green", html)\n\n  def renderAlert(html: Html): Html = div(styleAttr := "background: red", html)\n\n  def renderUsers(users: List[User]): Html = {\n    table(\n      borderAttr := "1",\n      tHead(\n        tr(\n          th("Name"),\n          th("Age"),\n        ),\n      ),\n      tBody(\n        ol(users.map { u =>\n          tr(\n            td(u.name),\n            td(u.age.toString),\n          )\n        }),\n      ),\n    )\n  }\n\n}\n\nobject NotificationWithFlash extends ZIOAppDefault {\n  val homeRoute: Route[Any, Nothing] =\n    Method.GET / PathCodec.empty -> handler {\n      Response.html(\n        form(idAttr := "myform", actionAttr := "/users/save", methodAttr := "POST",\n          label("Name:", forAttr("name")), br(),\n          input(typeAttr := "text", idAttr := "name", nameAttr := "name"), br(),\n          label("Age:", forAttr := "age"), br(),\n          input(typeAttr := "number", idAttr := "age", nameAttr := "age"), br(), br(),\n          button("Submit", typeAttr := "submit"),\n        ),\n      )\n    }\n    \nval saveUserRoute: Route[Flash.Backend with Ref[List[User]], Nothing] =\n  Method.POST / "users" / "save" -> handler { (req: Request) =>\n    for {\n      usersDb <- ZIO.service[Ref[List[User]]]\n      flashBackend <- ZIO.service[Flash.Backend]\n      form    <- req.body.asURLEncodedForm\n      name    <- ZIO.fromOption(form.get("name")).flatMap(_.asText)\n      age     <- ZIO.fromOption(form.get("age")).flatMap(_.asText).map(_.toInt)\n      _       <- usersDb.update(_ appended User(name, age))\n      response <- flashBackend.addFlash(\n          response = Response.seeOther(URL.root / "users"), \n          setter = Flash.setNotice("User saved successfully!")\n        )\n    } yield response\n  }.catchAll { _ =>\n    handler {\n      for {\n        flashBackend <- ZIO.service[Flash.Backend]\n        response <- flashBackend.addFlash(\n            response = Response.seeOther(URL.root / "users"),\n            setter = Flash.setAlert("Failed to save user! Something went wrong!")\n          )\n      } yield response\n    }\n  }\n\n\nval getUsersRoute: Route[Ref[List[User]] with Flash.Backend, Nothing] =\n  Method.GET / "users" -> handler { (req: Request) =>\n    for {\n      flashBackend <- ZIO.service[Flash.Backend]\n      usersDb      <- ZIO.service[Ref[List[User]]]\n      users        <- usersDb.get\n      usersHTML = ui.renderUsers(users)\n      html <- flashBackend.flashOrElse(\n        request = req,\n        flash = Flash.getMessageHtml.foldHtml(ui.renderNotice, ui.renderAlert)(ui.renderBothMessage),\n      )(ui.renderNoFlash)\n    } yield Response.html(html ++ usersHTML)\n  }\n\n  val app = Routes(saveUserRoute, getUsersRoute, homeRoute)\n\n  def run = Server.serve(app).provide(Server.default, Flash.Backend.inMemory, ZLayer(Ref.make(List.empty[User])))\n}\n'})}),(0,a.jsxs)(s.p,{children:["If we run the server and open the browser to ",(0,a.jsx)(s.code,{children:"http://localhost:8080"}),", we will see a form to submit user details. After submitting the form, we will see the outcome of the form submission on the ",(0,a.jsx)(s.code,{children:"/users"})," endpoint. The ",(0,a.jsx)(s.code,{children:"/users"})," endpoint is responsible for getting the stored flash messages and displaying them to the user."]}),(0,a.jsx)(s.p,{children:"If we refresh the page, the form won't be resubmitted, and the notification won't be displayed again. Flash messages are one-time messages that disappear after the first read."})]}),"\n",(0,a.jsx)(s.h2,{id:"settingretrieving-flash-messages",children:"Setting/Retrieving Flash Messages"}),"\n",(0,a.jsxs)(s.p,{children:["There are two types of flash messages, notice and alert. To set a flash message, we use the ",(0,a.jsx)(s.code,{children:"Flash.setNotice"})," and ",(0,a.jsx)(s.code,{children:"Flash.setAlert"})," methods. These methods take a message of type ",(0,a.jsx)(s.code,{children:"A"})," and return a ",(0,a.jsx)(s.code,{children:"Flash.Setter[A]"})," object:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-scala",children:'import zio.http._\nimport zio.schema.DeriveSchema\n\ncase class CustomAlert(\n  message: String,\n  cause: String\n)\n\nimplicit val customAlertSchema = DeriveSchema.gen[CustomAlert]\n\nval notice1: Flash.Setter[String] = \n  Flash.setNotice("The form was submitted successfully!")\nval notice2: Flash.Setter[Int] = \n  Flash.setNotice(10)\n\nval alert1: Flash.Setter[String] = \n  Flash.setAlert("The form submission failed. Please try again!")\nval alert2: Flash.Setter[CustomAlert] = \n  Flash.setAlert(CustomAlert("The form submission failed!", "Invalid form data."))\n'})}),"\n",(0,a.jsxs)(s.p,{children:["The ",(0,a.jsx)(s.code,{children:"Flash.Setter[A]"})," object is used to set the flash message in the session data by calling the ",(0,a.jsx)(s.code,{children:"Response#addFlash"})," or ",(0,a.jsx)(s.code,{children:"Flash.Backend#addFlash"})," methods:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-scala",children:"val response1: Response = response.addFlash(notice1)\nval response2: Response = response.addFlash(alert1)\n"})}),"\n",(0,a.jsxs)(s.p,{children:["The notice and alert flash messages are stored in the session data with their respective predefined keys, ",(0,a.jsx)(s.code,{children:"notice"})," and ",(0,a.jsx)(s.code,{children:"alert"}),". We have also a general setter to set a flash message with a custom key, ",(0,a.jsx)(s.code,{children:"Flash.setValue"}),". It takes a key and a value of type ",(0,a.jsx)(s.code,{children:"A"})," and returns a ",(0,a.jsx)(s.code,{children:"Flash.Setter[A]"})," object:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-scala",children:'import zio.http._\nimport zio.schema.DeriveSchema\n\nval setter1: Flash.Setter[String] = \n  Flash.setValue("security", "You haven\'t changed your password for a long time!")\nval setter2: Flash.Setter[Int] = \n  Flash.setValue("quota", 90)\n\ncase class Notification(\n  message: String,\n  service: String,\n  severity: Int \n)\nimplicit val notificationSchema = DeriveSchema.gen[Notification]\nval setter3: Flash.Setter[Notification] = \n  Flash.setValue("notification", Notification("Service is down!", "Database", 3))\n'})}),"\n",(0,a.jsxs)(s.p,{children:["The flash messages can be retrieved from the session data by calling the ",(0,a.jsx)(s.code,{children:"Request.flash"})," method. This method takes a ",(0,a.jsx)(s.code,{children:"Flash[A]"})," object and returns the typed value of the flash message (",(0,a.jsx)(s.code,{children:"Option[A]"}),"). To create a ",(0,a.jsx)(s.code,{children:"Flash"})," object, we use the ",(0,a.jsx)(s.code,{children:"Flash.get*"})," methods:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-scala",children:'request.flash(Flash.getNotice[String])\nrequest.flash(Flash.getNotice[Int])\n\nrequest.flash(Flash.getAlert[String])\nrequest.flash(Flash.getAlert[CustomAlert])\n\nrequest.flash(Flash.get[String]("security"))\nrequest.flash(Flash.get[Int]("quota"))\nrequest.flash(Flash.get[Notification]("notification"))\n'})}),"\n",(0,a.jsx)(s.p,{children:"Let's take a look at list of setter methods:"}),"\n",(0,a.jsxs)(s.table,{children:[(0,a.jsx)(s.thead,{children:(0,a.jsxs)(s.tr,{children:[(0,a.jsx)(s.th,{children:"Method"}),(0,a.jsx)(s.th,{children:"Output"}),(0,a.jsx)(s.th,{children:"Description"})]})}),(0,a.jsxs)(s.tbody,{children:[(0,a.jsxs)(s.tr,{children:[(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"Flash.setValue[A: Schema](key: String, a: A)"})}),(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"Setter[A]"})}),(0,a.jsxs)(s.td,{children:["Sets a flash value of type ",(0,a.jsx)(s.code,{children:"A"})," with the given key in the flash scope."]})]}),(0,a.jsxs)(s.tr,{children:[(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"Flash.setNotice[A: Schema](a: A)"})}),(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"Setter[A]"})}),(0,a.jsxs)(s.td,{children:["Sets a flash notice message with the provided value of type ",(0,a.jsx)(s.code,{children:"A"})," in the flash scope."]})]}),(0,a.jsxs)(s.tr,{children:[(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"Flash.setAlert[A: Schema](a: A)"})}),(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"Setter[A]"})}),(0,a.jsxs)(s.td,{children:["Sets a flash alert message with the provided value of type ",(0,a.jsx)(s.code,{children:"A"})," in the flash scope."]})]}),(0,a.jsxs)(s.tr,{children:[(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"Flash.setEmpty"})}),(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"Setter[Unit]"})}),(0,a.jsx)(s.td,{children:"Clears the flash scope by setting it to empty."})]})]})]}),"\n",(0,a.jsx)(s.p,{children:"And here is the list of getter methods:"}),"\n",(0,a.jsxs)(s.table,{children:[(0,a.jsx)(s.thead,{children:(0,a.jsxs)(s.tr,{children:[(0,a.jsx)(s.th,{children:"Method"}),(0,a.jsx)(s.th,{children:"Output"}),(0,a.jsx)(s.th,{children:"Description"})]})}),(0,a.jsxs)(s.tbody,{children:[(0,a.jsxs)(s.tr,{children:[(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"Flash.get[A: Schema](key: String)"})}),(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"Flash[A]"})}),(0,a.jsxs)(s.td,{children:["Gets any flash value of type ",(0,a.jsx)(s.code,{children:"A"})," with the given key ",(0,a.jsx)(s.code,{children:"key"}),"."]})]}),(0,a.jsxs)(s.tr,{children:[(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"Flash.getString(key: String)"})}),(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"Flash[String]"})}),(0,a.jsxs)(s.td,{children:["Gets a flash value of type ",(0,a.jsx)(s.code,{children:"String"})," with the given key ",(0,a.jsx)(s.code,{children:"key"}),"."]})]}),(0,a.jsxs)(s.tr,{children:[(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"Flash.getNotice[A: Schema]"})}),(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"Flash[A]"})}),(0,a.jsxs)(s.td,{children:["Gets a flash value of type ",(0,a.jsx)(s.code,{children:"A"})," associated with the notice key."]})]}),(0,a.jsxs)(s.tr,{children:[(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"Flash.getAlert[A: Schema]"})}),(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"Flash[A]"})}),(0,a.jsxs)(s.td,{children:["Gets a flash value of type ",(0,a.jsx)(s.code,{children:"A"})," associated with the alert key."]})]}),(0,a.jsxs)(s.tr,{children:[(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"Flash.getFloat(key: String)"})}),(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"Flash[Float]"})}),(0,a.jsxs)(s.td,{children:["Gets a flash value of type ",(0,a.jsx)(s.code,{children:"Float"})," with the given key ",(0,a.jsx)(s.code,{children:"key"}),"."]})]}),(0,a.jsxs)(s.tr,{children:[(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"Flash.getDouble(key: String)"})}),(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"Flash[Double]"})}),(0,a.jsxs)(s.td,{children:["Gets a flash value of type ",(0,a.jsx)(s.code,{children:"Double"})," with the given key ",(0,a.jsx)(s.code,{children:"key"}),"."]})]}),(0,a.jsxs)(s.tr,{children:[(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"Flash.getInt(key: String)"})}),(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"Flash[Int]"})}),(0,a.jsxs)(s.td,{children:["Gets a flash value of type ",(0,a.jsx)(s.code,{children:"Int"})," with the given key ",(0,a.jsx)(s.code,{children:"key"}),"."]})]}),(0,a.jsxs)(s.tr,{children:[(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"Flash.getLong(key: String)"})}),(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"Flash[Long]"})}),(0,a.jsxs)(s.td,{children:["Gets a flash value of type ",(0,a.jsx)(s.code,{children:"Long"})," with the given key ",(0,a.jsx)(s.code,{children:"key"}),"."]})]}),(0,a.jsxs)(s.tr,{children:[(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"Flash.getUUID(key: String)"})}),(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"Flash[UUID]"})}),(0,a.jsxs)(s.td,{children:["Gets a flash value of type ",(0,a.jsx)(s.code,{children:"UUID"})," with the given key ",(0,a.jsx)(s.code,{children:"key"}),"."]})]}),(0,a.jsxs)(s.tr,{children:[(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"Flash.getBoolean(key: String)"})}),(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"Flash[Boolean]"})}),(0,a.jsxs)(s.td,{children:["Gets a flash value of type ",(0,a.jsx)(s.code,{children:"Boolean"})," with the given key ",(0,a.jsx)(s.code,{children:"key"}),"."]})]}),(0,a.jsxs)(s.tr,{children:[(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"Flash.get[A: Schema]"})}),(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"Flash[A]"})}),(0,a.jsxs)(s.td,{children:["Gets the first flash value of type ",(0,a.jsx)(s.code,{children:"A"})," regardless of any key."]})]})]})]}),"\n",(0,a.jsx)(s.h2,{id:"settingretrieving-multiple-flash-messages",children:"Setting/Retrieving Multiple Flash Messages"}),"\n",(0,a.jsx)(s.p,{children:"Flash messages are composable, this means that we can have multiple flash messages and setting/retrieving them in a single request/response. Let's compose two setters and add them to a response:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-scala",children:'val setter: Flash.Setter[(String, String)] = \n  Flash.setNotice("The form was submitted successfully!") ++\n    Flash.setAlert("You are reaching your quota!")\nval response = Response.ok.addFlash(setter)\n'})}),"\n",(0,a.jsx)(s.p,{children:"Then we can retrieve both messages from the request:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-scala",children:"val getter: Flash[(String, String)] = \n  Flash.getNotice[String] <*> Flash.getAlert[String]\nval result: Option[(String, String)] = \n  request.flash(getter)\n"})}),"\n",(0,a.jsxs)(s.p,{children:["To render both messages, ZIO HTTP provides the ",(0,a.jsx)(s.code,{children:"Flash#getMessage"})," and ",(0,a.jsx)(s.code,{children:"Flash#getMessageHtml"})," which they return ",(0,a.jsx)(s.code,{children:"Flash[Message[A, B]]"})," and ",(0,a.jsx)(s.code,{children:"Flash[Message[Html, Html]]"}),". The ",(0,a.jsx)(s.code,{children:"Message"})," represents both a ",(0,a.jsx)(s.strong,{children:"notice"})," and an ",(0,a.jsx)(s.strong,{children:"alert"})," message, so we can render it by folding both messages into a single value using the ",(0,a.jsx)(s.code,{children:"Flash#foldHtml"})," method:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-scala",children:"val getBoth: Flash[Html] =\n  Flash.getMessageHtml.foldHtml(renderNotice, renderAlert)(renderBothMessage)\nval html = request.flash(getBoth).getOrElse(renderNoFlash)\n"})}),"\n",(0,a.jsxs)(t,{children:[(0,a.jsx)("summary",{children:(0,a.jsx)("b",{children:"Full Implementation Showcase"})}),(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-scala",children:'import zio._\nimport zio.http._\nimport zio.http.template._\n\nobject ui {\n  def renderNoFlash = Html.fromString("no-flash")\n\n  def renderNotice(html: Html): Html = div(styleAttr := "background: green", html)\n\n  def renderAlert(html: Html): Html = div(styleAttr := "background: red", html)\n\n  def renderBothMessage(notice: Html, alert: Html): Html = notice ++ alert\n}\n\nobject SetGetBothFlashExample extends ZIOAppDefault {\n  val routes = Routes(\n    Method.GET / "set-flash" -> handler {\n      val setBoth: Flash.Setter[(String, String)] =\n        Flash.setNotice("The form was submitted successfully!") ++\n          Flash.setAlert("You are reaching your quota!")\n      Response\n        .seeOther(URL.root / "get-flash")\n        .addFlash(setBoth)\n    },\n    Method.GET / "get-flash" -> handler { (req: Request) =>\n      val getBoth: Flash[Html] =\n        Flash.getMessageHtml.foldHtml(ui.renderNotice, ui.renderAlert)(ui.renderBothMessage)\n      Response.html(\n        req.flash(getBoth).getOrElse(ui.renderNoFlash),\n      )\n    },\n  ).sandbox\n\n  def run = Server.serve(routes).provide(Server.default, Flash.Backend.inMemory)\n}\n'})})]}),"\n",(0,a.jsx)(s.h2,{id:"flash-backends",children:"Flash Backends"}),"\n",(0,a.jsx)(s.h3,{id:"cookie-based-flash-scope",children:"Cookie-based Flash-scope"}),"\n",(0,a.jsxs)(s.p,{children:["By default, ZIO HTTP uses ",(0,a.jsx)(s.strong,{children:"cookie-based flash-scope"})," to store flash messages. This means that flash messages are stored in the session data as a cookie named ",(0,a.jsx)(s.code,{children:"zio-http-flash"}),". Let's run a simple example and see what is stored in the session data:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-scala",children:'import zio._\nimport zio.http._\n\nobject CookieBasedFlashExample extends ZIOAppDefault {\n  val routes = Routes(\n    Method.GET / "set-flash" -> handler {\n      Response\n        .seeOther(URL.root / "get-flash")\n        .addFlash(\n          Flash.setNotice("The form was submitted successfully!"),\n        )\n    },\n    Method.GET / "get-flash" -> handler { (req: Request) =>\n      Response.text(\n        req.flash(Flash.getNotice[String]).getOrElse("no-flash"),\n      )\n    },\n  ).sandbox\n\n  def run = Server.serve(routes).provide(Server.default)\n}\n'})}),"\n",(0,a.jsxs)(s.p,{children:["After running the server and calling the ",(0,a.jsx)(s.code,{children:"/set-flash"})," endpoint, we can inspect the headers of the response and see the ",(0,a.jsx)(s.code,{children:"zio-http-flash"})," cookie:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-bash",children:"$ curl -X GET http://127.0.0.1:8080/set-flash -i\nHTTP/1.1 303 See Other\nlocation: /get-flash\nset-cookie: zio-http-flash=%7B%22notice%22%3A%22%5C%22The+form+was+submitted+successfully%21%5C%22%22%7D; Path=/\ncontent-length: 0\n"})}),"\n",(0,a.jsxs)(s.p,{children:["We can see that the flash message is encoded and stored inside the ",(0,a.jsx)(s.code,{children:"zio-http-flash"})," cookie. The browser will store this cookie and send it back to the server on subsequent requests. If we call the ",(0,a.jsx)(s.code,{children:"/get-flash"})," endpoint with the ",(0,a.jsx)(s.code,{children:"zio-http-flash"})," cookie, we will see the flash message:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-bash",children:'$ curl -X GET http://127.0.0.1:8080/get-flash -H "cookie: zio-http-flash=%7B%22notice%22%3A%22%5C%22The+form+was+submitted+successfully%21%5C%22%22%7D; Path=/" -i\nHTTP/1.1 200 OK\ncontent-type: text/plain\ncontent-length: 28\n\nThe form was submitted successfully!\u23ce\n'})}),"\n",(0,a.jsx)(s.p,{children:"Using cookies to store flash messages has some limitations, such as the maximum size of the cookie, which is around 4KB."}),"\n",(0,a.jsx)(s.h3,{id:"backend-based-flash-scope",children:"Backend-based Flash-scope"}),"\n",(0,a.jsxs)(s.p,{children:["To overcome these limitations, ZIO HTTP provides a way to store flash messages in custom backends, such as in-memory, Redis, or any other custom backend. To use a backend, we need to get ",(0,a.jsx)(s.code,{children:"Flash.Backend"})," service from the environment and use it to set and retrieve flash messages and finally, we should provide an implementation of the ",(0,a.jsx)(s.code,{children:"Flash.Backend"})," trait to the HTTP application."]}),"\n",(0,a.jsxs)(s.p,{children:["ZIO HTTP has a built-in in-memory backend that can be used to store flash messages in memory of the server, but still requires a cookie to store the identifier of the flash messages. To use the in-memory backend, we can provide the ",(0,a.jsx)(s.code,{children:"Flash.Backend.inMemory"})," layer to our application:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-scala",children:'import zio._\nimport zio.http._\nimport zio.http.template._\n\nobject FlashBackendExample extends ZIOAppDefault {\n  val routes = Routes(\n    Method.GET / "set-flash" -> handler {\n      for {\n        flashBackend <- ZIO.service[Flash.Backend]\n        response     <- flashBackend.addFlash(\n          Response.seeOther(URL.root / "get-flash"),\n          Flash.setNotice("The form was submitted successfully!"),\n        )\n      } yield response\n    },\n    Method.GET / "get-flash" -> handler { (req: Request) =>\n      for {\n        flashBackend <- ZIO.service[Flash.Backend]\n        notice       <- flashBackend.flash(req, Flash.getNotice[String])\n      } yield Response.text(notice)\n    },\n  ).sandbox\n\n  def run = Server.serve(routes).provide(Server.default, Flash.Backend.inMemory)\n}\n'})}),"\n",(0,a.jsxs)(s.p,{children:["By running the server and calling the ",(0,a.jsx)(s.code,{children:"/set-flash"})," endpoint, we can see that the ",(0,a.jsx)(s.code,{children:"zio-http-flash"})," cookie is only used to store the identifier of the flash messages (",(0,a.jsx)(s.code,{children:"flashId"}),"), any other data is stored in server memory:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-bash",children:"milad@nixos ~> curl -x GET http://127.0.0.1:8080/set-flash -i\nHTTP/1.1 303 See Other\nlocation: /get-flash\nset-cookie: zio-http-flash=%7B%22flashId%22%3A%22%5C%22560c32c7-35c7-441e-9861-97562732db29%5C%22%22%7D; Path=/\ncontent-length: 0\n"})}),"\n",(0,a.jsxs)(s.p,{children:["If we call the ",(0,a.jsx)(s.code,{children:"/get-flash"})," endpoint with the ",(0,a.jsx)(s.code,{children:"zio-http-flash"})," cookie, we will see the flash message:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-bash",children:'$ curl -X GET http://127.0.0.1:8080/get-flash -H "cookie: zio-http-flash=%7B%22flashId%22%3A%22%5C%22560c32c7-35c7-441e-9861-97562732db29%5C%22%22%7D; Path=/" -i\nHTTP/1.1 200 OK\ncontent-type: text/plain\ncontent-length: 28\n\nThe form was submitted successfully!\n'})}),"\n",(0,a.jsx)(s.admonition,{type:"note",children:(0,a.jsxs)(s.p,{children:["When we are using ",(0,a.jsx)(s.strong,{children:"cookie-based flash-scope"}),", we are responsible for removing (expiring) the flash messages from the session data after being read/displayed to the user. However, when we are using ",(0,a.jsx)(s.strong,{children:"in-memory backed"}),", the flash messages are automatically removed, so after the first read, we have no access to the flash messages anymore."]})})]})}function c(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);