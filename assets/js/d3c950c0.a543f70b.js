"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[26234],{28453:(e,t,i)=>{i.d(t,{R:()=>s,x:()=>u});var r=i(96540);const n={},o=r.createContext(n);function s(e){const t=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function u(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:s(e.components),r.createElement(o.Provider,{value:t},e.children)}},46800:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>a,contentTitle:()=>u,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"reference/stm/tpriorityqueue","title":"TPriorityQueue","description":"A TPriorityQueue[A] is a mutable queue that can participate in STM transactions. A TPriorityQueue contains values of type A for which an Ordering is defined. Unlike a TQueue, take returns the highest priority value (the value that is first in the specified ordering) as opposed to the first value offered to the queue. The ordering of elements sharing the same priority when taken from the queue is not guaranteed.","source":"@site/versioned_docs/version-1.0.18/reference/stm/tpriorityqueue.md","sourceDirName":"reference/stm","slug":"/reference/stm/tpriorityqueue","permalink":"/1.0.18/reference/stm/tpriorityqueue","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/versioned_docs/version-1.0.18/reference/stm/tpriorityqueue.md","tags":[],"version":"1.0.18","frontMatter":{"id":"tpriorityqueue","title":"TPriorityQueue"}}');var n=i(74848),o=i(28453);const s={id:"tpriorityqueue",title:"TPriorityQueue"},u=void 0,a={},c=[{value:"Creating a TPriorityQueue",id:"creating-a-tpriorityqueue",level:2},{value:"Offering elements to a TPriorityQueue",id:"offering-elements-to-a-tpriorityqueue",level:2},{value:"Taking elements from a TPriorityQueue",id:"taking-elements-from-a-tpriorityqueue",level:2},{value:"Size of a TPriorityQueue",id:"size-of-a-tpriorityqueue",level:2}];function l(e){const t={code:"code",h2:"h2",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(t.p,{children:["A ",(0,n.jsx)(t.code,{children:"TPriorityQueue[A]"})," is a mutable queue that can participate in STM transactions. A ",(0,n.jsx)(t.code,{children:"TPriorityQueue"})," contains values of type ",(0,n.jsx)(t.code,{children:"A"})," for which an ",(0,n.jsx)(t.code,{children:"Ordering"})," is defined. Unlike a ",(0,n.jsx)(t.code,{children:"TQueue"}),", ",(0,n.jsx)(t.code,{children:"take"})," returns the highest priority value (the value that is first in the specified ordering) as opposed to the first value offered to the queue. The ordering of elements sharing the same priority when taken from the queue is not guaranteed."]}),"\n",(0,n.jsx)(t.h2,{id:"creating-a-tpriorityqueue",children:"Creating a TPriorityQueue"}),"\n",(0,n.jsxs)(t.p,{children:["You can create an empty ",(0,n.jsx)(t.code,{children:"TPriorityQueue"})," using the ",(0,n.jsx)(t.code,{children:"empty"})," constructor:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-scala",children:"import zio._\nimport zio.stm._\n\nval minQueue: STM[Nothing, TPriorityQueue[Int]] =\n  TPriorityQueue.empty\n"})}),"\n",(0,n.jsxs)(t.p,{children:["Notice that a ",(0,n.jsx)(t.code,{children:"TPriorityQueue"})," is created with an implicit ",(0,n.jsx)(t.code,{children:"Ordering"}),". By default, ",(0,n.jsx)(t.code,{children:"take"})," will return the value that is first in the specified ordering. For example, in a queue of events ordered by time the earliest event would be taken first. If you want a different behavior you can use a custom ",(0,n.jsx)(t.code,{children:"Ordering"}),"."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-scala",children:"val maxQueue: STM[Nothing, TPriorityQueue[Int]] =\n  TPriorityQueue.empty(Ordering[Int].reverse)\n"})}),"\n",(0,n.jsxs)(t.p,{children:["You can also create a ",(0,n.jsx)(t.code,{children:"TPriorityQueue"})," initialized with specified elements using the ",(0,n.jsx)(t.code,{children:"fromIterable"})," or ",(0,n.jsx)(t.code,{children:"make"}),' constructors". The ',(0,n.jsx)(t.code,{children:"fromIterable"})," constructor takes a ",(0,n.jsx)(t.code,{children:"Iterable"})," while the ",(0,n.jsx)(t.code,{children:"make"})," constructor takes a variable arguments sequence of elements."]}),"\n",(0,n.jsx)(t.h2,{id:"offering-elements-to-a-tpriorityqueue",children:"Offering elements to a TPriorityQueue"}),"\n",(0,n.jsxs)(t.p,{children:["You can offer elements to a ",(0,n.jsx)(t.code,{children:"TPriorityQueue"})," using the ",(0,n.jsx)(t.code,{children:"offer"})," or ",(0,n.jsx)(t.code,{children:"offerAll"})," methods. The ",(0,n.jsx)(t.code,{children:"offerAll"})," method is more efficient if you want to offer more than one element to the queue at the same time."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-scala",children:"val queue: STM[Nothing, TPriorityQueue[Int]] =\n  for {\n    queue <- TPriorityQueue.empty[Int]\n    _     <- queue.offerAll(List(2, 4, 6, 3, 5, 6))\n  } yield queue\n"})}),"\n",(0,n.jsx)(t.h2,{id:"taking-elements-from-a-tpriorityqueue",children:"Taking elements from a TPriorityQueue"}),"\n",(0,n.jsxs)(t.p,{children:["Take an element from a ",(0,n.jsx)(t.code,{children:"TPriorityQueue"})," using the ",(0,n.jsx)(t.code,{children:"take"}),". ",(0,n.jsx)(t.code,{children:"take"})," will semantically block until there is at least one value in the queue to take. You can also use ",(0,n.jsx)(t.code,{children:"takeAll"})," to immediately take all values that are currently in the queue, or ",(0,n.jsx)(t.code,{children:"takeUpTo"})," to immediately take up to the specified number of elements from the queue."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-scala",children:"val sorted: STM[Nothing, Chunk[Int]] =\n  for {\n    queue  <- TPriorityQueue.empty[Int]\n    _      <- queue.offerAll(List(2, 4, 6, 3, 5, 6))\n    sorted <- queue.takeAll\n  } yield sorted\n"})}),"\n",(0,n.jsxs)(t.p,{children:["You can also use ",(0,n.jsx)(t.code,{children:"takeOption"})," method to take the first value from the queue if it exists without suspending or the ",(0,n.jsx)(t.code,{children:"peek"})," method to observe the first element of the queue if it exists without removing it from the queue."]}),"\n",(0,n.jsxs)(t.p,{children:["Sometimes you want to take a snapshot of the current state of the queue without modifying it. For this the ",(0,n.jsx)(t.code,{children:"toChunk"})," combinator or its variants ",(0,n.jsx)(t.code,{children:"toList"})," or ",(0,n.jsx)(t.code,{children:"toVector"})," are extremely helpful. These will return an immutable collection that consists of all of the elements currently in the queue, leaving the state of the queue unchanged."]}),"\n",(0,n.jsx)(t.h2,{id:"size-of-a-tpriorityqueue",children:"Size of a TPriorityQueue"}),"\n",(0,n.jsxs)(t.p,{children:["You can check the size of the ",(0,n.jsx)(t.code,{children:"TPriorityQueue"})," using the ",(0,n.jsx)(t.code,{children:"size"})," method:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-scala",children:"\nval size: STM[Nothing, Int] =\n  for {\n    queue <- TPriorityQueue.empty[Int]\n    _     <- queue.offerAll(List(2, 4, 6, 3, 5, 6))\n    size  <- queue.size\n  } yield size\n"})})]})}function d(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}}}]);