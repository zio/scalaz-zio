"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[23935],{72402:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"reference/error-management/operations/error-refinement","title":"Error Refinement","description":"ZIO has some operators useful for converting defects into failures. So we can take part in non-recoverable errors and convert them into the typed error channel and vice versa.","source":"@site/docs/reference/error-management/operations/error-refinement.md","sourceDirName":"reference/error-management/operations","slug":"/reference/error-management/operations/error-refinement","permalink":"/reference/error-management/operations/error-refinement","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/error-management/operations/error-refinement.md","tags":[],"version":"current","frontMatter":{"id":"error-refinement","title":"Error Refinement"},"sidebar":"reference-sidebar","previous":{"title":"Converting Defects to Failures","permalink":"/reference/error-management/operations/converting-defects-to-failures"},"next":{"title":"Flattening Optional Error Types","permalink":"/reference/error-management/operations/flattening-optional-error-types"}}');var i=r(74848),t=r(28453);const a={id:"error-refinement",title:"Error Refinement"},s=void 0,c={},l=[{value:"Refining",id:"refining",level:2},{value:"<code>ZIO#refineToOrDie</code>",id:"ziorefinetoordie",level:3},{value:"<code>ZIO#refineOrDie</code>",id:"ziorefineordie",level:3},{value:"<code>ZIO#refineOrDieWith</code>",id:"ziorefineordiewith",level:3},{value:"Unrefining",id:"unrefining",level:2},{value:"<code>ZIO#unrefineTo[E1 &gt;: E]</code>",id:"ziounrefinetoe1--e",level:3},{value:"<code>ZIO#unrefine</code>",id:"ziounrefine",level:3},{value:"<code>ZIO#unrefineWith</code>",id:"ziounrefinewith",level:3}];function d(e){const n={code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"ZIO has some operators useful for converting defects into failures. So we can take part in non-recoverable errors and convert them into the typed error channel and vice versa."}),"\n",(0,i.jsxs)(n.p,{children:["Note that both ",(0,i.jsx)(n.code,{children:"ZIO#refine*"})," and ",(0,i.jsx)(n.code,{children:"ZIO#unrefine*"})," do not alter the error behavior, but only change the error model. That is to say, if an effect fails or die, then after ",(0,i.jsx)(n.code,{children:"ZIO#refine*"})," or ",(0,i.jsx)(n.code,{children:"ZIO#unrefine*"}),", it will still fail or die; and if an effect succeeds, then after ",(0,i.jsx)(n.code,{children:"ZIO#refine*"})," or ",(0,i.jsx)(n.code,{children:"ZIO#unrefine*"}),", it will still succeed; only the manner in which it signals the error will be altered by these two methods:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"ZIO#refine*"})," pinches off a piece of ",(0,i.jsx)(n.em,{children:"failure"})," of type ",(0,i.jsx)(n.code,{children:"E"}),", and converts it into a ",(0,i.jsx)(n.em,{children:"defect"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"ZIO#unrefine*"})," pinches off a piece of a ",(0,i.jsx)(n.em,{children:"defect"}),", and converts it into a ",(0,i.jsx)(n.em,{children:"failure"})," of type ",(0,i.jsx)(n.code,{children:"E"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"refining",children:"Refining"}),"\n",(0,i.jsx)(n.h3,{id:"ziorefinetoordie",children:(0,i.jsx)(n.code,{children:"ZIO#refineToOrDie"})}),"\n",(0,i.jsxs)(n.p,{children:["This operator ",(0,i.jsx)(n.strong,{children:"narrows"})," down the type of the error channel from ",(0,i.jsx)(n.code,{children:"E"})," to the ",(0,i.jsx)(n.code,{children:"E1"}),". It leaves the rest errors untyped, so everything that doesn't fit is turned into a defect. So it makes the error space ",(0,i.jsx)(n.strong,{children:"smaller"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"ZIO[-R, +E, +A] {\n  def refineToOrDie[E1 <: E]: ZIO[R, E1, A]\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the following example, we are going to implement ",(0,i.jsx)(n.code,{children:"parseInt"})," by importing ",(0,i.jsx)(n.code,{children:"String#toInt"})," code from the standard scala library using ",(0,i.jsx)(n.code,{children:"ZIO#attempt"})," and then refining the error channel from ",(0,i.jsx)(n.code,{children:"Throwable"})," to the ",(0,i.jsx)(n.code,{children:"NumberFormatException"})," error type:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"import zio._\n\ndef parseInt(input: String): ZIO[Any, NumberFormatException, Int] =\n  ZIO.attempt(input.toInt)                 // ZIO[Any, Throwable, Int]\n    .refineToOrDie[NumberFormatException]  // ZIO[Any, NumberFormatException, Int]\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In this example, if the ",(0,i.jsx)(n.code,{children:"input.toInt"})," throws any other exceptions other than ",(0,i.jsx)(n.code,{children:"NumberFormatException"}),", e.g. ",(0,i.jsx)(n.code,{children:"IndexOutOfBoundsException"}),", will be translated to the ZIO defect."]}),"\n",(0,i.jsx)(n.h3,{id:"ziorefineordie",children:(0,i.jsx)(n.code,{children:"ZIO#refineOrDie"})}),"\n",(0,i.jsx)(n.p,{children:"It is the more powerful version of the previous operator. Instead of refining to one specific error type, we can refine to multiple error types using a partial function:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"trait ZIO[-R, +E, +A] {\n  def refineOrDie[E1](pf: PartialFunction[E, E1]): ZIO[R, E1, A]\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the following example, we excluded the ",(0,i.jsx)(n.code,{children:"Baz"})," exception from recoverable errors, so it will be converted to a defect. In another word, we narrowed ",(0,i.jsx)(n.code,{children:"DomainError"})," down to just ",(0,i.jsx)(n.code,{children:"Foo"})," and ",(0,i.jsx)(n.code,{children:"Bar"})," errors:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nsealed abstract class DomainError(msg: String)\n  extends Exception(msg)\n    with Serializable\n    with Product\ncase class Foo(msg: String) extends DomainError(msg)\ncase class Bar(msg: String) extends DomainError(msg)\ncase class Baz(msg: String) extends DomainError(msg)\n\nobject MainApp extends ZIOAppDefault {\n  val effect: ZIO[Any, DomainError, Unit] =\n    ZIO.fail(Baz("Oh uh!"))\n\n  val refined: ZIO[Any, DomainError, Unit] =\n    effect.refineOrDie {\n      case foo: Foo => foo\n      case bar: Bar => bar\n    }\n\n  def run = refined.catchAll(_ => ZIO.unit).debug\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"ziorefineordiewith",children:(0,i.jsx)(n.code,{children:"ZIO#refineOrDieWith"})}),"\n",(0,i.jsxs)(n.p,{children:["In the two previous refine combinators, we were dealing with exceptional effects whose error channel type was ",(0,i.jsx)(n.code,{children:"Throwable"})," or a subtype of that. The ",(0,i.jsx)(n.code,{children:"ZIO#refineOrDieWith"})," operator is a more powerful version of refining operators. It can work with any exceptional effect whether they are ",(0,i.jsx)(n.code,{children:"Throwable"})," or not. When we narrow down the failure space, some failures become defects. To convert those failures to defects, it takes a function from ",(0,i.jsx)(n.code,{children:"E"})," to ",(0,i.jsx)(n.code,{children:"Throwable"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"trait ZIO[-R, +E, +A] {\n  def refineOrDieWith[E1](pf: PartialFunction[E, E1])(f: E => Throwable): ZIO[R, E1, A]\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the following example, we excluded the ",(0,i.jsx)(n.code,{children:"BazError"})," from recoverable errors, so it will be converted to a defect. In another word, we narrowed the whole space of ",(0,i.jsx)(n.code,{children:"String"}),' errors down to just "FooError" and "BarError":']}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def effect(i: String): ZIO[Any, String, Nothing] = {\n    if (i == "foo") ZIO.fail("FooError")\n    else if (i == "bar") ZIO.fail("BarError")\n    else ZIO.fail("BazError")\n  }\n\n  val refined: ZIO[Any, String, Nothing] =\n    effect("baz").refineOrDieWith {\n      case "FooError" | "BarError" => "Oh Uh!"\n    }(e => new Throwable(e))\n\n  def run = refined.catchAll(_ => ZIO.unit)\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"unrefining",children:"Unrefining"}),"\n",(0,i.jsx)(n.h3,{id:"ziounrefinetoe1--e",children:(0,i.jsx)(n.code,{children:"ZIO#unrefineTo[E1 >: E]"})}),"\n",(0,i.jsxs)(n.p,{children:["This operator ",(0,i.jsx)(n.strong,{children:"broadens"})," the type of the error channel from ",(0,i.jsx)(n.code,{children:"E"})," to the ",(0,i.jsx)(n.code,{children:"E1"})," and embeds some defects into it. So it is going from some fiber failures back to errors and thus making the error type ",(0,i.jsx)(n.strong,{children:"larger"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"trait ZIO[-R, +E, +A] {\n  def unrefineTo[E1 >: E]: ZIO[R, E1, A]\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the following example, we are going to implement ",(0,i.jsx)(n.code,{children:"parseInt"})," by importing ",(0,i.jsx)(n.code,{children:"String#toInt"})," code from the standard scala library using ",(0,i.jsx)(n.code,{children:"ZIO#succeed"})," and then unrefining the error channel from ",(0,i.jsx)(n.code,{children:"Nothing"})," to the ",(0,i.jsx)(n.code,{children:"NumberFormatException"})," error type:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"import zio._\n\ndef parseInt(input: String): ZIO[Any, NumberFormatException, Int] =\n  ZIO.succeed(input.toInt)              // ZIO[Any, Nothing, Int]\n    .unrefineTo[NumberFormatException]  // ZIO[Any, NumberFormatException, Int]\n"})}),"\n",(0,i.jsx)(n.h3,{id:"ziounrefine",children:(0,i.jsx)(n.code,{children:"ZIO#unrefine"})}),"\n",(0,i.jsxs)(n.p,{children:["It is a more powerful version of the previous operator. It takes a partial function from ",(0,i.jsx)(n.code,{children:"Throwable"})," to ",(0,i.jsx)(n.code,{children:"E1"})," and converts those defects to recoverable errors:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"trait ZIO[-R, +E, +A] {\n  def unrefine[E1 >: E](pf: PartialFunction[Throwable, E1]): ZIO[R, E1, A]\n}\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'import zio._\n\ncase class Foo(msg: String) extends Throwable(msg)\ncase class Bar(msg: String) extends Throwable(msg)\ncase class Baz(msg: String) extends Throwable(msg)\n\nobject MainApp extends ZIOAppDefault {\n  def unsafeOpThatMayThrows(i: String): String =\n    if (i == "foo")\n      throw Foo("Oh uh!")\n    else if (i == "bar")\n      throw Bar("Oh Error!")\n    else if (i == "baz")\n      throw Baz("Oh no!")\n    else i\n\n  def effect(i: String): ZIO[Any, Nothing, String] =\n    ZIO.succeed(unsafeOpThatMayThrows(i))\n\n  val unrefined: ZIO[Any, Foo, String] =\n    effect("foo").unrefine { case e: Foo => e }\n\n  def run = unrefined.catchAll(_ => ZIO.unit)\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Using ",(0,i.jsx)(n.code,{children:"ZIO#unrefine"})," we can have more control to unrefine a ZIO effect that may die because of some defects, for example in the following example we are going to convert both ",(0,i.jsx)(n.code,{children:"Foo"})," and ",(0,i.jsx)(n.code,{children:"Bar"})," defects to recoverable errors and remain ",(0,i.jsx)(n.code,{children:"Baz"})," unrecoverable:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'val unrefined: ZIO[Any, Throwable, String] =\n  effect("foo").unrefine {\n    case e: Foo => e\n    case e: Bar => e\n  }\n'})}),"\n",(0,i.jsx)(n.h3,{id:"ziounrefinewith",children:(0,i.jsx)(n.code,{children:"ZIO#unrefineWith"})}),"\n",(0,i.jsxs)(n.p,{children:["This is the most powerful version of unrefine operators. It takes a partial function, as the previous operator, and then tries to broaden the failure space by converting some of the defects to typed recoverable errors. If it doesn't find any defect, it will apply the ",(0,i.jsx)(n.code,{children:"f"})," which is a function from ",(0,i.jsx)(n.code,{children:"E"})," to ",(0,i.jsx)(n.code,{children:"E1"}),", and map all typed errors using this function:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"trait ZIO[-R, +E, +A] {\n  def unrefineWith[E1](pf: PartialFunction[Throwable, E1])(f: E => E1): ZIO[R, E1, A]\n}\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  case class Foo(msg: String) extends Exception(msg)\n  case class Bar(msg: String) extends Exception(msg)\n\n  val effect: ZIO[Any, Foo, Nothing] =\n    ZIO.ifZIO(Random.nextBoolean)(\n      onTrue = ZIO.fail(Foo("Oh uh!")),\n      onFalse = ZIO.die(Bar("Boom!"))\n    )\n\n  val unrefined: ZIO[Any, String, Nothing] =\n    effect\n      .unrefineWith {\n        case e: Bar => e.getMessage\n      }(e => e.getMessage)\n\n  def run = unrefined.cause.debug\n}\n'})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>s});var o=r(96540);const i={},t=o.createContext(i);function a(e){const n=o.useContext(t);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(t.Provider,{value:n},e.children)}}}]);