"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[59233],{13266:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"reference/test/services/random","title":"TestRandom","description":"When working with randomness, testing might be hard because the inputs to the tested function change on every invocation. So our code behaves in an indeterministic way.","source":"@site/docs/reference/test/services/random.md","sourceDirName":"reference/test/services","slug":"/reference/test/services/random","permalink":"/reference/test/services/random","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/test/services/random.md","tags":[],"version":"current","frontMatter":{"id":"random","title":"TestRandom"},"sidebar":"reference-sidebar","previous":{"title":"TestClock","permalink":"/reference/test/services/clock"},"next":{"title":"TestSystem","permalink":"/reference/test/services/system"}}');var o=t(74848),a=t(28453);const r={id:"random",title:"TestRandom"},i=void 0,d={},c=[{value:"Initial Seed with Series of Internal State Transition",id:"initial-seed-with-series-of-internal-state-transition",level:2},{value:"Feeding Predefined Random Values",id:"feeding-predefined-random-values",level:2}];function l(e){const n={code:"code",em:"em",h2:"h2",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"When working with randomness, testing might be hard because the inputs to the tested function change on every invocation. So our code behaves in an indeterministic way."}),"\n",(0,o.jsxs)(n.p,{children:["Precisely because of this reason ",(0,o.jsx)(n.code,{children:"ZIO"})," exposes ",(0,o.jsx)(n.code,{children:"TestRandom"})," module which allows for fully deterministic testing of code that deals with Randomness. ",(0,o.jsx)(n.code,{children:"TestRandom"})," can operate in two modes based on the needed use-case. It can generate a sequence of psudeo-random values using an initial seed with series of internal state transition or by feeding predefined random values."]}),"\n",(0,o.jsx)(n.h2,{id:"initial-seed-with-series-of-internal-state-transition",children:"Initial Seed with Series of Internal State Transition"}),"\n",(0,o.jsxs)(n.p,{children:["In the first mode, the ",(0,o.jsx)(n.code,{children:"TestRandom"})," is a purely functional pseudo-random number generator. It will generate pseudo-random values just like ",(0,o.jsx)(n.code,{children:"scala.util.Random"}),". While the ",(0,o.jsx)(n.code,{children:"scala.util.Random"})," doesn't have internal state, the ",(0,o.jsx)(n.code,{children:"TestRandom"})," has an internal state. Instead, methods like ",(0,o.jsx)(n.code,{children:"nextInt"})," describe state transitions from one random state to another that are automatically composed together through methods like ",(0,o.jsx)(n.code,{children:"flatMap"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["The random seed can be set using ",(0,o.jsx)(n.code,{children:"setSeed"})," and ",(0,o.jsx)(n.code,{children:"TestRandom"})," is guaranteed to return the same sequence of values for any given seed. This is useful for deterministically generating a sequence of pseudo-random values and powers the property based testing functionality in ZIO Test:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.test.{test, _}\nimport zio.test.Assertion._\n\ntest("Use setSeed to generate stable values") {\n  for {\n    _ <- TestRandom.setSeed(27)\n    r1 <- Random.nextLong\n    r2 <- Random.nextLong\n    r3 <- Random.nextLong\n  } yield\n    assertTrue(\n      List(r1, r2, r3) == List[Long](\n        -4947896108136290151L,\n        -5264020926839611059L,\n        -9135922664019402287L\n      )\n    )\n}\n// res0: Spec[Any, Nothing] = Spec(\n//   caseValue = LabeledCase(\n//     label = "Use setSeed to generate stable values",\n//     spec = Spec(\n//       caseValue = TestCase(\n//         test = FlatMap(\n//           trace = "repl.MdocSession.MdocApp.res0(random.md:17)",\n//           first = Stateful(\n//             trace = "repl.MdocSession.MdocApp.res0(random.md:17)",\n//             onState = zio.ZIO$$$Lambda$18748/0x00007f5d76edaf78@60df6e92\n//           ),\n//           successK = zio.test.package$ZTest$$$Lambda$18757/0x00007f5d76ee96d8@25ddeced\n//         ),\n//         annotations = Map(zio.test.TestAnnotation@b4aaf9ee -> List(SourceLocation(random.md,17)))\n//       )\n//     )\n//   )\n// )\n'})}),"\n",(0,o.jsx)(n.h2,{id:"feeding-predefined-random-values",children:"Feeding Predefined Random Values"}),"\n",(0,o.jsxs)(n.p,{children:["In the second mode, ",(0,o.jsx)(n.code,{children:"TestRandom"})," maintains an internal buffer of values that can be ",(0,o.jsx)(n.em,{children:"fed"})," with methods such as ",(0,o.jsx)(n.code,{children:"feedInts"})," and then when random values of that type are generated they will first be taken from the buffer. This is useful for verifying that functions produce the expected output for a given sequence of ",(0,o.jsx)(n.em,{children:"random"})," inputs."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"TestRandom"})," will automatically take values from the buffer if a value of the appropriate type is available and otherwise generate a pseudo-random value, so there is nothing we need to do to switch between the two modes. Just generate random values as we normally would to get pseudo-random values, or feed in values of our own to get those values back."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.test.{test, _}\nimport zio.test.Assertion._\n\ntest("One can provide its own list of ints") {\n  for {\n    _ <- TestRandom.feedInts(1, 9, 2, 8, 3, 7, 4, 6, 5)\n    r1 <- Random.nextInt\n    r2 <- Random.nextInt\n    r3 <- Random.nextInt\n    r4 <- Random.nextInt\n    r5 <- Random.nextInt\n    r6 <- Random.nextInt\n    r7 <- Random.nextInt\n    r8 <- Random.nextInt\n    r9 <- Random.nextInt\n  } yield assertTrue(\n    List(1, 9, 2, 8, 3, 7, 4, 6, 5) == List(r1, r2, r3, r4, r5, r6, r7, r8, r9)\n  )\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["We can also use methods like ",(0,o.jsx)(n.code,{children:"clearInts"})," to clear the buffer of values of a given type, so we can fill the buffer with new values or go back to pseudo-random number generation."]})]})}function m(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>i});var s=t(96540);const o={},a=s.createContext(o);function r(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);