"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[47968],{28453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>c});var a=i(96540);const r={},t=a.createContext(r);function l(e){const n=a.useContext(t);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),a.createElement(t.Provider,{value:n},e.children)}},88549:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>u,frontMatter:()=>l,metadata:()=>a,toc:()=>s});const a=JSON.parse('{"id":"reference/contextual/automatic-zlayer-derivation","title":"Automatic ZLayer Derivation","description":"ZIO\'s ZLayer is a powerful tool for building modular, testable, and composable applications. With the ZLayer.derive","source":"@site/docs/reference/contextual/automatic-zlayer-derivation.md","sourceDirName":"reference/contextual","slug":"/reference/contextual/automatic-zlayer-derivation","permalink":"/reference/contextual/automatic-zlayer-derivation","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/contextual/automatic-zlayer-derivation.md","tags":[],"version":"current","frontMatter":{"id":"automatic-zlayer-derivation","title":"Automatic ZLayer Derivation"},"sidebar":"reference-sidebar","previous":{"title":"ZLayer","permalink":"/reference/contextual/zlayer"},"next":{"title":"RLayer","permalink":"/reference/contextual/rlayer"}}');var r=i(74848),t=i(28453);const l={id:"automatic-zlayer-derivation",title:"Automatic ZLayer Derivation"},c=void 0,o={},s=[{value:"Basic Use Cases",id:"basic-use-cases",level:2},{value:"Default Values",id:"default-values",level:2},{value:"Pre-defined Default Values",id:"pre-defined-default-values",level:3},{value:"<code>Config[A]</code>",id:"configa",level:4},{value:"Some Concurrency Primitives",id:"some-concurrency-primitives",level:4},{value:"Creating New Default Value",id:"creating-new-default-value",level:3},{value:"Overriding Predefined Default Values",id:"overriding-predefined-default-values",level:3},{value:"Caveat: Use <code>Default.WithContext[R, E, A]</code> instead of <code>Default[A]</code> for type annotation",id:"caveat-use-defaultwithcontextr-e-a-instead-of-defaulta-for-type-annotation",level:3},{value:"Attaching Scoped Resources",id:"attaching-scoped-resources",level:2},{value:"Lifecycle Hooks",id:"lifecycle-hooks",level:3},{value:"Caveat: Manual layers do not respect <code>ZLayer.Derive.Scoped</code> and <code>ZLayer.Derive.AcquireRelease</code>",id:"caveat-manual-layers-do-not-respect-zlayerderivescoped-and-zlayerderiveacquirerelease",level:3}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["ZIO's ",(0,r.jsx)(n.code,{children:"ZLayer"})," is a powerful tool for building modular, testable, and composable applications. With the ",(0,r.jsx)(n.code,{children:"ZLayer.derive"}),"\nutility, you can automatically derive simple ",(0,r.jsx)(n.code,{children:"ZLayer"})," instances for your services, reducing boilerplate and simplifying\nyour codebase."]}),"\n",(0,r.jsx)(n.h2,{id:"basic-use-cases",children:"Basic Use Cases"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nclass Database(connection: String)\nobject Database {\n  val layer: ZLayer[String, Nothing, Database] = ZLayer.derive[Database]\n}\n\nclass UserService(db: Database)\nobject UserService {\n  val layer: ZLayer[Database, Nothing, UserService] = ZLayer.derive[UserService]\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"default-values",children:"Default Values"}),"\n",(0,r.jsxs)(n.p,{children:["For services that might have default values or configurations, ",(0,r.jsx)(n.code,{children:"ZLayer.derive"})," can use implicit\n",(0,r.jsx)(n.code,{children:"ZLayer.Derive.Default[A]"})," values:"]}),"\n",(0,r.jsx)(n.h3,{id:"pre-defined-default-values",children:"Pre-defined Default Values"}),"\n",(0,r.jsxs)(n.p,{children:["There are some pre-defined ",(0,r.jsx)(n.code,{children:"ZLayer.Derive.Default[A]"})," instances for the following types:"]}),"\n",(0,r.jsx)(n.h4,{id:"configa",children:(0,r.jsx)(n.code,{children:"Config[A]"})}),"\n",(0,r.jsxs)(n.p,{children:["When a service ",(0,r.jsx)(n.code,{children:"A"})," has a constructor parameter ",(0,r.jsx)(n.code,{children:"B"})," and there's an implicit ",(0,r.jsx)(n.code,{children:"Config[B]"})," instance, ",(0,r.jsx)(n.code,{children:"ZLayer.derive"}),"\nautomatically loads ",(0,r.jsx)(n.code,{children:"B"})," using ",(0,r.jsx)(n.code,{children:"ZIO.config"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio._\n\ncase class APIClientConfig(appKey: String, secretKey: Config.Secret)\nobject APIClientConfig {\n  // Because we have an implicit `Config[APIClientConfig]` in scope...\n  implicit val config: Config[APIClientConfig] =\n    (Config.string("appKey") ++ Config.secret("secretKey")).map {\n      case (uri, key) => APIClientConfig(uri, key)\n    }\n}\n\nclass APIClient(config: APIClientConfig) { /* ... */ }\nobject APIClient {\n\n  // `APIClientConfig` is automatically loaded using `ZIO.config` by `ZLayer.derive`,\n  // instead of being required as a layer input.\n  val layer: ZLayer[Any, Config.Error, APIClient] = ZLayer.derive[APIClient]\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Refer to ",(0,r.jsx)(n.a,{href:"/reference/configuration/",children:"Configuration"})," for more about ",(0,r.jsx)(n.code,{children:"Config"}),"."]}),"\n",(0,r.jsx)(n.h4,{id:"some-concurrency-primitives",children:"Some Concurrency Primitives"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"Promise[E, A]"})}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Queue[A]"})," (using ",(0,r.jsx)(n.code,{children:"Queue.unbounded"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Hub[A]"})," (using ",(0,r.jsx)(n.code,{children:"Hub.unbounded"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Ref[A]"})," (when ",(0,r.jsx)(n.code,{children:"A"})," has a default instance)"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"creating-new-default-value",children:"Creating New Default Value"}),"\n",(0,r.jsxs)(n.p,{children:["There are three main ways to create a ",(0,r.jsx)(n.code,{children:"ZLayer.Derive.Default"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"ZLayer.Derive.Default.succeed"})," for creating default values from simple values."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"ZLayer.Derive.Default.fromZIO"})," for creating default values from effects."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"ZLayer.Derive.Default.fromLayer"})," for creating default values from layers."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"overriding-predefined-default-values",children:"Overriding Predefined Default Values"}),"\n",(0,r.jsx)(n.p,{children:"At times, you may want to override a default value in specific scenarios. To achieve this, you can define your own\nimplicit value in a scope with a higher implicit priority, like a closer lexical scope."}),"\n",(0,r.jsxs)(n.p,{children:["A common scenario for this is when you want to discard a pre-defined default value and instead treat it as a dependency.\nUse ",(0,r.jsx)(n.code,{children:"ZLayer.Derive.Default.service"})," for this purpose:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"import zio._\nimport ZLayer.Derive.Default\n\nclass Wheels(number: Int)\nobject Wheels {\n  implicit val defaultWheels: Default.WithContext[Any, Nothing, Wheels] =\n    Default.succeed(new Wheels(4))\n}\nclass Car(wheels: Wheels)\n\nval carLayer1: ZLayer[Any, Nothing, Car] = ZLayer.derive[Car] // wheels.number == 4\nval carLayer2: ZLayer[Wheels, Nothing, Car] = locally {\n  // The default instance is discarded\n  implicit val newWheels: Default.WithContext[Wheels, Nothing, Wheels] =\n     Default.service[Wheels]\n\n  ZLayer.derive[Car]\n}\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"caveat-use-defaultwithcontextr-e-a-instead-of-defaulta-for-type-annotation",children:["Caveat: Use ",(0,r.jsx)(n.code,{children:"Default.WithContext[R, E, A]"})," instead of ",(0,r.jsx)(n.code,{children:"Default[A]"})," for type annotation"]}),"\n",(0,r.jsxs)(n.p,{children:["When providing type annotations for ",(0,r.jsx)(n.code,{children:"ZLayer.derive"}),", you must use ",(0,r.jsx)(n.code,{children:"ZLayer.Derive.Default.WithContext[R, E, A]"})," instead\nof the more general ",(0,r.jsx)(n.code,{children:"ZLayer.Derive.Default[A]"}),". Using the latter will result in a compilation error due to missing type\ndetails."]}),"\n",(0,r.jsx)(n.p,{children:"If you're uncertain about the exact type signature, a practical approach is to omit the type annotation initially. Then,\nuse your IDE's autocomplete feature to insert the inferred type."}),"\n",(0,r.jsx)(n.h2,{id:"attaching-scoped-resources",children:"Attaching Scoped Resources"}),"\n",(0,r.jsxs)(n.p,{children:["For services requiring resource management, ",(0,r.jsx)(n.code,{children:"ZLayer.derive"})," offers built-in support for scoped values. When a service\n",(0,r.jsx)(n.code,{children:"A"})," implements the ",(0,r.jsx)(n.code,{children:"ZLayer.Derive.Scoped[-R, +E]"})," trait, ",(0,r.jsx)(n.code,{children:"ZLayer.derive[A]"})," automatically recognizes it. As a result,\nthe ",(0,r.jsx)(n.code,{children:"scoped"})," effect is executed during the layer's construction and finalization phases."]}),"\n",(0,r.jsxs)(n.p,{children:["The 'resource' might be a background task, a lock file, or etc., that can be managed by ",(0,r.jsx)(n.a,{href:"/reference/resource/scope",children:(0,r.jsx)(n.code,{children:"Scope"})}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"import zio._\n\ntrait Connection {\n  def healthCheck: ZIO[Any, Throwable, Unit]\n  // ...\n}\n\nclass ThirdPartyService(connection: Connection) extends ZLayer.Derive.Scoped[Any, Nothing] {\n\n  // Repeats health check every 10 seconds in background during the layer's lifetime\n  override def scoped(implicit trace: Trace): ZIO[Scope, Nothing, Any] =\n    connection.healthCheck\n      .ignoreLogged\n      .repeat(Schedule.spaced(10.seconds))\n      .forkScoped\n}\n\nobject ThirdPartyService {\n  // `ZLayer.Derive.Scoped` should be used with `ZLayer.derive`\n  val layer: ZLayer[Connection, Nothing, ThirdPartyService] = ZLayer.derive[ThirdPartyService]\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.code,{children:"scoped"})," fails during resource acquisition, the entire ",(0,r.jsx)(n.code,{children:"ZLayer"})," initialization process fails."]}),"\n",(0,r.jsx)(n.h3,{id:"lifecycle-hooks",children:"Lifecycle Hooks"}),"\n",(0,r.jsxs)(n.p,{children:["Additionally, there's the ",(0,r.jsx)(n.code,{children:"ZLayer.Derive.AcquireRelease[R, E, A]"})," trait. This is a specialized version of\n",(0,r.jsx)(n.code,{children:"ZLayer.Derive.Scoped"})," designed for added convenience, allowing users to define initialization and finalization hooks\ndistinctly."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"import zio._\nimport java.io.File\n\ndef acquireLockFile(path: String): ZIO[Any, Throwable, File] = ???\ndef deleteFile(file: File): ZIO[Any, Throwable, Unit] = ???\n\nclass ASingletonService(lockFilePath: String) extends ZLayer.Derive.AcquireRelease[Any, Throwable, File] {\n\n  override def acquire: ZIO[Any, Throwable, File] =\n     acquireLockFile(lockFilePath)\n\n  override def release(lockFile: File): ZIO[Any, Nothing, Any] =\n     deleteFile(lockFile).ignore\n}\n\nobject ASingletonService {\n  // Note: it's for illustrative example. In a real-world application, you will probably want to\n  //       put the `String` in a config.\n  val layer: ZLayer[String, Throwable, ASingletonService] = ZLayer.derive[ASingletonService]\n}\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"caveat-manual-layers-do-not-respect-zlayerderivescoped-and-zlayerderiveacquirerelease",children:["Caveat: Manual layers do not respect ",(0,r.jsx)(n.code,{children:"ZLayer.Derive.Scoped"})," and ",(0,r.jsx)(n.code,{children:"ZLayer.Derive.AcquireRelease"})]}),"\n",(0,r.jsxs)(n.p,{children:["When manually creating ",(0,r.jsx)(n.code,{children:"ZLayer"})," instances without using ",(0,r.jsx)(n.code,{children:"ZLayer.derive"}),", the lifecycle hooks won't be automatically\ninvoked. Refer to ",(0,r.jsx)(n.a,{href:"/reference/resource/",children:"Resource Management in ZIO"})," for more details about general resource management\nin ZIO."]})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);