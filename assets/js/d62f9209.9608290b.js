"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[2637],{28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>r});var a=n(96540);const o={},s=a.createContext(o);function i(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),a.createElement(s.Provider,{value:t},e.children)}},49770:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"zio-schema/automatic-schema-derivation","title":"Automatic Schema Derivation","description":"Automatic schema derivation is the process of generating schema definitions for data types automatically, without the need to manually write them. It allows us to generate the schema for a data type based on its structure and annotations.","source":"@site/docs/zio-schema/automatic-schema-derivation.md","sourceDirName":"zio-schema","slug":"/zio-schema/automatic-schema-derivation","permalink":"/zio-schema/automatic-schema-derivation","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-schema/automatic-schema-derivation.md","tags":[],"version":"current","frontMatter":{"id":"automatic-schema-derivation","title":"Automatic Schema Derivation"},"sidebar":"ecosystem-sidebar","previous":{"title":"Manual Schema Construction","permalink":"/zio-schema/manual-schema-construction"},"next":{"title":"Operations","permalink":"/zio-schema/operations/"}}');var o=n(74848),s=n(28453);const i={id:"automatic-schema-derivation",title:"Automatic Schema Derivation"},r=void 0,c={},d=[];function m(e){const t={code:"code",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"Automatic schema derivation is the process of generating schema definitions for data types automatically, without the need to manually write them. It allows us to generate the schema for a data type based on its structure and annotations."}),"\n",(0,o.jsx)(t.p,{children:"Instead of manually specifying the schema for each data type, we can rely on automatic schema derivation to generate the schema for us. This approach can save time and reduce the potential for errors, especially when dealing with complex data models."}),"\n",(0,o.jsx)(t.p,{children:"By leveraging reflection and type introspection using macros, automatic schema derivation analyzes the structure of the data type and its fields, including their names, types, and annotations. It then generates the corresponding schema definition based on this analysis."}),"\n",(0,o.jsxs)(t.p,{children:["ZIO streamlines schema derivation through its ",(0,o.jsx)(t.code,{children:"zio-schema-derivation"})," package, which utilizes the capabilities of Scala macros to automatically derive schemas. In order to use automatic schema derivation, we neeed to add the following line to our ",(0,o.jsx)(t.code,{children:"build.sbt"})," file:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:'libraryDependencies += "dev.zio" %% "zio-schema-derivation" % 1.6.1\n'})}),"\n",(0,o.jsx)(t.p,{children:"Once again, let's revisit our domain models:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:"final case class Person(name: String, age: Int)\n\nsealed trait PaymentMethod\n\nobject PaymentMethod {\n  final case class CreditCard(number: String, expirationMonth: Int, expirationYear: Int) extends PaymentMethod\n  final case class WireTransfer(accountNumber: String, bankCode: String) extends PaymentMethod\n}\n\nfinal case class Customer(person: Person, paymentMethod: PaymentMethod)\n"})}),"\n",(0,o.jsx)(t.p,{children:"We can easily use auto derivation to create schemas:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:"import zio.schema._\nimport zio.schema.codec._\n\nfinal case class Person(name: String, age: Int)\n\nobject Person {\n  implicit val schema: Schema[Person] = DeriveSchema.gen[Person]\n}\n\nsealed trait PaymentMethod\n\nobject PaymentMethod {\n\n  implicit val schema: Schema[PaymentMethod] =\n    DeriveSchema.gen[PaymentMethod]\n\n  final case class CreditCard(\n      number: String,\n      expirationMonth: Int,\n      expirationYear: Int\n  ) extends PaymentMethod\n\n  final case class WireTransfer(accountNumber: String, bankCode: String)\n      extends PaymentMethod\n}\n\nfinal case class Customer(person: Person, paymentMethod: PaymentMethod)\n\nobject Customer {\n  implicit val schema: Schema[Customer] = DeriveSchema.gen[Customer]\n}\n"})}),"\n",(0,o.jsx)(t.p,{children:"Now we can write an example that demonstrates a roundtrip test for protobuf codecs:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:'// Create a customer instance\nval customer =\n  Customer(\n    person = Person("John Doe", 42),\n    paymentMethod = PaymentMethod.CreditCard("1000100010001000", 6, 2024)\n  )\n\n// Create binary codec from customer \nval customerCodec: BinaryCodec[Customer] =\n  ProtobufCodec.protobufCodec[Customer]\n\n// Encode the customer object\nval encodedCustomer: Chunk[Byte] = customerCodec.encode(customer)\n\n// Decode the byte array back to the person instance\nval decodedCustomer: Either[DecodeError, Customer] =\n  customerCodec.decode(encodedCustomer)\n\nassert(Right(customer) == decodedCustomer)\n'})})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(m,{...e})}):m(e)}}}]);