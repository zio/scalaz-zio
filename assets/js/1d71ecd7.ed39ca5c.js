"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[9763],{28453:(e,n,a)=>{a.d(n,{R:()=>t,x:()=>s});var r=a(96540);const o={},i=r.createContext(o);function t(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:t(e.components),r.createElement(i.Provider,{value:n},e.children)}},72446:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>t,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"reference/di/examples","title":"Examples","description":"An Example of a ZIO Application with Multiple Config Layers","source":"@site/docs/reference/di/examples.md","sourceDirName":"reference/di","slug":"/reference/di/examples","permalink":"/reference/di/examples","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/di/examples.md","tags":[],"version":"current","frontMatter":{"id":"examples","title":"Examples"},"sidebar":"reference-sidebar","previous":{"title":"Overriding Dependency Graph","permalink":"/reference/di/overriding-dependency-graph"},"next":{"title":"Introduction","permalink":"/reference/contextual/"}}');var o=a(74848),i=a(28453);const t={id:"examples",title:"Examples"},s=void 0,c={},l=[{value:"An Example of a ZIO Application with Multiple Config Layers",id:"an-example-of-a-zio-application-with-multiple-config-layers",level:2},{value:"An Example of Manually Generating a Dependency Graph",id:"an-example-of-manually-generating-a-dependency-graph",level:2},{value:"An Example of Automatically Generating a Dependency Graph",id:"an-example-of-automatically-generating-a-dependency-graph",level:2},{value:"An Example of Providing Different Implementations of the Same Service",id:"an-example-of-providing-different-implementations-of-the-same-service",level:2},{value:"An Example of How to Get Fresh Layers",id:"an-example-of-how-to-get-fresh-layers",level:2},{value:"An Example of Pass-through Dependencies",id:"an-example-of-pass-through-dependencies",level:2},{value:"An Example of Updating Hidden Dependencies",id:"an-example-of-updating-hidden-dependencies",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"an-example-of-a-zio-application-with-multiple-config-layers",children:"An Example of a ZIO Application with Multiple Config Layers"}),"\n",(0,o.jsxs)(n.p,{children:["In the following example, we have an application that requires ",(0,o.jsx)(n.code,{children:"AppConfig"})," layer, which itself requires ",(0,o.jsx)(n.code,{children:"DBConfig"})," and ",(0,o.jsx)(n.code,{children:"ServerConfig"})," layers:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import zio._\n\ncase class ServerConfig(host: String, port: Int)\nobject ServerConfig {\n  val layer: ULayer[ServerConfig] =\n    ZLayer.succeed(ServerConfig("localhost", 8080))\n}\n\ncase class DBConfig(name: String)\nobject DBConfig {\n  val layer: ULayer[DBConfig] =\n    ZLayer.succeed(DBConfig("my-test-db"))\n}\n\ncase class AppConfig(db: DBConfig, serverConfig: ServerConfig)\nobject AppConfig {\n  val layer: ZLayer[DBConfig with ServerConfig, Nothing, AppConfig] =\n    ZLayer {\n      for {\n        db     <- ZIO.service[DBConfig]\n        server <- ZIO.service[ServerConfig]\n      } yield AppConfig(db, server)\n    }\n}\n\nobject MainApp extends ZIOAppDefault {\n  val myApp =\n    for {\n      c <- ZIO.service[AppConfig]\n      _ <- ZIO.debug(s"Application started with config: ${c}")\n    } yield ()\n\n  def run = myApp.provide(AppConfig.layer, DBConfig.layer, ServerConfig.layer)\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"an-example-of-manually-generating-a-dependency-graph",children:"An Example of Manually Generating a Dependency Graph"}),"\n",(0,o.jsxs)(n.p,{children:["Suppose we have defined the ",(0,o.jsx)(n.code,{children:"UserRepo"}),", ",(0,o.jsx)(n.code,{children:"DocumentRepo"}),", ",(0,o.jsx)(n.code,{children:"Database"}),", ",(0,o.jsx)(n.code,{children:"BlobStorage"}),", and ",(0,o.jsx)(n.code,{children:"Cache"})," services and their respective implementations as follows:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import zio._\n\ncase class User(email: String, name: String)\n\ntrait UserRepo {\n  def save(user: User): Task[Unit]\n\n  def get(email: String): Task[User]\n}\n\nobject UserRepo {\n  def save(user: User): ZIO[UserRepo, Throwable, Unit] =\n    ZIO.serviceWithZIO(_.save(user))\n\n  def get(email: String): ZIO[UserRepo, Throwable, User] =\n    ZIO.serviceWithZIO(_.get(email))\n}\n\ncase class UserRepoLive(cache: Cache, database: Database) extends UserRepo {\n  override def save(user: User): Task[Unit] = ???\n\n  override def get(email: String): Task[User] = ???\n}\n\nobject UserRepoLive {\n  val layer: URLayer[Cache & Database, UserRepo] =\n    ZLayer {\n      for {\n        cache    <- ZIO.service[Cache]\n        database <- ZIO.service[Database]\n      } yield UserRepoLive(cache, database)\n    }\n}\n\ntrait Database\n\ncase class DatabaseLive() extends Database\n\nobject DatabaseLive {\n  val layer: ZLayer[Any, Nothing, Database] =\n    ZLayer.succeed(DatabaseLive())\n}\n\ntrait Cache {\n  def save(key: String, value: Array[Byte]): Task[Unit]\n\n  def get(key: String): Task[Array[Byte]]\n\n  def remove(key: String): Task[Unit]\n}\n\nclass InmemeoryCache() extends Cache {\n  override def save(key: String, value: Array[Byte]): Task[Unit] = ???\n\n  override def get(key: String): Task[Array[Byte]] = ???\n\n  override def remove(key: String): Task[Unit] = ???\n}\n\nobject InmemoryCache {\n  val layer: ZLayer[Any, Throwable, Cache] =\n    ZLayer(ZIO.attempt(new InmemeoryCache).debug("initialized"))\n}\n\nclass PersistentCache() extends Cache {\n  override def save(key: String, value: Array[Byte]): Task[Unit] = ???\n\n  override def get(key: String): Task[Array[Byte]] = ???\n\n  override def remove(key: String): Task[Unit] = ???\n}\n\nobject PersistentCache {\n  val layer: ZLayer[Any, Throwable, Cache] =\n    ZLayer(ZIO.attempt(new PersistentCache).debug("initialized"))\n}\n\ncase class Document(title: String, author: String, body: String)\n\ntrait DocumentRepo {\n  def save(document: Document): Task[Unit]\n\n  def get(id: String): Task[Document]\n}\n\nobject DocumentRepo {\n  def save(document: Document): ZIO[DocumentRepo, Throwable, Unit] =\n    ZIO.serviceWithZIO(_.save(document))\n\n  def get(id: String): ZIO[DocumentRepo, Throwable, Document] =\n    ZIO.serviceWithZIO(_.get(id))\n}\n\ncase class DocumentRepoLive(cache: Cache, blobStorage: BlobStorage) extends DocumentRepo {\n  override def save(document: Document): Task[Unit] = ???\n\n  override def get(id: String): Task[Document] = ???\n}\n\nobject DocumentRepoLive {\n  val layer: ZLayer[Cache & BlobStorage, Nothing, DocumentRepo] =\n    ZLayer {\n      for {\n        cache       <- ZIO.service[Cache]\n        blobStorage <- ZIO.service[BlobStorage]\n      } yield DocumentRepoLive(cache, blobStorage)\n    }\n}\n\ntrait BlobStorage {\n  def store(key: String, value: Array[Byte]): Task[Unit]\n}\n\ncase class BlobStorageLive() extends BlobStorage {\n  override def store(key: String, value: Array[Byte]): Task[Unit] = ???\n}\n\nobject BlobStorageLive {\n  val layer: URLayer[Any, BlobStorage] =\n    ZLayer.succeed(BlobStorageLive())\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"And then assume we have the following ZIO application:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import zio._\n\ndef myApp: ZIO[DocumentRepo & UserRepo, Throwable, Unit] =\n  for {\n    _ <- UserRepo.save(User("john@doe", "john"))\n    _ <- DocumentRepo.save(Document("introduction to zio", "john", ""))\n    _ <- UserRepo.get("john@doe").debug("retrieved john@doe user")\n    _ <- DocumentRepo.get("introduction to zio").debug("retrieved article about zio")\n  } yield ()\n'})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"myApp"})," requires ",(0,o.jsx)(n.code,{children:"DocumentRepo"})," and ",(0,o.jsx)(n.code,{children:"UserRepo"})," services to run. So we need to create a ",(0,o.jsx)(n.code,{children:"ZLayer"})," which requires no services and produces ",(0,o.jsx)(n.code,{children:"DocumentRepo"})," and ",(0,o.jsx)(n.code,{children:"UserRepo"}),". We can manually create this layer using ",(0,o.jsx)(n.a,{href:"/reference/di/manual-layer-construction#vertical-and-horizontal-composition",children:"vertical and horizontal layer composition"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  val layers: ZLayer[Any, Any, DocumentRepo with UserRepo] =\n    (BlobStorageLive.layer ++ InmemoryCache.layer ++ DatabaseLive.layer) >>>\n      (DocumentRepoLive.layer >+> UserRepoLive.layer)\n\n  def run = myApp.provideLayer(layers)\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"an-example-of-automatically-generating-a-dependency-graph",children:"An Example of Automatically Generating a Dependency Graph"}),"\n",(0,o.jsxs)(n.p,{children:["Instead of creating the required layer manually, we can use the ",(0,o.jsx)(n.code,{children:"ZIO#provide"}),". ZIO internally creates the dependency graph automatically based on all dependencies provided:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  def run =\n    myApp.provide(\n      InmemoryCache.layer,\n      DatabaseLive.layer,\n      UserRepoLive.layer,\n      BlobStorageLive.layer,\n      DocumentRepoLive.layer\n    )\n    \n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"an-example-of-providing-different-implementations-of-the-same-service",children:"An Example of Providing Different Implementations of the Same Service"}),"\n",(0,o.jsxs)(n.p,{children:["Let's say we want to provide different versions of the same service to different services. In this example, both ",(0,o.jsx)(n.code,{children:"UserRepo"})," and ",(0,o.jsx)(n.code,{children:"DocumentRepo"})," services require the ",(0,o.jsx)(n.code,{children:"Cache"})," service. However, we want to provide different cache implementations for these two services. Our goal is to provide an ",(0,o.jsx)(n.code,{children:"InmemoryCache"})," layer for ",(0,o.jsx)(n.code,{children:"UserRepo"})," and a ",(0,o.jsx)(n.code,{children:"PersistentCache"})," layer for the ",(0,o.jsx)(n.code,{children:"DocumentRepo"})," service:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  val layers: ZLayer[Any, Throwable, UserRepo with DocumentRepo] =\n    ((InmemoryCache.layer ++ DatabaseLive.layer) >>> UserRepoLive.layer) ++\n      ((PersistentCache.layer ++ BlobStorageLive.layer) >>> DocumentRepoLive.layer)\n\n  def run = myApp.provideLayer(layers)\n}\n\n// Output:\n// initialized: zio.examples.PersistentCache@6e899128\n// initialized: zio.examples.InmemeoryCache@852e20a\n"})}),"\n",(0,o.jsx)(n.h2,{id:"an-example-of-how-to-get-fresh-layers",children:"An Example of How to Get Fresh Layers"}),"\n",(0,o.jsxs)(n.p,{children:["Having covered the topic of ",(0,o.jsx)(n.a,{href:"/reference/di/dependency-memoization#acquiring-a-fresh-version",children:"acquiring fresh layers"}),", let's see an example of using the ",(0,o.jsx)(n.code,{children:"ZLayer#fresh"})," operator."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"DocumentRepo"})," and ",(0,o.jsx)(n.code,{children:"UserRepo"})," services are dependent on an in-memory cache service. On the other hand, let's assume the cache service is quite simple, and we might be prone to cache conflicts between services. While sharing the cache service may cause some problems for our business logic, we should separate the cache service for both ",(0,o.jsx)(n.code,{children:"DocumentRepo"})," and ",(0,o.jsx)(n.code,{children:"UserRepo"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  val layers: ZLayer[Any, Throwable, UserRepo & DocumentRepo] =\n    ((InmemoryCache.layer.fresh ++ DatabaseLive.layer) >>> UserRepoLive.layer) ++\n      ((InmemoryCache.layer.fresh ++ BlobStorageLive.layer) >>> DocumentRepoLive.layer)\n\n  def run = myApp.provideLayer(layers)\n}\n\n// Output:\n// initialized: zio.examples.InmemoryCache@13c9672b\n// initialized: zio.examples.InmemoryCache@26d79027\n"})}),"\n",(0,o.jsx)(n.h2,{id:"an-example-of-pass-through-dependencies",children:"An Example of Pass-through Dependencies"}),"\n",(0,o.jsxs)(n.p,{children:["Notice that in the previous examples, both ",(0,o.jsx)(n.code,{children:"UserRepo"})," and ",(0,o.jsx)(n.code,{children:"DocuemntRepo"})," have some ",(0,o.jsx)(n.a,{href:"/reference/di/manual-layer-construction#hidden-versus-passed-through-dependencies",children:"hidden dependencies"}),", such as ",(0,o.jsx)(n.code,{children:"Cache"}),", ",(0,o.jsx)(n.code,{children:"Database"}),", and ",(0,o.jsx)(n.code,{children:"BlobStorage"}),".  So these hidden dependencies are no longer expressed in the type signature of the ",(0,o.jsx)(n.code,{children:"layers"}),". From the perspective of a caller, ",(0,o.jsx)(n.code,{children:"layers"})," just outputs a ",(0,o.jsx)(n.code,{children:"UserRepo"})," and ",(0,o.jsx)(n.code,{children:"DocuemntRepo"})," and requires no inputs. The caller does not need to be concerned with the internal implementation details of how the ",(0,o.jsx)(n.code,{children:"UserRepo"})," and ",(0,o.jsx)(n.code,{children:"DocumentRepo"})," are constructed."]}),"\n",(0,o.jsxs)(n.p,{children:['An upstream dependency that is used by many other services can be "passed-through" and included in a layer\'s output. This can be done with the ',(0,o.jsx)(n.code,{children:">+>"})," operator, which provides the output of one layer to another layer, returning a new layer that outputs the services of ",(0,o.jsx)(n.em,{children:"both"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"The following example shows how to passthrough all dependencies to the final layer:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  // passthrough all dependencies\n  val layers: ZLayer[Any, Throwable, Database & BlobStorage & Cache & DocumentRepo & UserRepo] =\n    DatabaseLive.layer >+>\n      BlobStorageLive.layer >+>\n      InmemoryCache.layer >+>\n      DocumentRepoLive.layer >+>\n      UserRepoLive.layer\n\n  // providing all passthrough dependencies to the ZIO application\n  def run = myApp.provideLayer(layers)\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"an-example-of-updating-hidden-dependencies",children:"An Example of Updating Hidden Dependencies"}),"\n",(0,o.jsxs)(n.p,{children:["One of the use cases of having explicit all dependencies in the final layer is that we can ",(0,o.jsx)(n.a,{href:"/reference/di/examples#an-example-of-updating-hidden-dependencies",children:"update"})," those hidden layers using ",(0,o.jsx)(n.code,{children:"ZLayer#update"}),". In the following example, we are replacing the ",(0,o.jsx)(n.code,{children:"InmemoryCache"})," with another implementation called ",(0,o.jsx)(n.code,{children:"PersistentCache"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  def myApp: ZIO[DocumentRepo & UserRepo, Nothing, Unit] =\n    for {\n      _ <- ZIO.service[UserRepo]\n      _ <- ZIO.service[DocumentRepo]\n    } yield ()\n\n  val layers: ZLayer[Any, Throwable, Database & BlobStorage & Cache & DocumentRepo & UserRepo] =\n    DatabaseLive.layer >+>\n      BlobStorageLive.layer >+>\n      InmemoryCache.layer >+>\n      DocumentRepoLive.layer >+>\n      UserRepoLive.layer\n\n  def run =\n    myApp.provideLayer(\n      layers.update[Cache](_ => new PersistentCache)\n    )\n}\n"})})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);