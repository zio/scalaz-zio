"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[69436],{28453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>o});var i=r(96540);const s={},t=i.createContext(s);function a(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(t.Provider,{value:n},e.children)}},57876:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"reference/error-management/operations/exposing-errors-in-the-success-channel","title":"Exposing Errors in The Success Channel","description":"Before taking into ZIO#either and ZIO#absolve, let\'s see their signature:","source":"@site/docs/reference/error-management/operations/exposing-errors-in-the-success-channel.md","sourceDirName":"reference/error-management/operations","slug":"/reference/error-management/operations/exposing-errors-in-the-success-channel","permalink":"/reference/error-management/operations/exposing-errors-in-the-success-channel","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/error-management/operations/exposing-errors-in-the-success-channel.md","tags":[],"version":"current","frontMatter":{"id":"exposing-errors-in-the-success-channel","title":"Exposing Errors in The Success Channel"},"sidebar":"reference-sidebar","previous":{"title":"Tapping Errors","permalink":"/reference/error-management/operations/tapping-errors"},"next":{"title":"Exposing the Cause in The Success Channel","permalink":"/reference/error-management/operations/exposing-the-cause-in-the-success-channel"}}');var s=r(74848),t=r(28453);const a={id:"exposing-errors-in-the-success-channel",title:"Exposing Errors in The Success Channel"},o=void 0,c={},l=[{value:"<code>ZIO#either</code>",id:"zioeither",level:2},{value:"<code>ZIO#absolve</code>/<code>ZIO.absolve</code>",id:"zioabsolvezioabsolve",level:2}];function d(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Before taking into ",(0,s.jsx)(n.code,{children:"ZIO#either"})," and ",(0,s.jsx)(n.code,{children:"ZIO#absolve"}),", let's see their signature:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"trait ZIO[-R, +E, +A] {\n  def either(implicit ev: CanFail[E]): URIO[R, Either[E, A]]\n  def absolve[E1 >: E, B](implicit ev: A IsSubtypeOfOutput Either[E1, B]): ZIO[R, E1, B]\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Before continuing, let's take a look again at the ",(0,s.jsx)(n.code,{children:"validate"})," function we have written earlier:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nsealed trait AgeValidationException extends Exception\ncase class NegativeAgeException(age: Int) extends AgeValidationException\ncase class IllegalAgeException(age: Int)  extends AgeValidationException\n\ndef validate(age: Int): ZIO[Any, AgeValidationException, Int] =\n  if (age < 0)\n    ZIO.fail(NegativeAgeException(age))\n  else if (age < 18)\n    ZIO.fail(IllegalAgeException(age))\n  else ZIO.succeed(age)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Now we are ready to use ",(0,s.jsx)(n.code,{children:"ZIO#either"})," and ",(0,s.jsx)(n.code,{children:"ZIO#absolve"})," operations:"]}),"\n",(0,s.jsx)(n.h2,{id:"zioeither",children:(0,s.jsx)(n.code,{children:"ZIO#either"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"ZIO#either"})," convert a ",(0,s.jsx)(n.code,{children:"ZIO[R, E, A]"})," effect to another effect in which its failure (",(0,s.jsx)(n.code,{children:"E"}),") and success (",(0,s.jsx)(n.code,{children:"A"}),") channel have been lifted into an ",(0,s.jsx)(n.code,{children:"Either[E, A]"})," data type as success channel of the ",(0,s.jsx)(n.code,{children:"ZIO"})," data type:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nval age: Int = ???\n\nval res: URIO[Any, Either[AgeValidationException, Int]] = validate(age).either\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The resulting effect is an unexceptional effect and cannot fail, because the failure case has been exposed as part of the ",(0,s.jsx)(n.code,{children:"Either"})," success case. The error parameter of the returned ",(0,s.jsx)(n.code,{children:"ZIO"})," is ",(0,s.jsx)(n.code,{children:"Nothing"}),", since it is guaranteed the ",(0,s.jsx)(n.code,{children:"ZIO"})," effect does not model failure."]}),"\n",(0,s.jsxs)(n.p,{children:["This method is useful for recovering from ",(0,s.jsx)(n.code,{children:"ZIO"})," effects that may fail:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport java.io.IOException\n\nval myApp: ZIO[Any, IOException, Unit] =\n  for {\n    _ <- Console.print("Please enter your age: ")\n    age <- Console.readLine.map(_.toInt)\n    res <- validate(age).either\n    _ <- res match {\n      case Left(error) => ZIO.debug(s"validation failed: $error")\n      case Right(age) => ZIO.debug(s"The $age validated!")\n    }\n  } yield ()\n'})}),"\n",(0,s.jsxs)(n.h2,{id:"zioabsolvezioabsolve",children:[(0,s.jsx)(n.code,{children:"ZIO#absolve"}),"/",(0,s.jsx)(n.code,{children:"ZIO.absolve"})]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"ZIO#abolve"})," operator and the ",(0,s.jsx)(n.code,{children:"ZIO.absolve"})," constructor perform the inverse. They submerge the error case of an ",(0,s.jsx)(n.code,{children:"Either"})," into the ",(0,s.jsx)(n.code,{children:"ZIO"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nval age: Int = ???\nvalidate(age) // ZIO[Any, AgeValidationException, Int]\n  .either     // ZIO[Any, Either[AgeValidationException, Int]]\n  .absolve    // ZIO[Any, AgeValidationException, Int]\n"})}),"\n",(0,s.jsx)(n.p,{children:"Here is another example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import zio._\n\ndef sqrt(input: ZIO[Any, Nothing, Double]): ZIO[Any, String, Double] =\n  ZIO.absolve(\n    input.map { value =>\n      if (value < 0.0)\n        Left("Value must be >= 0.0")\n      else\n        Right(Math.sqrt(value))\n    }\n  )\n'})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);