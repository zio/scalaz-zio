"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[26455],{86765:(e,a,r)=>{r.r(a),r.d(a,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>m});const t=JSON.parse('{"id":"reference/stm/tsemaphore","title":"TSemaphore","description":"TSemaphore is a semaphore with transactional semantics that can be used to control access to a common resource. It","source":"@site/docs/reference/stm/tsemaphore.md","sourceDirName":"reference/stm","slug":"/reference/stm/tsemaphore","permalink":"/reference/stm/tsemaphore","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/stm/tsemaphore.md","tags":[],"version":"current","frontMatter":{"id":"tsemaphore","title":"TSemaphore"},"sidebar":"reference-sidebar","previous":{"title":"TReentrantLock","permalink":"/reference/stm/treentrantlock"},"next":{"title":"THub","permalink":"/reference/stm/thub"}}');var i=r(74848),n=r(28453);const s={id:"tsemaphore",title:"TSemaphore"},o=void 0,c={},m=[{value:"Create a TSemaphore",id:"create-a-tsemaphore",level:2},{value:"Acquire a permit",id:"acquire-a-permit",level:2},{value:"Release a permit",id:"release-a-permit",level:2},{value:"Retrieve available permits",id:"retrieve-available-permits",level:2},{value:"Execute an arbitrary STM action with automatic acquire and release",id:"execute-an-arbitrary-stm-action-with-automatic-acquire-and-release",level:2},{value:"Acquire and release multiple permits",id:"acquire-and-release-multiple-permits",level:2}];function l(e){const a={code:"code",h2:"h2",p:"p",pre:"pre",...(0,n.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(a.p,{children:[(0,i.jsx)(a.code,{children:"TSemaphore"})," is a semaphore with transactional semantics that can be used to control access to a common resource. It\nholds a certain number of permits, and permits may be acquired or released."]}),"\n",(0,i.jsx)(a.h2,{id:"create-a-tsemaphore",children:"Create a TSemaphore"}),"\n",(0,i.jsxs)(a.p,{children:["Creating a ",(0,i.jsx)(a.code,{children:"TSemaphore"})," with 10 permits:"]}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-scala",children:"import zio._\nimport zio.stm._\n\nval tSemaphoreCreate: STM[Nothing, TSemaphore] = TSemaphore.make(10L)\n"})}),"\n",(0,i.jsx)(a.h2,{id:"acquire-a-permit",children:"Acquire a permit"}),"\n",(0,i.jsxs)(a.p,{children:["Acquiring a permit reduces the number of remaining permits that the ",(0,i.jsx)(a.code,{children:"TSemaphore"})," contains. Acquiring a permit is done\nwhen a user wants to access a common shared resource:"]}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-scala",children:"import zio._\nimport zio.stm._\n\nval tSemaphoreAcq: STM[Nothing, TSemaphore] = for {\n  tSem <- TSemaphore.make(2L)\n  _    <- tSem.acquire\n} yield tSem\n\ntSemaphoreAcq.commit\n"})}),"\n",(0,i.jsx)(a.p,{children:"Note that if you try to acquire a permit when there are no more remaining permits in the semaphore then execution will be blocked semantically until a permit is ready to be acquired. Note that semantic blocking does not block threads and the STM transaction will only be retried when a permit is released."}),"\n",(0,i.jsx)(a.h2,{id:"release-a-permit",children:"Release a permit"}),"\n",(0,i.jsx)(a.p,{children:"Once you have finished accessing the shared resource, you must release your permit so other parties can access the\nshared resource:"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-scala",children:"import zio._\nimport zio.stm._\n\nval tSemaphoreRelease: STM[Nothing, TSemaphore] = for {\n  tSem <- TSemaphore.make(1L)\n  _    <- tSem.acquire\n  _    <- tSem.release\n} yield tSem\n\ntSemaphoreRelease.commit\n"})}),"\n",(0,i.jsx)(a.h2,{id:"retrieve-available-permits",children:"Retrieve available permits"}),"\n",(0,i.jsxs)(a.p,{children:["You can query for the remaining amount of permits in the TSemaphore by using ",(0,i.jsx)(a.code,{children:"available"}),":"]}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-scala",children:"import zio._\nimport zio.stm._\n\nval tSemaphoreAvailable: STM[Nothing, Long] = for {\n  tSem <- TSemaphore.make(2L)\n  _    <- tSem.acquire\n  cap  <- tSem.available\n} yield cap\n\ntSemaphoreAvailable.commit\n"})}),"\n",(0,i.jsxs)(a.p,{children:["The above code creates a TSemaphore with two permits and acquires one permit without releasing it. Here, ",(0,i.jsx)(a.code,{children:"available"}),"\nwill report that there is a single permit left."]}),"\n",(0,i.jsx)(a.h2,{id:"execute-an-arbitrary-stm-action-with-automatic-acquire-and-release",children:"Execute an arbitrary STM action with automatic acquire and release"}),"\n",(0,i.jsx)(a.p,{children:"You can choose to execute any arbitrary STM action that requires acquiring and releasing permit on TSemaphore as part\nof the same transaction. Rather than doing:"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-scala",children:"import zio._\nimport zio.stm._\n\ndef yourSTMAction: STM[Nothing, Unit] = STM.unit\n\nval tSemaphoreWithoutPermit: STM[Nothing, Unit] = \n  for {\n    sem <- TSemaphore.make(1L)\n    _   <- sem.acquire\n    a   <- yourSTMAction\n    _   <- sem.release\n  } yield a\n\ntSemaphoreWithoutPermit.commit\n"})}),"\n",(0,i.jsxs)(a.p,{children:["You can simply use ",(0,i.jsx)(a.code,{children:"withPermit"})," instead:"]}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-scala",children:"import zio._\nimport zio.stm._\n\nval tSemaphoreWithPermit: IO[Nothing, Unit] =\n  for {\n    sem <- TSemaphore.make(1L).commit\n    a   <- sem.withPermit(yourSTMAction.commit)\n  } yield a\n"})}),"\n",(0,i.jsxs)(a.p,{children:["It is considered best practice to use ",(0,i.jsx)(a.code,{children:"withPermit"})," over using an ",(0,i.jsx)(a.code,{children:"acquire"})," and a ",(0,i.jsx)(a.code,{children:"release"})," directly unless dealing with more complicated use cases that involve multiple STM actions where ",(0,i.jsx)(a.code,{children:"acquire"})," is not at the start and ",(0,i.jsx)(a.code,{children:"release"})," is not at the end of the STM transaction."]}),"\n",(0,i.jsx)(a.h2,{id:"acquire-and-release-multiple-permits",children:"Acquire and release multiple permits"}),"\n",(0,i.jsxs)(a.p,{children:["It is possible to acquire and release multiple permits at a time using ",(0,i.jsx)(a.code,{children:"acquireN"})," and ",(0,i.jsx)(a.code,{children:"releaseN"}),":"]}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-scala",children:"import zio._\nimport zio.stm._\n\nval tSemaphoreAcquireNReleaseN: STM[Nothing, Boolean] = for {\n  sem <- TSemaphore.make(3L)\n  _   <- sem.acquireN(3L)\n  cap <- sem.available \n  _   <- sem.releaseN(3L)\n} yield cap == 0\n\ntSemaphoreAcquireNReleaseN.commit\n"})})]})}function h(e={}){const{wrapper:a}={...(0,n.R)(),...e.components};return a?(0,i.jsx)(a,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},28453:(e,a,r)=>{r.d(a,{R:()=>s,x:()=>o});var t=r(96540);const i={},n=t.createContext(i);function s(e){const a=t.useContext(n);return t.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function o(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(n.Provider,{value:a},e.children)}}}]);