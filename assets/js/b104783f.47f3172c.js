"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[11898],{57350:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"zio-flow/backends","title":"Backends","description":"This page lists all the provided backend implementations for storing persistent data in the ZIO Flow executors.","source":"@site/docs/zio-flow/backends.md","sourceDirName":"zio-flow","slug":"/zio-flow/backends","permalink":"/zio-flow/backends","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-flow/backends.md","tags":[],"version":"current","frontMatter":{"id":"backends","title":"Backends"},"sidebar":"ecosystem-sidebar","previous":{"title":"Execution","permalink":"/zio-flow/execution"},"next":{"title":"Testing","permalink":"/zio-flow/testing"}}');var s=a(74848),o=a(28453);const i={id:"backends",title:"Backends"},r="Backends",l={},d=[{value:"RocksDB",id:"rocksdb",level:2},{value:"Cassandra",id:"cassandra",level:2},{value:"Supported Versions",id:"supported-versions",level:3},{value:"Database Setup",id:"database-setup",level:3},{value:"Performance/Scaling Considerations:",id:"performancescaling-considerations",level:3},{value:"DynamoDB",id:"dynamodb",level:2},{value:"Metrics",id:"metrics",level:3},{value:"Database Setup",id:"database-setup-1",level:3},{value:"Performance/Scaling Considerations:",id:"performancescaling-considerations-1",level:3},{value:"In-memory",id:"in-memory",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"backends",children:"Backends"})}),"\n",(0,s.jsxs)(n.p,{children:["This page lists all the provided ",(0,s.jsx)(n.em,{children:"backend implementations"})," for storing persistent data in the ZIO Flow executors.\nBackend implementations need to implement two interfaces:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"KeyValueStore"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"IndexedStore"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Custom backend implementations are possible by implementing these traits, and a shared ",(0,s.jsx)(n.em,{children:"test suite"})," is published to\nvalidate the custom implementations (more information about this can be found in\nthe ",(0,s.jsx)(n.a,{href:"testing#testing-backends",children:"testing section"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"rocksdb",children:"RocksDB"}),"\n",(0,s.jsx)(n.p,{children:"The RocksDb backend is implemented in the following module:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'libraryDependencies += "dev.zio" %% "zio-flow-rocksdb" % "1.0.0-RC4"\n'})}),"\n",(0,s.jsx)(n.p,{children:"RocksDb databases are stored in local files. You can use the same file for the key-value store and the indexed store,\nbut you don't have to."}),"\n",(0,s.jsx)(n.h2,{id:"cassandra",children:"Cassandra"}),"\n",(0,s.jsx)(n.p,{children:"To use Cassandra as a ZIO Flow backend, add the following dependency:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'libraryDependencies += "dev.zio" %% "zio-flow-cassandra" % "1.0.0-RC4"\n'})}),"\n",(0,s.jsx)(n.h3,{id:"supported-versions",children:"Supported Versions"}),"\n",(0,s.jsxs)(n.p,{children:["The Cassandra module supports Cassandra 3.x, Cassandra 4.x and ScyllaDB 4.x. Specifically, we test against Cassandra\n3.11, Cassandra 4.1, and ScyllaDB 4.5. See ",(0,s.jsx)(n.code,{children:"CassandraKeyValueStoreSpec.scala"})," in the test suite for more details."]}),"\n",(0,s.jsx)(n.h3,{id:"database-setup",children:"Database Setup"}),"\n",(0,s.jsx)(n.p,{children:"The Cassandra module requires two tables (column family) for persistence."}),"\n",(0,s.jsx)(n.p,{children:"To create these tables, run the following CQL statements:"}),"\n",(0,s.jsx)(n.p,{children:"for key-value store:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cql",children:"CREATE TABLE _zflow_key_value_store (\n  zflow_kv_namespace  VARCHAR,\n  zflow_kv_key        BLOB,\n  zflow_kv_timestamp  BIGINT,\n  zflow_kv_value      BLOB,\n  PRIMARY KEY (zflow_kv_namespace, zflow_kv_key, zflow_kv_timestamp)\n);\n"})}),"\n",(0,s.jsx)(n.p,{children:"for indexed store:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cql",children:"CREATE TABLE _zflow_idx_store (\n  zflow_idx_topic  VARCHAR,\n  zflow_idx_index  BIGINT,\n  zflow_idx_value  BLOB,\n  PRIMARY KEY (zflow_idx_topic, zflow_idx_index)\n);\n"})}),"\n",(0,s.jsx)(n.p,{children:"You should add table options to this statement in a production environment for tuning. Please consult the official\ndocumentations of the database product of your choosing."}),"\n",(0,s.jsx)(n.h3,{id:"performancescaling-considerations",children:"Performance/Scaling Considerations:"}),"\n",(0,s.jsxs)(n.p,{children:["As you can see from the CQL above, the primary key is composed of the three columns, ",(0,s.jsx)(n.code,{children:"zflow_kv_namespace"}),"\n, ",(0,s.jsx)(n.code,{children:"zflow_kv_key"})," and ",(0,s.jsx)(n.code,{children:"zflow_kv_timestamp"}),". In particular, ",(0,s.jsx)(n.code,{children:"zflow_kv_namespace"})," is the partition key and ",(0,s.jsx)(n.code,{children:"zflow_kv_key"}),"\nand ",(0,s.jsx)(n.code,{children:"zflow_kv_timestamp"})," are the clustering keys. Assuming the default partitioner (Murmur3Partitioner) is used, data\nwill be partitioned by the hash values of the ",(0,s.jsx)(n.code,{children:"zflow_kv_namespace"})," column. If one small set of namespace values are the\nmajority for all possible values, that will create data skew and can have a big impact to your cluster down the road.\nSome consideration is needed when deciding the type of values ",(0,s.jsx)(n.code,{children:"zflow_kv_namespace"})," should store."]}),"\n",(0,s.jsx)(n.h2,{id:"dynamodb",children:"DynamoDB"}),"\n",(0,s.jsx)(n.p,{children:"To use AWS DynamoDb as a key-value store or indexed store implementation add the following dependency:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'libraryDependencies += "dev.zio" %% "zio-flow-dynamodb" % "1.0.0-RC4"\n'})}),"\n",(0,s.jsx)(n.h3,{id:"metrics",children:"Metrics"}),"\n",(0,s.jsxs)(n.p,{children:["The DynamoDb backend does not publish any metrics by default, but you can use ",(0,s.jsx)(n.code,{children:"zio-aws"}),"'s built-in metrics aspect to\nenable AWS operation level metrics:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'DynamoDb.live @@ zio.aws.core.aspects.callDuration(\n  prefix = "zioflow",\n  boundaries = Histogram.Boundaries.exponential(0.01, 2, 14)\n)\n'})}),"\n",(0,s.jsx)(n.h3,{id:"database-setup-1",children:"Database Setup"}),"\n",(0,s.jsx)(n.p,{children:"The DynamoDB module requires two tables for persistence (one for key-value store, one for indexed store).\nHere's a Python script to create the table:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import boto3\n\ndynamodb = boto3.resource('dynamodb')\n\ndynamodb.create_table (\n    TableName = '_zflow_key_value_store',\n    AttributeDefinitions = [\n         {\n             'AttributeName': 'zflow_kv_key',\n             'AttributeType': 'B'\n         },\n         {\n             'AttributeName': 'zflow_kv_timestamp',\n             'AttributeType': 'N'\n         }\n    ],    \n    KeySchema = [\n        {\n            'AttributeName': 'zflow_kv_key',\n            'KeyType': 'HASH'\n        },\n        {\n            'AttributeName': 'zflow_kv_timestamp',\n            'KeyType': 'RANGE'\n        }\n    ],\n    GlobalSecondaryIndexes = [\n        {\n            'IndexName': 'namespace_index',\n            'KeySchema': [\n                {\n                    'AttributeName': 'zflow_kv_namespace',\n                    'KeyType': 'HASH'\n                }\n            ],\n            'Projection': {\n                'NonKeyAttributes': ['zflow_kv_value'],\n                'ProjectionType': 'INCLUDE'\n            },\n            'ProvisionedThroughput' = {\n                'ReadCapacityUnits': 1,\n                'WriteCapacityUnits': 1\n            }\n        }\n    ],\n    ProvisionedThroughput = {\n        'ReadCapacityUnits': 1,\n        'WriteCapacityUnits': 1\n    }\n)\n\ndynamodb.create_table (\n    TableName = '_zflow_indexed_store',\n    AttributeDefinitions = [\n         {\n             'AttributeName': 'zflow_idx_topic',\n             'AttributeType': 'S'\n         },\n         {\n             'AttributeName': 'zflow_idx_index',\n             'AttributeType': 'N'\n         }\n    ],    \n    KeySchema = [\n        {\n            'AttributeName': 'zflow_idx_topic',\n            'KeyType': 'HASH'\n        },\n        {\n            'AttributeName': 'zflow_idx_index',\n            'KeyType': 'RANGE'\n        }\n    ],    \n    ProvisionedThroughput = {\n        'ReadCapacityUnits': 1,\n        'WriteCapacityUnits': 1\n    }\n)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Of course, you can use your favourite AWS tool to create the table (e.g. DynamoDB Console) or to automate the creation (\ne.g. via CloudFormation). You should customize the ",(0,s.jsx)(n.code,{children:"ProvisionedThroughput"})," settings when the table is provisioned."]}),"\n",(0,s.jsx)(n.h3,{id:"performancescaling-considerations-1",children:"Performance/Scaling Considerations:"}),"\n",(0,s.jsxs)(n.p,{children:["As you can see from the script above, the primary key is composed of the two columns, ",(0,s.jsx)(n.code,{children:"zflow_kv_key"}),"\nand ",(0,s.jsx)(n.code,{children:"zflow_kv_timestamp"}),". In particular, ",(0,s.jsx)(n.code,{children:"zflow_kv_key"})," is the partition key and ",(0,s.jsx)(n.code,{children:"zflow_kv_timestamp"})," is the sort key.\nInternally, zio-flow will store the namespace as part of the ",(0,s.jsx)(n.code,{children:"zflow_kv_key"})," value as well, but it will also\nstore it in the ",(0,s.jsx)(n.code,{children:"zflow_kv_namespace"})," attribute for easy access to all values within a namespace. This requires\na secondary index to be set up on the ",(0,s.jsx)(n.code,{children:"zflow_kv_namespace"})," attribute."]}),"\n",(0,s.jsx)(n.h2,{id:"in-memory",children:"In-memory"}),"\n",(0,s.jsx)(n.p,{children:"ZIO Flow also provides a default in-memory implementation for both the key-value store and the indexed store. These are\nuseful for running ZIO Flow programs in tests, but they are not safe to use in production."}),"\n",(0,s.jsx)(n.p,{children:"The following layers create the in-memory implementations of the stores:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"import zio.flow.runtime._\n\nKeyValueStore.inMemory\n// res0: zio.ZLayer[Any, Nothing, KeyValueStore] = Suspend(\n//   self = zio.ZLayer$ScopedEnvironmentPartiallyApplied$$$Lambda$13761/0x000000080335e2c8@141d6bd8\n// )\nIndexedStore.inMemory\n// res1: zio.ZLayer[Any, Nothing, IndexedStore] = Suspend(\n//   self = zio.ZLayer$$$Lambda$13752/0x0000000803352838@3db1a527\n// )\n"})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},28453:(e,n,a)=>{a.d(n,{R:()=>i,x:()=>r});var t=a(96540);const s={},o=t.createContext(s);function i(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);