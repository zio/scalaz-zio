"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[80780],{46297:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"reference/stream/zchannel/channel-interruption","title":"Channel Interruption","description":"We can interrupt a channel using the ZChannel.interruptWhen operator. It takes a ZIO effect that will be evaluated, if it finishes before the channel is closed, it will interrupt the channel, and the terminal value of the returned channel will be the success value of the effect:","source":"@site/docs/reference/stream/zchannel/channel-interruption.md","sourceDirName":"reference/stream/zchannel","slug":"/reference/stream/zchannel/channel-interruption","permalink":"/reference/stream/zchannel/channel-interruption","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/stream/zchannel/channel-interruption.md","tags":[],"version":"current","frontMatter":{"id":"channel-interruption","title":"Channel Interruption"},"sidebar":"reference-sidebar","previous":{"title":"Channel Operations","permalink":"/reference/stream/zchannel/channel-operations"},"next":{"title":"SubscriptionRef","permalink":"/reference/stream/subscription-ref"}}');var i=t(74848),a=t(28453);const s={id:"channel-interruption",title:"Channel Interruption"},o=void 0,c={},l=[];function h(e){const n={code:"code",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["We can interrupt a channel using the ",(0,i.jsx)(n.code,{children:"ZChannel.interruptWhen"})," operator. It takes a ZIO effect that will be evaluated, if it finishes before the channel is closed, it will interrupt the channel, and the terminal value of the returned channel will be the success value of the effect:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.stream._\n\ndef randomNumbers: ZChannel[Any, Any, Any, Any, Nothing, Int, Nothing] =\n  ZChannel\n    .fromZIO(Random.nextIntBounded(100))\n    .flatMap(ZChannel.write) *>\n    ZChannel.fromZIO(ZIO.sleep(1.second)) *> randomNumbers\n\nrandomNumbers.interruptWhen(ZIO.sleep(3.seconds).as("Done!")).runCollect.debug\n// One output: (Chunk(84,57,70),Done!)\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Another version of ",(0,i.jsx)(n.code,{children:"interruptWhen"})," takes a ",(0,i.jsx)(n.code,{children:"Promise"})," as an argument. It will interrupt the channel when the promise is fulfilled:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"import zio.stream._\n\nfor {\n  p <- Promise.make[Nothing, Unit]\n  f <- randomNumbers\n    .interruptWhen(p)\n    .mapOutZIO(e => Console.printLine(e))\n    .runDrain\n    .fork\n  _ <- p.succeed(()).delay(5.seconds)\n  _ <- f.join\n} yield ()\n\n// Output:\n// 74\n// 60\n// 52\n// 52\n// 79\n"})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var r=t(96540);const i={},a=r.createContext(i);function s(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);