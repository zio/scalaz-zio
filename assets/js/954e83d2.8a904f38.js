"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[95269],{7129:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"reference/resource/index","title":"Introduction to Resource Management in ZIO","description":"When we are writing a long-lived application, resource management is very important. Proper resource management is vital to any large-scale application. We need to make sure that our application is resource-safe, and it doesn\'t leak any resource.","source":"@site/docs/reference/resource/index.md","sourceDirName":"reference/resource","slug":"/reference/resource/","permalink":"/reference/resource/","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/resource/index.md","tags":[],"version":"current","frontMatter":{"id":"index","title":"Introduction to Resource Management in ZIO"},"sidebar":"reference-sidebar","previous":{"title":"THub","permalink":"/reference/stm/thub"},"next":{"title":"Scope","permalink":"/reference/resource/scope"}}');var a=r(74848),t=r(28453);const i={id:"index",title:"Introduction to Resource Management in ZIO"},c=void 0,o={},l=[{value:"Try / Finally",id:"try--finally",level:2},{value:"ZIO Solution",id:"zio-solution",level:2},{value:"Acquire Release",id:"acquire-release",level:3},{value:"Scope",id:"scope",level:3}];function d(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"When we are writing a long-lived application, resource management is very important. Proper resource management is vital to any large-scale application. We need to make sure that our application is resource-safe, and it doesn't leak any resource."}),"\n",(0,a.jsx)(n.p,{children:"Leaking socket connections, database connections or file descriptors is not acceptable in a web application. ZIO provides some good construct to make sure about this concern."}),"\n",(0,a.jsx)(n.p,{children:"To write a resource-safe application, we need to make sure whenever we are opening a resource, we have a mechanism to close that resource whether we use that resource completely or not, for example, an exception occurred during resource usage."}),"\n",(0,a.jsx)(n.h2,{id:"try--finally",children:"Try / Finally"}),"\n",(0,a.jsxs)(n.p,{children:["Before we dive into the ZIO solution, it's better to review the ",(0,a.jsx)(n.code,{children:"try"})," / ",(0,a.jsx)(n.code,{children:"finally"})," which is the standard approach in the Scala language to manage resources."]}),"\n",(0,a.jsxs)(n.p,{children:["Scala has a ",(0,a.jsx)(n.code,{children:"try"})," / ",(0,a.jsx)(n.code,{children:"finally"})," construct which helps us to make sure we don't leak resources because no matter what happens in the try, the ",(0,a.jsx)(n.code,{children:"finally"})," block will be executed. So we can open files in the try block, and then we can close them in the ",(0,a.jsx)(n.code,{children:"finally"})," block, and that gives us the guarantee that we will not leak resources."]}),"\n",(0,a.jsx)(n.p,{children:"Assume we want to read a file and return the number of its lines:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'def lines(file: String): Task[Long] = ZIO.attempt {\n  def countLines(br: BufferedReader): Long = br.lines().count()\n  val bufferedReader = new BufferedReader(\n    new InputStreamReader(new FileInputStream("file.txt")),\n    2048\n  )\n  val count = countLines(bufferedReader)\n  bufferedReader.close()\n  count\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["What happens if after opening the file and before closing the file, an exception occurs? So, the ",(0,a.jsx)(n.code,{children:"bufferedReader.close()"})," line, doesn't have a chance to close the resource. This creates a resource leakage. The Scala language has ",(0,a.jsx)(n.code,{children:"try...finally"})," construct, which helps up to prevent these situations."]}),"\n",(0,a.jsxs)(n.p,{children:["Let's rewrite the above example with ",(0,a.jsx)(n.code,{children:"try..finally"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'def lines(file: String): Task[Long] = ZIO.attempt {\n  def countLines(br: BufferedReader): Long = br.lines().count()\n  val bufferedReader = new BufferedReader(\n    new InputStreamReader(new FileInputStream("file.txt")),\n    2048\n  )\n  try countLines(bufferedReader)\n  finally bufferedReader.close()\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Now, we are sure that if our program is interrupted during the process of a file, the ",(0,a.jsx)(n.code,{children:"finally"})," block will be executed."]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"try"})," / ",(0,a.jsx)(n.code,{children:"finally"})," solve simple problems, but it has some drawbacks:"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"It's not composable; We can't compose multiple resources together."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"When we have multiple resources, we end up with messy and ugly code, hard to reason about, and refactoring."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"We don't have any control over the order of resource clean-up"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"It only helps us to handle resources sequentially. It can't compose multiple resources, concurrently."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"It doesn't support asynchronous workflows."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"It's a manual way of resource management, not automatic. To have a resource-safe application we need to manually check that all resources are managed correctly. This way of resource management is error-prone in case of forgetting to manage resources, correctly."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"zio-solution",children:"ZIO Solution"}),"\n",(0,a.jsx)(n.p,{children:"ZIO's resource management features work across synchronous, asynchronous, concurrent, and other effect types, and provide strong guarantees even in the presence of failure, interruption, or defects in the application."}),"\n",(0,a.jsx)(n.p,{children:"ZIO has two major mechanisms to manage resources."}),"\n",(0,a.jsx)(n.h3,{id:"acquire-release",children:"Acquire Release"}),"\n",(0,a.jsxs)(n.p,{children:["ZIO generalized the pattern of ",(0,a.jsx)(n.code,{children:"try"})," / ",(0,a.jsx)(n.code,{children:"finally"})," and encoded it in ",(0,a.jsx)(n.code,{children:"ZIO.acquireRelease"})," or ",(0,a.jsx)(n.code,{children:"ZIO#acquireRelease"})," operations."]}),"\n",(0,a.jsx)(n.p,{children:"Every acquire release requires three actions:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Acquiring Resource"}),"\u2014 An effect describing the acquisition of resource. For example, opening a file."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Using Resource"}),"\u2014 An effect describing the actual process to produce a result. For example, counting the number of lines in a file."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Releasing Resource"}),"\u2014 An effect describing the final step of releasing or cleaning up the resource. For example, closing a file."]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"def use(resource: Resource): Task[Any] = ZIO.attempt(???)\ndef release(resource: Resource): UIO[Unit] = ZIO.succeed(???)\ndef acquire: Task[Resource]                = ZIO.attempt(???)\n\nval result: Task[Any] = ZIO.acquireReleaseWith(acquire)(release)(use)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The acquire release guarantees us that the ",(0,a.jsx)(n.code,{children:"acquiring"})," and ",(0,a.jsx)(n.code,{children:"releasing"})," of a resource will not be interrupted. These two guarantees ensure us that the resource will always be released."]}),"\n",(0,a.jsxs)(n.p,{children:["Let's try a real example. We are going to write a function which count line number of given file. As we are working with file resource, we should separate our logic into three part. At the first part, we create a ",(0,a.jsx)(n.code,{children:"BufferedReader"}),". At the second, we count the file lines with given ",(0,a.jsx)(n.code,{children:"BufferedReader"})," resource, and at the end we close that resource:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"def lines(file: String): Task[Long] = {\n  def countLines(reader: BufferedReader): Task[Long]    = ZIO.attempt(reader.lines().count())\n  def releaseReader(reader: BufferedReader): UIO[Unit]  = ZIO.succeed(reader.close())\n  def acquireReader(file: String): Task[BufferedReader] = ZIO.attempt(new BufferedReader(new FileReader(file), 2048))\n\n  ZIO.acquireReleaseWith(acquireReader(file))(releaseReader)(countLines)\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Let's write another function which copy a file from source to destination file. We can do that by nesting two acquire releases one for the ",(0,a.jsx)(n.code,{children:"FileInputStream"})," and the other for ",(0,a.jsx)(n.code,{children:"FileOutputStream"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"def is(file: String): Task[FileInputStream]  = ZIO.attempt(???)\ndef os(file: String): Task[FileOutputStream] = ZIO.attempt(???)\n\ndef close(resource: Closeable): UIO[Unit] = ZIO.succeed(???)\ndef copy(from: FileInputStream, to: FileOutputStream): Task[Unit] = ???\n\ndef transfer(src: String, dst: String): ZIO[Any, Throwable, Unit] = {\n  ZIO.acquireReleaseWith(is(src))(close) { in =>\n    ZIO.acquireReleaseWith(os(dst))(close) { out =>\n      copy(in, out)\n    }\n  }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["As there isn't any dependency between our two resources (",(0,a.jsx)(n.code,{children:"is"})," and ",(0,a.jsx)(n.code,{children:"os"}),"), it doesn't make sense to use nested acquire releases, so let's ",(0,a.jsx)(n.code,{children:"zip"})," these two acquisition into one effect, and then use one acquire release on them:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"def transfer(src: String, dst: String): ZIO[Any, Throwable, Unit] =\n  ZIO.acquireReleaseWith {\n    is(src).zipPar(os(dst))\n  } { case (in, out) =>\n    ZIO.succeed(in.close()).zipPar(ZIO.succeed(out.close()))\n  } { case (in, out) =>\n    copy(in, out)\n  }\n"})}),"\n",(0,a.jsx)(n.p,{children:"While using acquire release is a nice and simple way of managing resources, but there are some cases where an acquire release is not the best choice:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Acquire release is not composable\u2014 When we have multiple resources, composing them with an acquire release is not straightforward."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Messy nested acquire releases \u2014 In the case of multiple resources, nested acquire releases remind us of callback hell awkwardness. The acquire release is designed with nested resource acquisition. In the case of multiple resources, we encounter inefficient nested acquire release calls, and it causes refactoring a complicated process."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Using acquire releases is simple and straightforward, but in the case of multiple resources, it isn't a good player. This is where we need another abstraction to cover these issues."}),"\n",(0,a.jsx)(n.h3,{id:"scope",children:"Scope"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"Scope"})," is a composable data type for resource management, which wraps the acquisition and release action of a resource. We can think of ",(0,a.jsx)(n.code,{children:"Scope"})," as a handle with built-in acquisition and release logic."]}),"\n",(0,a.jsxs)(n.p,{children:["To create a scoped resource, we need to provide ",(0,a.jsx)(n.code,{children:"acquire"})," and ",(0,a.jsx)(n.code,{children:"release"})," action of that resource to the ",(0,a.jsx)(n.code,{children:"acquireRelease"})," constructor:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"val scoped = ZIO.acquireRelease(acquire)(release)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["We can use scoped resources by calling ",(0,a.jsx)(n.code,{children:"scoped"})," on that. A scoped resource is meant to be used only inside of the ",(0,a.jsx)(n.code,{children:"scoped"})," block. So that resource is not available outside of the ",(0,a.jsx)(n.code,{children:"scoped"})," block."]}),"\n",(0,a.jsxs)(n.p,{children:["Let's try to rewrite a ",(0,a.jsx)(n.code,{children:"transfer"})," example with ",(0,a.jsx)(n.code,{children:"Scope"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"def transfer(from: String, to: String): ZIO[Any, Throwable, Unit] = {\n  val resource = for {\n    from <- ZIO.acquireRelease(is(from))(close)\n    to   <- ZIO.acquireRelease(os(to))(close)\n  } yield (from, to)\n\n  ZIO.scoped {\n    resource.flatMap { case (in, out) =>\n      copy(in, out)\n    }\n  }\n}\n"})})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>c});var s=r(96540);const a={},t=s.createContext(a);function i(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);