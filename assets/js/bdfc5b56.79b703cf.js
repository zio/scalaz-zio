"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[37172],{32687:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"reference/stream/zsink","title":"ZSink","description":"Introduction","source":"@site/versioned_docs/version-1.0.18/reference/stream/zsink.md","sourceDirName":"reference/stream","slug":"/reference/stream/zsink","permalink":"/1.0.18/reference/stream/zsink","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/versioned_docs/version-1.0.18/reference/stream/zsink.md","tags":[],"version":"1.0.18","frontMatter":{"id":"zsink","title":"ZSink"},"sidebar":"overview_sidebar","previous":{"title":"Transducer","permalink":"/1.0.18/reference/stream/transducer"},"next":{"title":"Sink","permalink":"/1.0.18/reference/stream/sink"}}');var t=i(74848),r=i(28453);const a={id:"zsink",title:"ZSink"},c=void 0,l={},o=[{value:"Introduction",id:"introduction",level:2},{value:"Creating sinks",id:"creating-sinks",level:2},{value:"Common Constructors",id:"common-constructors",level:3},{value:"From Success and Failure",id:"from-success-and-failure",level:3},{value:"Collecting",id:"collecting",level:3},{value:"Folding",id:"folding",level:3},{value:"From Effect",id:"from-effect",level:3},{value:"From File",id:"from-file",level:3},{value:"From OutputStream",id:"from-outputstream",level:3},{value:"From Queue",id:"from-queue",level:3},{value:"From Hub",id:"from-hub",level:3},{value:"From Push",id:"from-push",level:3},{value:"ZSink&#39;s Encoding",id:"zsinks-encoding",level:4},{value:"Creating ZSink using Push",id:"creating-zsink-using-push",level:4},{value:"Operations",id:"operations",level:2},{value:"contramap",id:"contramap",level:3},{value:"dimap",id:"dimap",level:3},{value:"Concurrency and Parallelism",id:"concurrency-and-parallelism",level:2},{value:"Parallel Zipping",id:"parallel-zipping",level:3},{value:"Racing",id:"racing",level:3},{value:"Leftovers",id:"leftovers",level:2},{value:"Exposing Leftovers",id:"exposing-leftovers",level:3},{value:"Dropping Leftovers",id:"dropping-leftovers",level:3}];function d(e){const n={code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.code,{children:"ZSink[R, E, I, L, Z]"})," is used to consume elements produced by a ",(0,t.jsx)(n.code,{children:"ZStream"}),". You can think of a sink as a function that will consume a variable amount of ",(0,t.jsx)(n.code,{children:"I"})," elements (could be 0, 1, or many!), might fail with an error of type ",(0,t.jsx)(n.code,{children:"E"}),", and will eventually yield a value of type ",(0,t.jsx)(n.code,{children:"Z"})," together with a remainder of type ",(0,t.jsx)(n.code,{children:"L"})," as leftover."]}),"\n",(0,t.jsxs)(n.p,{children:["To consume a stream using ",(0,t.jsx)(n.code,{children:"ZSink"})," we can pass ",(0,t.jsx)(n.code,{children:"ZSink"})," to the ",(0,t.jsx)(n.code,{children:"ZStream#run"})," function:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import zio._\nimport zio.stream._\n\nval stream = ZStream.fromIterable(1 to 1000)\nval sink   = ZSink.sum[Int]\nval sum    = stream.run(sink)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"creating-sinks",children:"Creating sinks"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"zio.stream"})," provides numerous kinds of sinks to use."]}),"\n",(0,t.jsx)(n.h3,{id:"common-constructors",children:"Common Constructors"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"ZSink.head"})," \u2014 It creates a sink containing the first element, returns ",(0,t.jsx)(n.code,{children:"None"})," for empty streams:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"val sink: ZSink[Any, Nothing, Int, Int, Option[Int]] = ZSink.head[Int]\nval head: ZIO[Any, Nothing, Option[Int]]             = ZStream(1, 2, 3, 4).run(sink)\n// Result: Some(1)\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"ZSink.last"})," \u2014 It consumes all elements of a stream and returns the last element of the stream:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"val sink: ZSink[Any, Nothing, Int, Nothing, Option[Int]] = ZSink.last[Int]\nval last: ZIO[Any, Nothing, Option[Int]]                 = ZStream(1, 2, 3, 4).run(sink)\n// Result: Some(4)\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"ZSink.count"})," \u2014 A sink that consumes all elements of the stream and counts the number of elements fed to it:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"val sink : ZSink[Any, Nothing, Int, Nothing, Int] = ZSink.sum[Int]\nval count: ZIO[Any, Nothing, Int]                 = ZStream(1, 2, 3, 4, 5).run(sink)\n// Result: 5\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"ZSink.sum"})," \u2014 A sink that consumes all elements of the stream and sums incoming numeric values:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"val sink : ZSink[Any, Nothing, Int, Nothing, Int] = ZSink.sum[Int]\nval sum: ZIO[Any, Nothing, Int]                 = ZStream(1, 2, 3, 4, 5).run(sink)\n// Result: 15\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"ZSink.take"})," \u2014 A sink that takes the specified number of values and result in a ",(0,t.jsx)(n.code,{children:"Chunk"})," data type:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"val sink  : ZSink[Any, Nothing, Int, Int, Chunk[Int]] = ZSink.take[Int](3)\nval stream: ZIO[Any, Nothing, Chunk[Int]]             = ZStream(1, 2, 3, 4, 5).run(sink)\n// Result: Chunk(1, 2, 3)\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"ZSink.drain"})," \u2014 A sink that ignores its inputs:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"val drain: ZSink[Any, Nothing, Any, Nothing, Unit] = ZSink.drain\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"ZSink.timed"})," \u2014 A sink that executes the stream and times its execution:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"val timed: ZSink[Clock, Nothing, Any, Nothing, Duration] = ZSink.timed\nval stream: ZIO[Clock, Nothing, Long] =\n  ZStream(1, 2, 3, 4, 5).fixed(2.seconds).run(timed).map(_.getSeconds)\n// Result: 10\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"ZSink.foreach"})," \u2014 A sink that executes the provided effectful function for every element fed to it:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"val printer: ZSink[Console, IOException, Int, Int, Unit] =\n  ZSink.foreach((i: Int) => zio.console.putStrLn(i.toString))\nval stream : ZIO[Console, IOException, Unit]             =\n  ZStream(1, 2, 3, 4, 5).run(printer)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"from-success-and-failure",children:"From Success and Failure"}),"\n",(0,t.jsxs)(n.p,{children:["Similar to the ",(0,t.jsx)(n.code,{children:"ZStream"})," data type, we can create a ",(0,t.jsx)(n.code,{children:"ZSink"})," using ",(0,t.jsx)(n.code,{children:"fail"})," and ",(0,t.jsx)(n.code,{children:"succeed"})," methods."]}),"\n",(0,t.jsxs)(n.p,{children:["A sink that doesn't consume any element of type ",(0,t.jsx)(n.code,{children:"String"})," from its upstream and successes with a value of ",(0,t.jsx)(n.code,{children:"Int"})," type:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"val succeed: ZSink[Any, Nothing, String, String, Int] = ZSink.succeed[String, Int](5)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["A sink that doesn't consume any element of type ",(0,t.jsx)(n.code,{children:"Int"})," from its upstream and intentionally fails with a message of ",(0,t.jsx)(n.code,{children:"String"})," type:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'val failed : ZSink[Any, String, Int, Int, Nothing] = ZSink.fail[String, Int]("fail!")\n'})}),"\n",(0,t.jsx)(n.h3,{id:"collecting",children:"Collecting"}),"\n",(0,t.jsxs)(n.p,{children:["To create a sink that collects all elements of a stream into a ",(0,t.jsx)(n.code,{children:"Chunk[A]"}),", we can use ",(0,t.jsx)(n.code,{children:"ZSink.collectAll"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"val stream    : UStream[Int]    = UStream(1, 2, 3, 4, 5)\nval collection: UIO[Chunk[Int]] = stream.run(ZSink.collectAll[Int])\n// Output: Chunk(1, 2, 3, 4, 5)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["We can collect all elements into a ",(0,t.jsx)(n.code,{children:"Set"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"val collectAllToSet: ZSink[Any, Nothing, Int, Nothing, Set[Int]] = ZSink.collectAllToSet[Int]\nval stream: ZIO[Any, Nothing, Set[Int]] = ZStream(1, 3, 2, 3, 1, 5, 1).run(collectAllToSet)\n// Output: Set(1, 3, 2, 5)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Or we can collect and merge them into a ",(0,t.jsx)(n.code,{children:"Map[K, A]"})," using a merge function. In the following example, we use ",(0,t.jsx)(n.code,{children:"(_:Int) % 3"})," to determine map keys and, we provide ",(0,t.jsx)(n.code,{children:"_ + _"})," function to merge multiple elements with the same key:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"val collectAllToMap: ZSink[Any, Nothing, Int, Nothing, Map[Int, Int]] = ZSink.collectAllToMap((_: Int) % 3)(_ + _)\nval stream: ZIO[Any, Nothing, Map[Int, Int]] = ZStream(1, 3, 2, 3, 1, 5, 1).run(collectAllToMap)\n// Output: Map(1 -> 3, 0 -> 6, 2 -> 7)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"folding",children:"Folding"}),"\n",(0,t.jsx)(n.p,{children:"Basic fold accumulation of received elements:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"ZSink.foldLeft[Int, Int](0)(_ + _)\n"})}),"\n",(0,t.jsx)(n.p,{children:"A fold with short-circuiting has a termination predicate that determines the end of the folding process:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"ZStream.iterate(0)(_ + 1).run(\n  ZSink.fold(0)(sum => sum <= 10)((acc, n: Int) => acc + n)\n)\n// Output: 15\n"})}),"\n",(0,t.jsx)(n.h3,{id:"from-effect",children:"From Effect"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"ZSink.fromEffect"})," creates a single-value sink produced from an effect:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"val sink = ZSink.fromEffect(ZIO.succeed(1))\n"})}),"\n",(0,t.jsx)(n.h3,{id:"from-file",children:"From File"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"ZSink.fromFile"})," creates a file sink that consumes byte chunks and writes them to the specified file:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'def fileSink(path: Path): ZSink[Blocking, Throwable, String, Byte, Long] =\n  ZSink\n    .fromFile(path)\n    .contramapChunks[String](_.flatMap(_.getBytes))\n\nval result = ZStream("Hello", "ZIO", "World!")\n  .intersperse("\\n")\n  .run(fileSink(Paths.get("file.txt")))\n'})}),"\n",(0,t.jsx)(n.h3,{id:"from-outputstream",children:"From OutputStream"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"ZSink.fromOutputStream"})," creates a sink that consumes byte chunks and write them to the ",(0,t.jsx)(n.code,{children:"OutputStream"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'ZStream("Application", "Error", "Logs")\n  .intersperse("\\n")\n  .run(\n    ZSink\n      .fromOutputStream(System.err)\n      .contramapChunks[String](_.flatMap(_.getBytes))\n  )\n'})}),"\n",(0,t.jsx)(n.h3,{id:"from-queue",children:"From Queue"}),"\n",(0,t.jsxs)(n.p,{children:["A queue has a finite or infinite buffer size, so they are useful in situations where we need to consume streams as fast as we can, and then do some batching operations on consumed messages. By using ",(0,t.jsx)(n.code,{children:"ZSink.fromQueue"})," we can create a sink that is backed by a queue; it enqueues each element into the specified queue:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"val myApp: ZIO[Console with Clock, IOException, Unit] =\n  for {\n    queue    <- ZQueue.bounded[Int](32)\n    producer <- ZStream\n      .iterate(1)(_ + 1)\n      .fixed(200.millis)\n      .run(ZSink.fromQueue(queue))\n      .fork\n    consumer <- queue.take.flatMap(x => putStrLn(x.toString)).forever\n    _        <- producer.zip(consumer).join\n  } yield ()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"from-hub",children:"From Hub"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Hub"})," is an asynchronous data type in which publisher can publish their messages to that and subscribers can subscribe to take messages from the ",(0,t.jsx)(n.code,{children:"Hub"}),". The ",(0,t.jsx)(n.code,{children:"ZSink.fromHub"})," takes a ",(0,t.jsx)(n.code,{children:"ZHub"})," and returns a ",(0,t.jsx)(n.code,{children:"ZSink"})," which publishes each element to that ",(0,t.jsx)(n.code,{children:"ZHub"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["In the following example, the ",(0,t.jsx)(n.code,{children:"sink"})," consumes elements of the ",(0,t.jsx)(n.code,{children:"producer"})," stream and publishes them to the ",(0,t.jsx)(n.code,{children:"hub"}),". We have two consumers that are subscribed to that hub and they are taking its elements forever:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'val myApp: ZIO[Console with Clock, IOException, Unit] =\n  for {\n    promise <- Promise.make[Nothing, Unit]\n    hub <- ZHub.bounded[Int](1)\n    sink <- ZIO.succeed(ZSink.fromHub(hub))\n    producer <- ZStream.iterate(0)(_ + 1).fixed(1.seconds).run(sink).fork\n    consumers <- hub.subscribe.zip(hub.subscribe).use { case (left, right) =>\n      for {\n        _ <- promise.succeed(())\n        f1 <- left.take.flatMap(e => putStrLn(s"Left Queue: $e")).forever.fork\n        f2 <- right.take.flatMap(e => putStrLn(s"Right Queue: $e")).forever.fork\n        _ <- f1.zip(f2).join\n      } yield ()\n    }.fork\n    _ <- promise.await\n    _ <- producer.zip(consumers).join\n  } yield ()\n'})}),"\n",(0,t.jsx)(n.h3,{id:"from-push",children:"From Push"}),"\n",(0,t.jsxs)(n.p,{children:["Before deepening into creating a ",(0,t.jsx)(n.code,{children:"ZSink"})," using ",(0,t.jsx)(n.code,{children:"Push"})," data-type, we need to learn more about the implementation details of ",(0,t.jsx)(n.code,{children:"ZSink"}),". Note that this topic is for advanced users, and we do not require using ",(0,t.jsx)(n.code,{children:"Push"})," data-type to create ZIO sinks, most of the time."]}),"\n",(0,t.jsx)(n.h4,{id:"zsinks-encoding",children:"ZSink's Encoding"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"ZSink"})," is a wrapper data-type around ",(0,t.jsx)(n.em,{children:"managed"})," ",(0,t.jsx)(n.code,{children:"Push"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"abstract class ZSink[-R, +E, -I, +L, +Z] private (\n    val push: ZManaged[R, Nothing, ZSink.Push[R, E, I, L, Z]]\n) \n\nobject ZSink {\n  type Push[-R, +E, -I, +L, +Z] =\n    Option[Chunk[I]] => ZIO[R, (Either[E, Z], Chunk[L]), Unit]\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Push"})," is a function from ",(0,t.jsx)(n.code,{children:"Option[Chunk[I]]"})," to ",(0,t.jsx)(n.code,{children:"ZIO[R, (Either[E, Z], Chunk[L]), Unit]"}),". We can create four different data-types using its smart constructors:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Push.more"})," \u2014 Using this constructor we create a ",(0,t.jsx)(n.code,{children:"Push"})," data-type that requires more values to consume (",(0,t.jsx)(n.code,{children:"Option[Chunk[I]] => UIO[Unit]"}),"):"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"object Push {\n  val more: ZIO[Any, Nothing, Unit] = UIO.unit\n}\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Push.emit"})," \u2014 By providing ",(0,t.jsx)(n.code,{children:"z"})," (as an ",(0,t.jsx)(n.em,{children:"end"})," value) and ",(0,t.jsx)(n.code,{children:"leftover"})," arguments to this constructor we can create a ",(0,t.jsx)(n.code,{children:"Push"})," data-type describing a sink that ends with ",(0,t.jsx)(n.code,{children:"z"})," value and emits its leftovers (",(0,t.jsx)(n.code,{children:"Option[Chunk[I]] => IO[(Right[Nothing, Z], Chunk[I]), Nothing]"}),"):"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"object Push {\ndef emit[I, Z](\n    z: Z,\n    leftover: Chunk[I]\n): IO[(Right[Nothing, Z], Chunk[I]), Nothing] =\n  IO.fail((Right(z), leftover))\n}\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"3",children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Push.fail"})," \u2014 By providing an error message and leftover to this constructor, we can create a ",(0,t.jsx)(n.code,{children:"Push"})," data-type describing a sink that fails with ",(0,t.jsx)(n.code,{children:"e"})," and emits the leftover (",(0,t.jsx)(n.code,{children:"Option[Chunk[I]] => IO[(Left[E, Nothing], Chunk[I]), Nothing]"}),"):"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"def fail[I, E](\n    e: E,\n    leftover: Chunk[I]\n): IO[(Left[E, Nothing], Chunk[I]), Nothing] = \n  IO.fail((Left(e), leftover))\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"4",children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Push.halt"})," \u2014 By providing a ",(0,t.jsx)(n.code,{children:"Cause"})," we can create a ",(0,t.jsx)(n.code,{children:"Push"})," data-type describing a sink that halts the process of consuming elements (",(0,t.jsx)(n.code,{children:"Option[Chunk[I]] => ZIO[Any, (Left[E, Nothing], Chunk[Nothing]), Nothing]"}),"):"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"def halt[E](\n    c: Cause[E]\n): ZIO[Any, (Left[E, Nothing], Chunk[Nothing]), Nothing] =\n  IO.halt(c).mapError(e => (Left(e), Chunk.empty))\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Now, we are ready to see how the existing ",(0,t.jsx)(n.code,{children:"ZSink.head"})," sink is implemented using ",(0,t.jsx)(n.code,{children:"Push"})," data-type:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"def head[I]: ZSink[Any, Nothing, I, I, Option[I]] =\n  ZSink[Any, Nothing, I, I, Option[I]](ZManaged.succeed({\n    case Some(ch) =>\n      if (ch.isEmpty) { // If the chunk is empty, we require more elements\n        Push.more\n      } else {\n        Push.emit(Some(ch.head), ch.drop(1))\n      }\n    case None => Push.emit(None, Chunk.empty)\n  }))\n"})}),"\n",(0,t.jsx)(n.h4,{id:"creating-zsink-using-push",children:"Creating ZSink using Push"}),"\n",(0,t.jsxs)(n.p,{children:["To create a ZSink using ",(0,t.jsx)(n.code,{children:"Push"})," data-type, we should use ",(0,t.jsx)(n.code,{children:"ZSink.fromPush"})," constructor. This constructor is implemented as below:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"object ZSink {\n  def fromPush[R, E, I, L, Z](sink: Push[R, E, I, L, Z]): ZSink[R, E, I, L, Z] =\n    ZSink(Managed.succeed(sink))\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["So nothing special, it just creates us a new ",(0,t.jsx)(n.code,{children:"ZSink"})," containing a managed push."]}),"\n",(0,t.jsxs)(n.p,{children:["Let's rewrite ",(0,t.jsx)(n.code,{children:"ZSink.succeed"})," and ",(0,t.jsx)(n.code,{children:"ZSink.fail"})," \u2014 the two existing ZIO sinks \u2014 using ",(0,t.jsx)(n.code,{children:"fromPush"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"def succeed[I, Z](z: => Z): ZSink[Any, Nothing, I, I, Z] =\n  ZSink.fromPush[Any, Nothing, I, I, Z] { c =>\n    val leftover = c.fold[Chunk[I]](Chunk.empty)(identity)\n    Push.emit(z, leftover)\n  }\n  \ndef fail[E, I](e: => E): ZSink[Any, E, I, I, Nothing] =\n  ZSink.fromPush[Any, E, I, I, Nothing] { c =>\n    val leftover = c.fold[Chunk[I]](Chunk.empty)(identity)\n    Push.fail(e, leftover)\n  }\n"})}),"\n",(0,t.jsx)(n.h2,{id:"operations",children:"Operations"}),"\n",(0,t.jsx)(n.p,{children:"Having created the sink, we can transform it with provided operations."}),"\n",(0,t.jsx)(n.h3,{id:"contramap",children:"contramap"}),"\n",(0,t.jsxs)(n.p,{children:["Contramap is a simple combinator to change the domain of an existing function. While ",(0,t.jsx)(n.em,{children:"map"})," changes the co-domain of a function, the ",(0,t.jsx)(n.em,{children:"contramap"})," changes the domain of a function. So the ",(0,t.jsx)(n.em,{children:"contramap"})," takes a function and maps over its input."]}),"\n",(0,t.jsxs)(n.p,{children:["This is useful when we have a fixed output, and our existing function cannot consume those outputs. So we can use ",(0,t.jsx)(n.em,{children:"contramap"})," to create a new function that can consume that fixed output. Assume we have a ",(0,t.jsx)(n.code,{children:"ZSink.sum"})," that sums incoming numeric values, but we have a ",(0,t.jsx)(n.code,{children:"ZStream"})," of ",(0,t.jsx)(n.code,{children:"String"})," values. We can convert the ",(0,t.jsx)(n.code,{children:"ZSink.sum"})," to a sink that can consume ",(0,t.jsx)(n.code,{children:"String"})," values;"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'val numericSum: ZSink[Any, Nothing, Int, Nothing, Int]    = \n  ZSink.sum[Int]\nval stringSum : ZSink[Any, Nothing, String, Nothing, Int] = \n  numericSum.contramap((x: String) => x.toInt)\n\nval sum: ZIO[Any, Nothing, Int] =\n  ZStream("1", "2", "3", "4", "5").run(stringSum)\n// Output: 15\n'})}),"\n",(0,t.jsx)(n.h3,{id:"dimap",children:"dimap"}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.code,{children:"dimap"})," is an extended ",(0,t.jsx)(n.code,{children:"contramap"})," that additionally transforms sink's output:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'// Convert its input to integers, do the computation and then convert them back to a string\nval sumSink: ZSink[Any, Nothing, String, Nothing, String] =\n  numericSum.dimap[String, String](_.toInt, _.toString)\n  \nval sum: ZIO[Any, Nothing, String] =\n  ZStream("1", "2", "3", "4", "5").run(sumSink)\n// Output: 15\n'})}),"\n",(0,t.jsx)(n.h2,{id:"concurrency-and-parallelism",children:"Concurrency and Parallelism"}),"\n",(0,t.jsx)(n.h3,{id:"parallel-zipping",children:"Parallel Zipping"}),"\n",(0,t.jsxs)(n.p,{children:["Like ",(0,t.jsx)(n.code,{children:"ZStream"}),", two ",(0,t.jsx)(n.code,{children:"ZSink"})," can be zipped together. Both of them will be run in parallel, and their results will be combined in a tuple:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"val kafkaSink: ZSink[Any, Throwable, Record, Record, Unit] =\n  ZSink.foreach[Any, Throwable, Record](record => ZIO.effect(???))\n\nval pulsarSink: ZSink[Any, Throwable, Record, Record, Unit] =\n  ZSink.foreach[Any, Throwable, Record](record => ZIO.effect(???))\n\nval stream: ZSink[Any, Throwable, Record, Record, (Unit, Unit)] =\n  kafkaSink zipPar pulsarSink \n"})}),"\n",(0,t.jsx)(n.h3,{id:"racing",children:"Racing"}),"\n",(0,t.jsxs)(n.p,{children:["We are able to ",(0,t.jsx)(n.code,{children:"race"})," multiple sinks, they will run in parallel, and the one that wins will provide the result of our program:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"val stream: ZSink[Any, Throwable, Record, Record, Unit] =\n  kafkaSink race pulsarSink \n"})}),"\n",(0,t.jsxs)(n.p,{children:["To determine which one succeeded, we should use the ",(0,t.jsx)(n.code,{children:"ZSink#raceBoth"})," combinator, it returns an ",(0,t.jsx)(n.code,{children:"Either"})," result."]}),"\n",(0,t.jsx)(n.h2,{id:"leftovers",children:"Leftovers"}),"\n",(0,t.jsx)(n.h3,{id:"exposing-leftovers",children:"Exposing Leftovers"}),"\n",(0,t.jsxs)(n.p,{children:["A sink consumes a variable amount of ",(0,t.jsx)(n.code,{children:"I"})," elements (zero or more) from the upstream. If the upstream is finite, we can expose leftover values by calling ",(0,t.jsx)(n.code,{children:"ZSink#exposeLeftOver"}),". It returns a tuple that contains the result of the previous sink and its leftovers:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"val s1: ZIO[Any, Nothing, (Chunk[Int], Chunk[Int])] =\n  ZStream(1, 2, 3, 4, 5).run(\n    ZSink.take(3).exposeLeftover\n  )\n// Output: (Chunk(1, 2, 3), Chunk(4, 5))\n\n\nval s2: ZIO[Any, Nothing, (Option[Int], Chunk[Int])] =\n  ZStream(1, 2, 3, 4, 5).run(\n    ZSink.head[Int].exposeLeftover\n  )\n// Output: (Some(1), Chunk(2, 3, 4, 5))\n"})}),"\n",(0,t.jsx)(n.h3,{id:"dropping-leftovers",children:"Dropping Leftovers"}),"\n",(0,t.jsxs)(n.p,{children:["If we don't need leftovers, we can drop them by using ",(0,t.jsx)(n.code,{children:"ZSink#dropLeftover"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"ZSink.take[Int](3).dropLeftover\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>c});var s=i(96540);const t={},r=s.createContext(t);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);