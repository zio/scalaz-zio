"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[52744],{32221:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"reference/core/cause","title":"Cause","description":"CauseE] is a description of a full story of failure, which is included in an [Exit.Failure. Many times in ZIO something can fail for a value of type E, but there are other ways things can fail too.","source":"@site/versioned_docs/version-1.0.18/reference/core/cause.md","sourceDirName":"reference/core","slug":"/reference/core/cause","permalink":"/1.0.18/reference/core/cause","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/versioned_docs/version-1.0.18/reference/core/cause.md","tags":[],"version":"1.0.18","frontMatter":{"id":"cause","title":"Cause"},"sidebar":"overview_sidebar","previous":{"title":"Exit","permalink":"/1.0.18/reference/core/exit"},"next":{"title":"Runtime","permalink":"/1.0.18/reference/core/runtime"}}');var s=r(74848),t=r(28453);const o={id:"cause",title:"Cause"},a=void 0,c={},l=[{value:"Cause Variations",id:"cause-variations",level:2},{value:"Lossless Error Model",id:"lossless-error-model",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Cause[E]"})," is a description of a full story of failure, which is included in an ",(0,s.jsx)(n.a,{href:"/1.0.18/reference/core/exit",children:"Exit.Failure"}),". Many times in ZIO something can fail for a value of type ",(0,s.jsx)(n.code,{children:"E"}),", but there are other ways things can fail too."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"IO[E, A]"})," is polymorphic in values of type ",(0,s.jsx)(n.code,{children:"E"})," and we can work with any error type that we want, but there is a lot of information that is not inside an arbitrary ",(0,s.jsx)(n.code,{children:"E"})," value. So as a result ZIO needs somewhere to store things like ",(0,s.jsx)(n.strong,{children:"unexpected exceptions or defects"}),", ",(0,s.jsx)(n.strong,{children:"stack and execution traces"}),", ",(0,s.jsx)(n.strong,{children:"cause of fiber interruptions"}),", and so forth."]}),"\n",(0,s.jsx)(n.h2,{id:"cause-variations",children:"Cause Variations"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Cause"})," has several variations which encode all the cases:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Fail[+E](value: E)"})," contains the cause of expected failure of type ",(0,s.jsx)(n.code,{children:"E"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Die(value: Throwable)"})," contains the cause of a defect or in other words, an unexpected failure of type ",(0,s.jsx)(n.code,{children:"Throwable"}),". If we have a bug in our code and something throws an unexpected exception, that information would be described inside a Die."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Interrupt(fiberId)"})," contains information of the fiber id that causes fiber interruption."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Traced(cause, trace)"})," store stack traces and execution traces."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"Meta(cause, data)"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Both(left, right)"})," & ",(0,s.jsx)(n.code,{children:"Then(left, right)"})," store composition of two parallel and sequential causes. Sometimes fibers can fail for more than one reason. If we are doing two things at once and both of them fail then we actually have two errors. Examples:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If we perform ZIO's analog of try-finally (e.g. ZIO#ensuring), and both of ",(0,s.jsx)(n.code,{children:"try"})," and ",(0,s.jsx)(n.code,{children:"finally"})," blocks fail, so their causes are encoded with ",(0,s.jsx)(n.code,{children:"Then"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["If we run two parallel fibers with ",(0,s.jsx)(n.code,{children:"zipPar"})," and all of them fail, so their causes will be encoded with ",(0,s.jsx)(n.code,{children:"Both"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Let's try to create some of these causes:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.duration._\nfor {\n  failExit <- ZIO.fail("Oh! Error!").run\n  dieExit  <- ZIO.effectTotal(5 / 0).run\n  thenExit <- ZIO.fail("first").ensuring(ZIO.die(throw new Exception("second"))).run\n  bothExit <- ZIO.fail("first").zipPar(ZIO.die(throw new Exception("second"))).run\n  fiber    <- ZIO.sleep(1.second).fork\n  _        <- fiber.interrupt\n  interruptionExit <- fiber.join.run\n} yield ()\n'})}),"\n",(0,s.jsx)(n.h2,{id:"lossless-error-model",children:"Lossless Error Model"}),"\n",(0,s.jsxs)(n.p,{children:["ZIO is very aggressive about preserving the full information related to a failure. ZIO capture all type of errors into the ",(0,s.jsx)(n.code,{children:"Cause"})," data type. So its error model is lossless. It doesn't throw information related to the failure result. So we can figure out exactly what happened during the operation of our effects."]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>a});var i=r(96540);const s={},t=i.createContext(s);function o(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);