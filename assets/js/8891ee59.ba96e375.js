"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[59461],{55239:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>c,metadata:()=>a,toc:()=>r});const a=JSON.parse('{"id":"reference/architecture/functional-design-patterns","title":"Functional Design Patterns","description":"When designing an API, there are patterns that are commonly used. In this section, we are going to talk about some of these patterns:","source":"@site/docs/reference/architecture/functional-design-patterns.md","sourceDirName":"reference/architecture","slug":"/reference/architecture/functional-design-patterns","permalink":"/reference/architecture/functional-design-patterns","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/architecture/functional-design-patterns.md","tags":[],"version":"current","frontMatter":{"id":"functional-design-patterns","title":"Functional Design Patterns"},"sidebar":"reference-sidebar","previous":{"title":"Architectural Patterns","permalink":"/reference/architecture/architectural-patterns"},"next":{"title":"Introduction to Writing ZIO Services","permalink":"/reference/service-pattern/introduction"}}');var s=t(74848),i=t(28453);const c={id:"functional-design-patterns",title:"Functional Design Patterns"},o=void 0,l={},r=[{value:"Functional Data Modeling",id:"functional-data-modeling",level:2},{value:"Functional Domain Modeling",id:"functional-domain-modeling",level:2},{value:"Executable Encoding",id:"executable-encoding",level:3},{value:"Declarative Encoding",id:"declarative-encoding",level:3}];function d(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"When designing an API, there are patterns that are commonly used. In this section, we are going to talk about some of these patterns:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Functional Data Modeling"}),"\n",(0,s.jsxs)(n.li,{children:["Functional Domain Modeling","\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Declarative Encoding"}),"\n",(0,s.jsx)(n.li,{children:"Executable Encoding"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"functional-data-modeling",children:"Functional Data Modeling"}),"\n",(0,s.jsx)(n.p,{children:"Before we start talking about functional data modeling, let's first recap the object-oriented way of modeling data."}),"\n",(0,s.jsx)(n.p,{children:"The essence of object-oriented data modeling is inheritance. We have classes, traits, abstract classes, and subtyping. The core idea is to describe the commonalities between different types of data in a base interface or abstract class, and then extend it to describe the differences in the subclasses; so each subclass has its type-specific details while sharing the commonalities with the base type:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"abstract class Event {\n  def id: String\n  def timestamp: Long\n}\n\ncase class ClickEvent(id: String, timestamp: Long, element: String) extends Event\ncase class ViewEvent(id: String, timestamp: Long, page: String) extends Event\n"})}),"\n",(0,s.jsx)(n.p,{children:"There is some problem with this approach, let's iterate some of them:"}),"\n",(0,s.jsxs)(n.p,{children:["One of the problems with this approach is that it is not a good fit when we want to write generic operations on the ",(0,s.jsx)(n.code,{children:"Event"})," type. For example, if we want to write an operation that changes the timestamp of an event, we should match the input event and then do the transformation for each case. Then finally, we should use ",(0,s.jsx)(n.code,{children:"asInstanceOf"})," to cast the result back to the original type:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"def updateTimestamp[E <: Event](event: E, timestamp: Long): E =\n  event match {\n    case e: ClickEvent => e.copy(timestamp = timestamp).asInstanceOf[E]\n    case e: ViewEvent => e.copy(timestamp = timestamp).asInstanceOf[E]\n  }\n"})}),"\n",(0,s.jsx)(n.p,{children:"This introduces a lot of boilerplate code. It also has a type-safety issue. If we forget to add all the cases for the match expression, the compiler will not be able to detect it."}),"\n",(0,s.jsx)(n.p,{children:"In functional data modeling, we don't use inheritance. All tools we have are sum types and product types. By using these two types, we can mathematically model the data. Let's try to model the previous example using sum and product types:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"case class Event(id: String, timestamp: Long, details: EventType)\n\nsealed trait EventType\nobject EventType {\n  final case class ClickEvent(element: String) extends EventType\n  final case class ViewEvent(page: String) extends EventType\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In this approach, we describe commonalities with product types, and differences with sum types. So we push ",(0,s.jsx)(n.code,{children:"id"}),", ",(0,s.jsx)(n.code,{children:"timestamp"}),", and ",(0,s.jsx)(n.code,{children:"details"})," to the ",(0,s.jsx)(n.code,{children:"Event"})," case class, and encode the type-specific details of the event in the ",(0,s.jsx)(n.code,{children:"EventType"})," which is a sum type."]}),"\n",(0,s.jsx)(n.p,{children:'The product and sum types are called "Algebraic Data Types" (ADT). They are the building blocks of modeling data in functional programming:'}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Product types"})," are the cartesian product of the types they contain. For example, ",(0,s.jsx)(n.code,{children:"Event"})," is the product of ",(0,s.jsx)(n.code,{children:"String"}),", ",(0,s.jsx)(n.code,{children:"Long"}),", and ",(0,s.jsx)(n.code,{children:"EventType"}),". In scala, we use ",(0,s.jsx)(n.code,{children:"case class"})," to model product types."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Sum types"})," are the disjoint union of the types they represent. For example, ",(0,s.jsx)(n.code,{children:"EventType"})," is the either ",(0,s.jsx)(n.code,{children:"ClickEvent"})," or ",(0,s.jsx)(n.code,{children:"ViewEvent"}),". In scala 2, we use ",(0,s.jsx)(n.code,{children:"sealed trait"}),"s and In Scala 3, we use ",(0,s.jsx)(n.code,{children:"enum"}),"s to model sum types."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"functional-domain-modeling",children:"Functional Domain Modeling"}),"\n",(0,s.jsx)(n.p,{children:"Functional domain modeling is the process of modeling solutions to problems in a specific domain using functional programming. It is a very broad topic, and we are not going to cover all the details here. However, we are going to talk about the general patterns that are commonly used in functional domain modeling, in a nutshell."}),"\n",(0,s.jsx)(n.p,{children:"In functional programming, we have two primary tools:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Nouns (Data)"}),"\n",(0,s.jsx)(n.li,{children:"Verbs (Operators)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"So to provide a solution to every domain problem, we should follow these steps:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Extracting the Core Model"}),'\u2014 First, we need to focus on extracting the "minimum" information required to describe the "solution" to the "fundamental problem" in that domain. So we should ask ourselves, "what is the most fundamental problem we have in this domain?".']}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Providing Operators"}),'\u2014 Once we find out what is the core model of our domain, we should provide a set of "orthogonal operators" that are going to provide a "solution" to the "complex problems" by combining sub-problems.']}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Packaging the Data Type"}),'\u2014 To achieve great modularity, we package both the "core model" and "operators" in one place which is called "data type".']}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Defining Constructors"}),'\u2014 Also to have a better ergonomic API, we put all solutions to the "basic and simple problems" in that domain in the companion object of the "data type".']}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The ZIO ecosystem defines all data types in such a way, including ZIO, Fiber, Reference, Stream, etc."}),"\n",(0,s.jsx)(n.p,{children:"There are two main encoding styles in functional domain modeling:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Executable Encoding"}),' is a functional domain modeling where we use operators and constructors to provide the "final" solution to the domain problems.']}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Declarative Encoding"}),' is a functional domain modeling where we use constructors and operators to provide the "description" of the solution to the domain problems. Later, we interpret the description to get the "final" solution.']}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"A real-life example will help you understand the differences between these two approaches. Let's say we want to write an effect system from scratch. To keep things simple we will create an effect system that only supports sequencial effects. So at the end, we would like to write a program like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'object Main extends scala.App {\n  val app =\n    for {\n      _    <- IO.succeed(print("Enter your name: "))\n      name <- IO.succeed(scala.io.StdIn.readLine())\n      _    <- IO.succeed(println(s"Hello, $name"))\n    } yield ()\n\n  app.unsafeRunSync()\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"executable-encoding",children:"Executable Encoding"}),"\n",(0,s.jsx)(n.p,{children:"The executable encoding is straightforward. After defining the core model, we just need to think about the execution steps for each operator."}),"\n",(0,s.jsxs)(n.p,{children:["In the following example, we describe the core model as ",(0,s.jsx)(n.code,{children:"IO"})," case class, which has a ",(0,s.jsx)(n.code,{children:"thunk"})," of code that is going to be executed when we call ",(0,s.jsx)(n.code,{children:"unsafeRunSync"}),": ",(0,s.jsx)(n.code,{children:"case class IO[+A](private val thunk: () => A)"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["We should provide a set of operators: ",(0,s.jsx)(n.code,{children:"IO#map"}),", ",(0,s.jsx)(n.code,{children:"IO#flatMap"}),", and ",(0,s.jsx)(n.code,{children:"IO#unsafeRunSync"}),". We have also one constructor: ",(0,s.jsx)(n.code,{children:"IO.succeed"}),". Implementing these operators requires us to think about how they should actually executed to produce the desired result."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, when we implement ",(0,s.jsx)(n.code,{children:"map"}),",  should execute the ",(0,s.jsx)(n.code,{children:"thunk"})," of the current ",(0,s.jsx)(n.code,{children:"IO"})," and then apply the ",(0,s.jsx)(n.code,{children:"f"})," function to the result. The same applies to ",(0,s.jsx)(n.code,{children:"flatMap"})," and ",(0,s.jsx)(n.code,{children:"unsafeRunSync"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"final case class IO[+A](private val thunk: () => A) {\n  def map[B](f: A => B): IO[B]         = IO.succeed(f(thunk()))\n  def flatMap[B](f: A => IO[B]): IO[B] = IO.succeed(f(thunk()).unsafeRunSync())\n  def unsafeRunSync(): A               = thunk()\n}\n\nobject IO {\n  def succeed[A](value: => A): IO[A] = IO(() => value)\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Now we can run the greeting program with the above encoding."}),"\n",(0,s.jsx)(n.h3,{id:"declarative-encoding",children:"Declarative Encoding"}),"\n",(0,s.jsx)(n.p,{children:"In contrast to the executable encoding, the declarative encoding is lazy. This means that the definition of the language is separate from how it is interpreted."}),"\n",(0,s.jsxs)(n.p,{children:["In this example, we describe the problem of sequencing effects as a data type called ",(0,s.jsx)(n.code,{children:"FlatMap"})," that contains two information: the first effect to be executed and the function that should be applied to the result of the first effect. To describe the thunk of code that will be executed by the interpreter, we create another data type called ",(0,s.jsx)(n.code,{children:"Succeed"}),". Similarly, we need another data type called ",(0,s.jsx)(n.code,{children:"SucceedNow"})," to describe the already evaluated values."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"sealed trait IO[+A]\nobject IO {\n  final case class SucceedNow[A](value: A)                    extends IO[A]\n  final case class Succeed[A](thunk: () => A)                 extends IO[A]\n  final case class FlatMap[A, B](io: IO[A], cont: A => IO[B]) extends IO[B]\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Assume we have written the following program:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'val app: IO[Int] = \n  for {\n    a <- IO.succeed(scala.io.StdIn.readLine("Enter the first number: ").toInt)\n    b <- IO.succeed(scala.io.StdIn.readLine("Enter the second number: ").toInt) \n  } yield (a + b)\n'})}),"\n",(0,s.jsx)(n.p,{children:"This program will be translated into the following tree data structure using the declarative encoding:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'val app: IO[Int] = \n  IO.FlatMap(\n    IO.Succeed(() => scala.io.StdIn.readLine("Enter the first number: ").toInt),\n    (a: Int) =>\n      IO.FlatMap(\n        IO.Succeed(() => scala.io.StdIn.readLine("Enter the second number: ").toInt),\n        (b: Int) => IO.SucceedNow(a + b)\n      )\n  )\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The only operator that deals with the interpretation of the program is ",(0,s.jsx)(n.code,{children:"unsafeRunSync"}),". Let's see how the whole encoding looks like:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"sealed trait IO[+A] { self =>\n  def map[B](f: A => B): IO[B] = flatMap(f andThen IO.succeedNow)\n\n  def flatMap[B](f: A => IO[B]): IO[B] = IO.FlatMap(self, f)\n\n  def unsafeRunSync(): A = {\n    type Cont = Any => IO[Any]\n\n    def run(stack: List[Cont], currentIO: IO[Any]): A = {\n      def continue(value: Any) =\n        stack match {\n          case ::(cont, next) => run(next, cont(value))\n          case Nil            => value.asInstanceOf[A]\n        }\n\n      currentIO match {\n        case IO.SucceedNow(value) => continue(value)\n        case IO.Succeed(thunk)    => continue(thunk())\n        case IO.FlatMap(io, cont) => run(stack appended cont, io)\n      }\n    }\n\n    run(stack = Nil, currentIO = self)\n  }\n}\n\nobject IO {\n  def succeedNow[A](value: A): IO[A] = IO.SucceedNow(value)\n  def succeed[A](value: => A): IO[A] = IO.Succeed(() => value)\n\n  final case class SucceedNow[A](value: A)                    extends IO[A]\n  final case class Succeed[A](thunk: () => A)                 extends IO[A]\n  final case class FlatMap[A, B](io: IO[A], cont: A => IO[B]) extends IO[B]\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>o});var a=t(96540);const s={},i=a.createContext(s);function c(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);