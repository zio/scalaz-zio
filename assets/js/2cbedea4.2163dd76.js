"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[80171],{28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>a});var s=n(96540);const d={},r=s.createContext(d);function i(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:i(e.components),s.createElement(r.Provider,{value:t},e.children)}},43888:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"reference/test/property-testing/index","title":"Introduction To Property Testing","description":"What is Property-Based Testing?","source":"@site/docs/reference/test/property-testing/index.md","sourceDirName":"reference/test/property-testing","slug":"/reference/test/property-testing/","permalink":"/reference/test/property-testing/","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/test/property-testing/index.md","tags":[],"version":"current","frontMatter":{"id":"index","title":"Introduction To Property Testing"},"sidebar":"reference-sidebar","previous":{"title":"Dynamic Test Generation","permalink":"/reference/test/dynamic-test-generation"},"next":{"title":"Getting Started","permalink":"/reference/test/property-testing/getting-started"}}');var d=n(74848),r=n(28453);const i={id:"index",title:"Introduction To Property Testing"},a=void 0,c={},o=[{value:"What is Property-Based Testing?",id:"what-is-property-based-testing",level:2}];function l(e){const t={code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(t.h2,{id:"what-is-property-based-testing",children:"What is Property-Based Testing?"}),"\n",(0,d.jsx)(t.p,{children:"In property-based testing, instead of testing individual values and making assertions on the results, we rely on testing the properties of the system which is under the test."}),"\n",(0,d.jsxs)(t.p,{children:["To be more acquainted with property-based testing, let's look at how we can test a simple addition function. So assume we have a function ",(0,d.jsx)(t.code,{children:"add"})," that adds two numbers:"]}),"\n",(0,d.jsx)(t.pre,{children:(0,d.jsx)(t.code,{className:"language-scala",children:"def add(a: Int, b: Int): Int = ???\n"})}),"\n",(0,d.jsx)(t.p,{children:"in a typical test we start with some well-known values as test inputs and check if the function returns the expected values for each of the pair inputs:"}),"\n",(0,d.jsxs)(t.table,{children:[(0,d.jsx)(t.thead,{children:(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.th,{style:{textAlign:"center"},children:"Input"}),(0,d.jsx)(t.th,{style:{textAlign:"center"},children:"Expected Output"})]})}),(0,d.jsxs)(t.tbody,{children:[(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{style:{textAlign:"center"},children:"(0, 0)"}),(0,d.jsx)(t.td,{style:{textAlign:"center"},children:"0"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{style:{textAlign:"center"},children:"(1, 0)"}),(0,d.jsx)(t.td,{style:{textAlign:"center"},children:"1"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{style:{textAlign:"center"},children:"(0, 1)"}),(0,d.jsx)(t.td,{style:{textAlign:"center"},children:"1"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{style:{textAlign:"center"},children:"(0, -1)"}),(0,d.jsx)(t.td,{style:{textAlign:"center"},children:"-1"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{style:{textAlign:"center"},children:"(-1, 0)"}),(0,d.jsx)(t.td,{style:{textAlign:"center"},children:"-1"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{style:{textAlign:"center"},children:"..."}),(0,d.jsx)(t.td,{style:{textAlign:"center"},children:"..."})]})]})]}),"\n",(0,d.jsxs)(t.p,{children:["Now we can test all the inputs and make sure the ",(0,d.jsx)(t.code,{children:"add"})," function returns the expected values:"]}),"\n",(0,d.jsx)(t.pre,{children:(0,d.jsx)(t.code,{className:"language-scala",children:'import zio.test._\n\nobject AdditionSpec extends ZIOSpecDefault {\n\n  def add(a: Int, b: Int): Int = ???\n\n  val testData = Seq(\n    ((0, 0), 0),\n    ((1, 0), 1),\n    ((0, 1), 1),\n    ((0, -1), -1),\n    ((-1, 0), -1),\n    ((1, 1), 2),\n    ((1, -1), 0),\n    ((-1, 1), 0)\n  )\n\n  def spec =\n    test("test add function") {\n      assertTrue {\n        testData.forall { case ((a, b), expected) =>\n          add(a, b) == expected\n        }\n      }\n    }\n}\n'})}),"\n",(0,d.jsx)(t.p,{children:"This is not a very good approach because it is very hard to find a set of inputs that will cover all possible behaviors of the addition function."}),"\n",(0,d.jsxs)(t.p,{children:["Instead, in property-based testing, we extract the set of properties that our function must satisfy. So let's think about the ",(0,d.jsx)(t.code,{children:"add"})," function and find out what properties it must satisfy:"]}),"\n",(0,d.jsxs)(t.ol,{children:["\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.strong,{children:"Commutative Property"}),"\u2014 It says that changing the order of addends does not change the result. So for all ",(0,d.jsx)(t.code,{children:"a"})," and ",(0,d.jsx)(t.code,{children:"b"}),", ",(0,d.jsx)(t.code,{children:"add(a, b)"})," must be equal to ",(0,d.jsx)(t.code,{children:"add(a, b)"}),":"]}),"\n"]}),"\n",(0,d.jsx)(t.pre,{children:(0,d.jsx)(t.code,{className:"language-scala",children:"assertTrue(add(a, b) == add(b, a))\n"})}),"\n",(0,d.jsxs)(t.ol,{start:"2",children:["\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.strong,{children:"Associative Property"}),"\u2014 This says that changing the grouping of addends does not change the result. So for all ",(0,d.jsx)(t.code,{children:"a"}),", ",(0,d.jsx)(t.code,{children:"b"})," and ",(0,d.jsx)(t.code,{children:"c"}),", the ",(0,d.jsx)(t.code,{children:"add(add(a, b), c)"})," must be equal to ",(0,d.jsx)(t.code,{children:"add(a, add(b, c))"}),":"]}),"\n"]}),"\n",(0,d.jsx)(t.pre,{children:(0,d.jsx)(t.code,{className:"language-scala",children:"assertTrue(add(add(a, b), c) == add(a, add(b, c)))\n"})}),"\n",(0,d.jsxs)(t.ol,{start:"3",children:["\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.strong,{children:"Identity Property"}),"\u2014 For all ",(0,d.jsx)(t.code,{children:"a"}),", ",(0,d.jsx)(t.code,{children:"add(a, 0)"})," must be equal to ",(0,d.jsx)(t.code,{children:"a"}),":"]}),"\n"]}),"\n",(0,d.jsx)(t.pre,{children:(0,d.jsx)(t.code,{className:"language-scala",children:"assertTrue(add(a, 0) == a)\n"})}),"\n",(0,d.jsxs)(t.p,{children:["If we test all of these properties we can be sure that the ",(0,d.jsx)(t.code,{children:"add"})," function works as expected, so let's see how we can do that using the ",(0,d.jsx)(t.code,{children:"Gen"})," data type:"]}),"\n",(0,d.jsx)(t.pre,{children:(0,d.jsx)(t.code,{className:"language-scala",children:'import zio.test._\n\nobject AdditionSpec extends ZIOSpecDefault {\n\n  def add(a: Int, b: Int): Int = ???\n\n  def spec = suite("Add Spec")(\n    test("add is commutative") {\n      check(Gen.int, Gen.int) { (a, b) =>\n        assertTrue(add(a, b) == add(b, a))\n      }\n    },\n    test("add is associative") {\n      check(Gen.int, Gen.int, Gen.int) { (a, b, c) =>\n        assertTrue(add(add(a, b), c) == add(a, add(b, c)))\n      }\n    },\n    test("add is identitive") {\n      check(Gen.int) { a =>\n        assertTrue(add(a, 0) == a)\n      }\n    }\n  )\n}\n'})})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,d.jsx)(t,{...e,children:(0,d.jsx)(l,{...e})}):l(e)}}}]);