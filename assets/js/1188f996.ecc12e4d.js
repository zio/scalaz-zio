"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[59043],{51802:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>a,toc:()=>o});const a=JSON.parse('{"id":"zio-schema/basic-building-blocks","title":"Basic Building Blocks","description":"To get started, first we need to understand that a ZIO Schema is basically built-up from these three","source":"@site/docs/zio-schema/basic-building-blocks.md","sourceDirName":"zio-schema","slug":"/zio-schema/basic-building-blocks","permalink":"/zio-schema/basic-building-blocks","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-schema/basic-building-blocks.md","tags":[],"version":"current","frontMatter":{"id":"basic-building-blocks","title":"Basic Building Blocks"},"sidebar":"ecosystem-sidebar","previous":{"title":"Use cases","permalink":"/zio-schema/use-cases"},"next":{"title":"Standard Type Reference","permalink":"/zio-schema/standard-type-reference"}}');var c=s(74848),i=s(28453);const t={id:"basic-building-blocks",title:"Basic Building Blocks"},l=void 0,r={},o=[{value:"Primitives",id:"primitives",level:2},{value:"Fail",id:"fail",level:2},{value:"Collections",id:"collections",level:2},{value:"Sequence",id:"sequence",level:3},{value:"Map",id:"map",level:3},{value:"Set",id:"set",level:3},{value:"Records",id:"records",level:2},{value:"Enumerations",id:"enumerations",level:2},{value:"Optionals",id:"optionals",level:2},{value:"Either",id:"either",level:2},{value:"Tuple",id:"tuple",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.p,{children:["To get started, first we need to understand that a ZIO Schema is basically built-up from these three\nsealed traits: ",(0,c.jsx)(n.code,{children:"Record[R]"}),", ",(0,c.jsx)(n.code,{children:"Enum[A]"})," and ",(0,c.jsx)(n.code,{children:"Sequence[Col, Elem]"}),", along with the case class ",(0,c.jsx)(n.code,{children:"Primitive[A]"}),". Every other type is just a specialisation of one of these (or not relevant to get you started)."]}),"\n",(0,c.jsxs)(n.p,{children:["The core data type of ZIO Schema is a ",(0,c.jsx)(n.code,{children:"Schema[A]"})," which is ",(0,c.jsxs)(n.strong,{children:["invariant in ",(0,c.jsx)(n.code,{children:"A"})]})," by necessity, because a Schema allows us to derive operations that produce an ",(0,c.jsx)(n.code,{children:"A"})," but also operations that consume an ",(0,c.jsx)(n.code,{children:"A"})," and that imposes limitations on the types of ",(0,c.jsx)(n.strong,{children:"transformation operators"})," and ",(0,c.jsx)(n.strong,{children:"composition operators"})," that we can provide based on a ",(0,c.jsx)(n.code,{children:"Schema"}),"."]}),"\n",(0,c.jsx)(n.p,{children:"It looks kind of like this (simplified):"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:"sealed trait Schema[A] { self =>\n  def zip[B](that: Schema[B]): Schema[(A, B)]\n\n  def transform[B](f: A => B, g: B => A): Schema[B]\n}\n"})}),"\n",(0,c.jsx)(n.h2,{id:"primitives",children:"Primitives"}),"\n",(0,c.jsxs)(n.p,{children:["To describe scalar data type ",(0,c.jsx)(n.code,{children:"A"}),", we use the ",(0,c.jsx)(n.code,{children:"Primitive[A]"})," data type which basically is a wrapper around ",(0,c.jsx)(n.code,{children:"StandardType"}),":"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:"case class Primitive[A](standardType: StandardType[A]) extends Schema[A]\n"})}),"\n",(0,c.jsxs)(n.p,{children:["Primitive values are represented using the ",(0,c.jsx)(n.code,{children:"Primitive[A]"})," type class and represent the elements that we cannot further define through other means. If we visualize our data structure as a tree, primitives are the leaves."]}),"\n",(0,c.jsxs)(n.p,{children:["For a list of all standard types (and therefore primitive types) with built-in support, please see the ",(0,c.jsx)(n.a,{href:"/zio-schema/standard-type-reference",children:"standard type reference"})]}),"\n",(0,c.jsxs)(n.p,{children:["Inside ",(0,c.jsx)(n.code,{children:"Schema"}),"'s companion object, we have an implicit conversion from ",(0,c.jsx)(n.code,{children:"StandardType[A]"})," to ",(0,c.jsx)(n.code,{children:"Schema[A]"}),":"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:"object Schema {\n   implicit def primitive[A](implicit standardType: StandardType[A]): Schema[A] = ???\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["So we can easily create a ",(0,c.jsx)(n.code,{children:"Schema"})," for a primitive type ",(0,c.jsx)(n.code,{children:"A"})," either by calling ",(0,c.jsx)(n.code,{children:"Schema.primitive[A]"})," or by calling ",(0,c.jsx)(n.code,{children:"Schema.apply[A]"}),":"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:"val intSchema1: Schema[Int] = Schema[Int]\nval intSchema2: Schema[Int] = Schema.primitive[Int] \n"})}),"\n",(0,c.jsx)(n.h2,{id:"fail",children:"Fail"}),"\n",(0,c.jsxs)(n.p,{children:["To represents the absence of schema information for the given ",(0,c.jsx)(n.code,{children:"A"})," type, we can use ",(0,c.jsx)(n.code,{children:"Schema.fail"})," constructor, which creates the following schema:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:"object Schema {\n  case class Fail[A](\n    message: String,\n    annotations: Chunk[Any] = Chunk.empty\n  ) extends Schema[A]\n}\n"})}),"\n",(0,c.jsx)(n.h2,{id:"collections",children:"Collections"}),"\n",(0,c.jsx)(n.h3,{id:"sequence",children:"Sequence"}),"\n",(0,c.jsxs)(n.p,{children:["Often we have a type that is a collection of elements. For example, we might have a ",(0,c.jsx)(n.code,{children:"List[User]"}),". This is called a ",(0,c.jsx)(n.code,{children:"Sequence"})," and is represented using the ",(0,c.jsx)(n.code,{children:"Sequence[Col, Elem, I]"})," type class:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:"object Schema {\n  sealed trait Collection[Col, Elem] extends Schema[Col]\n  \n  final case class Sequence[Col, Elem, I](\n      elementSchema: Schema[Elem],\n      fromChunk: Chunk[Elem] => Col,\n      toChunk: Col => Chunk[Elem],\n      override val annotations: Chunk[Any] = Chunk.empty,\n      identity: I\n    ) extends Collection[Col, Elem]\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["The ",(0,c.jsx)(n.code,{children:"Sequence"})," can be anything that can be isomorphic to a list."]}),"\n",(0,c.jsxs)(n.p,{children:["Here is an example schema for list of ",(0,c.jsx)(n.code,{children:"Person"}),"s:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport zio.schema._\nimport zio.schema.Schema._\n  \ncase class Person(name: String, age: Int)\n\nobject Person {\n  implicit val schema: Schema[Person] = DeriveSchema.gen[Person]\n}\n\nval personListSchema: Schema[List[Person]] =\n  Sequence[List[Person], Person, String](\n    elementSchema = Schema[Person],\n    fromChunk = _.toList,\n    toChunk = i => Chunk.fromIterable(i),\n    annotations = Chunk.empty,\n    identity = "List"\n  )\n'})}),"\n",(0,c.jsxs)(n.p,{children:["ZIO Schema has ",(0,c.jsx)(n.code,{children:"Schema.list[A]"}),", ",(0,c.jsx)(n.code,{children:"Schema.chunk[A]"})," and ",(0,c.jsx)(n.code,{children:"Schema.vector[A]"})," constructors that create ",(0,c.jsx)(n.code,{children:"Schema[List[A]]"}),", ",(0,c.jsx)(n.code,{children:"Schema[Chunk[A]]"})," and ",(0,c.jsx)(n.code,{children:"Schema[Vector[A]]"})," for us:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:"import zio._\nimport zio.schema._\nimport zio.schema.Schema._\n  \ncase class Person(name: String, age: Int)\n\nobject Person {\n  implicit val schema: Schema[Person] = DeriveSchema.gen[Person]\n  \n  implicit val listSchema:   Schema[List[Person]]   = Schema.list[Person]\n  implicit val chunkSchema:  Schema[Chunk[Person]]  = Schema.chunk[Person]\n  implicit val vectorSchema: Schema[Vector[Person]] = Schema.vector[Person]\n}\n"})}),"\n",(0,c.jsx)(n.h3,{id:"map",children:"Map"}),"\n",(0,c.jsx)(n.p,{children:"Likewise, we can have a type that is a map of keys to values. ZIO Schema represents this using the following type class:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:"object Schema {\n  sealed trait Collection[Col, Elem] extends Schema[Col]\n\n  case class Map[K, V](\n    keySchema: Schema[K],\n    valueSchema: Schema[V],\n    override val annotations: Chunk[Any] = Chunk.empty\n  ) extends Collection[scala.collection.immutable.Map[K, V], (K, V)]\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["It stores the key and value schemas. Like ",(0,c.jsx)(n.code,{children:"Sequence"}),", instead of using ",(0,c.jsx)(n.code,{children:"Map"})," directly, we can use the ",(0,c.jsx)(n.code,{children:"Schema.map[K, V]"})," constructor:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:"import zio._\nimport zio.schema._\nimport zio.schema.Schema._\n  \ncase class Person(name: String, age: Int)\n\nobject Person {\n  implicit val schema: Schema[Person] = DeriveSchema.gen[Person]\n  \n  implicit val mapSchema: Schema[scala.collection.immutable.Map[String, Person]] = \n    Schema.map[String, Person]\n}\n"})}),"\n",(0,c.jsx)(n.h3,{id:"set",children:"Set"}),"\n",(0,c.jsxs)(n.p,{children:["The ",(0,c.jsx)(n.code,{children:"Set"})," type class is similar to ",(0,c.jsx)(n.code,{children:"Sequence"})," and ",(0,c.jsx)(n.code,{children:"Map"}),". It is used to represent a schema for a set of elements:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:"object Schema {\n  sealed trait Collection[Col, Elem] extends Schema[Col]\n\n  case class Set[A](\n    elementSchema: Schema[A],\n    override val annotations: Chunk[Any] = Chunk.empty\n  ) extends Collection[scala.collection.immutable.Set[A], A]\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["To create a ",(0,c.jsx)(n.code,{children:"Schema"})," for a ",(0,c.jsx)(n.code,{children:"Set[A]"}),", we can use the above type class directly or use the ",(0,c.jsx)(n.code,{children:"Schema.set[A]"})," constructor:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:"import zio._\nimport zio.schema._\nimport zio.schema.Schema._\n  \ncase class Person(name: String, age: Int)\n\nobject Person {\n  implicit val schema: Schema[Person] = DeriveSchema.gen[Person]\n  \n  implicit val setSchema: Schema[scala.collection.immutable.Set[Person]] = \n    Schema.set[Person]\n}\n"})}),"\n",(0,c.jsx)(n.h2,{id:"records",children:"Records"}),"\n",(0,c.jsxs)(n.p,{children:["Our data structures usually are composed of a lot of types. For example, we might have a ",(0,c.jsx)(n.code,{children:"User"})," type that has a ",(0,c.jsx)(n.code,{children:"name"})," field, an ",(0,c.jsx)(n.code,{children:"age"})," field, an ",(0,c.jsx)(n.code,{children:"address"})," field, and a ",(0,c.jsx)(n.code,{children:"friends"})," field."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:"case class User(name: String, age: Int, address: Address, friends: List[User])\n"})}),"\n",(0,c.jsxs)(n.p,{children:["This is called a ",(0,c.jsx)(n.strong,{children:"product type"})," in functional programming. The equivalent of a product type in ZIO Schema is called a record."]}),"\n",(0,c.jsxs)(n.p,{children:["In ZIO Schema such a record would be represented using the ",(0,c.jsx)(n.code,{children:"Record[R]"})," typeclass:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:"object Schema {\n  sealed trait Field[R, A] {\n    type Field <: Singleton with String\n    def name: Field\n    def schema: Schema[A]\n  }\n\n  sealed trait Record[R] extends Schema[R] {\n    def id: TypeId\n    def fields: Chunk[Field[_]]\n    def construct(fieldValues: Chunk[Any]): Either[String, R]\n  }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["ZIO Schema has specialized record types for case classes, called ",(0,c.jsx)(n.code,{children:"CaseClass1[A, Z]"}),", ",(0,c.jsx)(n.code,{children:"CaseClass2[A1, A2, Z]"}),", ..., ",(0,c.jsx)(n.code,{children:"CaseClass22"}),". Here is the definition of ",(0,c.jsx)(n.code,{children:"apply"})," method of ",(0,c.jsx)(n.code,{children:"CaseClass1"})," and ",(0,c.jsx)(n.code,{children:"CaseClass2"}),":"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:"sealed trait CaseClass1[A, Z] extends Record[Z]\n\nobject CaseClass1 {\n  def apply[A, Z](\n    id0: TypeId,\n    field0: Field[Z, A],\n    defaultConstruct0: A => Z,\n    annotations0: Chunk[Any] = Chunk.empty\n  ): CaseClass1[A, Z] = ???\n}\n\nobject CaseClass2 {\n  def apply[A1, A2, Z](\n    id0: TypeId,\n    field01: Field[Z, A1],\n    field02: Field[Z, A2],\n    construct0: (A1, A2) => Z,\n    annotations0: Chunk[Any] = Chunk.empty\n  ): CaseClass2[A1, A2, Z] = ???\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["As we can see, they take a ",(0,c.jsx)(n.code,{children:"TypeId"}),", a number of fields of type ",(0,c.jsx)(n.code,{children:"Field"}),", and a construct function. The ",(0,c.jsx)(n.code,{children:"TypeId"})," is used to uniquely identify the type. The ",(0,c.jsx)(n.code,{children:"Field"})," is used to store the name of the field and the schema of the field. The ",(0,c.jsx)(n.code,{children:"construct"})," is used to construct the type from the field values."]}),"\n",(0,c.jsxs)(n.p,{children:["Here is an example of defining schema for ",(0,c.jsx)(n.code,{children:"Person"})," data type:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:'import zio.schema._\n\nfinal case class Person(name: String, age: Int)\n\nobject Person {\n  implicit val schema: Schema[Person] =\n    Schema.CaseClass2[String, Int, Person](\n      id0 = TypeId.fromTypeName("Person"),\n      field01 = \n        Schema.Field(\n          name0 = "name",\n          schema0 = Schema[String],\n          get0 = _.name,\n          set0 = (p, x) => p.copy(name = x)\n        ),\n      field02 = \n        Schema.Field(\n          name0 = "age",\n          schema0 = Schema[Int],\n          get0 = _.age,\n          set0 = (person, age) => person.copy(age = age)\n        ),\n      construct0 = (name, age) => Person(name, age),\n    )\n}\n'})}),"\n",(0,c.jsxs)(n.p,{children:["There is also the ",(0,c.jsx)(n.code,{children:"GenericRecord"})," which is used to either ad-hoc records or records that have more than 22 fields:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:"object Schema {\n  sealed case class GenericRecord(\n    id: TypeId,\n    fieldSet: FieldSet,\n    override val annotations: Chunk[Any] = Chunk.empty\n  ) extends Record[ListMap[String, _]]\n}\n"})}),"\n",(0,c.jsx)(n.h2,{id:"enumerations",children:"Enumerations"}),"\n",(0,c.jsx)(n.p,{children:"Other times, you might have a type that represents a list of different types. For example, we might have a type, like this:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:"sealed trait PaymentMethod \n\nobject PaymentMethod {\n  final case class CreditCard(number: String, expirationMonth: Int, expirationYear: Int) extends PaymentMethod\n  final case class WireTransfer(accountNumber: String, bankCode: String) extends PaymentMethod\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["In functional programming, this kind of type is called a ",(0,c.jsx)(n.strong,{children:"sum type"}),":"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["In Scala 2, this is called a ",(0,c.jsx)(n.strong,{children:"sealed trait"}),"."]}),"\n",(0,c.jsxs)(n.li,{children:["In Scala3, this is called an ",(0,c.jsx)(n.strong,{children:"enum"}),"."]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["In ZIO Schema we call these types ",(0,c.jsx)(n.code,{children:"enumeration"})," types, and they are represented using the ",(0,c.jsx)(n.code,{children:"Enum[A]"})," type class."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:"object Schema {\n  sealed trait Enum[Z] extends Schema[Z]\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["It has specialized types ",(0,c.jsx)(n.code,{children:"Enum1[A, Z]"}),", ",(0,c.jsx)(n.code,{children:"Enum2[A1, A2, Z]"}),", ..., ",(0,c.jsx)(n.code,{children:"Enum22[A1, A2, ..., A22, Z]"})," for enumerations with 1, 2, ..., 22 cases. Here is the definition of ",(0,c.jsx)(n.code,{children:"Enum1"})," and ",(0,c.jsx)(n.code,{children:"Enum2"}),":"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:"  sealed case class Enum1[A, Z](\n    id: TypeId,\n    case1: Case[Z, A],\n    annotations: Chunk[Any] = Chunk.empty\n  ) extends Enum[Z]\n\n  sealed case class Enum2[A1, A2, Z](\n    id: TypeId,\n    case1: Case[Z, A1],\n    case2: Case[Z, A2],\n    annotations: Chunk[Any] = Chunk.empty\n  ) extends Enum[Z]\n\n  // Enum3, Enum4, ..., Enum22\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["If the enumeration has more than 22 cases, we can use the ",(0,c.jsx)(n.code,{children:"EnumN"})," type class:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:"object Schema {\n  sealed case class EnumN[Z, C <: CaseSet.Aux[Z]](\n    id: TypeId,\n    caseSet: C,\n    annotations: Chunk[Any] = Chunk.empty\n  ) extends Enum[Z]\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["It has a simple constructor called ",(0,c.jsx)(n.code,{children:"Schema.enumeration"}),":"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:"object Schema {\n  def enumeration[A, C <: CaseSet.Aux[A]](id: TypeId, caseSet: C): Schema[A] = ???\n}\n"})}),"\n",(0,c.jsx)(n.h2,{id:"optionals",children:"Optionals"}),"\n",(0,c.jsxs)(n.p,{children:["To create a ",(0,c.jsx)(n.code,{children:"Schema"})," for optional values, we can use the ",(0,c.jsx)(n.code,{children:"Optional"})," type class:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:"object Schema {\n  case class Optional[A](\n    schema: Schema[A],\n    annotations: Chunk[Any] = Chunk.empty\n  ) extends Schema[Option[A]]\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["Using the ",(0,c.jsx)(n.code,{children:"Schema.option[A]"})," constructor, makes it easier to do so:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:"val option: Schema[Option[Person]] = Schema.option[Person]\n"})}),"\n",(0,c.jsx)(n.h2,{id:"either",children:"Either"}),"\n",(0,c.jsxs)(n.p,{children:["Here is the same but for ",(0,c.jsx)(n.code,{children:"Either"}),":"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:"object Schema {\n  case class Either[A, B](\n    left: Schema[A],\n    right: Schema[B],\n    annotations: Chunk[Any] = Chunk.empty\n  ) extends Schema[scala.util.Either[A, B]]\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["We can use ",(0,c.jsx)(n.code,{children:"Schema.either[A, B]"})," to create a ",(0,c.jsx)(n.code,{children:"Schema"})," for ",(0,c.jsx)(n.code,{children:"scala.util.Either[A, B]"}),":"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:"val eitherPersonSchema: Schema[scala.util.Either[String, Person]] = \n  Schema.either[String, Person]\n"})}),"\n",(0,c.jsx)(n.h2,{id:"tuple",children:"Tuple"}),"\n",(0,c.jsxs)(n.p,{children:["Each schema has a ",(0,c.jsx)(n.code,{children:"Schema#zip"})," operator that allows us to combine two schemas and create a schema for a tuple of the two types:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:"object Schema {\n  def zip[B](that: Schema[B]): Schema[(A, B)] = \n    Schema.Tuple2(self, that)\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["It is implemented using the ",(0,c.jsx)(n.code,{children:"Schema.Tuple2"})," type class:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:"object Schema {\n  final case class Tuple2[A, B](\n    left: Schema[A],\n    right: Schema[B], \n    annotations: Chunk[Any] = Chunk.em\n    pty\n  ) extends Schema[(A, B)] \n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"ZIO Schema also provides implicit conversions for tuples of arity 2, 3, ..., 22:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:"object Schema {\n  implicit def tuple2[A, B](implicit c1: Schema[A], c2: Schema[B]): Schema[(A, B)] =\n    c1.zip(c2)\n\n  implicit def tuple3[A, B, C](implicit c1: Schema[A], c2: Schema[B], c3: Schema[C]): Schema[(A, B, C)] =\n    c1.zip(c2).zip(c3).transform({ case ((a, b), c) => (a, b, c) }, { case (a, b, c) => ((a, b), c) })\n\n  // tuple3, tuple4, ..., tuple22\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["So we can easily create a ",(0,c.jsx)(n.code,{children:"Schema"})," for a tuple of n elements, just by calling ",(0,c.jsx)(n.code,{children:"Schema[(A1, A2, ..., An)]"}),":"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-scala",children:"import zio.schema._\n\nval tuple2: Schema[(String, Int)]          = Schema[(String, Int)]\nval tuple3: Schema[(String, Int, Boolean)] = Schema[(String, Int, Boolean)]\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(d,{...e})}):d(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>l});var a=s(96540);const c={},i=a.createContext(c);function t(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:t(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);