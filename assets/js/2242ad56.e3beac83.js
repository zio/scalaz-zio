"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[84103],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>l});var r=t(96540);const a={},i=r.createContext(a);function o(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),r.createElement(i.Provider,{value:n},e.children)}},89935:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"reference/error-management/imperative-vs-declarative","title":"Imperative vs. Declarative Error Handling","description":"To figure out the benefit of typed errors in declarative error handling, we need to understand the drawbacks of the imperative approach and then see how the declarative approach can be used to solve the same problem.","source":"@site/docs/reference/error-management/declarative.md","sourceDirName":"reference/error-management","slug":"/reference/error-management/imperative-vs-declarative","permalink":"/reference/error-management/imperative-vs-declarative","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/error-management/declarative.md","tags":[],"version":"current","frontMatter":{"id":"imperative-vs-declarative","title":"Imperative vs. Declarative Error Handling","sidebar_label":"Imperative vs. Declarative"},"sidebar":"reference-sidebar","previous":{"title":"Fatal Errors","permalink":"/reference/error-management/types/fatals"},"next":{"title":"Expected and Unexpected Errors","permalink":"/reference/error-management/expected-and-unexpected-errors"}}');var a=t(74848),i=t(28453);const o={id:"imperative-vs-declarative",title:"Imperative vs. Declarative Error Handling",sidebar_label:"Imperative vs. Declarative"},l=void 0,s={},c=[{value:"Imperative Error Handling",id:"imperative-error-handling",level:2},{value:"Declarative Error Handling",id:"declarative-error-handling",level:2},{value:"Imperative vs. Declarative",id:"imperative-vs-declarative",level:2},{value:"Referential Transparency",id:"referential-transparency",level:3},{value:"Type-safety",id:"type-safety",level:3},{value:"Exhaustivity Checking",id:"exhaustivity-checking",level:3},{value:"Error Model",id:"error-model",level:3}];function h(e){const n={blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"To figure out the benefit of typed errors in declarative error handling, we need to understand the drawbacks of the imperative approach and then see how the declarative approach can be used to solve the same problem."}),"\n",(0,a.jsx)(n.h2,{id:"imperative-error-handling",children:"Imperative Error Handling"}),"\n",(0,a.jsxs)(n.p,{children:["In the imperative style, when we encounter a wrong state, we throw an exception, and to handle exceptions, we have to use the ",(0,a.jsx)(n.code,{children:"try"}),"/",(0,a.jsx)(n.code,{children:"catch"})," language construct. Whenever we encounter an exception inside a ",(0,a.jsx)(n.code,{children:"try"})," block, the control flow will jump to the ",(0,a.jsx)(n.code,{children:"catch"})," block. In the catch block, we can handle the exception and decide what to do next. This is a very common pattern in imperative programming."]}),"\n",(0,a.jsxs)(n.p,{children:["For example, we can write the ",(0,a.jsx)(n.code,{children:"divide"})," function like this:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'def divide(a: Int, b: Int): Int =\n  if (b == 0)\n    throw new IllegalArgumentException("Division by zero")\n  else\n    a / b\n'})}),"\n",(0,a.jsxs)(n.p,{children:["As we know that this function throws an exception when ",(0,a.jsx)(n.code,{children:"b"})," is zero, so we need to handle the exception when we call this function:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"def readFromConsole: (Int, Int) = ???\n\nval (a, b) = readFromConsole\n\ntry {\n  Some(divide(a, b))\n} catch {\n  case _: IllegalArgumentException => None\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"declarative-error-handling",children:"Declarative Error Handling"}),"\n",(0,a.jsxs)(n.p,{children:["In declarative error handling, we treat errors as values instead of throwing exceptions. So instead of breaking the flow of the program, we can return a value that represents the error. When we have a workflow of type ",(0,a.jsx)(n.code,{children:"ZIO[R, E, A]"}),", the ",(0,a.jsx)(n.code,{children:"E"})," type parameter is used to represent that our workflow may fail with an error of type ",(0,a.jsx)(n.code,{children:"E"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["For example, the following program written with ZIO may fail with an error of type ",(0,a.jsx)(n.code,{children:"AgeValidationException"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nsealed trait AgeValidationException extends Exception\ncase class NegativeAgeException(age: Int) extends AgeValidationException\ncase class IllegalAgeException(age: Int)  extends AgeValidationException\n\ndef validate(age: Int): ZIO[Any, AgeValidationException, Int] =\n  if (age < 0)\n    ZIO.fail(NegativeAgeException(age))\n  else if (age < 18)\n    ZIO.fail(IllegalAgeException(age))\n  else ZIO.succeed(age)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["We can handle errors using ",(0,a.jsx)(n.code,{children:"catchAll"}),"/",(0,a.jsx)(n.code,{children:"catchSome"})," methods instead of using ",(0,a.jsx)(n.code,{children:"try"}),"/",(0,a.jsx)(n.code,{children:"catch"})," blocks:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"validate(17).catchAll {\n  case NegativeAgeException(age) => ???\n  case IllegalAgeException(age)  => ???\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"imperative-vs-declarative",children:"Imperative vs. Declarative"}),"\n",(0,a.jsx)(n.h3,{id:"referential-transparency",children:"Referential Transparency"}),"\n",(0,a.jsx)(n.p,{children:"We say that an expression is referentially transparent if it can be replaced with its value without changing the behavior of the program. This property helps us to reason about a program easily. Also writing tests for our programs becomes much easier."}),"\n",(0,a.jsx)(n.p,{children:"Unfortunately, when we throw an exception, we lose the ability to reason about our programs. Exceptions break the referential transparency of our programs. For example, let's say we have the following function:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"def divide10By(b: Int): Option[Int] = {\n  val result = divide(10, b)\n  try {\n    Some(result)\n  } catch {\n    case _: IllegalArgumentException => None\n  }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["If we call ",(0,a.jsx)(n.code,{children:"divide10By(0)"}),", we will get an exception (",(0,a.jsx)(n.code,{children:"IllegalArgumentException"}),"). Now, let's see what happens if we replace the result with its value like this:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"def divide10By(b: Int): Option[Int] = \n  try {\n    Some(divide(10, b))\n  } catch {\n    case _: IllegalArgumentException => None\n  }\n"})}),"\n",(0,a.jsxs)(n.p,{children:["In this case, if we call ",(0,a.jsx)(n.code,{children:"divide10By(0)"}),", we will get the ",(0,a.jsx)(n.code,{children:"None"})," value. The behavior of the function will be changed. We cannot reason about the behavior of our program by substituting expressions with their values. In this style of error handling, the behavior of the program is dependent on where we call our expressions, inside or outside the ",(0,a.jsx)(n.code,{children:"try"})," block."]}),"\n",(0,a.jsxs)(n.p,{children:["When we model our programs with the ",(0,a.jsx)(n.code,{children:"ZIO"}),", we sure that our programs are referentially transparent. We can reason about our programs very easily without having to worry about changing the behavior of our programs."]}),"\n",(0,a.jsx)(n.h3,{id:"type-safety",children:"Type-safety"}),"\n",(0,a.jsx)(n.p,{children:"There is no way to know what errors can be thrown by looking at the function signature. The only way to find out in which circumstance a method may throw an exception is to read and investigate its implementation. So the compiler cannot prevent us from writing unsafe codes. It is also hard for a developer to read the documentation event through reading the documentation is not sufficient as it may be obsolete, or it may don't reflect the exact exceptions."}),"\n",(0,a.jsx)(n.p,{children:"In ZIO when we see the type of the effect, we can determine what kind of error it can fail with. This helps us to have compile-time type-safety on our programs not only on success values but also on failure values."}),"\n",(0,a.jsx)(n.h3,{id:"exhaustivity-checking",children:"Exhaustivity Checking"}),"\n",(0,a.jsxs)(n.p,{children:["When we use ",(0,a.jsx)(n.code,{children:"try"}),"/",(0,a.jsx)(n.code,{children:"catch"})," the compiler doesn't know about errors at compile time, so if we forgot to handle one of the exceptions the compiler doesn't help us to write total functions. This code will crash at runtime because we forgot to handle the ",(0,a.jsx)(n.code,{children:"IllegalAgeException"})," case:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"try {\n  validate(17)\n} catch {\n  case NegativeAgeException(age) => ???\n  //  case IllegalAgeException(age) => ???\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"When we are using typed errors we can have exhaustive checking support from the compiler. For example, when we are catching all errors if we forgot to handle one of the cases, the compiler warns us about that:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"validate(17).catchAll {\n  case NegativeAgeException(age) => ???\n}\n\n// match may not be exhaustive.\n// It would fail on the following input: IllegalAgeException(_)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["In the example above, if we only handle ",(0,a.jsx)(n.code,{children:"NegativeAgeException"}),", the compiler will complain about the ",(0,a.jsx)(n.code,{children:"IllegalAgeException"})," being unhandled. This helps us cover all cases and write ",(0,a.jsx)(n.em,{children:"total functions"})," easily."]}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Note:"})}),"\n",(0,a.jsxs)(n.p,{children:["When a function is defined for all possible input values, it is called a ",(0,a.jsx)(n.em,{children:"total function"})," in functional programming."]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"error-model",children:"Error Model"}),"\n",(0,a.jsxs)(n.p,{children:["The error model based on the ",(0,a.jsx)(n.code,{children:"try"}),"/",(0,a.jsx)(n.code,{children:"catch"}),"/",(0,a.jsx)(n.code,{children:"finally"})," statement is lossy and broken. Because if we have the combinations of these statements we can throw many exceptions, and then we are only able to catch one of them. All the other ones are lost. They are swallowed into a black hole, and also the one that we catch is the wrong one. It is not the primary cause of the failure."]}),"\n",(0,a.jsxs)(n.p,{children:["To be more specific, if the ",(0,a.jsx)(n.code,{children:"try"})," block throws an exception, and the ",(0,a.jsx)(n.code,{children:"finally"})," block throws an exception as well, then, if these are caught at a higher level, only the finalizer's exception will be caught normally, not the exception from the try block."]}),"\n",(0,a.jsx)(n.p,{children:"In the following example, we are going to show this behavior:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:' try {\n    try throw new Error("e1")\n    finally throw new Error("e2")\n } catch {\n   case e: Error => println(e)\n }\n\n// Output:\n// e2\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The above program just prints the ",(0,a.jsx)(n.code,{children:"e2"})," while it is not the primary cause of failure. That is why we say the ",(0,a.jsx)(n.code,{children:"try"}),"/",(0,a.jsx)(n.code,{children:"catch"})," model is lossy."]}),"\n",(0,a.jsx)(n.p,{children:"In ZIO, all the errors will still be reported. So even though we are only able to catch one error, the other ones will be reported which we have full control over them. They don't get lost."}),"\n",(0,a.jsx)(n.p,{children:"Let's write a ZIO version:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'ZIO.fail("e1")\n  .ensuring(ZIO.succeed(throw new Exception("e2")))\n  .catchAll {\n    case "e1" => Console.printLine("e1")\n    case "e2" => Console.printLine("e2")\n  }\n\n// Output:\n// e1\n'})}),"\n",(0,a.jsxs)(n.p,{children:["ZIO guarantees that no errors are lost. It has a ",(0,a.jsx)(n.em,{children:"lossless error model"}),". This guarantee is provided via a hierarchy of supervisors and information made available via data types such as ",(0,a.jsx)(n.code,{children:"Exit"})," and ",(0,a.jsx)(n.code,{children:"Cause"}),". All errors will be reported. If there's a bug in the code, ZIO enables us to find out about it."]})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}}}]);