"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[55858],{28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>r});var s=t(96540);const a={},c=s.createContext(a);function i(e){const n=s.useContext(c);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(c.Provider,{value:n},e.children)}},91458:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"zio-metrics-connectors/metrics/metric-reference","title":"ZIO Metric Reference","description":"All ZIO metrics are defined in the form of aspects that can be applied to effects without changing","source":"@site/docs/zio-metrics-connectors/metrics/metric-reference.md","sourceDirName":"zio-metrics-connectors/metrics","slug":"/zio-metrics-connectors/metrics/metric-reference","permalink":"/zio-metrics-connectors/metrics/metric-reference","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-metrics-connectors/metrics/metric-reference.md","tags":[],"version":"current","frontMatter":{"id":"metric-reference","title":"ZIO Metric Reference"},"sidebar":"ecosystem-sidebar","previous":{"title":"Metrics","permalink":"/zio-metrics-connectors/metrics/"},"next":{"title":"StatsD Client","permalink":"/zio-metrics-connectors/metrics/statsd-client"}}');var a=t(74848),c=t(28453);const i={id:"metric-reference",title:"ZIO Metric Reference"},r=void 0,o={},l=[{value:"Counter",id:"counter",level:2},{value:"API",id:"api",level:3},{value:"Examples",id:"examples",level:3},{value:"Gauges",id:"gauges",level:2},{value:"API",id:"api-1",level:3},{value:"Examples",id:"examples-1",level:3},{value:"Histograms",id:"histograms",level:2},{value:"API",id:"api-2",level:3},{value:"Examples",id:"examples-2",level:3},{value:"Summaries",id:"summaries",level:2},{value:"API",id:"api-3",level:3},{value:"Examples",id:"examples-3",level:3},{value:"Frequencies",id:"frequencies",level:2},{value:"API",id:"api-4",level:3},{value:"Examples",id:"examples-4",level:3}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,c.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"All ZIO metrics are defined in the form of aspects that can be applied to effects without changing\nthe signature of the effect it is applied to."}),"\n",(0,a.jsxs)(n.p,{children:["Also, every ",(0,a.jsx)(n.code,{children:"Metric"}),"s implementation are further qualified by a type parameter ",(0,a.jsx)(n.code,{children:"In"})," that must be compatible with\nthe output type of the effect. Practically this means that, for example, a ",(0,a.jsx)(n.code,{children:"Metric.Counter[Any]"})," can be applied\nto any effect while a ",(0,a.jsx)(n.code,{children:"Metric.Counter[Double]"})," can only be applied to effects producing a ",(0,a.jsx)(n.code,{children:"Double"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Finally, each metric understands a certain data type it can observe to manipulate its state.\nCounters, Gauges, Histograms and Summaries all understand ",(0,a.jsx)(n.code,{children:"Double"})," values while a Frequency understands\n",(0,a.jsx)(n.code,{children:"String"})," values."]}),"\n",(0,a.jsxs)(n.p,{children:["In cases where the output type of effect is not compatible with the type required to manipulate the\nmetric, the API defines a ",(0,a.jsx)(n.code,{children:"contramap"})," method to construct a ",(0,a.jsx)(n.code,{children:"Metric[_, In2, _]"})," with a mapper function\nfrom ",(0,a.jsx)(n.code,{children:"In"})," to the type required by the metric."]}),"\n",(0,a.jsxs)(n.p,{children:["There is also an ability to set up additional conditions for metric value capture.\nSuch methods like ",(0,a.jsx)(n.code,{children:"trackAll"}),", ",(0,a.jsx)(n.code,{children:"trackDefectWith"}),", ",(0,a.jsx)(n.code,{children:"trackDurationWith"}),", ",(0,a.jsx)(n.code,{children:"trackErrorWith"})," and ",(0,a.jsx)(n.code,{children:"trackSuccessWith"})," allow for\ncustomized tracking based on specific criteria. This flexibility enables us to define our own tracking logic and metrics\nbased on the requirements of our application. For example, we can track defects only when certain conditions are met or\ntrack the duration of specific ZIO effects.\nThe ZIO Metric methods like ",(0,a.jsx)(n.code,{children:"trackErrorWith"})," allow capturing and tracking\nerrors in ZIO effects.\nEach of this help methods returns new ",(0,a.jsx)(n.code,{children:"ZIOAspect"}),", for example:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'val countAllErrors: ZIOAspect[Nothing, Any, Nothing, Any, Nothing, Any] = Metric.counter("countAllErrors").contramap[Any](_ => 1L).trackError\n'})}),"\n",(0,a.jsxs)(n.p,{children:["It is possible to add some custom tag to Metric via ",(0,a.jsx)(n.code,{children:"tagged()"})," methods."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'val countRequests = Metric.counter("countRequests")\n\nval countRequestsByPath = for {\n  _ <- requestLogic @@ countRequests.tagged("path", path)\n} yield ()\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The API functions in this document are implemented in the ",(0,a.jsx)(n.code,{children:"Metric"})," object. An aspect can be applied to\nan effect with the ",(0,a.jsx)(n.code,{children:"@@"})," operator."]}),"\n",(0,a.jsxs)(n.p,{children:["Once an application is instrumented with Metric aspects, it can be configured with a client implementation\nthat is responsible for providing the captured metrics to an appropriate backend. Currently, ZIO Metrics supports\nclients for ",(0,a.jsx)(n.a,{href:"/zio-metrics-connectors/metrics/statsd-client",children:"StatsD"})," and ",(0,a.jsx)(n.a,{href:"/zio-metrics-connectors/metrics/prometheus-client",children:"Prometheus"})," out of the box."]}),"\n",(0,a.jsx)(n.h2,{id:"counter",children:"Counter"}),"\n",(0,a.jsx)(n.p,{children:"A counter is simply a named variable that increases over time."}),"\n",(0,a.jsx)(n.h3,{id:"api",children:"API"}),"\n",(0,a.jsx)(n.p,{children:"Create a counter which is incremented by value produced by effect every time it is executed successfully. This can be\napplied to any effect."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"def counter(name: String): Metric.Counter[Long]\n\ndef counterDouble(name: String): Metric.Counter[Double]\n\ndef counterInt(name: String): Metric.Counter[Int]\n"})}),"\n",(0,a.jsx)(n.h3,{id:"examples",children:"Examples"}),"\n",(0,a.jsxs)(n.p,{children:["Create a counter named ",(0,a.jsx)(n.code,{children:"countAll"})," which is incremented by ",(0,a.jsx)(n.code,{children:"1"})," every time it is invoked."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'val aspCountAll = Metric.counter("countAll").contramap[Any](_ => 1L)\n'})}),"\n",(0,a.jsx)(n.p,{children:"After contramap to Any, the counter can be applied to any effect. Note, that the same aspect can be applied\nto more than one effect. In the example we would count the sum of executions of both effects\nin the for comprehension."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"val countAll = for {\n  _ <- ZIO.unit @@ aspCountAll\n  _ <- ZIO.unit @@ aspCountAll\n} yield ()\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Create a counter named ",(0,a.jsx)(n.code,{children:"countBytes"})," that can be applied to effects having the output type ",(0,a.jsx)(n.code,{children:"Double"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'val aspCountBytes = Metric.counterDouble("countBytes")\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Now we can apply it to effects producing ",(0,a.jsx)(n.code,{children:"Double"})," (in a real application the value might be\nthe number of bytes read from a stream or something similar):"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"val countBytes = nextDoubleBetween(0.0d, 100.0d) @@ aspCountBytes\n"})}),"\n",(0,a.jsx)(n.h2,{id:"gauges",children:"Gauges"}),"\n",(0,a.jsxs)(n.p,{children:["A gauge is a named variable of type ",(0,a.jsx)(n.code,{children:"Double"})," that can change over time. It can either be set\nto an absolute value or relative to the current value."]}),"\n",(0,a.jsx)(n.h3,{id:"api-1",children:"API"}),"\n",(0,a.jsx)(n.p,{children:"Create a gauge that can be set to absolute values. It can be applied to effects yielding a Double"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"def gauge(name: String): Metric.Gauge[Double]\n"})}),"\n",(0,a.jsx)(n.h3,{id:"examples-1",children:"Examples"}),"\n",(0,a.jsx)(n.p,{children:"Create a gauge that can be set to absolute values, it can be applied to effects yielding a Double"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'val aspGauge = Metric.gauge("setGauge")\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Now we can apply these aspects to effects having an output type ",(0,a.jsx)(n.code,{children:"Double"}),". Note that we can instrument\nan effect with any number of aspects if the type constraints are satisfied."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"val gaugeSomething = for {\n  _ <- nextDoubleBetween(0.0d, 100.0d) @@ aspGauge @@ aspCountAll\n} yield ()\n"})}),"\n",(0,a.jsx)(n.h2,{id:"histograms",children:"Histograms"}),"\n",(0,a.jsxs)(n.p,{children:["A histogram observes ",(0,a.jsx)(n.code,{children:"Double"})," values and counts the observed values in buckets. Each bucket is defined\nby an upper boundary and the count for a bucket with the upper boundary ",(0,a.jsx)(n.code,{children:"b"})," increases by ",(0,a.jsx)(n.code,{children:"1"})," if an observed\nvalue ",(0,a.jsx)(n.code,{children:"v"})," is less or equal to ",(0,a.jsx)(n.code,{children:"b"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["As a consequence, all buckets that have a boundary ",(0,a.jsx)(n.code,{children:"b1"})," with ",(0,a.jsx)(n.code,{children:"b1 > b"})," will increase by ",(0,a.jsx)(n.code,{children:"1"})," after observing ",(0,a.jsx)(n.code,{children:"v"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"A histogram also keeps track of the overall count of observed values and the sum of all observed values."}),"\n",(0,a.jsxs)(n.p,{children:["By definition, the last bucket is always defined as ",(0,a.jsx)(n.code,{children:"Double.MaxValue"}),", so that the count of observed values in\nthe last bucket is always equal to the overall count of observed values within the histogram."]}),"\n",(0,a.jsx)(n.p,{children:"To define a histogram aspect, the API requires that the boundaries for the histogram are specified when creating\nthe aspect."}),"\n",(0,a.jsxs)(n.p,{children:["The mental model for a histogram is inspired\nfrom ",(0,a.jsx)(n.a,{href:"https://prometheus.io/docs/concepts/metric_types/#histogram",children:"Prometheus"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"api-2",children:"API"}),"\n",(0,a.jsxs)(n.p,{children:["Create a histogram that can be applied to effects producing ",(0,a.jsx)(n.code,{children:"Double"})," values. The values will be counted as outlined\nabove."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"def histogram(name: String, boundaries: Histogram.Boundaries): Metric.Histogram[Double]\n"})}),"\n",(0,a.jsx)(n.h3,{id:"examples-2",children:"Examples"}),"\n",(0,a.jsxs)(n.p,{children:["Create a histogram with 12 buckets: ",(0,a.jsx)(n.code,{children:"0..100"})," in steps of ",(0,a.jsx)(n.code,{children:"10"})," and ",(0,a.jsx)(n.code,{children:"Double.MaxValue"}),". It can be applied to effects\nyielding a ",(0,a.jsx)(n.code,{children:"Double"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'val aspHistogram =\n  Metric.histogram("myHistogram", Histogram.Boundaries.linear(0.0d, 10.0d, 11))\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Now we can apply the histogram to effects producing ",(0,a.jsx)(n.code,{children:"Double"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"val histogram = nextDoubleBetween(0.0d, 120.0d) @@ aspHistogram \n"})}),"\n",(0,a.jsx)(n.h2,{id:"summaries",children:"Summaries"}),"\n",(0,a.jsxs)(n.p,{children:["Similar to a histogram a summary also observes ",(0,a.jsx)(n.code,{children:"Double"})," values. While a histogram directly modifies the bucket counters\nand does not keep the individual samples, the summary keeps the observed samples in its internal state. To avoid the set\nof samples grow uncontrolled, the summary need to be configured with a maximum age ",(0,a.jsx)(n.code,{children:"t"})," and a maximum size ",(0,a.jsx)(n.code,{children:"n"}),". To\ncalculate the statistics, maximal ",(0,a.jsx)(n.code,{children:"n"})," samples will be used, all of which are not older than ",(0,a.jsx)(n.code,{children:"t"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"Essentially the set of samples is a sliding window over the last observed samples matching the conditions above."}),"\n",(0,a.jsxs)(n.p,{children:["A summary is used to calculate a set of quantiles over the current set of samples. A quantile is defined by a ",(0,a.jsx)(n.code,{children:"Double"}),"\nvalue ",(0,a.jsx)(n.code,{children:"q"}),"\nwith ",(0,a.jsx)(n.code,{children:"0 <= q <= 1"})," and resolves to a ",(0,a.jsx)(n.code,{children:"Double"})," as well."]}),"\n",(0,a.jsxs)(n.p,{children:["The value of a given quantile ",(0,a.jsx)(n.code,{children:"q"})," is the maximum value ",(0,a.jsx)(n.code,{children:"v"})," out of the current sample buffer with size ",(0,a.jsx)(n.code,{children:"n"})," where at\nmost ",(0,a.jsx)(n.code,{children:"q * n"}),"\nvalues out of the sample buffer are less or equal to ",(0,a.jsx)(n.code,{children:"v"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Typical quantiles for observation are ",(0,a.jsx)(n.code,{children:"0.5"})," (the median) and the ",(0,a.jsx)(n.code,{children:"0.95"}),". Quantiles are very good for monitoring Service\nLevel Agreements."]}),"\n",(0,a.jsxs)(n.p,{children:["The ZIO Metrics API also allows summaries to be configured with an error margin ",(0,a.jsx)(n.code,{children:"e"}),". The error margin is applied to the count of\nvalues, so that a\nquantile ",(0,a.jsx)(n.code,{children:"q"})," for a set of size ",(0,a.jsx)(n.code,{children:"s"})," resolves to value ",(0,a.jsx)(n.code,{children:"v"})," if the number ",(0,a.jsx)(n.code,{children:"n"})," of values less or equal to ",(0,a.jsx)(n.code,{children:"v"}),"\nis ",(0,a.jsx)(n.code,{children:"(1 -e)q * s <= n <= (1+e)q"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"api-3",children:"API"}),"\n",(0,a.jsxs)(n.p,{children:["A metric aspect that adds a value to a summary each time the effect it is applied to succeeds. This aspect can be\napplied to effects producing a ",(0,a.jsx)(n.code,{children:"Double"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"def summary(\n  name: String,\n  maxAge: Duration,\n  maxSize: Int,\n  error: Double,\n  quantiles: Chunk[Double]\n): Metric.Summary[Double]\n"})}),"\n",(0,a.jsx)(n.h3,{id:"examples-3",children:"Examples"}),"\n",(0,a.jsxs)(n.p,{children:["Create a summary that can hold 100 samples, the max age of the samples is ",(0,a.jsx)(n.code,{children:"1 day"})," and the\nerror margin is ",(0,a.jsx)(n.code,{children:"3%"}),". The summary should report the ",(0,a.jsx)(n.code,{children:"10%"}),", ",(0,a.jsx)(n.code,{children:"50%"})," and ",(0,a.jsx)(n.code,{children:"90%"})," Quantile.\nIt can be applied to effects yielding an ",(0,a.jsx)(n.code,{children:"Int"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'val aspSummary =\n  Metric.summary("mySummary", 1.day, 100, 0.03d, Chunk(0.1, 0.5, 0.9)).contramap[Int](_.toDouble)\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Now we can apply this aspect to an effect producing an ",(0,a.jsx)(n.code,{children:"Int"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"val summary = nextIntBetween(100, 500) @@ aspSummary\n"})}),"\n",(0,a.jsx)(n.h2,{id:"frequencies",children:"Frequencies"}),"\n",(0,a.jsx)(n.p,{children:"Frequencies are used to count the occurrences of distinct string values. For example an application that uses logical\nnames for its services, the number of invocations for each service can be tracked."}),"\n",(0,a.jsx)(n.p,{children:"Essentially, a Frequency is a set of related counters sharing the same name and tags. The counters are set\napart from each other by an additional configurable tag. The values of the tag represent the observed\ndistinct values."}),"\n",(0,a.jsx)(n.p,{children:"To configure a frequency aspect, the name of the tag holding the distinct values must be configured."}),"\n",(0,a.jsx)(n.h3,{id:"api-4",children:"API"}),"\n",(0,a.jsx)(n.p,{children:"A metric aspect that counts the number of occurrences of each distinct\nvalue returned by the effect it is applied to."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"def frequency(name: String): Metric.Frequency[String]\n"})}),"\n",(0,a.jsx)(n.h3,{id:"examples-4",children:"Examples"}),"\n",(0,a.jsx)(n.p,{children:"Create a Frequency to observe the occurrences of unique Strings.\nIt can be applied to effects yielding a String."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'val aspSet = Metric.frequency("mySet")\n'})}),"\n",(0,a.jsx)(n.p,{children:"Now we can generate some keys within an effect and start counting the occurrences\nfor each value."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'val set = nextIntBetween(10, 20).map(v => s"myKey-$v") @@ aspSet\n'})})]})}function h(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);