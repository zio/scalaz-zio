"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[43786],{28453:(e,r,n)=>{n.d(r,{R:()=>t,x:()=>o});var a=n(96540);const s={},l=a.createContext(s);function t(e){const r=a.useContext(l);return a.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),a.createElement(l.Provider,{value:r},e.children)}},36776:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>i,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"overview/overview_handling_errors","title":"Handling Errors","description":"This section looks at some of the common ways to detect and respond to failure.","source":"@site/versioned_docs/version-1.0.18/overview/handling_errors.md","sourceDirName":"overview","slug":"/overview/overview_handling_errors","permalink":"/1.0.18/overview/overview_handling_errors","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/versioned_docs/version-1.0.18/overview/handling_errors.md","tags":[],"version":"1.0.18","frontMatter":{"id":"overview_handling_errors","title":"Handling Errors"},"sidebar":"overview_sidebar","previous":{"title":"Basic Operations","permalink":"/1.0.18/overview/overview_basic_operations"},"next":{"title":"Handling Resources","permalink":"/1.0.18/overview/overview_handling_resources"}}');var s=n(74848),l=n(28453);const t={id:"overview_handling_errors",title:"Handling Errors"},o=void 0,i={},c=[{value:"Either",id:"either",level:2},{value:"Catching All Errors",id:"catching-all-errors",level:2},{value:"Catching Some Errors",id:"catching-some-errors",level:2},{value:"Fallback",id:"fallback",level:2},{value:"Folding",id:"folding",level:2},{value:"Retrying",id:"retrying",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const r={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.p,{children:"This section looks at some of the common ways to detect and respond to failure."}),"\n",(0,s.jsx)(r.h2,{id:"either",children:"Either"}),"\n",(0,s.jsxs)(r.p,{children:["You can surface failures with ",(0,s.jsx)(r.code,{children:"ZIO#either"}),", which takes an ",(0,s.jsx)(r.code,{children:"ZIO[R, E, A]"})," and produces an ",(0,s.jsx)(r.code,{children:"ZIO[R, Nothing, Either[E, A]]"}),"."]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-scala",children:'val zeither: UIO[Either[String, Int]] = \n  IO.fail("Uh oh!").either\n'})}),"\n",(0,s.jsxs)(r.p,{children:["You can submerge failures with ",(0,s.jsx)(r.code,{children:"ZIO.absolve"}),", which is the opposite of ",(0,s.jsx)(r.code,{children:"either"})," and turns an ",(0,s.jsx)(r.code,{children:"ZIO[R, Nothing, Either[E, A]]"})," into a ",(0,s.jsx)(r.code,{children:"ZIO[R, E, A]"}),":"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-scala",children:'def sqrt(io: UIO[Double]): IO[String, Double] =\n  ZIO.absolve(\n    io.map(value =>\n      if (value < 0.0) Left("Value must be >= 0.0")\n      else Right(Math.sqrt(value))\n    )\n  )\n'})}),"\n",(0,s.jsx)(r.h2,{id:"catching-all-errors",children:"Catching All Errors"}),"\n",(0,s.jsxs)(r.p,{children:["If you want to catch and recover from all types of errors and effectfully attempt recovery, you can use the ",(0,s.jsx)(r.code,{children:"catchAll"})," method:"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-scala",children:'val z: IO[IOException, Array[Byte]] = \n  openFile("primary.json").catchAll(_ => \n    openFile("backup.json"))\n'})}),"\n",(0,s.jsxs)(r.p,{children:["In the callback passed to ",(0,s.jsx)(r.code,{children:"catchAll"}),", you may return an effect with a different error type (or perhaps ",(0,s.jsx)(r.code,{children:"Nothing"}),"), which will be reflected in the type of effect returned by ",(0,s.jsx)(r.code,{children:"catchAll"}),"."]}),"\n",(0,s.jsx)(r.h2,{id:"catching-some-errors",children:"Catching Some Errors"}),"\n",(0,s.jsxs)(r.p,{children:["If you want to catch and recover from only some types of exceptions and effectfully attempt recovery, you can use the ",(0,s.jsx)(r.code,{children:"catchSome"})," method:"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-scala",children:'val data: IO[IOException, Array[Byte]] = \n  openFile("primary.data").catchSome {\n    case _ : FileNotFoundException => \n      openFile("backup.data")\n  }\n'})}),"\n",(0,s.jsxs)(r.p,{children:["Unlike ",(0,s.jsx)(r.code,{children:"catchAll"}),", ",(0,s.jsx)(r.code,{children:"catchSome"})," cannot reduce or eliminate the error type, although it can widen the error type to a broader class of errors."]}),"\n",(0,s.jsx)(r.h2,{id:"fallback",children:"Fallback"}),"\n",(0,s.jsxs)(r.p,{children:["You can try one effect, or, if it fails, try another effect, with the ",(0,s.jsx)(r.code,{children:"orElse"})," combinator:"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-scala",children:'val primaryOrBackupData: IO[IOException, Array[Byte]] = \n  openFile("primary.data").orElse(openFile("backup.data"))\n'})}),"\n",(0,s.jsx)(r.h2,{id:"folding",children:"Folding"}),"\n",(0,s.jsxs)(r.p,{children:["Scala's ",(0,s.jsx)(r.code,{children:"Option"})," and ",(0,s.jsx)(r.code,{children:"Either"})," data types have ",(0,s.jsx)(r.code,{children:"fold"}),", which let you handle both failure and success at the same time. In a similar fashion, ",(0,s.jsx)(r.code,{children:"ZIO"})," effects also have several methods that allow you to handle both failure and success."]}),"\n",(0,s.jsxs)(r.p,{children:["The first fold method, ",(0,s.jsx)(r.code,{children:"fold"}),", lets you non-effectfully handle both failure and success, by supplying a non-effectful handler for each case:"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-scala",children:'lazy val DefaultData: Array[Byte] = Array(0, 0)\n\nval primaryOrDefaultData: UIO[Array[Byte]] = \n  openFile("primary.data").fold(\n    _    => DefaultData,\n    data => data)\n'})}),"\n",(0,s.jsxs)(r.p,{children:["The second fold method, ",(0,s.jsx)(r.code,{children:"foldM"}),", lets you effectfully handle both failure and success, by supplying an effectful (but still pure) handler for each case:"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-scala",children:'val primaryOrSecondaryData: IO[IOException, Array[Byte]] = \n  openFile("primary.data").foldM(\n    _    => openFile("secondary.data"),\n    data => ZIO.succeed(data))\n'})}),"\n",(0,s.jsxs)(r.p,{children:["Nearly all error handling methods are defined in terms of ",(0,s.jsx)(r.code,{children:"foldM"}),", because it is both powerful and fast."]}),"\n",(0,s.jsxs)(r.p,{children:["In the following example, ",(0,s.jsx)(r.code,{children:"foldM"})," is used to handle both failure and success of the ",(0,s.jsx)(r.code,{children:"readUrls"})," method:"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-scala",children:'val urls: UIO[Content] =\n  readUrls("urls.json").foldM(\n    error   => IO.succeed(NoContent(error)), \n    success => fetchContent(success)\n  )\n'})}),"\n",(0,s.jsx)(r.h2,{id:"retrying",children:"Retrying"}),"\n",(0,s.jsx)(r.p,{children:"There are a number of useful methods on the ZIO data type for retrying failed effects."}),"\n",(0,s.jsxs)(r.p,{children:["The most basic of these is ",(0,s.jsx)(r.code,{children:"ZIO#retry"}),", which takes a ",(0,s.jsx)(r.code,{children:"Schedule"})," and returns a new effect that will retry the first effect if it fails, according to the specified policy:"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-scala",children:'import zio.clock._\n\nval retriedOpenFile: ZIO[Clock, IOException, Array[Byte]] = \n  openFile("primary.data").retry(Schedule.recurs(5))\n'})}),"\n",(0,s.jsxs)(r.p,{children:["The next most powerful function is ",(0,s.jsx)(r.code,{children:"ZIO#retryOrElse"}),", which allows specification of a fallback to use, if the effect does not succeed with the specified policy:"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-scala",children:'  openFile("primary.data").retryOrElse(\n    Schedule.recurs(5), \n    (_, _) => ZIO.succeed(DefaultData))\n'})}),"\n",(0,s.jsxs)(r.p,{children:["The final method, ",(0,s.jsx)(r.code,{children:"ZIO#retryOrElseEither"}),", allows returning a different type for the fallback."]}),"\n",(0,s.jsxs)(r.p,{children:["For more information on how to build schedules, see the documentation on ",(0,s.jsx)(r.a,{href:"/1.0.18/reference/misc/schedule",children:"Schedule"}),"."]}),"\n",(0,s.jsx)(r.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsxs)(r.p,{children:["If you are comfortable with basic error handling, then the next step is to learn about safe ",(0,s.jsx)(r.a,{href:"/1.0.18/overview/overview_handling_resources",children:"resource handling"}),"."]})]})}function h(e={}){const{wrapper:r}={...(0,l.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);