"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[13069],{32888:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"zio-process/basics","title":"Basics","description":"To build a description of a command:","source":"@site/docs/zio-process/basics.md","sourceDirName":"zio-process","slug":"/zio-process/basics","permalink":"/zio-process/basics","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-process/basics.md","tags":[],"version":"current","frontMatter":{"id":"basics","title":"Basics"},"sidebar":"ecosystem-sidebar","previous":{"title":"Getting Started","permalink":"/zio-process/getting-started"},"next":{"title":"Piping","permalink":"/zio-process/piping"}}');var o=s(74848),i=s(28453);const t={id:"basics",title:"Basics"},a=void 0,c={},d=[{value:"Transforming output",id:"transforming-output",level:2},{value:"List of lines",id:"list-of-lines",level:3},{value:"Stream of lines",id:"stream-of-lines",level:3},{value:"String",id:"string",level:3},{value:"Exit code",id:"exit-code",level:3},{value:"Kill a process",id:"kill-a-process",level:3},{value:"Stream of bytes",id:"stream-of-bytes",level:3},{value:"Access stdout and stderr separately",id:"access-stdout-and-stderr-separately",level:3},{value:"Error handling",id:"error-handling",level:2}];function l(e){const n={code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"To build a description of a command:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'val command = Command("cat", "file.txt")\n'})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"command.run"})," will return a handle to the process as ",(0,o.jsx)(n.code,{children:"ZIO[Blocking, CommandError, Process]"}),". Alternatively, instead of\nflat-mapping and calling methods on ",(0,o.jsx)(n.code,{children:"Process"}),", there are convenience methods on ",(0,o.jsx)(n.code,{children:"Command"})," itself for some common operations:"]}),"\n",(0,o.jsx)(n.h2,{id:"transforming-output",children:"Transforming output"}),"\n",(0,o.jsx)(n.h3,{id:"list-of-lines",children:"List of lines"}),"\n",(0,o.jsxs)(n.p,{children:["To obtain the output as a list of lines with the type ",(0,o.jsx)(n.code,{children:"ZIO[Blocking, CommandError, Chunk[String]]"})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"command.lines\n"})}),"\n",(0,o.jsx)(n.h3,{id:"stream-of-lines",children:"Stream of lines"}),"\n",(0,o.jsxs)(n.p,{children:["To obtain the output as a stream of lines with the type ",(0,o.jsx)(n.code,{children:"ZStream[Blocking, CommandError, String]"})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"command.linesStream\n"})}),"\n",(0,o.jsx)(n.p,{children:"This is particularly useful when dealing with large files and so on as to not use an unbounded amount of memory."}),"\n",(0,o.jsx)(n.h3,{id:"string",children:"String"}),"\n",(0,o.jsx)(n.p,{children:"If you don't need a structured type, you can return the entire output as a plain string:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"command.string\n"})}),"\n",(0,o.jsx)(n.p,{children:"This defaults to UTF-8. To use a different encoding, specify the charset:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"command.string(StandardCharsets.UTF_16)\n"})}),"\n",(0,o.jsx)(n.h3,{id:"exit-code",children:"Exit code"}),"\n",(0,o.jsx)(n.p,{children:"When you don't care about the output (or there is no output), you can return just the exit code."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"command.exitCode\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Note that ",(0,o.jsx)(n.code,{children:"Command#exitCode"})," will return the exit code in the ZIO's success channel whether it's 0 or not.\nIf you want non-zero exit codes to be considered an error, use ",(0,o.jsx)(n.code,{children:"Command#successfulExitCode"})," instead. This will\nreturn a ",(0,o.jsx)(n.code,{children:"CommandError.NonZeroErrorCode"})," in ZIO's error channel when the exit code is not 0:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'for {\n  exitCode  <- Command("java", "--non-existent-flag").successfulExitCode\n  // Won\'t reach this 2nd command since the previous command failed with `CommandError.NonZeroErrorCode`:\n  exitCode2 <- Command("java", "--non-existent-flag").successfulExitCode\n} yield ()\n'})}),"\n",(0,o.jsx)(n.h3,{id:"kill-a-process",children:"Kill a process"}),"\n",(0,o.jsxs)(n.p,{children:["You can kill a process by calling ",(0,o.jsx)(n.code,{children:"interrupt"})," on the running ",(0,o.jsx)(n.code,{children:"Fiber"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'for {\n  fiber <- Command("long-running-process").exitCode.forkDaemon\n  _     <- ZIO.sleep(5.seconds)\n  _     <- fiber.interrupt\n  _     <- fiber.join\n} yield ()\n'})}),"\n",(0,o.jsxs)(n.p,{children:["If you use ",(0,o.jsx)(n.code,{children:"Command#run"})," then you receive a handle to underlying ",(0,o.jsx)(n.code,{children:"Process"})," immediately, which means ZIO's built-in\ninterruption model no longer applies. In this case, if you want to kill a process before it's done terminating,\nyou can use ",(0,o.jsx)(n.code,{children:"kill"})," (the Unix SIGTERM equivalent) or ",(0,o.jsx)(n.code,{children:"killForcibly"})," (the Unix SIGKILL equivalent):"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'for {\n  process <- Command("long-running-process").run\n  _       <- ZIO.sleep(5.seconds)\n  _       <- process.kill\n} yield ()\n'})}),"\n",(0,o.jsx)(n.h3,{id:"stream-of-bytes",children:"Stream of bytes"}),"\n",(0,o.jsx)(n.p,{children:"If you need lower-level access to the output's stream of bytes, you can access them directly like so:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:"command.stream\n"})}),"\n",(0,o.jsx)(n.h3,{id:"access-stdout-and-stderr-separately",children:"Access stdout and stderr separately"}),"\n",(0,o.jsx)(n.p,{children:"There are times when you need to process the output of stderr as well."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'for {\n  process <- Command("./some-process").run\n  stdout  <- process.stdout.string\n  stderr  <- process.stderr.string\n  // ...\n} yield ()\n'})}),"\n",(0,o.jsx)(n.h2,{id:"error-handling",children:"Error handling"}),"\n",(0,o.jsxs)(n.p,{children:["Errors are represented as ",(0,o.jsx)(n.code,{children:"CommandError"})," in the error channel instead of ",(0,o.jsx)(n.code,{children:"IOException"}),". Since ",(0,o.jsx)(n.code,{children:"CommandError"})," is an ADT,\nyou can pattern match on it and handle specific cases rather than trying to parse the guts of ",(0,o.jsx)(n.code,{children:"IOException.getMessage"}),"\nyourself."]}),"\n",(0,o.jsxs)(n.p,{children:["For example, if you want to fallback to running a different program if it doesn't exist on the host machine, you can\nmatch on ",(0,o.jsx)(n.code,{children:"CommandError.ProgramNotFound"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'Command("some-program-that-may-not-exit").string.catchSome {\n  case CommandError.ProgramNotFound(_) => Command("fallback-program").string\n}\n'})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>a});var r=s(96540);const o={},i=r.createContext(o);function t(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:t(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);