"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[60969],{1124:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"reference/interruption/index","title":"Introduction to ZIO\'s Interruption Model","description":"While developing concurrent applications, there are several cases that we need to interrupt the execution of other fibers, for example:","source":"@site/docs/reference/interruption/index.md","sourceDirName":"reference/interruption","slug":"/reference/interruption/","permalink":"/reference/interruption/","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/interruption/index.md","tags":[],"version":"current","frontMatter":{"id":"index","title":"Introduction to ZIO\'s Interruption Model","sidebar_label":"Interruption Model"},"sidebar":"reference-sidebar","previous":{"title":"Examples","permalink":"/reference/error-management/examples"},"next":{"title":"Introduction to ZIO\'s Built-in Services","permalink":"/reference/services/"}}');var r=t(74848),o=t(28453);const s={id:"index",title:"Introduction to ZIO's Interruption Model",sidebar_label:"Interruption Model"},a=void 0,l={},c=[{value:"Polling vs. Asynchronous Interruption",id:"polling-vs-asynchronous-interruption",level:2},{value:"When Does a Fiber Get Interrupted?",id:"when-does-a-fiber-get-interrupted",level:2},{value:"Calling <code>Fiber#interrupt</code> Operator",id:"calling-fiberinterrupt-operator",level:3},{value:"Interruption of Parallel Effects",id:"interruption-of-parallel-effects",level:3},{value:"Child Fibers Are Scoped to Their Parents",id:"child-fibers-are-scoped-to-their-parents",level:3},{value:"Blocking Operations",id:"blocking-operations",level:2},{value:"Interruption of Blocking Operations",id:"interruption-of-blocking-operations",level:3},{value:"Cancellation of Blocking Operation",id:"cancellation-of-blocking-operation",level:3},{value:"Disabling Interruption of Fibers",id:"disabling-interruption-of-fibers",level:2}];function d(e){const n={code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["While developing concurrent applications, there are several cases that we need to ",(0,r.jsx)(n.em,{children:"interrupt"})," the execution of other fibers, for example:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"A parent fiber might start some child fibers to perform a task, and later the parent might decide that it doesn't need the result of some or all of the child fibers."}),"\n",(0,r.jsx)(n.li,{children:"Two or more fibers start a race with each other. The fiber whose result is computed first wins and all other fibers are no longer needed so they should be interrupted."}),"\n",(0,r.jsx)(n.li,{children:'In interactive applications, a user may want to stop some already running tasks, such as clicking on the "stop" button to prevent downloading more files.'}),"\n",(0,r.jsx)(n.li,{children:"Computations that run longer than expected should be aborted by using timeout operations."}),"\n",(0,r.jsx)(n.li,{children:"When we have an application that perform compute-intensive tasks based on the user inputs, if the user changes the input we should cancel the current task and perform another one."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"polling-vs-asynchronous-interruption",children:"Polling vs. Asynchronous Interruption"}),"\n",(0,r.jsxs)(n.p,{children:["A simple and naive way to implement fiber interruption is to provide a mechanism for one fiber to ",(0,r.jsx)(n.em,{children:"kill/terminate"})," another fiber. This is not a correct solution because if the target fiber is in the middle of changing a shared state it leads to an inconsistent state. So this solution doesn't guarantee to leave the shared mutable state internally consistent."]}),"\n",(0,r.jsx)(n.p,{children:"Other than the very simple kill solution, there are two popular valid solutions to this problem:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Semi-asynchronous Interruption (Polling for Interruption)"}),"\u2014 Imperative languages such as Java often use polling to implement a semi-asynchronous signaling mechanism. In this model, a fiber sends a request for interruption of other fiber. The target fiber keeps polling the interrupt status, and based on the interrupt status will find out that whether there is an interruption request from other fibers. If so, it should terminate itself as soon as possible."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Using this solution, the fiber itself takes care of critical sections. So while a fiber is in the middle of a critical section, if it receives an interruption request it should ignore the interruption and postpone the delivery of interruption during the critical section."}),"\n",(0,r.jsx)(n.p,{children:"The drawback of this solution is that, if the programmer forgets to poll regularly enough, then the target fiber becomes unresponsive and causes deadlocks. Another problem is that polling a global flag is not a functional operation and doesn't fit with ZIO's paradigm."}),"\n",(0,r.jsxs)(n.ol,{start:"2",children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Asynchronous Interruption"}),"\u2014 In asynchronous interruption, a fiber is allowed to terminate another fiber. So the target fiber is not responsible for polling the status, instead in critical sections the target fiber disables the interruptibility of these regions. This is a purely-functional solution and doesn't require polling a global state. ZIO uses this solution for its interruption model. It is a fully asynchronous signalling mechanism."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This mechanism doesn't have the drawback of forgetting to poll regularly and also it's fully compatible with the functional paradigm because in a purely-functional computation, we can abort the computation at any point, except for critical sections."}),"\n",(0,r.jsx)(n.h2,{id:"when-does-a-fiber-get-interrupted",children:"When Does a Fiber Get Interrupted?"}),"\n",(0,r.jsx)(n.p,{children:"There are several ways and situations that fibers can be interrupted. In this section we will introduce each one with an example of how to reproduce these situations:"}),"\n",(0,r.jsxs)(n.h3,{id:"calling-fiberinterrupt-operator",children:["Calling ",(0,r.jsx)(n.code,{children:"Fiber#interrupt"})," Operator"]}),"\n",(0,r.jsxs)(n.p,{children:["A fiber can be interrupted by calling ",(0,r.jsx)(n.code,{children:"Fiber#interrupt"})," on that fiber."]}),"\n",(0,r.jsx)(n.p,{children:"Let's try to make a fiber and then interrupt it:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def task = {\n    for {\n      fn <- ZIO.fiberId.map(_.threadName)\n      _ <- ZIO.debug(s"$fn starts a long running task")\n      _ <- ZIO.sleep(1.minute)\n      _ <- ZIO.debug("done!")\n    } yield ()\n  }\n\n  def run =\n    for {\n      f <-\n        task.onInterrupt(\n          ZIO.debug(s"Task interrupted while running")\n        ).fork\n      _ <- f.interrupt\n    } yield ()\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Here is the output of running this piece of code, which denotes that the task was interrupted:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Task interrupted while running\n"})}),"\n",(0,r.jsx)(n.h3,{id:"interruption-of-parallel-effects",children:"Interruption of Parallel Effects"}),"\n",(0,r.jsx)(n.p,{children:"When composing multiple parallel effects, when one of them is interrupted the other fibers will be interrupted also. So if we have two parallel tasks, if one of them fails or gets interrupted, the other will be interrupted:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  def debugInterruption(taskName: String) = (fibers: Set[FiberId]) =>\n    for {\n      fn <- ZIO.fiberId.map(_.threadName)\n      _ <- ZIO.debug(\n        s"The $fn fiber which is the underlying fiber of the $taskName task " +\n          s"interrupted by ${fibers.map(_.threadName).mkString(", ")}"\n      )\n    } yield ()\n\n  def task[R, E, A](name: String)(zio: ZIO[R, E, A]): ZIO[R, E, A] =\n    zio.onInterrupt(debugInterruption(name))\n\n  def debugMainFiber =\n    for {\n      fn <- ZIO.fiberId.map(_.threadName)\n      _ <- ZIO.debug(s"Main fiber ($fn) starts executing the whole application.")\n    } yield ()\n\n  def run = {\n    // self interrupting fiber \n    val first = task("first")(ZIO.interrupt)\n\n    // never ending fiber\n    val second = task("second")(ZIO.never)\n\n    debugMainFiber *> {\n      // uncomment each line and run the code to see the result\n\n      // first fiber will be interrupted \n      first *> second\n\n      // never ending application\n      // second *> first\n\n      // first fiber will be interrupted\n      // first <*> second\n\n      // never ending application\n      // second <*> first\n\n      // first and second will be interrupted\n      // first <&> second\n\n      // first and second will be interrupted \n      // second <&> first\n    }\n  }\n\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["In the above code the ",(0,r.jsx)(n.code,{children:"first <&> second"})," is a parallel composition of the ",(0,r.jsx)(n.code,{children:"first"})," and ",(0,r.jsx)(n.code,{children:"second"})," tasks. When we run them together, the ",(0,r.jsx)(n.code,{children:"zipWithPar"}),"/",(0,r.jsx)(n.code,{children:"<&>"})," operator will run these two tasks in two parallel fibers. If either side of this operator fails or is interrupted the other side will be interrupted."]}),"\n",(0,r.jsx)(n.h3,{id:"child-fibers-are-scoped-to-their-parents",children:"Child Fibers Are Scoped to Their Parents"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"If a child fiber does not complete its job or does not join its parent before the parent has completed its job, the child fiber will be interrupted:"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def debugInterruption(taskName: String) = (fibers: Set[FiberId]) =>\n    for {\n      fn <- ZIO.fiberId.map(_.threadName)\n      _  <- ZIO.debug(\n              s"the $fn fiber which is the underlying fiber of the $taskName task " +\n              s"interrupted by ${fibers.map(_.threadName).mkString(", ")}"\n            )\n    } yield ()\n\n  def run =\n    for {\n      fn <- ZIO.fiberId.map(_.threadName)\n      _  <- ZIO.debug(s"$fn starts working.")\n      child =\n        for {\n          cfn <- ZIO.fiberId.map(_.threadName)\n          _   <- ZIO.debug(s"$cfn starts working by forking from its parent ($fn)")\n          _   <- ZIO.never\n        } yield ()\n      _  <- child.onInterrupt(debugInterruption("child")).fork\n      _  <- ZIO.sleep(1.second)\n      _  <- ZIO.debug(s"$fn finishes its job and is going go exit.")\n    } yield ()\n    \n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Here is the result of one of the executions of this sample code:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"zio-fiber-2 starts working.\nzio-fiber-7 starts working by forking from its parent (zio-fiber-2)\nzio-fiber-2 finishes its job and is going to exit.\nthe zio-fiber-7 fiber which is the underlying fiber of the child task interrupted by zio-fiber-2\n"})}),"\n",(0,r.jsxs)(n.ol,{start:"2",children:["\n",(0,r.jsx)(n.li,{children:"If a parent fiber is interrupted, all its children will be interrupted:"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  def debugInterruption(taskName: String) = (fibers: Set[FiberId]) =>\n    for {\n      fn <- ZIO.fiberId.map(_.threadName)\n      _ <- ZIO.debug(\n        s"The $fn fiber which is the underlying fiber of the $taskName task " +\n          s"interrupted by ${fibers.map(_.threadName).mkString(", ")}"\n      )\n    } yield ()\n\n  def task =\n    for {\n      fn <- ZIO.fiberId.map(_.threadName)\n      _ <- ZIO.debug(s"$fn starts running that will print random numbers and booleans")\n      f1 <- Random.nextIntBounded(100)\n        .debug("random number ")\n        .schedule(Schedule.spaced(1.second).forever)\n        .onInterrupt(debugInterruption("random number"))\n        .fork\n      f2 <- Random.nextBoolean\n        .debug("random boolean ")\n        .schedule(Schedule.spaced(2.second).forever)\n        .onInterrupt(debugInterruption("random boolean"))\n        .fork\n        _ <- f1.join\n        _ <- f2.join\n    } yield ()\n\n  def run =\n    for {\n      f <- task.fork\n      _ <- ZIO.sleep(5.second)\n      _ <- f.interrupt\n    } yield ()\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Here is one sample output for this program:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"zio-fiber-7 starts running that will print random numbers and booleans\nrandom number : 65\nrandom boolean : true\nrandom number : 51\nrandom number : 46\nrandom boolean : true\nrandom number : 30\nThe zio-fiber-9 fiber which is the underlying fiber of the random boolean task interrupted by zio-fiber-7\nThe zio-fiber-8 fiber which is the underlying fiber of the random number task interrupted by zio-fiber-7\n"})}),"\n",(0,r.jsx)(n.h2,{id:"blocking-operations",children:"Blocking Operations"}),"\n",(0,r.jsx)(n.h3,{id:"interruption-of-blocking-operations",children:"Interruption of Blocking Operations"}),"\n",(0,r.jsxs)(n.p,{children:["By default, when we convert a blocking operation into a ZIO effect using ",(0,r.jsx)(n.code,{children:"attemptBlocking"}),", there is no guarantee that if that effect is interrupted the underlying effect will be interrupted."]}),"\n",(0,r.jsx)(n.p,{children:"Let's create a blocking effect from an endless loop:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nfor {\n  _ <- Console.printLine("Starting a blocking operation")\n  fiber <- ZIO.attemptBlocking {\n    while (true) {\n      Thread.sleep(1000)\n      println("Doing some blocking operation")\n    }\n  }.ensuring(\n    Console.printLine("End of a blocking operation").orDie\n  ).fork\n  _ <- fiber.interrupt.schedule(\n    Schedule.delayed(\n      Schedule.duration(1.seconds)\n    )\n  )\n} yield ()\n'})}),"\n",(0,r.jsxs)(n.p,{children:["When we interrupt this loop after one second it will still not stop. It will only stop when the entire JVM stops. The ",(0,r.jsx)(n.code,{children:"attemptBlocking"})," doesn't translate the ZIO interruption into thread interruption (",(0,r.jsx)(n.code,{children:"Thread.interrupt"}),")."]}),"\n",(0,r.jsxs)(n.p,{children:["Instead, we should use ",(0,r.jsx)(n.code,{children:"attemptBlockingInterrupt"})," to create interruptible blocking effects:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nfor {\n  _ <- Console.printLine("Starting a blocking operation")\n  fiber <- ZIO.attemptBlockingInterrupt {\n    while(true) {\n      Thread.sleep(1000)\n      println("Doing some blocking operation")\n    }\n  }.ensuring(\n     Console.printLine("End of the blocking operation").orDie\n   ).fork\n  _ <- fiber.interrupt.schedule(\n    Schedule.delayed(\n      Schedule.duration(3.seconds)\n    )\n  )\n} yield ()\n'})}),"\n",(0,r.jsx)(n.p,{children:"Notes:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["If we are converting a blocking I/O to a ZIO effect, it would be better to use ",(0,r.jsx)(n.code,{children:"attemptBlockingIO"})," which refines the error type to ",(0,r.jsx)(n.code,{children:"java.io.IOException"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"attemptBlockingInterrupt"})," method adds significant overhead. So for performance-sensitive applications, it is better to handle interruptions manually using ",(0,r.jsx)(n.code,{children:"attemptBlockingCancelable"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"cancellation-of-blocking-operation",children:"Cancellation of Blocking Operation"}),"\n",(0,r.jsxs)(n.p,{children:["Some blocking operations do not respect ",(0,r.jsx)(n.code,{children:"Thread#interrupt"})," by swallowing ",(0,r.jsx)(n.code,{children:"InterruptedException"}),". So they will not be interrupted via ",(0,r.jsx)(n.code,{children:"attemptBlockingInterrupt"}),". Instead, they may provide us an API to signal them to ",(0,r.jsx)(n.em,{children:"cancel"})," their operation."]}),"\n",(0,r.jsxs)(n.p,{children:["The following ",(0,r.jsx)(n.code,{children:"BlockingService"})," will not be interrupted in case of a ",(0,r.jsx)(n.code,{children:"Thread#interrupt"})," call, but it checks the ",(0,r.jsx)(n.code,{children:"released"})," flag constantly. If this flag becomes true, the blocking service will finish its job:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport java.util.concurrent.atomic.AtomicReference\n\nfinal case class BlockingService() {\n  private val released = new AtomicReference(false)\n\n  def start(): Unit = {\n    while (!released.get()) {\n      println("Doing some blocking operation")\n      try Thread.sleep(1000)\n      catch {\n        case _: InterruptedException => () // Swallowing InterruptedException\n      }\n    }\n    println("Blocking operation closed.")\n  }\n\n  def close(): Unit = {\n    println("Releasing resources and ready to be closed.")\n    released.getAndSet(true)\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["So to translate ZIO interruption into cancellation of these types of blocking operations we should use ",(0,r.jsx)(n.code,{children:"attemptBlockingCancelable"}),". This method takes a ",(0,r.jsx)(n.code,{children:"cancel"})," effect which is responsible for signalling the blocking code to close itself when ZIO interruption occurs:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"import zio._\n\nval myApp =\n  for {\n    service <- ZIO.attempt(BlockingService())\n    fiber   <- ZIO.attemptBlockingCancelable(\n      effect = service.start()\n    )(\n      cancel = ZIO.succeed(service.close())\n    ).fork\n    _       <- fiber.interrupt.schedule(\n      Schedule.delayed(\n        Schedule.duration(3.seconds)\n      )\n    )\n  } yield ()\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Here is another example of the cancellation of a blocking operation. When we ",(0,r.jsx)(n.code,{children:"accept"})," a server socket, this blocking operation will never be interrupted until we close it using the ",(0,r.jsx)(n.code,{children:"ServerSocket#close"})," method:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"import java.net.{Socket, ServerSocket}\nimport zio._\n\ndef accept(ss: ServerSocket): Task[Socket] =\n  ZIO.attemptBlockingCancelable(ss.accept())(ZIO.succeed(ss.close()))\n"})}),"\n",(0,r.jsx)(n.h2,{id:"disabling-interruption-of-fibers",children:"Disabling Interruption of Fibers"}),"\n",(0,r.jsx)(n.p,{children:"As we discussed earlier, it is dangerous for fibers to interrupt others. The danger with such an interruption is that:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["If the interruption occurs during the execution of an operation that must be ",(0,r.jsx)(n.em,{children:"finalized"}),", the finalization will not be executed."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["If this interruption occurs in the middle of a ",(0,r.jsx)(n.em,{children:"critical section"}),", it will cause an application state to become inconsistent."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["It is also a threat to ",(0,r.jsx)(n.em,{children:"resource safety"}),". If the fiber is in the middle of acquiring a resource and is interrupted, the application will leak resources."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["ZIO introduces the ",(0,r.jsx)(n.code,{children:"uninterruptible"})," and ",(0,r.jsx)(n.code,{children:"uninterruptibleMask"})," operations for this purpose. The former creates a region of code uninterruptible and the latter has the same functionality but gives us a ",(0,r.jsx)(n.code,{children:"restore"})," function that can be applied to any region of code to restore the interruptibility of that region."]}),"\n",(0,r.jsxs)(n.p,{children:["These operators are advanced and very low-level so we don't use them in regularly in application development unless we know what we are doing as library designers. If you find yourself using these operators, think again about refactoring your code using high-level operators like ",(0,r.jsx)(n.code,{children:"ZIO#onInterrupt"}),", ",(0,r.jsx)(n.code,{children:"ZIO#onDone"}),", ",(0,r.jsx)(n.code,{children:"ZIO#ensuring"}),", ",(0,r.jsx)(n.code,{children:"ZIO.acquireRelease*"})," and many other concurrent operators like ",(0,r.jsx)(n.code,{children:"race"}),", ",(0,r.jsx)(n.code,{children:"foreachPar"}),", etc."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var i=t(96540);const r={},o=i.createContext(r);function s(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);