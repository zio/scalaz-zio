"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[80256],{2621:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>n,toc:()=>r});const n=JSON.parse('{"id":"zio-dynamodb/guides/data-modelling","title":"High Level API Data Modelling and Limitations","description":"The High Level API relies heavily on ZIO Schema and inherits some of it\'s limitations, namely:","source":"@site/docs/zio-dynamodb/guides/data-modelling.md","sourceDirName":"zio-dynamodb/guides","slug":"/zio-dynamodb/guides/data-modelling","permalink":"/zio-dynamodb/guides/data-modelling","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-dynamodb/guides/data-modelling.md","tags":[],"version":"current","frontMatter":{"id":"data-modelling","title":"High Level API Data Modelling and Limitations"},"sidebar":"ecosystem-sidebar","previous":{"title":"High Level API Cheat Sheet","permalink":"/zio-dynamodb/guides/cheat-sheet"},"next":{"title":"Codec Customization","permalink":"/zio-dynamodb/guides/codec-customization"}}');var s=i(74848),a=i(28453);const o={id:"data-modelling",title:"High Level API Data Modelling and Limitations"},l=void 0,d={},r=[{value:"A maximum of <strong>22</strong> fields per case class",id:"a-maximum-of-22-fields-per-case-class",level:2},{value:"Deep OO Style hierarchies are not supported - modelling data using Product and Sum Types",id:"deep-oo-style-hierarchies-are-not-supported---modelling-data-using-product-and-sum-types",level:2}];function c(e){const t={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"The High Level API relies heavily on ZIO Schema and inherits some of it's limitations, namely:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["A maximum of ",(0,s.jsx)(t.strong,{children:"22"})," fields per case class"]}),"\n",(0,s.jsx)(t.li,{children:"Deep Object-Oriented hierarchies with abstract classes/fields are not supported - only hierarchies one level deep are supported"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"At first glance these seem limitations seem quite restrictive, however the next sections describe how these can be overcome."}),"\n",(0,s.jsxs)(t.h2,{id:"a-maximum-of-22-fields-per-case-class",children:["A maximum of ",(0,s.jsx)(t.strong,{children:"22"})," fields per case class"]}),"\n",(0,s.jsx)(t.p,{children:"The high level API uses the Reified Optics feature of ZIO Schema to generate optics for case classes and sealed traits. This feature has a limitation of 22 fields per case class."}),"\n",(0,s.jsx)(t.p,{children:"This limitation is something to be aware of when designing your models. In practice however this can be overcome by using nested case classes and in the case of deeply nested hierarchies, by using product and sum types (see section below)."}),"\n",(0,s.jsx)(t.h2,{id:"deep-oo-style-hierarchies-are-not-supported---modelling-data-using-product-and-sum-types",children:"Deep OO Style hierarchies are not supported - modelling data using Product and Sum Types"}),"\n",(0,s.jsx)(t.p,{children:"Deep Object-Oriented like hierarchies with abstract classes/fields are not supported - only hierarchies one level deep are supported - again this is a limitation of ZIO Schema - however these limitations can be overcome by using product and sum types rather than inheritance."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:"object OopStyle {\n  // ensure that all concrete classes have id field\n  sealed trait Invoice {\n    def id: Int\n  }\n  // (1) Intermediate abstraction with abstract fields - not supported by ZIO Schema\n  sealed trait Billed                                                 extends Invoice {\n    def amount: Double\n  }\n  final case class BilledMonthly(id: Int, amount: Double, month: Int) extends Billed\n  final case class BilledYearly(id: Int, amount: Double, year: Int)   extends Billed\n  final case class PreBilled(id: Int, count: Int)                     extends Invoice\n}\n\n// FP style modelling uses pure data (product and sum types) rather than inheritance hence avoiding classes like (1)\nobject FPStyle {\n  sealed trait BilledBody\n  final case class BilledMonthly(month: Int) extends BilledBody\n  final case class BilledYearly(year: Int)   extends BilledBody\n\n  sealed trait InvoiceBody\n  // (3) extract product refactoring\n  final case class Billed(amount: Double, billedBody: BilledBody) extends InvoiceBody\n  final case class PreBilled(count: Int)                          extends InvoiceBody\n\n  // (2) extract product refactoring\n  final case class Invoice(int: Int, body: InvoiceBody)\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"By using the FP approach to modelling we reduce the size of the concrete classes by factoring out common fields into a\nproduct type."}),"\n",(0,s.jsxs)(t.p,{children:["For brevity the above examples do not show the full integration with ZIO Schema - ",(0,s.jsx)(t.a,{href:"https://github.com/zio/zio-dynamodb/blob/series/2.x/dynamodb/src/it/scala/zio/dynamodb/TypeSafeApiAlternateModeling.scala",children:"for a full example see this IT test"}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},28453:(e,t,i)=>{i.d(t,{R:()=>o,x:()=>l});var n=i(96540);const s={},a=n.createContext(s);function o(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);