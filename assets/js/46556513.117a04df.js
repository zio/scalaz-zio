"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[31104],{28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var s=t(96540);const a={},r=s.createContext(a);function i(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(r.Provider,{value:n},e.children)}},48096:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"reference/stream/index","title":"Introduction to ZIO Streams","description":"The primary goal of a streaming library is to introduce a high-level API that abstracts the mechanism of reading and writing operations using data sources and destinations.","source":"@site/docs/reference/stream/index.md","sourceDirName":"reference/stream","slug":"/reference/stream/","permalink":"/reference/stream/","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/stream/index.md","tags":[],"version":"current","frontMatter":{"id":"index","title":"Introduction to ZIO Streams"},"sidebar":"reference-sidebar","previous":{"title":"ScopedRef","permalink":"/reference/resource/scopedref"},"next":{"title":"Installation","permalink":"/reference/stream/installation"}}');var a=t(74848),r=t(28453);const i={id:"index",title:"Introduction to ZIO Streams"},o=void 0,l={},h=[{value:"Use Cases",id:"use-cases",level:2},{value:"Motivation",id:"motivation",level:2},{value:"Why Streams?",id:"why-streams",level:2},{value:"1. High-level and Declarative",id:"1-high-level-and-declarative",level:3},{value:"2. Asynchronous and Non-blocking",id:"2-asynchronous-and-non-blocking",level:3},{value:"3. Concurrency and Parallelism",id:"3-concurrency-and-parallelism",level:3},{value:"4. Resource Safety",id:"4-resource-safety",level:3},{value:"5. High Performance and Efficiency",id:"5-high-performance-and-efficiency",level:3},{value:"6. Seamless Integration with ZIO",id:"6-seamless-integration-with-zio",level:3},{value:"7. Back-Pressure",id:"7-back-pressure",level:3},{value:"8. Infinite Data using Finite Memory",id:"8-infinite-data-using-finite-memory",level:3},{value:"Core Abstractions",id:"core-abstractions",level:2},{value:"Stream",id:"stream",level:3},{value:"Sink",id:"sink",level:3},{value:"Pipeline",id:"pipeline",level:3}];function c(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["The primary goal of a streaming library is to introduce ",(0,a.jsx)(n.strong,{children:"a high-level API that abstracts the mechanism of reading and writing operations using data sources and destinations"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"A streaming library helps us to concentrate on the business logic and separates us from low-level implementation details."}),"\n",(0,a.jsx)(n.h2,{id:"use-cases",children:"Use Cases"}),"\n",(0,a.jsx)(n.p,{children:"There are lots of examples of streaming that people might not recognize, this is a common problem especially for beginners. A beginner might say \"I don't need a streaming library. Why should I use that?\". It's because they don't see streams. Once we use a streaming library, we start to see streams everywhere but until then we don't understand where they are."}),"\n",(0,a.jsx)(n.p,{children:"Before diving into ZIO Streams, let's list some use cases of a streaming solution and see why we would want to program in a streaming fashion:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Files"}),' \u2014 Every time an old school API interacting with a file has very low-level operators like "Open a file, get me an InputStream, and a method to read the next chunk from that InputStream, and also another method to close the file". Although that is a very low-level imperative API, there is a way to see files as streams of bytes.']}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Sockets"})," \u2014 Instead of working with low-level APIs, we can use streams to provide a stream-based implementation of server socket that hides the low-level implementation details of sockets. We could model socket communication as a function from a stream of bytes to a stream of bytes. We can view the input of that socket as being a stream, and its output as being another stream."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Event-Sourcing"})," \u2014 In these days and age, it is common to want to build event-sourced applications which work on events or messages in a queuing system like Kafka or AMQP systems and so forth. The foundation of this architecture is streaming. Also, they are useful when we want to do a lot of data analytics and so forth."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"UI Applications"})," \u2014 Streams are the foundation of almost every single modern UI application. Every time we click on something, under the hood that is an event. We can use low-level APIs like subscribing callbacks to the user events but also we can view those as streams of events. So we can model subscriptions as streams of events in UI applications."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"HTTP Server"})," \u2014  An HTTP Server can be viewed as a stream. We have a stream of requests that are being transformed to a stream of responses; a function from a stream of bytes that go to a stream of bytes."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"So streams are everywhere. We can see all of these different things as being streams. Everywhere we look we can find streams. Basically, all data-driven applications, almost all data-driven applications can benefit from streams."}),"\n",(0,a.jsx)(n.h2,{id:"motivation",children:"Motivation"}),"\n",(0,a.jsxs)(n.p,{children:["Assume, we would like to take a list of numbers and grab all the prime numbers and then do some more hard work on each of these prime numbers. We can do it using ",(0,a.jsx)(n.code,{children:"ZIO.foreachPar"})," and ",(0,a.jsx)(n.code,{children:"ZIO.filterPar"})," operators like this:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"import zio.ZIOAspect._\n\ndef isPrime(number: Int): Task[Boolean] = ZIO.succeed(???)\ndef moreHardWork(i: Int): Task[Boolean] = ZIO.succeed(???)\n\nval numbers = 1 to 1000\n\nfor {\n  primes <- ZIO.filterPar(numbers)(isPrime)\n  _      <- ZIO.foreachPar(primes)(moreHardWork) @@ parallel(20)\n} yield ()\n"})}),"\n",(0,a.jsx)(n.p,{children:"This processes the list in parallel and filters all the prime numbers, then takes all the prime numbers and does some more hard work on them."}),"\n",(0,a.jsx)(n.p,{children:"There are two problems with this example:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"High Latency"})," \u2014 We are not getting any pipelining, we are doing batch processing. We need to wait for the entire list to be processed in the first step before we can continue to the next step. This can lead to a pretty severe loss of performance."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Limited Memory"})," \u2014 We need to keep the entire list in memory as we process it and this doesn't work if we are working with an infinite data stream."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"With ZIO stream we can change this program to the following code:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"def prime(number: Int): Task[(Boolean, Int)] = ZIO.succeed(???)\n\nZStream.fromIterable(numbers)\n  .mapZIOParUnordered(20)(prime(_))\n  .filter(_._1).map(_._2)\n  .mapZIOParUnordered(20)(moreHardWork(_))\n"})}),"\n",(0,a.jsxs)(n.p,{children:["We converted the list of numbers using ",(0,a.jsx)(n.code,{children:"ZStream.fromIterable"})," into a ",(0,a.jsx)(n.code,{children:"ZStream"}),", then we mapped it in parallel, twenty items at a time, and then we performed the hard work problem, twenty items of a time. This is a pipeline, and this easily works for an infinite list."]}),"\n",(0,a.jsx)(n.p,{children:'One might ask, "Okay, I can get the pipelining by using fibers and queues. So why should I use ZIO streams?". It is extremely tempting to write up the pipeline look like this. We can create a bunch of queues and fibers, then we have fibers that copy information between the queues and perform the processing concurrently. It ends up something like this:'}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"def writeToInput(q: Queue[Int]): Task[Unit]                            = ZIO.succeed(???)\ndef processBetweenQueues(from: Queue[Int], to: Queue[Int]): Task[Unit] = ZIO.succeed(???)\ndef printElements(q: Queue[Int]): Task[Unit]                           = ZIO.succeed(???)\n\nfor {\n  input  <- Queue.bounded[Int](16)\n  middle <- Queue.bounded[Int](16)\n  output <- Queue.bounded[Int](16)\n  _      <- writeToInput(input).fork\n  _      <- processBetweenQueues(input, middle).fork\n  _      <- processBetweenQueues(middle, output).fork\n  _      <- printElements(output).fork\n} yield ()\n"})}),"\n",(0,a.jsx)(n.p,{children:"We created a bunch of queues for buffering source, destination elements, and intermediate results."}),"\n",(0,a.jsx)(n.p,{children:"There are some problems with this solution. As fibers are low-level concurrency tools, using them to create a data pipeline is not straightforward. We need to handle interruptions properly. We should care about resources and prevent them to leak. We need to shutdown the pipeline in a right way by waiting for queues to be drained."}),"\n",(0,a.jsx)(n.p,{children:"Although fibers are very efficient and more performant than threads. They are advanced concurrency tools. So it is better to avoid using them to do manual pipelining. Instead, we can use ZIO streams:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"def generateElement: Task[Int]    = ZIO.succeed(???)\ndef process(i: Int): Task[Int]    = ZIO.succeed(???)\ndef printElem(i: Int): Task[Unit] = ZIO.succeed(???)\n\nZStream\n  .repeatZIO(generateElement)\n  .buffer(16)\n  .mapZIO(process(_))\n  .buffer(16)\n  .mapZIO(process(_))\n  .buffer(16)\n  .tap(printElem(_))\n"})}),"\n",(0,a.jsx)(n.p,{children:"We have a buffer in between each step. We performed our computations in between. This is everything we need to get that pipelining in the same fashion that it looked before."}),"\n",(0,a.jsx)(n.h2,{id:"why-streams",children:"Why Streams?"}),"\n",(0,a.jsx)(n.p,{children:"ZIO stream has super compelling advantages of using high-level streams. ZIO solution to streaming solves a lot of common streaming pain points. It shines in the following topics:"}),"\n",(0,a.jsx)(n.h3,{id:"1-high-level-and-declarative",children:"1. High-level and Declarative"}),"\n",(0,a.jsx)(n.p,{children:"This means in a very short snippet of a fluent code we can solve very outrageously complicated problems with just a few simple lines."}),"\n",(0,a.jsx)(n.h3,{id:"2-asynchronous-and-non-blocking",children:"2. Asynchronous and Non-blocking"}),"\n",(0,a.jsx)(n.p,{children:"They're reactive streams, they don't block threads. They're super-efficient and very scalable. We can minimize our application latency and increase its performance. We can avoid wasting precious thread resources by using non-blocking and asynchronous ZIO streams."}),"\n",(0,a.jsx)(n.h3,{id:"3-concurrency-and-parallelism",children:"3. Concurrency and Parallelism"}),"\n",(0,a.jsxs)(n.p,{children:["Streams are concurrent. They have a lot of concurrent operators. All the operations on them are safe to use in presence of concurrency. And also just like ZIO gives us parallel operators with everything, there are lots of parallel operators. We can use the parallel version of operators, like ",(0,a.jsx)(n.code,{children:"mapZIOPar"}),", ",(0,a.jsx)(n.code,{children:"flatMapPar"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"Parallel operators allow us to fully saturate and utilize all CPU cores of our machine. If we need to do bulk processing on a lot of data and use all the cores on our machine, so we can speed up the process by using these parallel operators."}),"\n",(0,a.jsx)(n.h3,{id:"4-resource-safety",children:"4. Resource Safety"}),"\n",(0,a.jsx)(n.p,{children:"Resource safety is not a simple thing to guarantee. Assume when we have several streams, some of them are sockets and files, some of them are API calls and database queries. When we have all these streams, and we are transforming and combining them, and we are timing some out, and also some of them are doing concurrent merges; what happens when things go wrong in one part of that stream graph? ZIO streams provides the guarantee that it will never leak resources."}),"\n",(0,a.jsx)(n.p,{children:"So when streams have to be terminated for error or timeout or interruption reasons or whatever, ZIO will always safely shutdown and release the resources associated with that stream usage."}),"\n",(0,a.jsx)(n.p,{children:"We don't have to worry about resource management anymore. We can work at high-level and just declaratively describe our stream graph and then ZIO will handle the tricky job of executing that and taking care to make sure that no resources are leaked in an event of something bad happens or even just a timeout, or interruption, or just we are done with a result. So resources are always safely released without any leaks."}),"\n",(0,a.jsx)(n.h3,{id:"5-high-performance-and-efficiency",children:"5. High Performance and Efficiency"}),"\n",(0,a.jsx)(n.p,{children:"When we are doing an I/O job, the granularity of data is not at the level of a single byte. For example, we never read or write a single element from/to a file descriptor. We always use multiple elements. So when we are doing an I/O operation it is a poor practice to read/write element by element and this decreases the performance of our program."}),"\n",(0,a.jsx)(n.p,{children:"In order to achieve high efficiency, ZIO stream implicitly chunks everything, but it still presents us with a nice API that is at the level of every single element. So we can always deal with streams of individual elements even though behind-the-scenes ZIO is doing some chunking to make that performant. This is one of the tricks that enables ZIO streams to have such great performance."}),"\n",(0,a.jsx)(n.p,{children:"ZIO Streams are working at the level of chunks. Every time we are working with ZIO streams, we are also working with chunks implicitly. So there are no streams with individual elements. Streams always use chunks. Every time we pull an element out of a ZIO stream, we end up pulling a chunk of elements under the hood."}),"\n",(0,a.jsx)(n.h3,{id:"6-seamless-integration-with-zio",children:"6. Seamless Integration with ZIO"}),"\n",(0,a.jsxs)(n.p,{children:["ZIO stream has a powerful seamless integrated support for ZIO. It uses ",(0,a.jsx)(n.code,{children:"Scope"}),", ",(0,a.jsx)(n.code,{children:"Schedule"}),", and any other powerful data types in ZIO. So we can stay within the same ecosystem and get all its significant benefits."]}),"\n",(0,a.jsx)(n.h3,{id:"7-back-pressure",children:"7. Back-Pressure"}),"\n",(0,a.jsx)(n.p,{children:"We get back-pressuring for free. With ZIO streams it is actually not a back-pressuring, but it is equivalent. In push-based streams like Akka Streams, streams are push-based; when an element comes in, it is pushed downward in the pipeline. That is what leads to the need for back-pressuring. Back-pressuring makes the push-based stream much more complicated than it needs to be."}),"\n",(0,a.jsx)(n.p,{children:"Push-based streams are good at splitting streams because we have one element, and we can push it to two different places. That is nice and elegant, but they're terrible at merging streams and that is because you end up needing to use queues, and then we run into a problem. In the case of using queues, we need back-pressuring, which leads to a complicated architecture."}),"\n",(0,a.jsx)(n.p,{children:"In ZIO when we merge streams, ZIO uses pull-based streams. They need minimal computation because we pull elements at the end of our data pipeline when needed. When the sink asks for one element, then that ripples all the way back through the very edges of the system."}),"\n",(0,a.jsx)(n.p,{children:"So when we pull one element at the end, no additional computation takes place until we pull the next element or decide that we are done pulling, and we close the stream. It causes the minimum amount of computation necessary to produce the result."}),"\n",(0,a.jsx)(n.p,{children:"Using the pull-based mechanism we have no producers, and it prevents producing more events than necessary. So ZIO streams does not need back-pressure even though it provides a form of that because it is lazy and on-demand and uses pull-based streams."}),"\n",(0,a.jsx)(n.p,{children:"So ZIO stream gives us the benefits of back-pressuring, but in a cleaner conceptual model that is very efficient and does not require all these levels of buffering."}),"\n",(0,a.jsx)(n.h3,{id:"8-infinite-data-using-finite-memory",children:"8. Infinite Data using Finite Memory"}),"\n",(0,a.jsx)(n.p,{children:"Streams let us work on infinite data in a finite amount of memory. When we are writing streaming logic, we don't have to worry about how much data we are ultimately going to be processed."}),"\n",(0,a.jsx)(n.p,{children:"That is because we are just building a workflow, a description of the processing. We are not manually loading up everything into memory, into a list, and then doing our processing on a list. That doesn't work very well because we can only fit a finite amount of memory into our computer at one time."}),"\n",(0,a.jsx)(n.p,{children:"ZIO streams enable us just concentrate on our business problem, and not on how much memory this program is going to consume. So we can write these computations that work over streams that are totally infinite but in a finite amount of memory and ZIO handles that for us."}),"\n",(0,a.jsx)(n.p,{children:"Assume we have the following code. This is a snippet of a code that reads a file into a string and splits the string into new lines, then iterates over lines and prints them out. It is pretty simple and easy to read and also it is simple to understand:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"for (line <- FileUtils.readFileToString(new File(\"file.txt\")).split('\\n'))\n  println(line)\n"})}),"\n",(0,a.jsx)(n.p,{children:"The only problem here is that if we run this code with a file that is very large which is bigger than our memory, that is not going to work. Instead, we can reach the same functionality, by using the stream API:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:'ZStream.fromFileName("file.txt")\n  .via(ZPipeline.utf8Decode >>> ZPipeline.splitLines)\n  .foreach(printLine(_))\n'})}),"\n",(0,a.jsx)(n.p,{children:"By using ZIO streams, we do not care how big is a file, we just concentrate on the logic of our application."}),"\n",(0,a.jsx)(n.h2,{id:"core-abstractions",children:"Core Abstractions"}),"\n",(0,a.jsxs)(n.p,{children:["To define a stream workflow there are three core abstraction in ZIO stream; ",(0,a.jsx)(n.em,{children:"Streams"}),", ",(0,a.jsx)(n.em,{children:"Sinks"}),", and ",(0,a.jsx)(n.em,{children:"Pipelines"}),":"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"/reference/stream/zstream/",children:"ZStream"})})," \u2014 Streams act as ",(0,a.jsx)(n.em,{children:"sources"})," of values. We get elements from them. They produce values."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"/reference/stream/zsink/",children:"ZSink"})})," \u2014 Sinks act as ",(0,a.jsx)(n.em,{children:"receptacles"})," or ",(0,a.jsx)(n.em,{children:"sinks"})," for values. They consume values."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"/reference/stream/zpipeline",children:"ZPipeline"})})," \u2014 Pipelines act as ",(0,a.jsx)(n.em,{children:"transformers"})," of values. They take individual values, and they transform or decode them."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"stream",children:"Stream"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"ZStream"})," data type similar to the ",(0,a.jsx)(n.code,{children:"ZIO"})," effect has ",(0,a.jsx)(n.code,{children:"R"}),", ",(0,a.jsx)(n.code,{children:"E"}),", and ",(0,a.jsx)(n.code,{children:"A"}),". It has environment, error, and element type."]}),"\n",(0,a.jsxs)(n.p,{children:["The difference between the ",(0,a.jsx)(n.code,{children:"ZIO"})," and ",(0,a.jsx)(n.code,{children:"ZStream"})," is that:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["A ",(0,a.jsx)(n.code,{children:"ZIO"})," effect will always succeed or fail. If it succeeds, it will succeed with a single element."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["A ",(0,a.jsx)(n.code,{children:"ZStream"})," can succeed with zero or more elements. So we can have an ",(0,a.jsx)(n.em,{children:"empty stream"}),". A ",(0,a.jsx)(n.code,{children:"ZStream[R, E, A]"})," doesn't necessarily produce any ",(0,a.jsx)(n.code,{children:"A"}),"s, it produces zero or more ",(0,a.jsx)(n.code,{children:"A"}),"s."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["So, that is a big difference. There is no such thing as a non-empty ",(0,a.jsx)(n.code,{children:"ZStream"}),". All ",(0,a.jsx)(n.code,{children:"ZStreams"})," are empty, they can produce any number of ",(0,a.jsx)(n.code,{children:"A"}),"s, which could be an infinite number of ",(0,a.jsx)(n.code,{children:"A"}),"s."]}),"\n",(0,a.jsx)(n.p,{children:"There is no way to check to see if a stream is empty or not, because that computation hasn't started. Streams are super lazy, so there is no way to say \"Oh! does this stream contain anything?\" No! We can't figure that out. We have to use it and try to do something with it, and then we are going to figure out whether it had something."}),"\n",(0,a.jsx)(n.h3,{id:"sink",children:"Sink"}),"\n",(0,a.jsxs)(n.p,{children:["The basic idea behind the ",(0,a.jsx)(n.code,{children:"Sink"})," is that ",(0,a.jsx)(n.strong,{children:"it consumes values of some type, and then it ends up when it is done. When the sink is done, it produces the value of a different type"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Sinks are a bit like ",(0,a.jsx)(n.strong,{children:"parsers"}),"; they consume some input, when they're done, they produce a value. Also, they are like ",(0,a.jsx)(n.strong,{children:"databases"}),"; they read enough from input when they don't want anymore, they can produce some value or return unit."]}),"\n",(0,a.jsxs)(n.p,{children:["Some sinks will produce nothing as their return type parameter is ",(0,a.jsx)(n.code,{children:"Nothing"}),", which means that the sink is always going to accept more and more input; it is never ever going to be done."]}),"\n",(0,a.jsx)(n.p,{children:"Just like Streams, sinks are super compositional. Sink's operators allow us to combine two sinks together or transform them. That allows us to generate a vast variety of sinks."}),"\n",(0,a.jsx)(n.p,{children:"Streams and Sinks are duals in category theory. One produces values, and the other one consumes them. They are mere images of each other. They both have to exist. A streaming library cannot be complete unless it has streams and sinks. That is why ZIO has a sort of better design than FS2 because FS2 has a stream, but it doesn't have a sink. Its Sink is just faked. It doesn't actually have a real sink. ZIO has a real sink, and we can compose them to generate new sinks."}),"\n",(0,a.jsx)(n.h3,{id:"pipeline",children:"Pipeline"}),"\n",(0,a.jsxs)(n.p,{children:["With ",(0,a.jsx)(n.code,{children:"Pipeline"}),"s, we can transform streams from one type to another, in a ",(0,a.jsx)(n.strong,{children:"stateful fashion"}),", which is sometimes necessary when we are doing encoding and decoding."]}),"\n",(0,a.jsxs)(n.p,{children:["Pipeline is a transformer of element types. Pipeline accepts some element of type ",(0,a.jsx)(n.code,{children:"A"})," and produces some element of type ",(0,a.jsx)(n.code,{children:"B"}),", and it may fail along the way or use the environment. It just transforms elements from one type to another type in a stateful way."]}),"\n",(0,a.jsx)(n.p,{children:"For example, we can write counter with pipelines. We take strings and then split them into lines, and then we take the lines, and we split them into words, and then we count them."}),"\n",(0,a.jsxs)(n.p,{children:["Another common use case of pipelines is ",(0,a.jsx)(n.strong,{children:"writing codecs"}),". We can use them to decode the bytes into strings. We have a bunch of bytes, and we want to end up with a JSON and then once we are in JSON land we want to go from JSON to our user-defined data type. So, by writing a pipeline we can convert that JSON to our user-defined data type."]}),"\n",(0,a.jsxs)(n.p,{children:["Pipelines can be thought of as ",(0,a.jsx)(n.strong,{children:"element transformers"}),". They transform elements of a stream:"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["We can take a pipeline, and we can stack it onto a stream to change the element type. For example, we have a Stream of ",(0,a.jsx)(n.code,{children:"A"}),"s, and a pipeline that goes from ",(0,a.jsx)(n.code,{children:"A"})," to ",(0,a.jsx)(n.code,{children:"B"}),", so we can take that pipeline from ",(0,a.jsx)(n.code,{children:"A"})," to ",(0,a.jsx)(n.code,{children:"B"})," and stack it on the stream to get back a stream of ",(0,a.jsx)(n.code,{children:"B"}),"s."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Also, we can stack a pipeline onto the front of a sink to change the input element type. If some sink consumes ",(0,a.jsx)(n.code,{children:"B"}),"s, and we have a pipeline from ",(0,a.jsx)(n.code,{children:"A"})," to ",(0,a.jsx)(n.code,{children:"B"})," we can take that pipeline stack it onto the front of the sink and get back a new sink that consumes ",(0,a.jsx)(n.code,{children:"A"}),"s."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Assume we are building the data pipeline, the elements come from the far left, and they end up on the far right. Events come from the stream, they end up on the sink, along the way they're transformed by pipelines. ",(0,a.jsx)(n.strong,{children:"Pipelines are the middle section of the pipe that keep on transforming those elements in a stateful way"}),"."]})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);