"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[58446],{6136:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"zio-akka-cluster/index","title":"Introduction to ZIO Akka Cluster","description":"This library is a ZIO wrapper for Akka Cluster.","source":"@site/docs/zio-akka-cluster/index.md","sourceDirName":"zio-akka-cluster","slug":"/zio-akka-cluster/","permalink":"/zio-akka-cluster/","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-akka-cluster/index.md","tags":[],"version":"current","frontMatter":{"id":"index","title":"Introduction to ZIO Akka Cluster","sidebar_label":"ZIO Akka Cluster"},"sidebar":"ecosystem-sidebar","previous":{"title":"Examples","permalink":"/zio-actors/examples"},"next":{"title":"ZIO Bson","permalink":"/zio-bson/"}}');var i=t(74848),r=t(28453);const a={id:"index",title:"Introduction to ZIO Akka Cluster",sidebar_label:"ZIO Akka Cluster"},o=void 0,l={},c=[{value:"Add the dependency",id:"add-the-dependency",level:2},{value:"How to use",id:"how-to-use",level:2},{value:"Akka Cluster",id:"akka-cluster",level:3},{value:"Akka PubSub",id:"akka-pubsub",level:3},{value:"Akka Cluster Sharding",id:"akka-cluster-sharding",level:3}];function d(e){const s={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(s.p,{children:["This library is a ",(0,i.jsx)(s.a,{href:"https://github.com/zio/zio",children:"ZIO"})," wrapper for ",(0,i.jsx)(s.a,{href:"https://doc.akka.io/docs/akka/current/index-cluster.html",children:"Akka Cluster"}),".\nIt exposes a purely functional API allowing you to leverage the distributed features of Akka without the need to use the actor model."]}),"\n",(0,i.jsx)(s.p,{children:"The following features are available:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Akka Cluster (join, leave, cluster state, cluster events)"}),"\n",(0,i.jsx)(s.li,{children:"Akka Distributed PubSub"}),"\n",(0,i.jsx)(s.li,{children:"Akka Cluster Sharding"}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"add-the-dependency",children:"Add the dependency"}),"\n",(0,i.jsxs)(s.p,{children:["To use ",(0,i.jsx)(s.code,{children:"zio-akka-cluster"}),", add the following line in your ",(0,i.jsx)(s.code,{children:"build.sbt"})," file:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:'libraryDependencies += "dev.zio" %% "zio-akka-cluster" % "0.3.0"\n'})}),"\n",(0,i.jsx)(s.h2,{id:"how-to-use",children:"How to use"}),"\n",(0,i.jsxs)(s.p,{children:["In order to use the library, you need to provide an ",(0,i.jsx)(s.code,{children:"ActorSystem"}),". Refer to the ",(0,i.jsx)(s.a,{href:"https://doc.akka.io/docs/akka/current/general/actor-systems.html",children:"Akka Documentation"})," if you need help."]}),"\n",(0,i.jsx)(s.h3,{id:"akka-cluster",children:"Akka Cluster"}),"\n",(0,i.jsx)(s.p,{children:"The features described here require the following import:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-scala",children:"import zio.akka.cluster.Cluster\n"})}),"\n",(0,i.jsxs)(s.p,{children:["When you create an ActorSystem, Akka will look at your configuration file and join a cluster if seed nodes are specified.\nSee ",(0,i.jsx)(s.a,{href:"https://doc.akka.io/docs/akka/current/cluster-usage.html",children:"Akka Documentation"})," to know more about cluster usage.\nYou can also manually join a cluster using ",(0,i.jsx)(s.code,{children:"Cluster.join"}),"."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-scala",children:"def join(seedNodes: List[Address]): ZIO[ActorSystem, Throwable, Unit]\n"})}),"\n",(0,i.jsxs)(s.p,{children:["It's possible to get the status of the cluster by calling ",(0,i.jsx)(s.code,{children:"Cluster.clusterState"})]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-scala",children:"val clusterState: ZIO[ActorSystem, Throwable, CurrentClusterState]\n"})}),"\n",(0,i.jsxs)(s.p,{children:["To monitor the cluster and be informed of changes (e.g. new members, member unreachable, etc), use ",(0,i.jsx)(s.code,{children:"Cluster.clusterEvents"}),".\nThis functions returns a ZIO ",(0,i.jsx)(s.code,{children:"Queue"})," that will be populated with the cluster events as they happen.\nThe returned queue is unbounded, but if you want to supply your own bounded queue, use ",(0,i.jsx)(s.code,{children:"Cluster.clusterEventsWith"}),".\nTo unsubscribe, simply ",(0,i.jsx)(s.code,{children:"shutdown"})," the queue.\n",(0,i.jsx)(s.code,{children:"initialStateAsEvents"})," indicates if you want to receive previous cluster events leading to the current state, or only future events."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-scala",children:"def clusterEvents(initialStateAsEvents: Boolean = false): ZIO[ActorSystem, Throwable, Queue[ClusterDomainEvent]]\n"})}),"\n",(0,i.jsxs)(s.p,{children:["Finally, you can leave the current cluster using ",(0,i.jsx)(s.code,{children:"Cluster.leave"}),"."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-scala",children:"val leave: ZIO[ActorSystem, Throwable, Unit]\n"})}),"\n",(0,i.jsx)(s.h3,{id:"akka-pubsub",children:"Akka PubSub"}),"\n",(0,i.jsx)(s.p,{children:"The features described here require the following import:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-scala",children:"import zio.akka.cluster.pubsub.PubSub\n"})}),"\n",(0,i.jsxs)(s.p,{children:["Akka Distributed PubSub lets you publish and receive events from any node in the cluster.\nSee ",(0,i.jsx)(s.a,{href:"https://doc.akka.io/docs/akka/current/distributed-pub-sub.html",children:"Akka Documentation"})," to know more about PubSub usage.\nTo create a ",(0,i.jsx)(s.code,{children:"PubSub"})," object which can both publish and subscribe, use ",(0,i.jsx)(s.code,{children:"PubSub.createPubSub"}),"."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-scala",children:"def createPubSub[A]: ZIO[ActorSystem, Throwable, PubSub[A]]\n"})}),"\n",(0,i.jsxs)(s.p,{children:["There are also less powerful variants ",(0,i.jsx)(s.code,{children:"PubSub.createPublisher"})," if you only need to publish and ",(0,i.jsx)(s.code,{children:"PubSub.createSubscriber"})," if you only need to subscribe."]}),"\n",(0,i.jsxs)(s.p,{children:["To publish a message, use ",(0,i.jsx)(s.code,{children:"publish"}),". It requires the following:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["the ",(0,i.jsx)(s.code,{children:"topic"})," you want to publish to"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"data"})," is the message to publish."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"sendOneMessageToEachGroup"})," can be used in order to send the message not to all subscribers but to only one subscriber per group."]}),"\n"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-scala",children:"def publish(topic: String, data: A, sendOneMessageToEachGroup: Boolean = false): Task[Unit]\n"})}),"\n",(0,i.jsxs)(s.p,{children:["To subscribe to messages, use ",(0,i.jsx)(s.code,{children:"listen"}),".  It requires the following:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["the ",(0,i.jsx)(s.code,{children:"topic"})," you want to subscribe to."]}),"\n",(0,i.jsxs)(s.li,{children:["a ",(0,i.jsx)(s.code,{children:"group"})," name if you want only one subscriber per group to receive each message, to be used with ",(0,i.jsx)(s.code,{children:"sendOneMessageToEachGroup=true"})]}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"listen"})," returns an unbounded ZIO ",(0,i.jsx)(s.code,{children:"Queue"})," that will be populated with the messages. To use a bounded queue, use ",(0,i.jsx)(s.code,{children:"listenWith"})," instead.\nNote that ",(0,i.jsx)(s.code,{children:"listen"})," waits for the subscription acknowledgment before completing, which means that once it completes, all messages published will be received.\nTo stop listening, simply ",(0,i.jsx)(s.code,{children:"shutdown"})," the queue."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-scala",children:"def listen(topic: String, group: Option[String] = None): Task[Queue[A]] =\n    Queue.unbounded[A].tap(listenWith(topic, _, group))\n"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Note on Serialization"}),"\nAkka messages are serialized when they are sent across the network. By default, Java serialization is used but it is not recommended to use it in production.\nSee ",(0,i.jsx)(s.a,{href:"https://doc.akka.io/docs/akka/current/serialization.html",children:"Akka Documentation"})," to see how to provide your own serializer.\nThis library wraps messages inside of a ",(0,i.jsx)(s.code,{children:"zio.akka.cluster.pubsub.MessageEnvelope"})," case class, so your serializer needs to cover it as well."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Example:"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-scala",children:'import akka.actor.ActorSystem\nimport zio.{ ZIO, ZLayer }\nimport zio.akka.cluster.pubsub.PubSub\n\nval actorSystem: ZLayer[Any, Throwable, ActorSystem] =\n  ZLayer\n    .scoped(\n      ZIO.acquireRelease(ZIO.attempt(ActorSystem("Test")))(sys => ZIO.fromFuture(_ => sys.terminate()).either)\n    )\n\n(for {\n  pubSub   <- PubSub.createPubSub[String]\n  queue    <- pubSub.listen("my-topic")\n  _        <- pubSub.publish("my-topic", "yo")\n  firstMsg <- queue.take\n} yield firstMsg).provideLayer(actorSystem)\n'})}),"\n",(0,i.jsx)(s.h3,{id:"akka-cluster-sharding",children:"Akka Cluster Sharding"}),"\n",(0,i.jsx)(s.p,{children:"The features described here require the following import:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-scala",children:"import zio.akka.cluster.sharding.Sharding\n"})}),"\n",(0,i.jsxs)(s.p,{children:["Akka Cluster Sharding lets you distribute entities across a cluster and communicate with them using a logical ID, without having to care about their physical location.\nIt is particularly useful when you have some business logic that needs to be processed by a single process across a cluster (e.g. some state that should be only in one place at a given time, a single writer to a database, etc).\nSee ",(0,i.jsx)(s.a,{href:"https://doc.akka.io/docs/akka/current/cluster-sharding.html",children:"Akka Documentation"})," to know more about Cluster Sharding usage."]}),"\n",(0,i.jsxs)(s.p,{children:["To start sharding a given entity type on a node, use ",(0,i.jsx)(s.code,{children:"Sharding.start"}),". It returns a ",(0,i.jsx)(s.code,{children:"Sharding"})," object which can be used to send messages, stop or passivate sharded entities."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-scala",children:"def start[R, Msg, State](\n    name: String,\n    onMessage: Msg => ZIO[Entity[State] with R, Nothing, Unit],\n    numberOfShards: Int = 100\n  ): ZIO[ActorSystem with R, Throwable, Sharding[Msg]]\n"})}),"\n",(0,i.jsx)(s.p,{children:"It requires:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["the ",(0,i.jsx)(s.code,{children:"name"})," of the entity type. Entities will be distributed on all the nodes of the cluster where ",(0,i.jsx)(s.code,{children:"start"})," was called with this ",(0,i.jsx)(s.code,{children:"name"}),"."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"onMessage"})," is the behavior of the sharded entity. For each received message, it will run an effect of type ",(0,i.jsx)(s.code,{children:"ZIO[Entity[State], Nothing, Unit]"}),":","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"Entity[State]"})," gives you access to a ",(0,i.jsx)(s.code,{children:"Ref[Option[State]]"})," which you can use to read or modify the state of the entity. The state is set to ",(0,i.jsx)(s.code,{children:"None"})," when the entity is started. This ",(0,i.jsx)(s.code,{children:"Entity"})," object also allows you to get the entity ID and to stop the entity from within (e.g. after some time of inactivity)."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"Nothing"})," means the effect should not fail, you must catch and handle potential errors"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"Unit"})," means the effect should not return anything"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"numberOfShards"})," indicates how entities will be split across nodes. See ",(0,i.jsx)(s.a,{href:"https://doc.akka.io/docs/akka/current/cluster-sharding.html#an-example",children:"this page"})," for more information."]}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["You can also use ",(0,i.jsx)(s.code,{children:"Sharding.startProxy"})," if you need to send messages to entities located on ",(0,i.jsx)(s.code,{children:"other"})," nodes."]}),"\n",(0,i.jsxs)(s.p,{children:["To send a message to a sharded entity without expecting a response, use ",(0,i.jsx)(s.code,{children:"send"}),". To send a message to a sharded entity expecting a response, use ",(0,i.jsx)(s.code,{children:"ask"}),". To stop one, use ",(0,i.jsx)(s.code,{children:"stop"}),".\nThe ",(0,i.jsx)(s.code,{children:"entityId"})," identifies the entity to target. Messages sent to the same ",(0,i.jsx)(s.code,{children:"entityId"})," from different nodes in the cluster will be handled by the same actor."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-scala",children:"def send(entityId: String, data: M): Task[Unit]\ndef ask[R](entityId: String, data: M): Task[R]\ndef stop(entityId: String): Task[Unit]\ndef passivate(entityId: String): Task[Unit]\n"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Note on Serialization"}),"\nAkka messages are serialized when they are sent across the network. By default, Java serialization is used, but it is not recommended in production.\nSee ",(0,i.jsx)(s.a,{href:"https://doc.akka.io/docs/akka/current/serialization.html",children:"Akka Documentation"})," to see how to provide your own serializer.\nThis library wraps messages inside of a ",(0,i.jsx)(s.code,{children:"zio.akka.cluster.sharding.MessageEnvelope"})," case class, so your serializer needs to cover it as well."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Example:"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-scala",children:'import akka.actor.ActorSystem\nimport zio.akka.cluster.sharding.{ Entity, Sharding }\nimport zio.{ ZIO, ZLayer }\n\nval actorSystem: ZLayer[Any, Throwable, ActorSystem] =\n  ZLayer\n    .scoped(\n      ZIO.acquireRelease(ZIO.attempt(ActorSystem("Test")))(sys => ZIO.fromFuture(_ => sys.terminate()).either)\n    )\n\nval behavior: String => ZIO[Entity[Int], Nothing, Unit] = {\n  case "+" => ZIO.serviceWithZIO[Entity[Int]](_.state.update(x => Some(x.getOrElse(0) + 1)))\n  case "-" => ZIO.serviceWithZIO[Entity[Int]](_.state.update(x => Some(x.getOrElse(0) - 1)))\n  case _   => ZIO.unit\n}\n\n(for {\n  sharding <- Sharding.start("session", behavior)\n  entityId = "1"\n  _        <- sharding.send(entityId, "+")\n  _        <- sharding.send(entityId, "+")\n  _        <- sharding.send(entityId, "-")\n} yield ()).provideLayer(actorSystem)\n'})})]})}function u(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,s,t)=>{t.d(s,{R:()=>a,x:()=>o});var n=t(96540);const i={},r=n.createContext(i);function a(e){const s=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),n.createElement(r.Provider,{value:s},e.children)}}}]);