"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[19080],{62496:(e,s,i)=>{i.r(s),i.d(s,{assets:()=>l,contentTitle:()=>c,default:()=>o,frontMatter:()=>d,metadata:()=>t,toc:()=>h});const t=JSON.parse('{"id":"reference/test/assertions/built-in-assertions","title":"Built-in Assertions","description":"To create Assertion[A] object one can use functions defined under zio.test.Assertion. There are already a number of useful assertions predefined like equalTo, isFalse, isTrue, contains, throws and more.","source":"@site/docs/reference/test/assertions/built-in-assertions.md","sourceDirName":"reference/test/assertions","slug":"/reference/test/assertions/built-in-assertions","permalink":"/reference/test/assertions/built-in-assertions","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/test/assertions/built-in-assertions.md","tags":[],"version":"current","frontMatter":{"id":"built-in-assertions","title":"Built-in Assertions"},"sidebar":"reference-sidebar","previous":{"title":"Smart Assertions","permalink":"/reference/test/assertions/smart-assertions"},"next":{"title":"Test Hierarchies and Organization","permalink":"/reference/test/test-hierarchies-and-organization"}}');var r=i(74848),n=i(28453);const d={id:"built-in-assertions",title:"Built-in Assertions"},c=void 0,l={},h=[{value:"Any",id:"any",level:2},{value:"A",id:"a",level:2},{value:"Numeric",id:"numeric",level:2},{value:"Ordering",id:"ordering",level:2},{value:"Iterable",id:"iterable",level:2},{value:"Ordering",id:"ordering-1",level:2},{value:"Seq",id:"seq",level:2},{value:"Either",id:"either",level:2},{value:"Exit/Cause/Throwable",id:"exitcausethrowable",level:2},{value:"Try",id:"try",level:2},{value:"Sum type",id:"sum-type",level:2},{value:"Map",id:"map",level:2},{value:"String",id:"string",level:2},{value:"Boolean",id:"boolean",level:2},{value:"Option",id:"option",level:2},{value:"Unit",id:"unit",level:2}];function a(e){const s={code:"code",em:"em",h2:"h2",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,n.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(s.p,{children:["To create ",(0,r.jsx)(s.code,{children:"Assertion[A]"})," object one can use functions defined under ",(0,r.jsx)(s.code,{children:"zio.test.Assertion"}),". There are already a number of useful assertions predefined like ",(0,r.jsx)(s.code,{children:"equalTo"}),", ",(0,r.jsx)(s.code,{children:"isFalse"}),", ",(0,r.jsx)(s.code,{children:"isTrue"}),", ",(0,r.jsx)(s.code,{children:"contains"}),", ",(0,r.jsx)(s.code,{children:"throws"})," and more."]}),"\n",(0,r.jsxs)(s.p,{children:["Using the ",(0,r.jsx)(s.code,{children:"Assertion"})," type effectively often involves finding the best fitting function for the type of assumptions you would like to verify."]}),"\n",(0,r.jsxs)(s.p,{children:["This list is intended to break up the available functions into groups based on the ",(0,r.jsx)(s.em,{children:"Result type"}),". The types of the functions are included as well, to guide intuition."]}),"\n",(0,r.jsxs)(s.p,{children:["For instance, if we wanted to assert that the fourth element of a ",(0,r.jsx)(s.code,{children:"Vector[Int]"})," was a value equal to the number ",(0,r.jsx)(s.code,{children:"5"}),", we would first look at assertions that operate on ",(0,r.jsx)(s.code,{children:"Seq[A]"}),", with the type ",(0,r.jsx)(s.code,{children:"Assertion[Seq[A]]"}),". For this example, I would select ",(0,r.jsx)(s.code,{children:"hasAt"}),", as it accepts both the position into a sequence, as well as an ",(0,r.jsx)(s.code,{children:"Assertion[A]"})," to apply at that position:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:"Assertion.hasAt[A](pos: Int)(assertion: Assertion[A]): Assertion[Seq[A]]\n"})}),"\n",(0,r.jsx)(s.p,{children:"I could start by writing:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:'import zio.test._\nimport zio.test.Assertion._\n\nval xs = Vector(0, 1, 2, 3)\n\ntest("Fourth value is equal to 5") {\n  assert(xs)(hasAt(3)(???))\n}\n'})}),"\n",(0,r.jsxs)(s.p,{children:["The second parameter to ",(0,r.jsx)(s.code,{children:"hasAt"})," is an ",(0,r.jsx)(s.code,{children:"Assertion[A]"})," that applies to the third element of that sequence, so I would look for functions that operate on ",(0,r.jsx)(s.code,{children:"A"}),", of the return type ",(0,r.jsx)(s.code,{children:"Assertion[A]"}),"."]}),"\n",(0,r.jsxs)(s.p,{children:["I could select ",(0,r.jsx)(s.code,{children:"equalTo"}),", as it accepts an ",(0,r.jsx)(s.code,{children:"A"})," as a parameter, allowing me to supply ",(0,r.jsx)(s.code,{children:"5"}),":"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:'import zio.test._\nimport zio.test.Assertion._\n\nval xs = Vector(0, 1, 2, 3)\n\ntest("Fourth value is equal to 5") {\n  assert(xs)(hasAt(3)(equalTo(5)))\n}\n'})}),"\n",(0,r.jsxs)(s.p,{children:["Let's say this is too restrictive, and I would prefer to assert that a value is ",(0,r.jsx)(s.em,{children:"near"})," the number five, with a tolerance of two. This requires a little more knowledge of the type ",(0,r.jsx)(s.code,{children:"A"}),", so I'll look for an assertion in the ",(0,r.jsx)(s.code,{children:"Numeric"})," section. ",(0,r.jsx)(s.code,{children:"approximatelyEquals"})," looks like what we want, as it permits the starting value ",(0,r.jsx)(s.code,{children:"reference"}),", as well as a ",(0,r.jsx)(s.code,{children:"tolerance"}),", for any ",(0,r.jsx)(s.code,{children:"A"})," that is ",(0,r.jsx)(s.code,{children:"Numeric"}),":"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:"Assertion.approximatelyEquals[A: Numeric](reference: A, tolerance: A): Assertion[A]\n"})}),"\n",(0,r.jsxs)(s.p,{children:["Changing out ",(0,r.jsx)(s.code,{children:"equalTo"})," with ",(0,r.jsx)(s.code,{children:"approximatelyEquals"})," leaves us with:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-scala",children:'import zio.test._\nimport zio.test.Assertion._\n\nval xs = Vector(0, 1, 2, 3)\n\ntest("Fourth value is approximately equal to 5") {\n  assert(xs)(hasAt(3)(approximatelyEquals(5, 2)))\n}\n'})}),"\n",(0,r.jsx)(s.h2,{id:"any",children:"Any"}),"\n",(0,r.jsxs)(s.p,{children:["Assertions that apply to ",(0,r.jsx)(s.code,{children:"Any"})," value."]}),"\n",(0,r.jsxs)(s.table,{children:[(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{children:"Function"}),(0,r.jsx)(s.th,{children:"Result type"}),(0,r.jsx)(s.th,{children:"Description"})]})}),(0,r.jsxs)(s.tbody,{children:[(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"anything"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Any]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that always succeeds."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"isNull"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Any]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires a null value."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"isSubtype[A](assertion: Assertion[A])(implicit C: ClassTag[A])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Any]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires a value have the specified type."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"nothing"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Any]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that always fails."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"throwsA[E: ClassTag]"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Any]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires the expression to throw."})]})]})]}),"\n",(0,r.jsx)(s.h2,{id:"a",children:"A"}),"\n",(0,r.jsx)(s.p,{children:"Assertions that apply to specific values."}),"\n",(0,r.jsxs)(s.table,{children:[(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{children:"Function"}),(0,r.jsx)(s.th,{children:"Result type"}),(0,r.jsx)(s.th,{children:"Description"})]})}),(0,r.jsxs)(s.tbody,{children:[(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"equalTo[A](expected: A)"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[A]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires a value equal the specified value."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"hasField[A, B](name: String, proj: A => B, assertion: Assertion[B])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[A]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that focuses in on a field in a case class."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"isOneOf[A](values: Iterable[A])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[A]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires a value to be equal to one of the specified values."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"not[A](assertion: Assertion[A])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[A]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that negates the specified assertion."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"throws[A](assertion: Assertion[Throwable])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[A]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires the expression to throw."})]})]})]}),"\n",(0,r.jsx)(s.h2,{id:"numeric",children:"Numeric"}),"\n",(0,r.jsxs)(s.p,{children:["Assertions on ",(0,r.jsx)(s.code,{children:"Numeric"})," types"]}),"\n",(0,r.jsxs)(s.table,{children:[(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{children:"Function"}),(0,r.jsx)(s.th,{children:"Result type"}),(0,r.jsx)(s.th,{children:"Description"})]})}),(0,r.jsxs)(s.tbody,{children:[(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"approximatelyEquals[A: Numeric](reference: A, tolerance: A)"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[A]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires a given numeric value to match a value with some tolerance."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"isNegative[A](implicit num: Numeric[A])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[A]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires a numeric value is negative."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"isPositive[A](implicit num: Numeric[A])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[A]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires a numeric value is positive."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"isZero[A](implicit num: Numeric[A])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[A]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires a numeric value is zero."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"nonNegative[A](implicit num: Numeric[A])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[A]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires a numeric value is non negative."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"nonPositive[A](implicit num: Numeric[A])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[A]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires a numeric value is non positive."})]})]})]}),"\n",(0,r.jsx)(s.h2,{id:"ordering",children:"Ordering"}),"\n",(0,r.jsxs)(s.p,{children:["Assertions on types that support ",(0,r.jsx)(s.code,{children:"Ordering"})]}),"\n",(0,r.jsxs)(s.table,{children:[(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{children:"Function"}),(0,r.jsx)(s.th,{children:"Result type"}),(0,r.jsx)(s.th,{children:"Description"})]})}),(0,r.jsxs)(s.tbody,{children:[(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"isGreaterThan[A](reference: A)(implicit ord: Ordering[A])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[A]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires the value be greater than the specified reference value."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"isGreaterThanEqualTo[A](reference: A)(implicit ord: Ordering[A])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[A]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires the value be greater than or equal to the specified reference value."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"isLessThan[A](reference: A)(implicit ord: Ordering[A])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[A]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires the value be less than the specified reference value."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"isLessThanEqualTo[A](reference: A)(implicit ord: Ordering[A])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[A]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires the value be less than or equal to the specified reference value."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"isWithin[A](min: A, max: A)(implicit ord: Ordering[A])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[A]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires a value to fall within a specified min and max (inclusive)."})]})]})]}),"\n",(0,r.jsx)(s.h2,{id:"iterable",children:"Iterable"}),"\n",(0,r.jsxs)(s.p,{children:["Assertions on types that extend ",(0,r.jsx)(s.code,{children:"Iterable"}),", like ",(0,r.jsx)(s.code,{children:"List"}),", ",(0,r.jsx)(s.code,{children:"Seq"}),", ",(0,r.jsx)(s.code,{children:"Set"}),", ",(0,r.jsx)(s.code,{children:"Map"}),", and many others."]}),"\n",(0,r.jsxs)(s.table,{children:[(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{children:"Function"}),(0,r.jsx)(s.th,{children:"Result type"}),(0,r.jsx)(s.th,{children:"Description"})]})}),(0,r.jsxs)(s.tbody,{children:[(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"contains[A](element: A)"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Iterable[A]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires an Iterable contain the specified element. See Assertion.exists if you want to require an Iterable to contain an element satisfying an assertion."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"exists[A](assertion: Assertion[A])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Iterable[A]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires an Iterable contain an element satisfying the given assertion."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"forall[A](assertion: Assertion[A])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Iterable[A]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires an Iterable contain only elements satisfying the given assertion."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"hasFirst[A](assertion: Assertion[A])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Iterable[A]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires an Iterable to contain the first element satisfying the given assertion."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"hasIntersection[A](other: Iterable[A])(assertion: Assertion[Iterable[A]])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Iterable[A]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires the intersection of two Iterables satisfy the given assertion."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"hasLast[A](assertion: Assertion[A])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Iterable[A]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires an Iterable to contain the last element satisfying the given assertion."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"hasSize[A](assertion: Assertion[Int])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Iterable[A]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires the size of an Iterable be satisfied by the specified assertion."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"hasAtLeastOneOf[A](other: Iterable[A])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Iterable[A]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires an Iterable contain at least one of the specified elements."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"hasAtMostOneOf[A](other: Iterable[A])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Iterable[A]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires an Iterable contain at most one of the specified elements."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"hasNoneOf[A](other: Iterable[A])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Iterable[A]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires an Iterable contain none of the specified elements."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"hasOneOf[A](other: Iterable[A])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Iterable[A]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires an Iterable contain exactly one of the specified elements."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"hasSameElements[A](other: Iterable[A])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Iterable[A]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires an Iterable to have the same elements as the specified Iterable, though not necessarily in the same order."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"hasSameElementsDistinct[A](other: Iterable[A])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Iterable[A]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires an Iterable to have the same distinct elements as the other Iterable, though not necessarily in the same order."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"hasSubset[A](other: Iterable[A])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Iterable[A]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires the specified Iterable to be a subset of the other Iterable."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"isDistinct"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Iterable[Any]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires an Iterable is distinct."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"isEmpty"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Iterable[Any]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires an Iterable to be empty."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"isNonEmpty"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Iterable[Any]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires an Iterable to be non empty."})]})]})]}),"\n",(0,r.jsx)(s.h2,{id:"ordering-1",children:"Ordering"}),"\n",(0,r.jsxs)(s.p,{children:["Assertions that apply to ordered ",(0,r.jsx)(s.code,{children:"Iterable"}),"s"]}),"\n",(0,r.jsxs)(s.table,{children:[(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{children:"Function"}),(0,r.jsx)(s.th,{children:"Result type"}),(0,r.jsx)(s.th,{children:"Description"})]})}),(0,r.jsxs)(s.tbody,{children:[(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"isSorted[A](implicit ord: Ordering[A])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Iterable[A]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires an Iterable is sorted."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"isSortedReverse[A](implicit ord: Ordering[A])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Iterable[A]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires an Iterable is sorted in reverse order."})]})]})]}),"\n",(0,r.jsx)(s.h2,{id:"seq",children:"Seq"}),"\n",(0,r.jsxs)(s.p,{children:["Assertions that operate on sequences (",(0,r.jsx)(s.code,{children:"List"}),", ",(0,r.jsx)(s.code,{children:"Vector"}),", ",(0,r.jsx)(s.code,{children:"Map"}),", and many others)"]}),"\n",(0,r.jsxs)(s.table,{children:[(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{children:"Function"}),(0,r.jsx)(s.th,{children:"Result type"}),(0,r.jsx)(s.th,{children:"Description"})]})}),(0,r.jsxs)(s.tbody,{children:[(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"endsWith[A](suffix: Seq[A])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Seq[A]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires a given string to end with the specified suffix."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"hasAt[A](pos: Int)(assertion: Assertion[A])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Seq[A]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires a sequence to contain an element satisfying the given assertion on the given position."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"startsWith[A](prefix: Seq[A])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Seq[A]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires a given sequence to start with the specified prefix."})]})]})]}),"\n",(0,r.jsx)(s.h2,{id:"either",children:"Either"}),"\n",(0,r.jsxs)(s.p,{children:["Assertions for ",(0,r.jsx)(s.code,{children:"Either"})," values."]}),"\n",(0,r.jsxs)(s.table,{children:[(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{children:"Function"}),(0,r.jsx)(s.th,{children:"Result type"}),(0,r.jsx)(s.th,{children:"Description"})]})}),(0,r.jsxs)(s.tbody,{children:[(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"isLeft[A](assertion: Assertion[A])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Either[A, Any]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires a Left value satisfying a specified assertion."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"isLeft"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Either[Any, Any]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires an Either is Left."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"isRight[A](assertion: Assertion[A])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Either[Any, A]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires a Right value satisfying a specified assertion."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"isRight"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Either[Any, Any]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires an Either is Right."})]})]})]}),"\n",(0,r.jsx)(s.h2,{id:"exitcausethrowable",children:"Exit/Cause/Throwable"}),"\n",(0,r.jsxs)(s.p,{children:["Assertions for ",(0,r.jsx)(s.code,{children:"Exit"})," or ",(0,r.jsx)(s.code,{children:"Cause"})," results."]}),"\n",(0,r.jsxs)(s.table,{children:[(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{children:"Function"}),(0,r.jsx)(s.th,{children:"Result type"}),(0,r.jsx)(s.th,{children:"Description"})]})}),(0,r.jsxs)(s.tbody,{children:[(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"containsCause[E](cause: Cause[E])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Cause[E]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires a Cause contain the specified cause."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"dies(assertion: Assertion[Throwable])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Exit[Any, Any]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires an exit value to die."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"failsCause[E](assertion: Assertion[Cause[E]])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Exit[E, Any]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires an exit value to fail with a cause that meets the specified assertion."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"fails[E](assertion: Assertion[E])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Exit[E, Any]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires an exit value to fail."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"isInterrupted"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Exit[Any, Any]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires an exit value to be interrupted."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"succeeds[A](assertion: Assertion[A])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Exit[Any, A]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires an exit value to succeed."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"hasMessage(message: Assertion[String])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Throwable]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires an exception to have a certain message."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"hasThrowableCause(cause: Assertion[Throwable])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Throwable]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires an exception to have a certain cause."})]})]})]}),"\n",(0,r.jsx)(s.h2,{id:"try",children:"Try"}),"\n",(0,r.jsxs)(s.table,{children:[(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{children:"Function"}),(0,r.jsx)(s.th,{children:"Result type"}),(0,r.jsx)(s.th,{children:"Description"})]})}),(0,r.jsxs)(s.tbody,{children:[(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"isFailure(assertion: Assertion[Throwable])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Try[Any]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires a Failure value satisfying the specified assertion."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"isFailure"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Try[Any]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires a Try value is Failure."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"isSuccess[A](assertion: Assertion[A])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Try[A]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires a Success value satisfying the specified assertion."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"isSuccess"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Try[Any]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires a Try value is Success."})]})]})]}),"\n",(0,r.jsx)(s.h2,{id:"sum-type",children:"Sum type"}),"\n",(0,r.jsx)(s.p,{children:"An assertion that applies to some type, giving a method to transform the source\ntype into another type, then assert a property on that projected type."}),"\n",(0,r.jsxs)(s.table,{children:[(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{children:"Function"}),(0,r.jsx)(s.th,{children:"Result type"}),(0,r.jsx)(s.th,{children:"Description"})]})}),(0,r.jsx)(s.tbody,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"isCase[Sum, Proj]( termName: String, term: Sum => Option[Proj], assertion: Assertion[Proj])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Sum]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires the sum type be a specified term."})]})})]}),"\n",(0,r.jsx)(s.h2,{id:"map",children:"Map"}),"\n",(0,r.jsxs)(s.p,{children:["Assertions for ",(0,r.jsx)(s.code,{children:"Map[K, V]"})]}),"\n",(0,r.jsxs)(s.table,{children:[(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{children:"Function"}),(0,r.jsx)(s.th,{children:"Result type"}),(0,r.jsx)(s.th,{children:"Description"})]})}),(0,r.jsxs)(s.tbody,{children:[(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"hasKey[K, V](key: K)"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Map[K, V]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires a Map to have the specified key."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"hasKey[K, V](key: K, assertion: Assertion[V])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Map[K, V]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires a Map to have the specified key with value satisfying the specified assertion."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"hasKeys[K, V](assertion: Assertion[Iterable[K]])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Map[K, V]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires a Map have keys satisfying the specified assertion."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"hasValues[K, V](assertion: Assertion[Iterable[V]])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Map[K, V]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires a Map have values satisfying the specified assertion."})]})]})]}),"\n",(0,r.jsx)(s.h2,{id:"string",children:"String"}),"\n",(0,r.jsx)(s.p,{children:"Assertions for Strings"}),"\n",(0,r.jsxs)(s.table,{children:[(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{children:"Function"}),(0,r.jsx)(s.th,{children:"Result type"}),(0,r.jsx)(s.th,{children:"Description"})]})}),(0,r.jsxs)(s.tbody,{children:[(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"containsString(element: String)"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[String]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires a substring to be present."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"endsWithString(suffix: String)"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[String]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires a given string to end with the specified suffix."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"equalsIgnoreCase(other: String)"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[String]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires a given string to equal another ignoring case."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"hasSizeString(assertion: Assertion[Int])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[String]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires the size of a string be satisfied by the specified assertion."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"isEmptyString"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[String]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires a given string to be empty."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"isNonEmptyString"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[String]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires a given string to be non empty."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"matchesRegex(regex: String)"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[String]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires a given string to match the specified regular expression."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"startsWithString(prefix: String)"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[String]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires a given string to start with a specified prefix."})]})]})]}),"\n",(0,r.jsx)(s.h2,{id:"boolean",children:"Boolean"}),"\n",(0,r.jsx)(s.p,{children:"Assertions for Booleans"}),"\n",(0,r.jsxs)(s.table,{children:[(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{children:"Function"}),(0,r.jsx)(s.th,{children:"Result type"}),(0,r.jsx)(s.th,{children:"Description"})]})}),(0,r.jsxs)(s.tbody,{children:[(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"isFalse"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Boolean]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires a value be false."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"isTrue"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Boolean]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires a value be true."})]})]})]}),"\n",(0,r.jsx)(s.h2,{id:"option",children:"Option"}),"\n",(0,r.jsx)(s.p,{children:"Assertions for Optional values"}),"\n",(0,r.jsxs)(s.table,{children:[(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{children:"Function"}),(0,r.jsx)(s.th,{children:"Result type"}),(0,r.jsx)(s.th,{children:"Description"})]})}),(0,r.jsxs)(s.tbody,{children:[(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"isNone"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Option[Any]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires a None value."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"isSome[A](assertion: Assertion[A])"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Option[A]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires a Some value satisfying the specified assertion."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"isSome"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Option[Any]]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires an Option is Some."})]})]})]}),"\n",(0,r.jsx)(s.h2,{id:"unit",children:"Unit"}),"\n",(0,r.jsx)(s.p,{children:"Assertion for Unit"}),"\n",(0,r.jsxs)(s.table,{children:[(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{children:"Function"}),(0,r.jsx)(s.th,{children:"Result type"}),(0,r.jsx)(s.th,{children:"Description"})]})}),(0,r.jsx)(s.tbody,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"isUnit"})}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Assertion[Unit]"})}),(0,r.jsx)(s.td,{children:"Makes a new assertion that requires the value be unit."})]})})]})]})}function o(e={}){const{wrapper:s}={...(0,n.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},28453:(e,s,i)=>{i.d(s,{R:()=>d,x:()=>c});var t=i(96540);const r={},n=t.createContext(r);function d(e){const s=t.useContext(n);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),t.createElement(n.Provider,{value:s},e.children)}}}]);