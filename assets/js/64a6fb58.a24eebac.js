"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[30323],{84660:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"reference/error-management/recovering/timing-out","title":"Timing out","description":"ZIO#timeout","source":"@site/docs/reference/error-management/recovering/timing-out.md","sourceDirName":"reference/error-management/recovering","slug":"/reference/error-management/recovering/timing-out","permalink":"/reference/error-management/recovering/timing-out","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/reference/error-management/recovering/timing-out.md","tags":[],"version":"current","frontMatter":{"id":"timing-out","title":"Timing out","sidebar_label":"5. Timing out"},"sidebar":"reference-sidebar","previous":{"title":"4. Retrying","permalink":"/reference/error-management/recovering/retrying"},"next":{"title":"6. Sandboxing","permalink":"/reference/error-management/recovering/sandboxing"}}');var o=t(74848),r=t(28453);const s={id:"timing-out",title:"Timing out",sidebar_label:"5. Timing out"},c=void 0,l={},a=[{value:"<code>ZIO#timeout</code>",id:"ziotimeout",level:2},{value:"<code>ZIO#timeoutTo</code>",id:"ziotimeoutto",level:2},{value:"<code>ZIO#timeoutFail</code>/<code>ZIO#timeoutFailCause</code>",id:"ziotimeoutfailziotimeoutfailcause",level:2}];function d(e){const n={code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"ziotimeout",children:(0,o.jsx)(n.code,{children:"ZIO#timeout"})}),"\n",(0,o.jsxs)(n.p,{children:["ZIO lets us timeout any effect using the ",(0,o.jsx)(n.code,{children:"ZIO#timeout"})," method, which returns a new effect that succeeds with an ",(0,o.jsx)(n.code,{children:"Option"}),". A value of ",(0,o.jsx)(n.code,{children:"None"})," indicates the timeout elapsed before the effect completed. If an effect times out, then instead of continuing to execute in the background, it will be interrupted so no resources will be wasted."]}),"\n",(0,o.jsx)(n.p,{children:"Assume we have the following effect:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nval myApp =\n  for {\n    _ <- ZIO.debug("start doing something.")\n    _ <- ZIO.sleep(2.second)\n    _ <- ZIO.debug("my job is finished!")\n  } yield "result"\n'})}),"\n",(0,o.jsxs)(n.p,{children:["We should note that when we use the ",(0,o.jsx)(n.code,{children:"ZIO#timeout"})," operator on the ",(0,o.jsx)(n.code,{children:"myApp"}),", it doesn't return until one of the following situations happens:"]}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["The original effect returns before the timeout elapses so the output will be ",(0,o.jsx)(n.code,{children:"Some"})," of the produced value by the original effect:"]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    myApp\n      .timeout(3.second)\n      .debug("output")\n      .timed\n      .map(_._1.toMillis / 1000)\n      .debug("execution time of the whole program in second")\n}\n\n// Output:\n// start doing something.\n// my job is finished!\n// output: Some(result)\n// execution time of the whole program in second: 2\n'})}),"\n",(0,o.jsxs)(n.ol,{start:"2",children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"The original effect interrupted after the timeout elapses:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["If the effect is interruptible it will be immediately interrupted, and finally, the timeout operation produces ",(0,o.jsx)(n.code,{children:"None"})," value."]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",metastring:"mdoc:compile-only",children:'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    myApp\n      .timeout(1.second)\n      .debug("output")\n      .timed\n      .map(_._1.toMillis / 1000)\n      .debug("execution time of the whole program in second")\n}\n\n// Output:\n// start doing something.\n// output: None\n// execution time of the whole program in second: 1\n'})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["If the effect is uninterruptible it will be blocked until the original effect safely finished its work, and then the timeout operator produces the ",(0,o.jsx)(n.code,{children:"None"})," value:"]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",metastring:"mdoc:compile-only",children:'import zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    myApp\n      .uninterruptible\n      .timeout(1.second)\n      .debug("output")\n      .timed\n      .map(_._1.toMillis / 1000)\n      .debug("execution time of the whole program in second")\n}\n\n// Output:\n// start doing something.\n// my job is finished!\n// output: None\n// execution time of the whole program in second: 2\n'})}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["Instead of waiting for the original effect to be interrupted, we can use ",(0,o.jsx)(n.code,{children:"effect.disconnect.timeout"})," which first disconnects the effect's interruption signal before performing the timeout. By using this technique, we can return early after the timeout has passed and before an underlying effect has been interrupted."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'object MainApp extends ZIOAppDefault {\n  def run =\n    myApp\n      .uninterruptible\n      .disconnect\n      .timeout(1.second)\n      .debug("output")\n      .timed\n      .map(_._1.toMillis / 1000)\n      .debug("execution time of the whole program in second")\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"By using this technique, the original effect will be interrupted in the background."}),"\n",(0,o.jsx)(n.h2,{id:"ziotimeoutto",children:(0,o.jsx)(n.code,{children:"ZIO#timeoutTo"})}),"\n",(0,o.jsx)(n.p,{children:"This operator is similar to the previous one, but it also allows us to manually create the final result type:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import zio._\n\nval delayedNextInt: ZIO[Any, Nothing, Int] =\n  Random.nextIntBounded(10).delay(2.second)\n\nval r1: ZIO[Any, Nothing, Option[Int]] =\n  delayedNextInt.timeoutTo(None)(Some(_))(1.seconds)\n\nval r2: ZIO[Any, Nothing, Either[String, Int]] =\n  delayedNextInt.timeoutTo(Left("timeout"))(Right(_))(1.seconds)\n\nval r3: ZIO[Any, Nothing, Int] =\n  delayedNextInt.timeoutTo(-1)(identity)(1.seconds)\n'})}),"\n",(0,o.jsxs)(n.h2,{id:"ziotimeoutfailziotimeoutfailcause",children:[(0,o.jsx)(n.code,{children:"ZIO#timeoutFail"}),"/",(0,o.jsx)(n.code,{children:"ZIO#timeoutFailCause"})]}),"\n",(0,o.jsx)(n.p,{children:"In case of elapsing the timeout, we can produce a particular error message:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-scala",children:'import zio._\nimport scala.concurrent.TimeoutException\n\nval r1: ZIO[Any, TimeoutException, Int] =\n  delayedNextInt.timeoutFail(new TimeoutException)(1.second)\n\nval r2: ZIO[Any, Nothing, Int] =\n  delayedNextInt.timeoutFailCause(Cause.die(new Error("timeout")))(1.second)\n'})})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>c});var i=t(96540);const o={},r=i.createContext(o);function s(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);