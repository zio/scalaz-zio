"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[86655],{70643:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"zio-deriving/index","title":"Introduction to ZIO Deriving","description":"ZIO Deriving is a Scala library for typeclass derivation with the design goals of:","source":"@site/docs/zio-deriving/index.md","sourceDirName":"zio-deriving","slug":"/zio-deriving/","permalink":"/zio-deriving/","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-deriving/index.md","tags":[],"version":"current","frontMatter":{"id":"index","title":"Introduction to ZIO Deriving","sidebar_label":"ZIO Deriving"},"sidebar":"ecosystem-sidebar","previous":{"title":"ZIO Constraintless","permalink":"/zio-constraintless/"},"next":{"title":"Introduction","permalink":"/zio-direct/"}}');var s=a(74848),r=a(28453);const t={id:"index",title:"Introduction to ZIO Deriving",sidebar_label:"ZIO Deriving"},l="Summary",c={},d=[{value:"What is a Typeclass?",id:"what-is-a-typeclass",level:2},{value:"Use in the Standard Library",id:"use-in-the-standard-library",level:3},{value:"Typeclass Derivation",id:"typeclass-derivation",level:3},{value:"Divide and Conquer",id:"divide-and-conquer",level:2},{value:"Lower Level",id:"lower-level",level:2},{value:"Meta",id:"meta",level:2},{value:"Lazy",id:"lazy",level:2}];function o(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"summary",children:"Summary"})}),"\n",(0,s.jsx)(n.p,{children:"ZIO Deriving is a Scala library for typeclass derivation with the design goals of:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"compatibility"})," source compatible with both Scala 2 and Scala 3."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"simple"})," the implementation has minimal macros and avoids type-level programming."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"fast compilations"})," never slower than manual instances."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"fast runtime"})," minimal overhead compared to manual instances."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The remainder of this document may be considered a standalone companion to ",(0,s.jsx)(n.a,{href:"https://leanpub.com/fpmortals",children:"Functional Programming for Mortalz"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"what-is-a-typeclass",children:"What is a Typeclass?"}),"\n",(0,s.jsx)(n.p,{children:"Typeclasses are a way to encode polymorphism, i.e. functions that work for a variety of different types."}),"\n",(0,s.jsxs)(n.p,{children:["A typeclass is a ",(0,s.jsx)(n.code,{children:"trait"})," that:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"holds no state"}),"\n",(0,s.jsx)(n.li,{children:"has a type parameter"}),"\n",(0,s.jsx)(n.li,{children:"has at least one abstract method"}),"\n",(0,s.jsx)(n.li,{children:"has laws"}),"\n",(0,s.jsx)(n.li,{children:"may contain generalised methods"}),"\n",(0,s.jsx)(n.li,{children:"may extend other typeclasses"}),"\n",(0,s.jsx)(n.li,{children:"has one implementation for each concrete type"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"use-in-the-standard-library",children:"Use in the Standard Library"}),"\n",(0,s.jsx)(n.p,{children:"The most visible example of a typeclass in the Scala standard library is the abstraction over numbers:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"package scala.math\n\ntrait Ordering[T] {\n  def compare(x: T, y: T): Int\n\n  def lt(x: T, y: T): Boolean = compare(x, y) < 0\n  def gt(x: T, y: T): Boolean = compare(x, y) > 0\n}\n\ntrait Numeric[T] extends Ordering[T] {\n  def plus(x: T, y: T): T\n  def times(x: T, y: T): T\n  def negate(x: T): T\n  def zero: T\n\n  def abs(x: T): T = if (lt(x, zero)) negate(x) else x\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"We can see all the key features of a typeclass in action:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"there is no state"}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Ordering"})," and ",(0,s.jsx)(n.code,{children:"Numeric"})," have type parameter ",(0,s.jsx)(n.code,{children:"T"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Ordering"})," has abstract ",(0,s.jsx)(n.code,{children:"compare"})," and ",(0,s.jsx)(n.code,{children:"Numeric"})," has abstract ",(0,s.jsx)(n.code,{children:"plus"}),", ",(0,s.jsx)(n.code,{children:"times"}),", ",(0,s.jsx)(n.code,{children:"negate"})," and ",(0,s.jsx)(n.code,{children:"zero"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Ordering"})," defines generalised ",(0,s.jsx)(n.code,{children:"lt"})," and ",(0,s.jsx)(n.code,{children:"gt"})," based on ",(0,s.jsx)(n.code,{children:"compare"}),",\n",(0,s.jsx)(n.code,{children:"Numeric"})," defines ",(0,s.jsx)(n.code,{children:"abs"})," in terms of ",(0,s.jsx)(n.code,{children:"lt"}),", ",(0,s.jsx)(n.code,{children:"negate"})," and ",(0,s.jsx)(n.code,{children:"zero"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Numeric"})," extends ",(0,s.jsx)(n.code,{children:"Ordering"})]}),"\n",(0,s.jsxs)(n.li,{children:["there is only one ",(0,s.jsx)(n.code,{children:"Numeric[Int]"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:['We can now write functions for types that "have a" ',(0,s.jsx)(n.code,{children:"Numeric"})," typeclass:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"def signOfTheTimes[T](t: T)(implicit N: Numeric[T]): T = {\n  import N._\n  times(negate(abs(t)), t)\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:['We are no longer dependent on the OOP hierarchy of our input types, i.e. we don\'t demand that our input "is a" ',(0,s.jsx)(n.code,{children:"Numeric"}),", which is vitally important if we want to support a third party class that we cannot redefine."]}),"\n",(0,s.jsxs)(n.p,{children:["But the syntax for ",(0,s.jsx)(n.code,{children:"signOfTheTimes"})," is clunky, there are some things we can do to clean it up. Introducing ",(0,s.jsx)(n.code,{children:"ops"})," on the typeclass companion:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"object Numeric {\n  object ops {\n    implicit class NumericOps[T](t: T)(implicit N: Numeric[T]) {\n      def +(o: T): T = N.plus(t, o)\n      def *(o: T): T = N.times(t, o)\n      def unary_-: T = N.negate(t)\n      def abs: T = N.abs(t)\n\n      // duplicated from Ordering.ops\n      def <(o: T): T = N.lt(t, o)\n      def >(o: T): T = N.gt(t, o)\n    }\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["By also using ",(0,s.jsx)(n.code,{children:"implicit"})," ",(0,s.jsx)(n.em,{children:"context bounds"})," we can now write:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"import Numeric.ops._\n\ndef signOfTheTimes[T: Numeric](t: T): T = -(t.abs) * t\n"})}),"\n",(0,s.jsx)(n.h3,{id:"typeclass-derivation",children:"Typeclass Derivation"}),"\n",(0,s.jsxs)(n.p,{children:["Typeclasses are ",(0,s.jsx)(n.em,{children:"wired up"})," using the ",(0,s.jsx)(n.code,{children:"implicit"})," language features."]}),"\n",(0,s.jsxs)(n.p,{children:["An ",(0,s.jsx)(n.em,{children:"instance"})," of ",(0,s.jsx)(n.code,{children:"Ordering"})," is defined as an ",(0,s.jsx)(n.code,{children:"implicit val"})," that implements the typeclass, and can provide faster implementations for the generalised methods (but they still box primitives, so aren't optimal):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"implicit val OrderingDouble: Ordering[Double] = new Ordering[Double] {\n  def compare(x: Double, y: Double): Int = java.lang.Double.compare(x, y)\n  override def lt(x: Double, y: Double): Boolean = x < y\n  override def gt(x: Double, y: Double): Boolean = x > y\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["with ",(0,s.jsx)(n.code,{children:"implicit def"})," provided for most stdlib collections"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"implicit def seqOrdering[CC[X] <: Seq[X], T: Ordering]: Ordering[CC[T]] = ...\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The process of generating typeclass instances from ",(0,s.jsx)(n.code,{children:"implicit def"})," rules is what we mean when we say ",(0,s.jsx)(n.em,{children:"typeclass derivation"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["To keep things nice and simple, and to avoid going into the ",(0,s.jsx)(n.em,{children:"implicit scope"}),' rules of the compiler, these derivations typically live on the companion object of the typeclass or data type (to do otherwise is to create an "orphan" and they are very difficult to reason about but are useful for library interop).']}),"\n",(0,s.jsx)(n.p,{children:"Say we create a simple data type like"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"case class Complex[A](r: A, i: A)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["there is no way to automatically generate an ",(0,s.jsx)(n.code,{children:"Ordering"})," instance, we must write one explicitly"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"object Complex {\n  implicit def ordering[A: Ordering]: Ordering[Complex[A]] = new Ordering[Complex[A]] {\n    def compare(x: Complex[A], y: Complex[A]): Int = ...\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["That's where libraries such as ",(0,s.jsx)(n.code,{children:"shapeless"}),", ",(0,s.jsx)(n.code,{children:"magnolia"})," and ",(0,s.jsx)(n.code,{children:"scalaz-deriving"})," come in. They allow users to write something closer to"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"object Complex {\n  implicit def ordering[A: Ordering]: Ordering[Complex[A]] = Ordering.derived\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"zio-deriving"})," is an alternative approach; the remainder of this document will explain how to create derivation rules for typeclasses using zio-deriving."]}),"\n",(0,s.jsx)(n.h2,{id:"divide-and-conquer",children:"Divide and Conquer"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"zio-deriving"})," defines some lawful user-facing typeclasses that abstract over typeclasses \ud83e\udd2f"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"trait XFunctor[F[_]] {\n  def xmap[A, B](fa: F[A])(f: A => B, g: B => A): F[B]\n}\n\ntrait Align[F[_]] {\n  def align[A, B](fa: F[A], fb: F[B]): F[(A, B)]\n}\n\ntrait Decide[F[_]] {\n  def decide[A, B](fa: F[A], fb: F[B]): F[Either[A, B]]\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Let's take a moment to read those type signatures. Your typeclass is the ",(0,s.jsx)(n.code,{children:"F[_]"}),". So they read like:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["if you give me a typeclass for an ",(0,s.jsx)(n.code,{children:"A"}),", and a way to convert an ",(0,s.jsx)(n.code,{children:"A"})," into a ",(0,s.jsx)(n.code,{children:"B"})," and a ",(0,s.jsx)(n.code,{children:"B"})," into an ",(0,s.jsx)(n.code,{children:"A"}),", then I can give you a typeclass for a ",(0,s.jsx)(n.code,{children:"B"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["if you give me a typeclass for an ",(0,s.jsx)(n.code,{children:"A"})," and a typeclass for a ",(0,s.jsx)(n.code,{children:"B"}),", then I can give you a typeclass for a tuple of ",(0,s.jsx)(n.code,{children:"A"})," and ",(0,s.jsx)(n.code,{children:"B"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["if you give me a typeclass for an ",(0,s.jsx)(n.code,{children:"A"})," and a typeclass for a ",(0,s.jsx)(n.code,{children:"B"}),", then I can give you a typeclass for either ",(0,s.jsx)(n.code,{children:"A"})," or ",(0,s.jsx)(n.code,{children:"B"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The laws are:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["identity: ",(0,s.jsx)(n.code,{children:"fa == xmap(fa)(id, id)"})]}),"\n",(0,s.jsxs)(n.li,{children:["composition: ",(0,s.jsx)(n.code,{children:"xmap(xmap(fa, f1, g1), f2, g2) == xmap(fa, f2 . f1, g1 . g2)"})]}),"\n",(0,s.jsxs)(n.li,{children:["associativity (align): ",(0,s.jsx)(n.code,{children:"align(align(fa, fb), fc) == align(fa, align(fb, fc))"})]}),"\n",(0,s.jsxs)(n.li,{children:["associativity (decide): ",(0,s.jsx)(n.code,{children:"decide(decide(fa, fb), fc) == decide(fa, decide(fb, fc))"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"zio-deriving"})," provides conveniences, to help implementing ",(0,s.jsx)(n.code,{children:"XFunctor"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"trait Covariant[F[_]] extends XFunctor[F] {\n  def fmap[A, B](fa: F[A])(f: A => B): F[B]\n}\n\ntrait Contravariant[F[_]] extends XFunctor[F] {\n  def contramap[A, B](fa: F[A])(f: B => A): F[B]\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["if you give me a typeclass for an ",(0,s.jsx)(n.code,{children:"A"}),", and a way to convert an ",(0,s.jsx)(n.code,{children:"A"})," into a ",(0,s.jsx)(n.code,{children:"B"}),", then I can give you a typeclass for a ",(0,s.jsx)(n.code,{children:"B"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["if you give me a typeclass for an ",(0,s.jsx)(n.code,{children:"A"}),", and a way to convert a ",(0,s.jsx)(n.code,{children:"B"})," into an ",(0,s.jsx)(n.code,{children:"A"}),", then I can give you a typeclass for a ",(0,s.jsx)(n.code,{children:"B"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"We can refer to these as the AC/DC typeclasses."}),"\n",(0,s.jsxs)(n.p,{children:["To get automatic derivation for any ",(0,s.jsx)(n.code,{children:"case class"})," the typeclass author implements ",(0,s.jsx)(n.code,{children:"Align"}),". For ",(0,s.jsx)(n.code,{children:"sealed trait"})," they implement ",(0,s.jsx)(n.code,{children:"Decide"}),", then mix ",(0,s.jsx)(n.code,{children:"Derivable"})," into the companion. Here's the implementation for ",(0,s.jsx)(n.code,{children:"Ordering"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"implicit val xfunctor: Contravariant[Ordering] = new Contravariant[Ordering] {\n  def contramap[A, B](fa: Ordering[A])(f: B => A): Ordering[B] = new Ordering[B] {\n    def compare(x: B, y: B): Int = fa.compare(f(x), f(y))\n  }\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"implicit val align: Align[Ordering] = new Align[Ordering] {\n  def align[A, B](fa: Ordering[A], fb: Ordering[B]): Ordering[(A, B)] = new Ordering[(A, B)] {\n    def compare(x: (A, B), y: (A, B)): Int = {\n      val xs = fa.compare(x._1, y._1)\n      if (xs != 0) xs\n      else fb.compare(x._2, y._2)\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"implicit val decide: Decide[Ordering] = new Decide[Ordering] {\n  def decide[A, B](fa: Ordering[A], fb: Ordering[B]): Ordering[Either[A, B]] = new Ordering[Either[A, B]] {\n    def compare(x: Either[A, B], y: Either[A, B]): Int = (x, y) match {\n      case (Left(xa), Left(ya)) => fa.compare(xa, ya)\n      case (Right(xb), Right(yb)) => fb.compare(xb, yb)\n      case (Left(_), Right(_)) => -1\n      case (Right(_), Left(_)) => 1\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Downstream users just need to type"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"case class Complex[A](r: A, i: A)\nobject Complex {\n  implicit def ordering[A: Ordering]: Ordering[Complex[A]] = Ordering.derived\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"which can be simplified further in Scala 3 to"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"case class Complex[A](r: A, i: A) derives Ordering\n"})}),"\n",(0,s.jsx)(n.p,{children:"And it's not just limited to case classes of 2 parameters, it works for all arities and sealed traits."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"sealed trait Dimension\ncase class Cube(x: Double, y: Double, z: Double) extends Dimension\ncase class Tesseract(x: Double, y: Double, z: Double, t: Double) extends Dimension\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The tests include a few more examples, which are good exercises. Try implementing ",(0,s.jsx)(n.code,{children:"XFunctor"}),", ",(0,s.jsx)(n.code,{children:"Align"})," and ",(0,s.jsx)(n.code,{children:"Decide"})," for"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"  trait Equal[A]  {\n    // type parameter is in contravariant (parameter) position\n    def equal(a1: A, a2: A): Boolean\n  }\n\n  trait Default[A] {\n    // type parameter is in covariant (return) position\n    def default: Either[String, A]\n  }\n\n  trait Semigroup[A] {\n    // type parameter is in both covariant and contravariant position (invariant)\n    def add(a1: A, a2: A): A\n  }\n"})}),"\n",(0,s.jsx)(n.p,{children:"Homework:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["We can't implement ",(0,s.jsx)(n.code,{children:"Decide[Semigroup]"}),", why not ?"]}),"\n",(0,s.jsxs)(n.li,{children:["why should we not implement ",(0,s.jsx)(n.code,{children:"Decide[Arbitrary]"})," (as in ScalaCheck / ScalaProps) ?"]}),"\n",(0,s.jsx)(n.li,{children:"what about case classes with no parameters, and case objects ?"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"lower-level",children:"Lower Level"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"zio-deriving"})," is just a bunch of generated code. Typeclass authors can use that mechanism directly if they can't write lawful AC/DC instances."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"zio-deriving"})," data types mirror cases classes and sealed traits of all shapes (hence the name!)"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"sealed trait Shape[A]\nsealed trait CaseClass[A] extends Shape[A] { def value(i: Int): Any }\nsealed trait SealedTrait[A] extends Shape[A] { def value: A ; def index: Int }\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"case class CaseClass0[A]() extends CaseClass[A]\ncase class CaseClass1[A, A1](_1: A1) extends CaseClass[A]\ncase class CaseClass2[A, A1, A2](_1: A1, _2: A2) extends CaseClass[A]\n...\ncase class CaseClass64[A, A1, A2, ...](_1: A1, _2: A2, ...) extends CaseClass[A]\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"sealed trait SealedTrait1[A, A1 <: A] extends SealedTrait[A]\nsealed trait SealedTrait2[A, A1 <: A, A2 <: A] extends SealedTrait[A]\n...\nsealed trait SealedTrait64[A, A1 <: A, A2 <: A, ...] extends SealedTrait[A]\n\nobject SealedTrait {\n  case class _1[A, ...](value: A1) extends ...\n  case class _2[A, ...](value: A2) extends ...\n  ...\n  case class _64[A, ...](value: A64) extends ...\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"The conversion between regular data types and the zio-deriving shapes is handled by a typeclass that has a macro that automatically creates instances of a"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"trait Shapely[A, B <: Shape[A]] {\n  def to(a: A): B\n  def from(b: B): A\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["where ",(0,s.jsx)(n.code,{children:"A"})," is your own case classes and sealed traits, ",(0,s.jsx)(n.code,{children:"B"})," is a ",(0,s.jsx)(n.code,{children:"zio-deriving.Shape"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"The typeclass law is that roundtripping recovers an equal value"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["identity: ",(0,s.jsx)(n.code,{children:"to(from(b)) == b"})," AND ",(0,s.jsx)(n.code,{children:"from(to(a)) == a"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Derivable"}),' trait provides all the boilerplate to apply a "divide and conquer" approach for all arities, into the tuple and ',(0,s.jsx)(n.code,{children:"Either"})," that were implemented in ",(0,s.jsx)(n.code,{children:"Align"})," and ",(0,s.jsx)(n.code,{children:"Decide"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Typeclass authors can skip AC/DC and write codegen directly in their build tool, it's easy!"}),"\n",(0,s.jsx)(n.p,{children:"Two reasons to do this are: if the typeclass can't be expressed as a lawful AC/DC, or maximal performance is required."}),"\n",(0,s.jsxs)(n.p,{children:["Let's write a typeclass and codegen the derivation rules for it in sbt. We want a way to get all the ",(0,s.jsx)(n.code,{children:"case object"})," values that extend a ",(0,s.jsx)(n.code,{children:"sealed trait"}),", a fairly standard enumeration encoding in Scala 2. Our typeclass is"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"trait Enum[A] { self =>\n  def values: List[A]\n\n  final def map[B](f: A => B): Enum[B] = new Enum[B] {\n    def values: List[B] = self.values.map(f)\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["and we would want to implement it for ",(0,s.jsx)(n.code,{children:"SealedTrait"})," something like this, hardcoded for sealed traits of 2 case objects"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"implicit def sealedtrait2[A, A1 <: A, A2 <: A](\n  implicit A1: ValueOf[A1], A2: ValueOf[A2]\n) = new Enum[SealedTrait2[A, A1, A2]] {\n  def values = _1(A1.value) :: _2(A2.value) :: Nil\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["which we then need to convert into codegen rules. ",(0,s.jsx)(n.code,{children:"project/ExamplesCodeGen.scala"})," contains the full code, like"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'    val enums = (1 to sum_arity).map { i =>\n      val tparams = (1 to i).map(p => s"A$p <: A").mkString(", ")\n      val tparams_ = (1 to i).map(p => s"A$p").mkString(", ")\n      val implicits = (1 to i).map(p => s"A$p: ValueOf[A$p]").mkString(", ")\n      val tycons = s"SealedTrait$i[A, $tparams_]"\n      val work = (1 to i).map { p => s"_$p(A$p.value)" }.mkString("", " :: ", " :: Nil")\n      s"""  implicit def sealedtrait$i[A, $tparams](implicit $implicits): Enum[$tycons] = new Enum[$tycons] {\n         |    def values: List[$tycons] = $work\n         |  }""".stripMargin\n    }\n    s"""package wheels.enums\n       |\n       |import zio-deriving._\n       |\n       |private[enums] trait GeneratedEnums {\n       |${enums.mkString("\\n\\n")}\n       |}""".stripMargin\n'})}),"\n",(0,s.jsxs)(n.p,{children:["There's not much more than ",(0,s.jsx)(n.code,{children:".map"})," and ",(0,s.jsx)(n.code,{children:".mkString"})," going on here."]}),"\n",(0,s.jsxs)(n.p,{children:["The way I create codegen rules is to start by copy/pasting another example and changing the strings to match the template that I wrote by hand. It would be possible to create a custom DSL for the templates, much like the Haskell ",(0,s.jsx)(n.a,{href:"https://hackage.haskell.org/package/boilerplate",children:(0,s.jsx)(n.code,{children:"boilerplate"})}),". But that is left as an exercise to the reader."]}),"\n",(0,s.jsxs)(n.p,{children:["With all the ",(0,s.jsx)(n.code,{children:"Enum"})," specific stuff stripped out, that template looks like"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'    val sealedtraits = (1 to 64).map { i =>\n      val tparams = (1 to i).map(p => s"").mkString("")\n      val implicits = (1 to i).map(p => s"").mkString("")\n      s""\n    }\n    s""\n'})}),"\n",(0,s.jsx)(n.p,{children:"Homework:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["implement ",(0,s.jsx)(n.code,{children:"Arbitrary"})," derivation rules for sealed traits"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"meta",children:"Meta"}),"\n",(0,s.jsx)(n.p,{children:"Sometimes our typeclasses might need access to more information than just the types."}),"\n",(0,s.jsxs)(n.p,{children:["That's where ",(0,s.jsx)(n.code,{children:"Meta"})," helps:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"trait Meta[A] {\n  def name: String\n  def annotations: List[Annotation]\n  def fieldNames: Array[String]\n  def fieldAnnotations: Array[List[Annotation]]\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"which is provided by a macro. A typical usecase for this is to implement an encoder or decoder."}),"\n",(0,s.jsxs)(n.p,{children:["I rewrote ",(0,s.jsx)(n.code,{children:"zio-json"})," to use zio-deriving and this is how an ",(0,s.jsx)(n.code,{children:"Encoder"})," is able to get the field names for case classes with annotations providing overrides"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"abstract class CaseClassEncoder[A, CC <: zio.deriving.CaseClass[A]](M: zio.deriving.Meta[A]) extends Encoder[CC] {\n  val names: Array[String] = M.fieldAnnotations\n    .zip(M.fieldNames)\n    .map {\n      case (a, n) => a.collectFirst { case field(name) => name }.getOrElse(n)\n    }\n    .toArray\n  ...\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"similarly, we can pick a different encoder based on some annotations"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"  implicit def sealedtrait2[A, A1 <: A, A2 <: A](\n    implicit M: Meta[A], M1: Meta[A1], M2: Meta[A2],\n             A1: Encoder[A1], A2: Encoder[A2]\n  ): Encoder[SealedTrait2[A, A1, A2]] = {\n    M.annotations.collectFirst { case discriminator(n) => n } match {\n      case None => ...\n      case Some(hintfield) => ...\n    }\n  }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["It is really easy to encode user-specified customisations with annotations instead of complex ",(0,s.jsx)(n.code,{children:"implicit"})," machinery. Here we can see 3 annotations being used by a user to customise the form of their JSON"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'@discriminator("hint")\nsealed abstract class Parent\n\n@hint("Cain")\ncase class Child1() extends Parent\n\n@hint("Abel")\ncase class Child2(@field("lamb") sheep: Int) extends Parent\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Note here that we're able to get the ",(0,s.jsx)(n.code,{children:"Meta"})," for every value in the sealed trait. That's not something that is easy to get hold of with shapeless or Magnolia and it opens up lots of possibilities for typeclass authors. In the case of ",(0,s.jsx)(n.code,{children:"zio-json"})," it allows additional performance optimisations and security protection because we can skip over fields that are not going to be relevant to any of the subtypes."]}),"\n",(0,s.jsx)(n.h2,{id:"lazy",children:"Lazy"}),"\n",(0,s.jsx)(n.p,{children:"This covers an advanced topic and you might never need to know about this."}),"\n",(0,s.jsx)(n.p,{children:"In Scala 2.13 and newer it is possible to use by-name implicit parameters"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"def foo(implicit =>bar: Bar): Baz = ...\n"})}),"\n",(0,s.jsxs)(n.p,{children:["meaning that the ",(0,s.jsx)(n.code,{children:"bar"})," is only evaluated when it is needed. It is a compiler warning in earlier versions of Scala and all implicit parameters are strictly evaluated. Normally that is not a problem, but think about what happens when deriving a typeclass for a data model such as"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"sealed trait ATree\ncase class Leaf(value: String) extends ATree\ncase class Branch(roots: List[ATree]) extends ATree\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If we were to ask for implicit evidence for a typeclass called ",(0,s.jsx)(n.code,{children:"Nuthin"})," like this"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"object ATree {\n  implicit val nuthin: Nuthin[ATree] = Nuthin.derived\n}\nobject Leaf {\n  implicit val nuthin: Nuthin[Leaf] = Nuthin.derived\n}\nobject Branch {\n  implicit val nuthin: Nuthin[Branch] = Nuthin.derived\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["then we'd get into a problem because ",(0,s.jsx)(n.code,{children:"Branch.nuthin"})," depends on ",(0,s.jsx)(n.code,{children:"ATree.nuthin"}),", and ",(0,s.jsx)(n.code,{children:"ATree.nuthin"})," depends on ",(0,s.jsx)(n.code,{children:"Branch.nuthin"})," : a cyclic dependency. The Scala compiler accepts cycles and at runtime we get a ",(0,s.jsx)(n.code,{children:"NullPointerException"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["You may think that a possible fix would be to use ",(0,s.jsx)(n.code,{children:"lazy val"})," instead of ",(0,s.jsx)(n.code,{children:"val"}),", but for reasons beyond my understanding, that results in infinite recursion. Sometimes."]}),"\n",(0,s.jsxs)(n.p,{children:["The safest workaround is to use a ",(0,s.jsx)(n.code,{children:"lazy val"})," on the ",(0,s.jsx)(n.code,{children:"sealed trait"})," and ",(0,s.jsx)(n.code,{children:"def"})," on the subtypes that refer to the parent"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"object ATree {\n  implicit lazy val nuthin: Nuthin[ATree] = Nuthin.derived\n}\nobject Leaf {\n  implicit val nuthin: Nuthin[Leaf] = Nuthin.derived\n}\nobject Branch {\n  implicit def nuthin: Nuthin[Branch] = Nuthin.derived\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"an alternative encoding of the same idea (but hiding the subtype instances) is"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"object ATree {\n  implicit lazy val nuthin: Nuthin[ATree] = {\n    implicit def leaf: Nuthin[Leaf] = Nuthin.derived\n    implicit def branch: Nuthin[Branch] = Nuthin.derived\n    Nuthin.derived\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["But that can still cause a problem if the ",(0,s.jsx)(n.code,{children:"derived"})," rule is evaluating all its dependencies. And since implicit parameters are strictly evaluated, that's exactly what would happen."]}),"\n",(0,s.jsx)(n.p,{children:"A simple fix is to use by-name implicit parameters in your generated code. However, that doesn't work for Scala 2.12 and earlier."}),"\n",(0,s.jsx)(n.p,{children:"A workaround is provided by"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"final class Lazy[A] private (private[this] var eval: () => A) {\n  lazy val value: A = {\n    val value0 = eval()\n    eval = null\n    value0\n  }\n}\nobject Lazy extends LazyCompat {\n  def apply[A](a: =>A): Lazy[A] = new Lazy[A](() => a)\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"which can be used to turn any parameter into a by-name one, but adding the extra benefit of caching and not holding a reference to the calculation."}),"\n",(0,s.jsxs)(n.p,{children:["When you ask for an implicit ",(0,s.jsx)(n.code,{children:"Lazy[Foo]"})," on Scala 2.13 or later, it will automatically use a by-name implicit. On Scala 2.12 or earlier, a macro ensures that the value of the implicit is calculated lazily, converting the call site into ",(0,s.jsx)(n.code,{children:"Lazy(implicitly[Foo])"})," instead of ",(0,s.jsx)(n.code,{children:"implicitly[Lazy[Foo]]"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Unlike ",(0,s.jsx)(n.code,{children:"shapeless.Lazy"}),", this one doesn't do anything funky with the compiler."]}),"\n",(0,s.jsxs)(n.p,{children:["So when generating typeclasses, make sure to wrap the dependencies with ",(0,s.jsx)(n.code,{children:"Lazy"}),". The JSON example above is more like"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"  implicit def sealedtrait2[A, A1 <: A, A2 <: A](\n    implicit M: Meta[A], M1: Meta[A1], M2: Meta[A2],\n             A1: Lazy[Encoder[A1]], A2: Lazy[Encoder[A2]]\n  ) = ...\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If you look at the actual definitions of the AC/DC typeclasses, you'll see that they are all by-name, to accomodate for this. Implementators may want to cache the values in a ",(0,s.jsx)(n.code,{children:"lazy val"}),". Another design choice for zio-deriving would be to use ",(0,s.jsx)(n.code,{children:"Lazy"})," in the AC/DC API but it felt like pollution."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},28453:(e,n,a)=>{a.d(n,{R:()=>t,x:()=>l});var i=a(96540);const s={},r=i.createContext(s);function t(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);