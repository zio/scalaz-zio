"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[71136],{45619:(e,o,n)=>{n.r(o),n.d(o,{assets:()=>l,contentTitle:()=>c,default:()=>k,frontMatter:()=>i,metadata:()=>r,toc:()=>s});const r=JSON.parse('{"id":"reference/stm/treentrantlock","title":"TReentrantLock","description":"A TReentrantLock allows safe concurrent access to some mutable state efficiently, allowing multiple fibers to read the","source":"@site/versioned_docs/version-1.0.18/reference/stm/treentrantlock.md","sourceDirName":"reference/stm","slug":"/reference/stm/treentrantlock","permalink":"/1.0.18/reference/stm/treentrantlock","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/versioned_docs/version-1.0.18/reference/stm/treentrantlock.md","tags":[],"version":"1.0.18","frontMatter":{"id":"treentrantlock","title":"TReentrantLock"}}');var t=n(74848),a=n(28453);const i={id:"treentrantlock",title:"TReentrantLock"},c=void 0,l={},s=[{value:"Semantics",id:"semantics",level:2},{value:"Creating a reentrant lock",id:"creating-a-reentrant-lock",level:2},{value:"Acquiring a read lock",id:"acquiring-a-read-lock",level:2},{value:"Acquiring a write lock",id:"acquiring-a-write-lock",level:2},{value:"Multiple fibers can hold read locks",id:"multiple-fibers-can-hold-read-locks",level:2},{value:"Upgrading and downgrading locks",id:"upgrading-and-downgrading-locks",level:2},{value:"Acquiring a write lock in a contentious scenario",id:"acquiring-a-write-lock-in-a-contentious-scenario",level:2},{value:"Safer methods  (<code>readLock</code> and <code>writeLock</code>)",id:"safer-methods--readlock-and-writelock",level:2}];function d(e){const o={code:"code",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(o.p,{children:"A TReentrantLock allows safe concurrent access to some mutable state efficiently, allowing multiple fibers to read the\nstate (because that is safe to do) but only one fiber to modify the state (to prevent data corruption). Also, even though\nthe TReentrantLock is implemented using STM; reads and writes can be committed, allowing this to be used as a building\nblock for solutions that expose purely ZIO effects and internally allow locking on more than one piece of state in a\nsimple and composable way (thanks to STM)."}),"\n",(0,t.jsxs)(o.p,{children:["A ",(0,t.jsx)(o.code,{children:"TReentrantLock"})," is a ",(0,t.jsx)(o.em,{children:"reentrant"})," read/write lock. A reentrant lock is one where a fiber can claim the lock multiple\ntimes without blocking on itself. It's useful in situations where it's not easy to keep track of whether you have already\ngrabbed a lock. If a lock is non re-entrant you could grab the lock, then block when you go to grab it again, effectively\ncausing a deadlock."]}),"\n",(0,t.jsx)(o.h2,{id:"semantics",children:"Semantics"}),"\n",(0,t.jsx)(o.p,{children:"This lock allows both readers and writers to reacquire read or write locks with reentrancy guarantees. Readers are not\nallowed until all write locks held by the writing fiber have been released. Writers are not allowed unless there are no\nother locks or the fiber wanting to hold a write lock already has a read lock and there are no other fibers holding a\nread lock."}),"\n",(0,t.jsx)(o.p,{children:"This lock also allows upgrading from a read lock to a write lock (automatically) and downgrading\nfrom a write lock to a read lock (automatically provided that you upgraded from a read lock to a write lock)."}),"\n",(0,t.jsx)(o.h2,{id:"creating-a-reentrant-lock",children:"Creating a reentrant lock"}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-scala",children:"import zio.stm._\n\nval reentrantLock = TReentrantLock.make\n"})}),"\n",(0,t.jsx)(o.h2,{id:"acquiring-a-read-lock",children:"Acquiring a read lock"}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-scala",children:"import zio.stm._\n\nval program =\n  (for {\n    lock <- TReentrantLock.make\n    _    <- lock.acquireRead\n    rst  <- lock.readLocked  // lock is read-locked once transaction completes\n    wst  <- lock.writeLocked // lock is not write-locked\n  } yield rst && !wst).commit\n"})}),"\n",(0,t.jsx)(o.h2,{id:"acquiring-a-write-lock",children:"Acquiring a write lock"}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-scala",children:"import zio._\nimport zio.stm._\n\nval writeLockProgram: UIO[Boolean] =\n  (for {\n    lock <- TReentrantLock.make\n    _    <- lock.acquireWrite\n    wst  <- lock.writeLocked // lock is write-locked once transaction completes\n    rst  <- lock.readLocked  // lock is not read-locked\n  } yield !rst && wst).commit\n"})}),"\n",(0,t.jsx)(o.h2,{id:"multiple-fibers-can-hold-read-locks",children:"Multiple fibers can hold read locks"}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-scala",children:"import zio._\nimport zio.stm._\n\nval multipleReadLocksProgram: UIO[(Int, Int)] = for {\n  lock          <- TReentrantLock.make.commit\n  fiber0        <- lock.acquireRead.commit.fork // fiber0 acquires a read-lock\n  currentState1 <- fiber0.join                  // 1 read lock held\n  fiber1        <- lock.acquireRead.commit.fork // fiber1 acquires a read-lock\n  currentState2 <- fiber1.join                  // 2 read locks held \n} yield (currentState1, currentState2)\n"})}),"\n",(0,t.jsx)(o.h2,{id:"upgrading-and-downgrading-locks",children:"Upgrading and downgrading locks"}),"\n",(0,t.jsx)(o.p,{children:"If your fiber already has a read lock then it is possible to upgrade the lock to a write lock provided that no other\nreader (other than your fiber) holds a lock"}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-scala",children:"import zio._\nimport zio.stm._\n\nval upgradeDowngradeProgram: UIO[(Boolean, Boolean, Boolean, Boolean)] = for {\n  lock               <- TReentrantLock.make.commit\n  _                  <- lock.acquireRead.commit\n  _                  <- lock.acquireWrite.commit  // upgrade\n  isWriteLocked      <- lock.writeLocked.commit   // now write-locked\n  isReadLocked       <- lock.readLocked.commit    // and read-locked\n  _                  <- lock.releaseWrite.commit  // downgrade\n  isWriteLockedAfter <- lock.writeLocked.commit   // no longer write-locked\n  isReadLockedAfter  <- lock.readLocked.commit    // still read-locked\n} yield (isWriteLocked, isReadLocked, isWriteLockedAfter, isReadLockedAfter)\n"})}),"\n",(0,t.jsx)(o.h2,{id:"acquiring-a-write-lock-in-a-contentious-scenario",children:"Acquiring a write lock in a contentious scenario"}),"\n",(0,t.jsx)(o.p,{children:"A write lock can be acquired immediately only if one of the following conditions are satisfied:"}),"\n",(0,t.jsxs)(o.ol,{children:["\n",(0,t.jsx)(o.li,{children:"There are no other holders of the lock"}),"\n",(0,t.jsx)(o.li,{children:"The current fiber is already holding a read lock and there are no other parties holding a read lock"}),"\n"]}),"\n",(0,t.jsx)(o.p,{children:"If either of the above scenarios are untrue then attempting to acquire a write lock will semantically block the fiber.\nHere is an example which demonstrates that a write lock can only be obtained by the fiber once all other readers (except\nthe fiber attempting to acquire the write lock) have released their hold on the (read or write) lock."}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-scala",children:'import zio._\nimport zio.clock._\nimport zio.console._\nimport zio.stm._\nimport zio.duration._\n\nval writeLockDemoProgram: URIO[Console with Clock, Unit] = for {\n  l  <- TReentrantLock.make.commit\n  _  <- putStrLn("Beginning test").orDie\n  f1 <- (l.acquireRead.commit *> ZIO.sleep(5.seconds) *> l.releaseRead.commit).fork\n  f2 <- (l.acquireRead.commit *> putStrLn("read-lock").orDie *> l.acquireWrite.commit *> putStrLn("I have upgraded!").orDie).fork\n  _  <- (f1 zip f2).join\n} yield ()\n'})}),"\n",(0,t.jsxs)(o.p,{children:["Here fiber ",(0,t.jsx)(o.code,{children:"f1"})," acquires a read lock and sleeps for 5 seconds before releasing it. Fiber ",(0,t.jsx)(o.code,{children:"f2"})," also acquires a read\nlock and immediately tries to acquire a write lock. However, ",(0,t.jsx)(o.code,{children:"f2"})," will have to semantically block for approximately 5\nseconds to obtain a write lock because ",(0,t.jsx)(o.code,{children:"f1"})," will release its hold on the lock and only then can ",(0,t.jsx)(o.code,{children:"f2"})," acquire a hold for\nthe write lock."]}),"\n",(0,t.jsxs)(o.h2,{id:"safer-methods--readlock-and-writelock",children:["Safer methods  (",(0,t.jsx)(o.code,{children:"readLock"})," and ",(0,t.jsx)(o.code,{children:"writeLock"}),")"]}),"\n",(0,t.jsxs)(o.p,{children:["Using ",(0,t.jsx)(o.code,{children:"acquireRead"}),", ",(0,t.jsx)(o.code,{children:"acquireWrite"}),", ",(0,t.jsx)(o.code,{children:"releaseRead"})," and ",(0,t.jsx)(o.code,{children:"releaseWrite"})," should be avoided for simple use cases relying on\nmethods like ",(0,t.jsx)(o.code,{children:"readLock"})," and ",(0,t.jsx)(o.code,{children:"writeLock"})," instead. ",(0,t.jsx)(o.code,{children:"readLock"})," and ",(0,t.jsx)(o.code,{children:"writeLock"})," automatically acquire and release the lock\nthanks to the ",(0,t.jsx)(o.code,{children:"Managed"})," construct. The program described below is a safer version of the program above and ensures we\ndon't hold onto any resources once we are done using the reentrant lock."]}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-scala",children:'import zio._\nimport zio.clock._\nimport zio.console._\nimport zio.stm._\nimport zio.duration._\n\nval saferProgram: URIO[Console with Clock, Unit] = for {\n  lock <- TReentrantLock.make.commit\n  f1   <- lock.readLock.use_(ZIO.sleep(5.seconds) *> putStrLn("Powering down").orDie).fork\n  f2   <- lock.readLock.use_(lock.writeLock.use_(putStrLn("Huzzah, writes are mine").orDie)).fork\n  _    <- (f1 zip f2).join\n} yield ()\n'})})]})}function k(e={}){const{wrapper:o}={...(0,a.R)(),...e.components};return o?(0,t.jsx)(o,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,o,n)=>{n.d(o,{R:()=>i,x:()=>c});var r=n(96540);const t={},a=r.createContext(t);function i(e){const o=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function c(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),r.createElement(a.Provider,{value:o},e.children)}}}]);