"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[44260],{51185:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>l,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"zio-prelude/functional-data-types/these","title":"These","description":"These[A, B] is a data type that models a value that can be either a Left with a value of type A, a Right with a value of type B, or a Both with both a value of type A and a value of type B.","source":"@site/docs/zio-prelude/functional-data-types/these.md","sourceDirName":"zio-prelude/functional-data-types","slug":"/zio-prelude/functional-data-types/these","permalink":"/zio-prelude/functional-data-types/these","draft":false,"unlisted":false,"editUrl":"https://github.com/zio/zio/edit/series/2.x/docs/zio-prelude/functional-data-types/these.md","tags":[],"version":"current","frontMatter":{"id":"these","title":"These"},"sidebar":"ecosystem-sidebar","previous":{"title":"NonEmptyList","permalink":"/zio-prelude/functional-data-types/nonemptylist"},"next":{"title":"Validation","permalink":"/zio-prelude/functional-data-types/validation"}}');var i=n(74848),a=n(28453);const o={id:"these",title:"These"},l=void 0,h={},c=[];function r(e){const t={code:"code",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"These[A, B]"})," is a data type that models a value that can be either a ",(0,i.jsx)(t.code,{children:"Left"})," with a value of type ",(0,i.jsx)(t.code,{children:"A"}),", a ",(0,i.jsx)(t.code,{children:"Right"})," with a value of type ",(0,i.jsx)(t.code,{children:"B"}),", or a ",(0,i.jsx)(t.code,{children:"Both"})," with both a value of type ",(0,i.jsx)(t.code,{children:"A"})," and a value of type ",(0,i.jsx)(t.code,{children:"B"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:"sealed trait These[+A, +B] {\n  case class Left[+A](a: A)           extends These[A, Nothing]\n  case class Right[+B](b: B)          extends These[Nothing, B]\n  case class Both[+A, +B](a: A, b: B) extends These[A, B]\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["You can think of ",(0,i.jsx)(t.code,{children:"These"})," as like ",(0,i.jsx)(t.code,{children:"Either"})," except that it has one additional case. Whereas an ",(0,i.jsx)(t.code,{children:"Either"})," contains either an ",(0,i.jsx)(t.code,{children:"A"})," or a ",(0,i.jsx)(t.code,{children:"B"})," but never both, a ",(0,i.jsx)(t.code,{children:"These"})," can contain both an ",(0,i.jsx)(t.code,{children:"A"})," and a ",(0,i.jsx)(t.code,{children:"B"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["A simple example of a situation where ",(0,i.jsx)(t.code,{children:"These"})," might arise is in merging two upstreams in a streaming application. We could be signaled when at least one upstream has data for us and could have a situation where either only the left upstream has data for us, only the right upstream has data for us, or both upstreams have data for us."]}),"\n",(0,i.jsxs)(t.p,{children:["Another example of using the ",(0,i.jsx)(t.code,{children:"These"})," data type is in implementing a variant of the ",(0,i.jsx)(t.code,{children:"zipAll"})," operator on collections."]}),"\n",(0,i.jsxs)(t.p,{children:["When we zip two collections, if the two collections have different sizes the default ",(0,i.jsx)(t.code,{children:"zipWith"}),' operator will just drop the "extra" elements from the larger collection.']}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:"import zio.Chunk\n\nval left: Chunk[Int] =\n  Chunk(1, 2, 3)\n// left: Chunk[Int] = IndexedSeq(1, 2, 3)\n\nval right: Chunk[Int] =\n  Chunk(4, 5, 6, 7, 8)\n// right: Chunk[Int] = IndexedSeq(4, 5, 6, 7, 8)\n\nval zip: Chunk[Int] =\n  left.zipWith(right)(_ + _)\n// zip: Chunk[Int] = IndexedSeq(5, 7, 9)\n"})}),"\n",(0,i.jsxs)(t.p,{children:["We can use the ",(0,i.jsx)(t.code,{children:"zipAll"})," operator to allow the caller to specify how they want to handle the situation where the two collections have different sizes. Normally the signature would look something like this:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:"def zipAllWith[A, B, C](\n  as: Chunk[A],\n  bs: Chunk[B]\n)(left: A => C, right: B => C, both: (A, B) => C): Chunk[C] =\n  ???\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Now the ",(0,i.jsx)(t.code,{children:"both"})," function will be called as long as there are elements of both collections to zip together. If the left collection is longer then the ",(0,i.jsx)(t.code,{children:"left"})," function will be called for the extra elements of the left collection, and if the right collection is longer then the ",(0,i.jsx)(t.code,{children:"right"})," operator will be called for the extra elements of the right collection."]}),"\n",(0,i.jsxs)(t.p,{children:["This works and is basically the signature of the ",(0,i.jsx)(t.code,{children:"zipAllWith"})," operator on ",(0,i.jsx)(t.code,{children:"Chunk"}),", but there is something a little less than ideal here that now we need to spread out the logic for handling these cases across three different functions. It would be nice if we could describe this as a single function."]}),"\n",(0,i.jsxs)(t.p,{children:["With ",(0,i.jsx)(t.code,{children:"These"})," we can do just that. We could rewrite the signature of ",(0,i.jsx)(t.code,{children:"zipAllWith"})," like this:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:"def zipAllWith[A, B, C](\n  as: Chunk[A],\n  bs: Chunk[B]\n)(f: These[A, B] => C): Chunk[C] =\n  ???\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Now the function ",(0,i.jsx)(t.code,{children:"f"})," bundles up all the logic that was previously in ",(0,i.jsx)(t.code,{children:"left"}),", ",(0,i.jsx)(t.code,{children:"right"}),", and ",(0,i.jsx)(t.code,{children:"both"}),". The caller gets to provide a single function that handles all three of these cases."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"These"})," data type is a relatively modest one, but it captures a situation that can arise where we can have both values in addition to one or the other. Otherwise, we would have to create our own data type for each of these situations, but now we can simply use ",(0,i.jsx)(t.code,{children:"These"}),"."]})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(r,{...e})}):r(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>l});var s=n(96540);const i={},a=s.createContext(i);function o(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);